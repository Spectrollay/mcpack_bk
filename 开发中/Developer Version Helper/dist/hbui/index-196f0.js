/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 65079:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./Acquire Hardware.jpg": 53603,
	"./Adventuring Time.jpg": 73217,
	"./Ahoy.jpg": 18376,
	"./Alternative Fuel.jpg": 43218,
	"./Archer.jpg": 67464,
	"./Artificial Selection.jpg": 827,
	"./Atlantis.jpg": 52133,
	"./Bake Bread.jpg": 41988,
	"./Beaconator.jpg": 81346,
	"./Beam Me Up.jpg": 811,
	"./Bee Our Guest.jpg": 67982,
	"./Benchmaking.jpg": 19119,
	"./Body Guard.jpg": 69501,
	"./Bullseye.jpg": 68592,
	"./Buy Low Sell High.jpg": 47461,
	"./Camouflage.jpg": 33732,
	"./Castaway.jpg": 77563,
	"./Cheating Death.jpg": 86795,
	"./Chestful of Cobblestone.jpg": 9071,
	"./Cover Me in Debris.jpg": 72844,
	"./Cow Tipper.jpg": 3139,
	"./DIAMONDS.jpg": 8348,
	"./Delicious Fish.jpg": 67607,
	"./Diamonds To You.jpg": 48677,
	"./Disenchanted.jpg": 33231,
	"./Dispense With This.jpg": 18905,
	"./Do a Barrel Roll.jpg": 57098,
	"./Dry Spell.jpg": 76844,
	"./Echolocation.jpg": 27149,
	"./Enchanter.jpg": 16996,
	"./Feeling ill.jpg": 55671,
	"./Free Diver.jpg": 84115,
	"./Freight Station.jpg": 6454,
	"./Fruit on the Loom.jpg": 28110,
	"./Getting Wood.jpg": 90796,
	"./Getting an Upgrade.jpg": 94267,
	"./Great View From Up Here.jpg": 29655,
	"./Have a Shearful Day.jpg": 57185,
	"./Hot Topic.jpg": 29199,
	"./Hot Tourist Destination.jpg": 65975,
	"./Inception.jpg": 32236,
	"./Into Fire.jpg": 92857,
	"./Into the Nether.jpg": 72312,
	"./Iron Belly.jpg": 32261,
	"./Iron Man.jpg": 66893,
	"./Its a sign.jpg": 36719,
	"./Ive Got a Bad Feeling About This.jpg": 72127,
	"./Kill the Beast.jpg": 91731,
	"./Leader Of The Pack.jpg": 7850,
	"./Let it Go.jpg": 55112,
	"./Librarian.jpg": 37,
	"./Lion Hunter.jpg": 93457,
	"./Local Brewery.jpg": 28556,
	"./MOAR_Tools.jpg": 71507,
	"./Map Room.jpg": 7424,
	"./Marine Biologist.jpg": 61851,
	"./Master Trader.jpg": 24273,
	"./Me Gold.jpg": 50459,
	"./Missing Content.jpg": 95541,
	"./Monster Hunter.jpg": 45981,
	"./Moskstraumen.jpg": 15168,
	"./On a Rail.jpg": 39216,
	"./One Pickle Two Pickle Sea Pickle Four.jpg": 81568,
	"./Oooh Shiny.jpg": 92011,
	"./Organizational Wizard.jpg": 75394,
	"./Overkill.jpg": 96121,
	"./Overpowered.jpg": 91330,
	"./Passing The Time.jpg": 49678,
	"./Plethora of Cats.jpg": 66862,
	"./Pork Chop.jpg": 3664,
	"./Pot Planter.jpg": 45459,
	"./Rabbit Season.jpg": 16013,
	"./Rainbow Collection.jpg": 73682,
	"./Renewable Energy.jpg": 72486,
	"./Repopulation.jpg": 48853,
	"./Return to Sender.jpg": 38735,
	"./Saddle Up.jpg": 10068,
	"./Sail the 7 Seas.jpg": 90261,
	"./Sleep With The Fishes.jpg": 8003,
	"./Smelt Everything.jpg": 46175,
	"./Sniper Duel.jpg": 38537,
	"./So I Got That Going for Me.jpg": 96350,
	"./Sound the Alarm.jpg": 34924,
	"./Stayin Frosty.jpg": 57213,
	"./Sticky Situation.jpg": 8072,
	"./Super Fuel.jpg": 18460,
	"./Super Sonic.jpg": 10988,
	"./Taking Inventory.jpg": 66570,
	"./Taste of Your Own Medicine.jpg": 786,
	"./The Beginning..jpg": 90678,
	"./The Beginning_.jpg": 661,
	"./The Deep End.jpg": 78965,
	"./The End... Again....jpg": 81023,
	"./The End.jpg": 56377,
	"./The End_.jpg": 68956,
	"./The Haggler.jpg": 47419,
	"./The Lie.jpg": 42539,
	"./Tie Dye Outfit.jpg": 32539,
	"./Time For Stew.jpg": 59906,
	"./Time to Farm.jpg": 43450,
	"./Time to Mine.jpg": 70040,
	"./Time to Strike.jpg": 50611,
	"./Top of the World.jpg": 93870,
	"./Total Beelocation.jpg": 30280,
	"./Trampoline.jpg": 29553,
	"./Treasure Hunter.jpg": 90104,
	"./Were being attacked.jpg": 13921,
	"./When Pigs Fly.jpg": 93624,
	"./Where Have You Been.jpg": 18324,
	"./You Need A Mint.jpg": 41395,
	"./Zombie Doctor.jpg": 87126,
	"./Zoologist.jpg": 94239
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 65079;

/***/ }),

/***/ 42569:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./placeholder1.jpg": 76243,
	"./placeholder2.jpg": 54705
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 42569;

/***/ }),

/***/ 14925:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./hat_fisherman_thumbnail_0.png": 40949,
	"./skin_slime_thumbnail_0.png": 36577,
	"./toothpick_wheat_thumbnail_0.png": 59001
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 14925;

/***/ }),

/***/ 83820:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Map = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const useFacetMemo_1 = __webpack_require__(44833);
const useFacetUnwrap_1 = __webpack_require__(88684);
const useFacetMap_1 = __webpack_require__(44283);
const types_1 = __webpack_require__(74093);
const Map = ({ array, children, equalityCheck }) => {
    var _a;
    const countValue = (_a = (0, useFacetUnwrap_1.useFacetUnwrap)((0, useFacetMap_1.useFacetMap)((array) => array.length, [], [array]))) !== null && _a !== void 0 ? _a : 0;
    return (react_1.default.createElement(react_1.default.Fragment, null, times((index) => equalityCheck != null ? (react_1.default.createElement(MapChildMemo, { key: index, arrayFacet: array, index: index, equalityCheck: equalityCheck, children: children })) : (react_1.default.createElement(MapChild, { key: index, arrayFacet: array, index: index, children: children })), countValue !== types_1.NO_VALUE ? countValue : 0)));
};
exports.Map = Map;
const MapChildMemo = ({ arrayFacet, index, children, equalityCheck }) => {
    const childFacet = (0, useFacetMemo_1.useFacetMemo)((array) => {
        if (index < array.length)
            return array[index];
        return types_1.NO_VALUE;
    }, [index], [arrayFacet], equalityCheck);
    return children(childFacet, index);
};
const MapChild = ({ arrayFacet, index, children }) => {
    const childFacet = (0, useFacetMap_1.useFacetMap)((array) => {
        if (index < array.length)
            return array[index];
        return types_1.NO_VALUE;
    }, [index], [arrayFacet]);
    return children(childFacet, index);
};
const times = (fn, n) => {
    const result = [];
    for (let index = 0; index < n; index++) {
        result.push(fn(index));
    }
    return result;
};
//# sourceMappingURL=Map.js.map

/***/ }),

/***/ 92885:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mount = void 0;
const useFacetUnwrap_1 = __webpack_require__(88684);
const Mount = ({ when, children, condition = true }) => {
    const whenValue = (0, useFacetUnwrap_1.useFacetUnwrap)(when);
    return whenValue === condition ? children : null;
};
exports.Mount = Mount;
//# sourceMappingURL=Mount.js.map

/***/ }),

/***/ 60725:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.With = void 0;
const useFacetUnwrap_1 = __webpack_require__(88684);
const useFacetMap_1 = __webpack_require__(44283);
const hasData = (_, shouldRender) => {
    return shouldRender === true;
};
const With = ({ data, children }) => {
    const shouldRenderFacet = (0, useFacetMap_1.useFacetMap)((data) => data != null, [], [data]);
    const shouldRender = (0, useFacetUnwrap_1.useFacetUnwrap)(shouldRenderFacet);
    return hasData(data, shouldRender) ? children(data) : null;
};
exports.With = With;
//# sourceMappingURL=With.js.map

/***/ }),

/***/ 12493:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(83820), exports);
__exportStar(__webpack_require__(92885), exports);
__exportStar(__webpack_require__(60725), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 41024:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createOptionalValueEqualityCheck = exports.createObjectWithKeySpecificEqualityCheck = exports.createUniformArrayEqualityCheck = exports.createUniformObjectEqualityCheck = exports.createNullableEqualityCheck = void 0;
const types_1 = __webpack_require__(74093);
/**
 * Creates an equality check that accepts null and undefined values
 *
 * @param comparator comparator to be wrapped with the null check
 */
const createNullableEqualityCheck = (comparator) => {
    const check = comparator();
    let previous = types_1.NO_VALUE;
    return (value) => {
        if (value == null || previous == null) {
            if (value != previous) {
                previous = value;
                return false;
            }
            else {
                return true;
            }
        }
        previous = value;
        return check(value);
    };
};
exports.createNullableEqualityCheck = createNullableEqualityCheck;
/**
 * Creates an equality check that tests that the values of all the properties in an object
 * haven't changed.
 *
 * The comparison used for the value of the properties is passed to it as an argument.
 *
 * @param comparator the equality check to be run for each property
 */
const createUniformObjectEqualityCheck = (comparator) => () => {
    const previous = {};
    let previousKeys = new Set();
    let initialized = false;
    return (current) => {
        var _a;
        let isEquals = true;
        for (const key in current) {
            if (!(key in previous)) {
                previous[key] = comparator();
            }
            if (!((_a = previous[key]) === null || _a === void 0 ? void 0 : _a.call(previous, current[key]))) {
                isEquals = false;
            }
            previousKeys.delete(key);
        }
        if (previousKeys.size > 0) {
            for (const key of previousKeys) {
                delete previous[key];
            }
            isEquals = false;
        }
        previousKeys = new Set();
        for (const key in current) {
            previousKeys.add(key);
        }
        if (!initialized) {
            initialized = true;
            return false;
        }
        return isEquals;
    };
};
exports.createUniformObjectEqualityCheck = createUniformObjectEqualityCheck;
/**
 * Creates an equality check that tests that the items in an array
 * haven't changed.
 *
 * The comparison used for the individual items is passed to it as an argument.
 *
 * @param comparator the equality check to be run for each item
 */
const createUniformArrayEqualityCheck = (comparator) => () => {
    const previous = [];
    let initialized = false;
    return (current) => {
        var _a, _b;
        const longestLength = Math.max((_a = previous === null || previous === void 0 ? void 0 : previous.length) !== null && _a !== void 0 ? _a : 0, (_b = current === null || current === void 0 ? void 0 : current.length) !== null && _b !== void 0 ? _b : 0);
        let isEquals = true;
        for (let i = 0; i < longestLength; i++) {
            if (previous[i] == null) {
                previous[i] = comparator();
            }
            if (!previous[i](current[i])) {
                isEquals = false;
            }
        }
        if (!initialized) {
            initialized = true;
            return false;
        }
        return isEquals;
    };
};
exports.createUniformArrayEqualityCheck = createUniformArrayEqualityCheck;
/**
 * Creates an equality check that tests whether each property of the target object has changed.
 * Each property is tested with a different comparator, so that they can be of different types.
 *
 * The comparator are passed down to it as an object with the same keys as the target object, but
 * comparators for each property as values.
 *
 * @param comparators the object containing the equality checks to be run for each property
 */
const createObjectWithKeySpecificEqualityCheck = (comparators) => () => {
    const initializingComparators = {};
    for (const key in comparators) {
        initializingComparators[key] = comparators[key]();
    }
    const initializedComparators = initializingComparators;
    return (current) => {
        let isEqual = true;
        for (const key in current) {
            if (!initializedComparators[key](current[key])) {
                // We don't break or skip the next comparators because we need all comparators
                // to run for their internal values to update, so we complete the for loop
                // even if one of the comparators reports false early on
                isEqual = false;
            }
        }
        return isEqual;
    };
};
exports.createObjectWithKeySpecificEqualityCheck = createObjectWithKeySpecificEqualityCheck;
/**
 * Creates an equality check that tests whether the value changed from null to defined or stayed the same
 *
 * If the value was not null before and it is not null currently, the comparison is done by the equality check
 * provided as an argument to this creator.
 *
 * This creator is useful to be able to make equality checkers for optional properties when you already have
 * an equality check for the underlying type.
 *
 * @param comparator the equality check to be run in case the value was defined before and now
 */
const createOptionalValueEqualityCheck = (comparator) => () => {
    let previousWasNullish = true;
    let initializedComparator = comparator();
    return (current) => {
        if (current == null) {
            if (previousWasNullish) {
                return true;
            }
            // If the next value is nullish, the current comparator will be outdated.
            // We cannot simply pass a nullish value to it, since it doesn't accept nullish.
            // Instead, we need to initialize a new comparator to reset it
            initializedComparator = comparator();
            previousWasNullish = true;
            return false;
        }
        previousWasNullish = false;
        return initializedComparator(current);
    };
};
exports.createOptionalValueEqualityCheck = createOptionalValueEqualityCheck;
//# sourceMappingURL=createEqualityChecks.js.map

/***/ }),

/***/ 27755:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFacetContext = void 0;
const react_1 = __webpack_require__(67294);
function createFacetContext(initialValue) {
    let warnedAboutInvalidAccess = false;
    const facet = {
        get: () => initialValue,
        observe: (listener) => {
            if (false) {}
            listener(initialValue);
            return () => { };
        },
    };
    const context = (0, react_1.createContext)(facet);
    return context;
}
exports.createFacetContext = createFacetContext;
function parseInitialValue(initialValue) {
    try {
        return JSON.stringify(initialValue, null, 2);
    }
    catch (e) {
        return initialValue;
    }
}
//# sourceMappingURL=createFacetContext.js.map

/***/ }),

/***/ 52868:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEqualityCheck = exports.nullableShallowArrayEqualityCheck = exports.nullableShallowObjectArrayEqualityCheck = exports.nullableShallowObjectEqualityCheck = exports.shallowArrayEqualityCheck = exports.shallowObjectArrayEqualityCheck = exports.shallowObjectEqualityCheck = exports.strictEqualityCheck = void 0;
const createEqualityChecks_1 = __webpack_require__(41024);
const types_1 = __webpack_require__(74093);
/**
 * Checks that the current value is exactly the same as the other previous one. Accepts value of type
 * function, number, boolean, string, undefined or null
 */
// eslint-disable-next-line @typescript-eslint/ban-types
const strictEqualityCheck = () => {
    let previous = types_1.NO_VALUE;
    return (current) => {
        if (previous !== current) {
            previous = current;
            return false;
        }
        return true;
    };
};
exports.strictEqualityCheck = strictEqualityCheck;
/**
 * Equality check that verifies the values of each key of an object.
 * Each value must be a primitive (boolean, number or string)
 *
 * For null or undefined values see nullableShallowObjectEqualityCheck
 */
exports.shallowObjectEqualityCheck = (0, createEqualityChecks_1.createUniformObjectEqualityCheck)(exports.strictEqualityCheck);
/**
 * Does a shallow object equality check for each element in an array
 *
 * For null or undefined values see nullableShallowObjectArrayEqualityCheck
 */
exports.shallowObjectArrayEqualityCheck = (0, createEqualityChecks_1.createUniformArrayEqualityCheck)(exports.shallowObjectEqualityCheck);
/**
 * Shallow equality check of primitives in an array
 *
 * For null or undefined values see nullableShallowArrayEqualityCheck
 */
exports.shallowArrayEqualityCheck = (0, createEqualityChecks_1.createUniformArrayEqualityCheck)(exports.strictEqualityCheck);
/**
 * Equality check that verifies the values of each key of an object.
 * Each value must be a primitive (boolean, number or string)
 *
 * Supports nullable values
 */
const nullableShallowObjectEqualityCheck = () => (0, createEqualityChecks_1.createNullableEqualityCheck)((0, createEqualityChecks_1.createUniformObjectEqualityCheck)(exports.strictEqualityCheck));
exports.nullableShallowObjectEqualityCheck = nullableShallowObjectEqualityCheck;
/**
 * Does a shallow object equality check for each element in an array
 *
 * Supports nullable values
 */
exports.nullableShallowObjectArrayEqualityCheck = (0, createEqualityChecks_1.createNullableEqualityCheck)((0, createEqualityChecks_1.createUniformArrayEqualityCheck)(exports.shallowObjectEqualityCheck));
/**
 * Shallow equality check of primitives in an array
 *
 * Supports nullable values
 */
exports.nullableShallowArrayEqualityCheck = (0, createEqualityChecks_1.createNullableEqualityCheck)((0, createEqualityChecks_1.createUniformArrayEqualityCheck)(exports.strictEqualityCheck));
/**
 * The default equality check that assumes data can be mutated.
 * It is used internally by default, so there is no need to provide it.
 */
const defaultEqualityCheck = () => {
    let previous = types_1.NO_VALUE;
    return (current) => {
        const typeofValue = typeof current;
        if (!(typeofValue === 'number' ||
            typeofValue === 'string' ||
            typeofValue === 'boolean' ||
            current === null ||
            current === undefined)) {
            return false;
        }
        if (current !== previous) {
            previous = current;
            return false;
        }
        return true;
    };
};
exports.defaultEqualityCheck = defaultEqualityCheck;
//# sourceMappingURL=equalityChecks.js.map

/***/ }),

/***/ 90486:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFacet = void 0;
const equalityChecks_1 = __webpack_require__(52868);
const types_1 = __webpack_require__(74093);
/**
 * The low level function to create a Facet, not recommended to be used if you can use any of the react facet hooks to create facets instead (Ex: useFacetState, useFacetWrap)
 */
function createFacet({ initialValue, startSubscription, equalityCheck = equalityChecks_1.defaultEqualityCheck, }) {
    const listeners = new Set();
    let currentValue = initialValue;
    let cleanupSubscription;
    const checker = equalityCheck === null || equalityCheck === void 0 ? void 0 : equalityCheck();
    const update = (newValue) => {
        if (equalityCheck != null) {
            // we optimize for the most common scenario of using the defaultEqualityCheck (by inline its implementation)
            if (equalityCheck === equalityChecks_1.defaultEqualityCheck) {
                const typeofValue = typeof newValue;
                if ((typeofValue === 'number' ||
                    typeofValue === 'string' ||
                    typeofValue === 'boolean' ||
                    newValue === null ||
                    newValue === undefined) &&
                    currentValue === newValue) {
                    return;
                }
            }
            else {
                if (checker != null && checker(newValue)) {
                    return;
                }
            }
        }
        currentValue = newValue;
        for (const listener of listeners) {
            listener(currentValue);
        }
    };
    /**
     * Simpler update implementation that only resets the value and runs all cleanup functions.
     * Done as a separated function to not interfere with the usual "hot-path" of the update function.
     */
    const updateToNoValue = () => {
        currentValue = types_1.NO_VALUE;
    };
    return {
        set: update,
        setWithCallback: (setter) => {
            const value = setter(currentValue);
            if (value === types_1.NO_VALUE) {
                updateToNoValue();
            }
            else {
                update(value);
            }
        },
        get: () => currentValue,
        observe: (listener) => {
            listeners.add(listener);
            if (currentValue !== types_1.NO_VALUE) {
                listener(currentValue);
            }
            // This is the first subscription, so we start subscribing to dependencies
            if (listeners.size === 1 && startSubscription) {
                cleanupSubscription = startSubscription(update);
            }
            return () => {
                listeners.delete(listener);
                // if this was the last to unsubscribe, we unsubscribe from our dependencies
                if (listeners.size === 0 && cleanupSubscription) {
                    currentValue = initialValue;
                    cleanupSubscription();
                }
            };
        },
    };
}
exports.createFacet = createFacet;
//# sourceMappingURL=createFacet.js.map

/***/ }),

/***/ 27200:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createReadOnlyFacet = void 0;
const createFacet_1 = __webpack_require__(90486);
function createReadOnlyFacet(options) {
    return (0, createFacet_1.createFacet)(options);
}
exports.createReadOnlyFacet = createReadOnlyFacet;
//# sourceMappingURL=createReadOnlyFacet.js.map

/***/ }),

/***/ 49095:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createStaticFacet = void 0;
/**
 * Creates a nonwritable barebones static facet to be used when you need an initial facet value outside the react context
 * that's meant to be replaced later by a real facet. Ex: with `createContext()`
 */
function createStaticFacet(value) {
    const facet = {
        get: () => value,
        observe: (listener) => {
            listener(value);
            return () => { };
        },
    };
    return facet;
}
exports.createStaticFacet = createStaticFacet;
//# sourceMappingURL=createStaticFacet.js.map

/***/ }),

/***/ 46103:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(90486), exports);
__exportStar(__webpack_require__(27200), exports);
__exportStar(__webpack_require__(49095), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 97190:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.areAllDefinedValues = void 0;
const hasDefinedValue_1 = __webpack_require__(83127);
const areAllDefinedValues = (facetValues) => {
    for (let i = 0; i < facetValues.length; i++) {
        if (!(0, hasDefinedValue_1.hasDefinedValue)(facetValues[i])) {
            return false;
        }
    }
    return true;
};
exports.areAllDefinedValues = areAllDefinedValues;
//# sourceMappingURL=areAllDefinedValues.js.map

/***/ }),

/***/ 83127:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasDefinedValue = void 0;
const types_1 = __webpack_require__(74093);
const hasDefinedValue = (value) => value != null && value !== types_1.NO_VALUE;
exports.hasDefinedValue = hasDefinedValue;
//# sourceMappingURL=hasDefinedValue.js.map

/***/ }),

/***/ 5900:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(97190), exports);
__exportStar(__webpack_require__(83127), exports);
__exportStar(__webpack_require__(86191), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 86191:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.multiObserve = void 0;
const types_1 = __webpack_require__(74093);
/**
 * Allows running an effect based on facet updates. Similar to React's useEffect.
 *
 * @param effect function that will do the side-effect (ex: update the DOM)
 * @param dependencies variable used by the map that are available in scope (similar as dependencies of useEffect)
 * @param facets facets that the effect listens to
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 */
function multiObserve(effect, facets) {
    if (facets.length === 1) {
        return facets[0].observe(effect);
    }
    let cleanup;
    let hasAllDependencies = false;
    const unsubscribes = [];
    const values = facets.map(() => types_1.NO_VALUE);
    for (let i = 0; i < facets.length; i++) {
        unsubscribes[i] = facets[i].observe((value) => {
            values[i] = value;
            hasAllDependencies = hasAllDependencies || values.every((value) => value != types_1.NO_VALUE);
            if (hasAllDependencies) {
                if (cleanup != null) {
                    cleanup();
                }
                cleanup = effect(...values);
            }
        });
    }
    return () => {
        for (let index = 0; index < unsubscribes.length; index++) {
            unsubscribes[index]();
        }
        if (cleanup != null) {
            cleanup();
        }
    };
}
exports.multiObserve = multiObserve;
//# sourceMappingURL=multiObserve.js.map

/***/ }),

/***/ 47923:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(2367), exports);
__exportStar(__webpack_require__(96955), exports);
__exportStar(__webpack_require__(28488), exports);
__exportStar(__webpack_require__(44283), exports);
__exportStar(__webpack_require__(44833), exports);
__exportStar(__webpack_require__(50813), exports);
__exportStar(__webpack_require__(80551), exports);
__exportStar(__webpack_require__(66280), exports);
__exportStar(__webpack_require__(95174), exports);
__exportStar(__webpack_require__(88684), exports);
__exportStar(__webpack_require__(99751), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2367:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetCallback = void 0;
const react_1 = __webpack_require__(67294);
const types_1 = __webpack_require__(74093);
function useFacetCallback(callback, dependencies, facets, defaultReturnValue) {
    (0, react_1.useLayoutEffect)(() => {
        // Make sure to start subscriptions, even though we are getting the values directly from them
        // We read the values using `.get` to make sure they are always up-to-date
        const unsubscribes = facets.map((facet) => facet.observe(() => { }));
        return () => {
            unsubscribes.forEach((unsubscribe) => unsubscribe());
        };
        // We care about each individual facet and if any is a different reference
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, facets);
    // We care about each individual dependency and if any is a different reference
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const callbackMemoized = (0, react_1.useCallback)(callback, dependencies);
    // Setup a ref so that the callback instance below can be kept the same
    // when Facet instances change across re-renders
    const facetsRef = (0, react_1.useRef)(facets);
    facetsRef.current = facets;
    return (0, react_1.useCallback)((...args) => {
        const facets = facetsRef.current;
        const values = facets.map((facet) => facet.get());
        for (const value of values) {
            if (value === types_1.NO_VALUE)
                return defaultReturnValue != null ? defaultReturnValue : types_1.NO_VALUE;
        }
        return callbackMemoized(...values)(...args);
    }, [callbackMemoized, defaultReturnValue]);
}
exports.useFacetCallback = useFacetCallback;
//# sourceMappingURL=useFacetCallback.js.map

/***/ }),

/***/ 96955:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetEffect = exports.createUseFacetEffect = void 0;
const react_1 = __webpack_require__(67294);
const types_1 = __webpack_require__(74093);
const createUseFacetEffect = (useHook) => {
    return function (effect, dependencies, facets) {
        // eslint-disable-next-line react-hooks/exhaustive-deps
        const effectMemoized = (0, react_1.useCallback)(effect, dependencies);
        useHook(() => {
            let cleanup;
            if (facets.length === 1) {
                const unsubscribe = facets[0].observe((value) => {
                    if (cleanup != null) {
                        cleanup();
                    }
                    cleanup = effectMemoized(value);
                });
                return () => {
                    unsubscribe();
                    if (cleanup != null) {
                        cleanup();
                    }
                };
            }
            let hasAllDependencies = false;
            const unsubscribes = [];
            const values = facets.map(() => types_1.NO_VALUE);
            facets.forEach((facet, index) => {
                unsubscribes[index] = facet.observe((value) => {
                    values[index] = value;
                    hasAllDependencies = hasAllDependencies || values.every((value) => value != types_1.NO_VALUE);
                    if (hasAllDependencies) {
                        if (cleanup != null) {
                            cleanup();
                        }
                        cleanup = effectMemoized(...values);
                    }
                });
            });
            return () => {
                unsubscribes.forEach((unsubscribe) => unsubscribe());
                if (cleanup != null) {
                    cleanup();
                }
            };
            // We care about each individual facet and if any is a different reference
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [effectMemoized, ...facets]);
    };
};
exports.createUseFacetEffect = createUseFacetEffect;
/**
 * Allows running an effect based on facet updates. Similar to React's useEffect.
 *
 * @param effect function that will do the side-effect (ex: update the DOM)
 * @param dependencies variable used by the map that are available in scope (similar as dependencies of useEffect)
 * @param facets facets that the effect listens to
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 */
exports.useFacetEffect = (0, exports.createUseFacetEffect)(react_1.useEffect);
//# sourceMappingURL=useFacetEffect.js.map

/***/ }),

/***/ 28488:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetLayoutEffect = void 0;
const react_1 = __webpack_require__(67294);
const useFacetEffect_1 = __webpack_require__(96955);
/**
 * Allows running an effect based on facet updates. Similar to React's useLayoutEffect.
 *
 * @param effect function that will do the side-effect (ex: update the DOM)
 * @param dependencies variable used by the map that are available in scope (similar as dependencies of useEffect)
 * @param facets facets that the effect listens to
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 */
exports.useFacetLayoutEffect = (0, useFacetEffect_1.createUseFacetEffect)(react_1.useLayoutEffect);
//# sourceMappingURL=useFacetLayoutEffect.js.map

/***/ }),

/***/ 44283:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetMap = void 0;
const react_1 = __webpack_require__(67294);
const equalityChecks_1 = __webpack_require__(52868);
const mapFacets_1 = __webpack_require__(12914);
/**
 * Helper hook that allows mapping a value from a facet with local variables/props in a React component
 *
 * @param selector function that takes value from provided facets and maps them to a new value
 * @param dependencies variable used by the selector that are available in scope (similar as dependencies of useEffect)
 * @param facets facets that we will listen for its values to be mapped
 * @param equalityCheck optional, has a default for immutable values
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 *
 * @returns a new facet definition that can be consumed as a regular facet
 */
function useFacetMap(selector, dependencies, facets, equalityCheck = equalityChecks_1.defaultEqualityCheck) {
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const selectorMemoized = (0, react_1.useCallback)(selector, dependencies);
    const facetComposition = (0, react_1.useMemo)(() => {
        return (0, mapFacets_1.mapFacetsLightweight)(facets, selectorMemoized, equalityCheck);
        // We need to disable the linter on the next line given we are spreading the facets as individual dependencies
        // of the effect. We do this to avoid re-running this effect when passing a new array with the same facets.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [selectorMemoized, equalityCheck, ...facets]);
    return facetComposition;
}
exports.useFacetMap = useFacetMap;
//# sourceMappingURL=useFacetMap.js.map

/***/ }),

/***/ 44833:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetMemo = void 0;
const react_1 = __webpack_require__(67294);
const equalityChecks_1 = __webpack_require__(52868);
const mapFacets_1 = __webpack_require__(12914);
/**
 * Helper hook that allows mapping a value from a facet with local variables/props in a React component
 *
 * @param selector function that takes value from provided facets and maps them to a new value
 * @param dependencies variable used by the selector that are available in scope (similar as dependencies of useEffect)
 * @param facets facets that we will listen for its values to be mapped
 * @param equalityCheck optional, has a default for immutable values
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 *
 * @returns a new facet definition that can be consumed as a regular facet
 */
function useFacetMemo(selector, dependencies, facets, equalityCheck = equalityChecks_1.defaultEqualityCheck) {
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const selectorMemoized = (0, react_1.useCallback)(selector, dependencies);
    const facetComposition = (0, react_1.useMemo)(() => {
        return (0, mapFacets_1.mapFacetsCached)(facets, selectorMemoized, equalityCheck);
        // We need to disable the linter on the next line given we are spreading the facets as individual dependencies
        // of the effect. We do this to avoid re-running this effect when passing a new array with the same facets.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [selectorMemoized, equalityCheck, ...facets]);
    return facetComposition;
}
exports.useFacetMemo = useFacetMemo;
//# sourceMappingURL=useFacetMemo.js.map

/***/ }),

/***/ 50813:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetPropSetter = void 0;
const react_1 = __webpack_require__(67294);
const types_1 = __webpack_require__(74093);
/**
 * Hook that returns a setter function to a specific property of a given a localFacet
 * Ex:
 * 	- Given a local facet { foo: 'bar' }
 *  - Could be used as useFacetSetter(facet, 'foo')
 *  - And the setter would set the foo property
 *
 * @param facet
 * @param prop the name of the prop to set
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function useFacetPropSetter(facet, prop) {
    return (0, react_1.useMemo)(() => (value) => {
        facet.setWithCallback((prev) => (Object.assign(Object.assign({}, (prev != types_1.NO_VALUE ? prev : {})), { [prop]: value })));
    }, [facet, prop]);
}
exports.useFacetPropSetter = useFacetPropSetter;
//# sourceMappingURL=useFacetPropSetter.js.map

/***/ }),

/***/ 66280:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetReducer = void 0;
const react_1 = __webpack_require__(67294);
const equalityChecks_1 = __webpack_require__(52868);
const useFacetState_1 = __webpack_require__(95174);
/**
 * Provides a parallel to React's useReducer, but instead returns a facet as the value
 *
 * @param reducer function that will take the previous state and an action to return a new state
 * @param initialState mandatory initial state for the reducer's facet
 * @param equalityCheck optional equality check (has a default checker)
 * @returns
 */
const useFacetReducer = (reducer, initialState, equalityCheck = equalityChecks_1.defaultEqualityCheck) => {
    const [state, setState] = (0, useFacetState_1.useFacetState)(initialState, equalityCheck);
    const dispatch = (0, react_1.useCallback)((action) => {
        setState((previousState) => reducer(previousState, action));
    }, [reducer, setState]);
    return [state, dispatch];
};
exports.useFacetReducer = useFacetReducer;
//# sourceMappingURL=useFacetReducer.js.map

/***/ }),

/***/ 80551:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetRef = void 0;
const react_1 = __webpack_require__(67294);
const useFacetEffect_1 = __webpack_require__(96955);
const types_1 = __webpack_require__(74093);
function useFacetRef(facet, defaultValue) {
    let value = facet.get();
    if (value === types_1.NO_VALUE && defaultValue != undefined) {
        value = defaultValue;
    }
    const ref = (0, react_1.useRef)(value);
    (0, useFacetEffect_1.useFacetEffect)((value) => {
        ref.current = value;
    }, [], [facet]);
    return ref;
}
exports.useFacetRef = useFacetRef;
//# sourceMappingURL=useFacetRef.js.map

/***/ }),

/***/ 95174:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetState = void 0;
const react_1 = __webpack_require__(67294);
const equalityChecks_1 = __webpack_require__(52868);
const facet_1 = __webpack_require__(46103);
/**
 * Provides a parallel to React's useState, but instead returns a facet as the value
 *
 * @param initialValue mandatory initial value (pass NO_VALUE to force it to be uninitialized)
 * @param equalityCheck optional (has a default checker)
 */
const useFacetState = (initialValue, equalityCheck = equalityChecks_1.defaultEqualityCheck) => {
    return (0, react_1.useMemo)(() => {
        const inlineFacet = (0, facet_1.createFacet)({ initialValue, equalityCheck });
        const setter = (setter) => {
            if (isSetterCallback(setter)) {
                inlineFacet.setWithCallback(setter);
            }
            else {
                inlineFacet.set(setter);
            }
        };
        return [inlineFacet, setter];
        /**
         * We ignore the changes to the initialValue since changes to the facet
         * done after creation must only be done through the setter, and we want
         * to ensure not to accidentally put more values in memory.
         */
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
};
exports.useFacetState = useFacetState;
const isSetterCallback = (setter) => {
    return typeof setter === 'function';
};
//# sourceMappingURL=useFacetState.js.map

/***/ }),

/***/ 88684:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetUnwrap = void 0;
const react_1 = __webpack_require__(67294);
const types_1 = __webpack_require__(74093);
/**
 * Hook that allows consuming values from a Facet
 * It acts as a regular react state, triggering a re-render of the component
 *
 * @param facet
 */
function useFacetUnwrap(prop) {
    const [state, setState] = (0, react_1.useState)(() => {
        if (!(0, types_1.isFacet)(prop))
            return { value: prop };
        return {
            value: prop.get(),
        };
    });
    (0, react_1.useLayoutEffect)(() => {
        if ((0, types_1.isFacet)(prop)) {
            return prop.observe((value) => {
                setState((previousState) => {
                    const { value: previousValue } = previousState;
                    const typeofValue = typeof previousValue;
                    /**
                     * Performs this equality check locally to prevent triggering two consecutive renderings
                     * for facets that have immutable values (unfortunately we can't handle mutable values).
                     *
                     * The two renderings might happen for the same state value if the Facet has a value on mount.
                     *
                     * The unwrap will get the value:
                     * - Once on initialization of the useState above
                     * - And another time on this observe initialization
                     */
                    if ((typeofValue === 'number' ||
                        typeofValue === 'string' ||
                        typeofValue === 'boolean' ||
                        value === undefined ||
                        value === null) &&
                        value === previousValue) {
                        return previousState;
                    }
                    return { value };
                });
            });
        }
    }, [prop]);
    return (0, types_1.isFacet)(prop) ? state.value : prop;
}
exports.useFacetUnwrap = useFacetUnwrap;
//# sourceMappingURL=useFacetUnwrap.js.map

/***/ }),

/***/ 99751:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetWrap = void 0;
const react_1 = __webpack_require__(67294);
const equalityChecks_1 = __webpack_require__(52868);
const facet_1 = __webpack_require__(46103);
const types_1 = __webpack_require__(74093);
/**
 * Wraps a FacetProp as a Facet
 * @param value
 */
function useFacetWrap(prop, equalityCheck = equalityChecks_1.defaultEqualityCheck) {
    const is = (0, types_1.isFacet)(prop);
    /**
     * Inline facet that only created if the provided prop is not a facet.
     *
     * We ignore the dependency change of `prop` since we want to update the inline
     * facet value via the setter below.
     */
    const inlineFacet = (0, react_1.useMemo)(() => (is ? undefined : (0, facet_1.createFacet)({ initialValue: prop, equalityCheck })), 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [is]);
    if (inlineFacet == null) {
        return prop;
    }
    else {
        inlineFacet.set(prop);
        return inlineFacet;
    }
}
exports.useFacetWrap = useFacetWrap;
//# sourceMappingURL=useFacetWrap.js.map

/***/ }),

/***/ 88572:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(12493), exports);
__exportStar(__webpack_require__(41024), exports);
__exportStar(__webpack_require__(27755), exports);
__exportStar(__webpack_require__(52868), exports);
__exportStar(__webpack_require__(46103), exports);
__exportStar(__webpack_require__(5900), exports);
__exportStar(__webpack_require__(47923), exports);
__exportStar(__webpack_require__(12914), exports);
__exportStar(__webpack_require__(74093), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 12914:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(43118), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8273:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapFacetArrayCached = void 0;
const types_1 = __webpack_require__(74093);
const mapIntoObserveArray_1 = __webpack_require__(71794);
const facet_1 = __webpack_require__(46103);
function mapFacetArrayCached(facets, fn, equalityCheck) {
    return (0, facet_1.createFacet)({
        // pass the equalityCheck to the mapIntoObserveArray to prevent even triggering the observable
        startSubscription: (0, mapIntoObserveArray_1.mapIntoObserveArray)(facets, fn, equalityCheck),
        initialValue: types_1.NO_VALUE,
    });
}
exports.mapFacetArrayCached = mapFacetArrayCached;
//# sourceMappingURL=mapFacetArrayCached.js.map

/***/ }),

/***/ 89160:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapFacetArrayLightweight = void 0;
const mapIntoObserveArray_1 = __webpack_require__(71794);
const types_1 = __webpack_require__(74093);
function mapFacetArrayLightweight(facets, fn, equalityCheck) {
    return {
        get: () => {
            const values = facets.map((facet) => facet.get());
            const hasAllValues = values.reduce((acc, value) => acc && value !== types_1.NO_VALUE, true);
            if (!hasAllValues)
                return types_1.NO_VALUE;
            return fn(...values);
        },
        observe: (0, mapIntoObserveArray_1.mapIntoObserveArray)(facets, fn, equalityCheck),
    };
}
exports.mapFacetArrayLightweight = mapFacetArrayLightweight;
//# sourceMappingURL=mapFacetArrayLightweight.js.map

/***/ }),

/***/ 26741:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapFacetSingleCached = void 0;
const types_1 = __webpack_require__(74093);
const mapIntoObserveSingle_1 = __webpack_require__(78781);
const facet_1 = __webpack_require__(46103);
function mapFacetSingleCached(facets, fn, equalityCheck) {
    return (0, facet_1.createFacet)({
        // pass the equalityCheck to the mapIntoObserveSingle to prevent even triggering the observable
        startSubscription: (0, mapIntoObserveSingle_1.mapIntoObserveSingle)(facets, fn, equalityCheck),
        initialValue: types_1.NO_VALUE,
    });
}
exports.mapFacetSingleCached = mapFacetSingleCached;
//# sourceMappingURL=mapFacetSingleCached.js.map

/***/ }),

/***/ 14714:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapFacetSingleLightweight = void 0;
const types_1 = __webpack_require__(74093);
const mapIntoObserveSingle_1 = __webpack_require__(78781);
function mapFacetSingleLightweight(facet, fn, equalityCheck) {
    return {
        get: () => {
            const value = facet.get();
            if (value === types_1.NO_VALUE)
                return types_1.NO_VALUE;
            return fn(value);
        },
        observe: (0, mapIntoObserveSingle_1.mapIntoObserveSingle)(facet, fn, equalityCheck),
    };
}
exports.mapFacetSingleLightweight = mapFacetSingleLightweight;
//# sourceMappingURL=mapFacetSingleLightweight.js.map

/***/ }),

/***/ 43118:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapFacetsCached = exports.mapFacetsLightweight = void 0;
const mapFacetArrayCached_1 = __webpack_require__(8273);
const mapFacetArrayLightweight_1 = __webpack_require__(89160);
const mapFacetSingleCached_1 = __webpack_require__(26741);
const mapFacetSingleLightweight_1 = __webpack_require__(14714);
function mapFacetsLightweight(facets, fn, equalityCheck) {
    if (facets.length === 1) {
        return (0, mapFacetSingleLightweight_1.mapFacetSingleLightweight)(facets[0], fn, equalityCheck);
    }
    else {
        return (0, mapFacetArrayLightweight_1.mapFacetArrayLightweight)(facets, fn, equalityCheck);
    }
}
exports.mapFacetsLightweight = mapFacetsLightweight;
function mapFacetsCached(facets, fn, equalityCheck) {
    if (facets.length === 1) {
        return (0, mapFacetSingleCached_1.mapFacetSingleCached)(facets[0], fn, equalityCheck);
    }
    else {
        return (0, mapFacetArrayCached_1.mapFacetArrayCached)(facets, fn, equalityCheck);
    }
}
exports.mapFacetsCached = mapFacetsCached;
//# sourceMappingURL=mapFacets.js.map

/***/ }),

/***/ 71794:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapIntoObserveArray = void 0;
const equalityChecks_1 = __webpack_require__(52868);
const types_1 = __webpack_require__(74093);
function mapIntoObserveArray(facets, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
fn, equalityCheck) {
    return (listener) => {
        let currentValue = types_1.NO_VALUE;
        const checker = equalityCheck === null || equalityCheck === void 0 ? void 0 : equalityCheck();
        const dependencyValues = facets.map(() => types_1.NO_VALUE);
        let hasAllDependencies = false;
        const subscriptions = facets.map((facet, index) => {
            // Most common scenario is not having any equality check
            if (equalityCheck == null) {
                return facet.observe((value) => {
                    dependencyValues[index] = value;
                    hasAllDependencies = hasAllDependencies || dependencyValues.every((value) => value != types_1.NO_VALUE);
                    if (hasAllDependencies) {
                        const result = fn(...dependencyValues);
                        if (result === types_1.NO_VALUE)
                            return;
                        listener(result);
                    }
                });
            }
            // Then we optimize for the second most common scenario of using the defaultEqualityCheck (by inline its implementation)
            if (equalityCheck === equalityChecks_1.defaultEqualityCheck) {
                return facet.observe((value) => {
                    dependencyValues[index] = value;
                    hasAllDependencies = hasAllDependencies || dependencyValues.every((value) => value != types_1.NO_VALUE);
                    if (hasAllDependencies) {
                        const result = fn(...dependencyValues);
                        if (result === types_1.NO_VALUE)
                            return;
                        const typeofValue = typeof currentValue;
                        if ((typeofValue === 'number' ||
                            typeofValue === 'string' ||
                            typeofValue === 'boolean' ||
                            currentValue === null ||
                            currentValue === undefined) &&
                            currentValue === result) {
                            return;
                        }
                        currentValue = result;
                        listener(result);
                    }
                });
            }
            // Just a type-check guard, it will never happen
            if (checker == null)
                return () => { };
            // Finally we use the custom equality check
            return facet.observe((value) => {
                dependencyValues[index] = value;
                hasAllDependencies = hasAllDependencies || dependencyValues.every((value) => value != types_1.NO_VALUE);
                if (hasAllDependencies) {
                    const result = fn(...dependencyValues);
                    if (result === types_1.NO_VALUE)
                        return;
                    if (checker(result))
                        return;
                    listener(result);
                }
            });
        });
        return () => {
            subscriptions.forEach((unsubscribe) => unsubscribe());
        };
    };
}
exports.mapIntoObserveArray = mapIntoObserveArray;
//# sourceMappingURL=mapIntoObserveArray.js.map

/***/ }),

/***/ 78781:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapIntoObserveSingle = void 0;
const equalityChecks_1 = __webpack_require__(52868);
const types_1 = __webpack_require__(74093);
function mapIntoObserveSingle(facet, fn, equalityCheck) {
    // Most common scenario is not having any equality check
    if (equalityCheck == null) {
        return (listener) => {
            return facet.observe((value) => {
                const result = fn(value);
                if (result === types_1.NO_VALUE)
                    return;
                listener(result);
            });
        };
    }
    // Then we optimize for the second most common scenario of using the defaultEqualityCheck (by inline its implementation)
    if (equalityCheck === equalityChecks_1.defaultEqualityCheck) {
        return (listener) => {
            let currentValue = types_1.NO_VALUE;
            return facet.observe((value) => {
                const result = fn(value);
                if (result === types_1.NO_VALUE)
                    return;
                const typeofValue = typeof currentValue;
                if ((typeofValue === 'number' ||
                    typeofValue === 'string' ||
                    typeofValue === 'boolean' ||
                    currentValue === null ||
                    currentValue === undefined) &&
                    currentValue === result) {
                    return;
                }
                currentValue = result;
                listener(result);
            });
        };
    }
    // Finally we use the custom equality check
    return (listener) => {
        const checker = equalityCheck();
        return facet.observe((value) => {
            const result = fn(value);
            if (result === types_1.NO_VALUE)
                return;
            if (checker(result))
                return;
            listener(result);
        });
    };
}
exports.mapIntoObserveSingle = mapIntoObserveSingle;
//# sourceMappingURL=mapIntoObserveSingle.js.map

/***/ }),

/***/ 74093:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NO_VALUE = exports.isFacet = exports.FACET_FACTORY = void 0;
exports.FACET_FACTORY = Symbol('facet-factory');
const isFacet = (value) => {
    return value != null && value.observe != null && value.get != null;
};
exports.isFacet = isFacet;
exports.NO_VALUE = Symbol.for('NoValue');
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 1170:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PauseMountProvider = exports.ImmediateMount = exports.useIsPaused = exports.useIsDeferring = exports.DeferredMountWithCallback = exports.useNotifyMountComplete = exports.DeferredMount = exports.DeferredMountProvider = exports.InnerDeferredMountProvider = exports.DeferredMountConfigProvider = void 0;
const react_1 = __importStar(__webpack_require__(67294));
const core_1 = __webpack_require__(88572);
const DeferredMountConfig = (0, react_1.createContext)({ forceImmediateMount: false });
function DeferredMountConfigProvider({ config, children }) {
    return react_1.default.createElement(DeferredMountConfig.Provider, { value: config }, children);
}
exports.DeferredMountConfigProvider = DeferredMountConfigProvider;
function useConfig() {
    return (0, react_1.useContext)(DeferredMountConfig);
}
/**
 * Targeting around 60fps
 */
const DEFAULT_FRAME_TIME_BUDGET = 16;
function InnerDeferredMountProvider({ children, frameTimeBudget = DEFAULT_FRAME_TIME_BUDGET, }) {
    const [isDeferring, setIsDeferring] = (0, core_1.useFacetState)(true);
    const [requestingToRun, setRequestingToRun] = (0, core_1.useFacetState)(false);
    const waitingForMountCallback = (0, react_1.useRef)(false);
    const deferredMountsRef = (0, react_1.useRef)([]);
    const pushDeferUpdateFunction = (0, react_1.useCallback)((updateFn) => {
        // Causes a re-render of this component that will kick-off the effect below
        setRequestingToRun(true);
        deferredMountsRef.current.push(updateFn);
        /**
         * Cleanup function that makes sure that we don't try to "mount" a deferred component
         * if it has already been unmounted.
         */
        return () => {
            // It is most common that we will be cleaning up after all deferred mounting has been run
            if (deferredMountsRef.current.length === 0 && !waitingForMountCallback.current)
                return;
            const index = deferredMountsRef.current.indexOf(updateFn);
            if (index !== -1) {
                deferredMountsRef.current.splice(index, 1);
            }
        };
    }, [setRequestingToRun]);
    (0, core_1.useFacetEffect)((requestingToRun) => {
        // Even if we are not considered to be running, we need to check if there is still
        // work pending to be done. If there is... we still need to run this effect.
        if (!requestingToRun && deferredMountsRef.current.length === 0 && !waitingForMountCallback.current)
            return;
        const work = (startTimestamp) => {
            const deferredMounts = deferredMountsRef.current;
            // We need to request the new frame at the top
            // otherwise, the state change at the bottom will trigger a new render
            // before we have a chance to cancel
            // Its not possible to detect this with unit testing, so verify on the browser
            // after a change here that this function is not executing every frame unnecessarily
            if (deferredMounts.length > 0 || waitingForMountCallback.current) {
                frameId = window.requestAnimationFrame(work);
            }
            else {
                // Used to check if the requestAnimationFrame has stopped running
                frameId = -1;
            }
            let lastUpdateCost = 0;
            let now = startTimestamp;
            while (deferredMounts.length > 0 &&
                now - startTimestamp + lastUpdateCost < frameTimeBudget &&
                !waitingForMountCallback.current) {
                const before = now;
                const updateFn = deferredMounts.shift();
                const result = updateFn(false);
                const after = performance.now();
                lastUpdateCost = after - before;
                now = after;
                // Can be a function that takes a callback if using DeferredMountWithCallback
                const resultTakesCallback = typeof result === 'function';
                if (resultTakesCallback) {
                    waitingForMountCallback.current = true;
                    result(() => {
                        waitingForMountCallback.current = false;
                        // If the requestAnimationFrame stops running while waiting for the
                        // callback we need to restart it to process the rest of the queue.
                        if (frameId === -1) {
                            frameId = window.requestAnimationFrame(work);
                        }
                    });
                }
            }
            if (deferredMounts.length === 0 && !waitingForMountCallback.current) {
                setIsDeferring(false);
                setRequestingToRun(false);
            }
        };
        let frameId = window.requestAnimationFrame(work);
        return () => {
            window.cancelAnimationFrame(frameId);
        };
    }, [frameTimeBudget, setIsDeferring, setRequestingToRun], [requestingToRun]);
    return (react_1.default.createElement(isDeferringContext.Provider, { value: isDeferring },
        react_1.default.createElement(pushDeferUpdateContext.Provider, { value: pushDeferUpdateFunction }, children)));
}
exports.InnerDeferredMountProvider = InnerDeferredMountProvider;
/**
 * Provider that must wrap a tree with nodes being deferred
 */
function DeferredMountProvider(props) {
    const config = useConfig();
    if (config.forceImmediateMount) {
        return react_1.default.createElement(react_1.default.Fragment, null, props.children);
    }
    return react_1.default.createElement(InnerDeferredMountProvider, Object.assign({}, props));
}
exports.DeferredMountProvider = DeferredMountProvider;
/**
 * Component that should wrap some mounting that must be deferred to a later frame
 * @param children component to be mounted deferred
 */
function DeferredMount({ children }) {
    const pushDeferUpdateFunction = (0, react_1.useContext)(pushDeferUpdateContext);
    const [deferred, setDeferred] = (0, react_1.useState)(pushDeferUpdateFunction != null);
    (0, react_1.useEffect)(() => {
        if (pushDeferUpdateFunction)
            pushDeferUpdateFunction(setDeferred);
    }, [pushDeferUpdateFunction]);
    if (deferred)
        return null;
    return children;
}
exports.DeferredMount = DeferredMount;
const NotifyMountComplete = (0, react_1.createContext)(() => { });
const useNotifyMountComplete = () => (0, react_1.useContext)(NotifyMountComplete);
exports.useNotifyMountComplete = useNotifyMountComplete;
/**
 * Component that should wrap some mounting that must be deferred to a later frame.
 * This will wait for a callback from the child component before marking itself as rendered.
 * @param children component to be mounted deferred
 */
function DeferredMountWithCallback({ children }) {
    const pushDeferUpdateFunction = (0, react_1.useContext)(pushDeferUpdateContext);
    const [deferred, setDeferred] = (0, react_1.useState)(pushDeferUpdateFunction != null);
    const resolveMountComplete = (0, react_1.useRef)();
    const mountCompleteBeforeInitialization = (0, react_1.useRef)(false);
    const onMountComplete = (0, react_1.useCallback)(() => {
        if (resolveMountComplete.current != null) {
            resolveMountComplete.current();
        }
        else {
            mountCompleteBeforeInitialization.current = true;
        }
    }, []);
    (0, react_1.useEffect)(() => {
        if (pushDeferUpdateFunction)
            pushDeferUpdateFunction((isDeferred) => {
                return (resolve) => {
                    setDeferred(isDeferred);
                    if (mountCompleteBeforeInitialization.current) {
                        resolve();
                    }
                    else {
                        resolveMountComplete.current = resolve;
                    }
                };
            });
    }, [pushDeferUpdateFunction, onMountComplete]);
    if (deferred)
        return null;
    return react_1.default.createElement(NotifyMountComplete.Provider, { value: onMountComplete }, children);
}
exports.DeferredMountWithCallback = DeferredMountWithCallback;
/**
 * Hook that informs if any mounting is currently being deferred
 * Can be used to show some loading indicator
 */
function useIsDeferring() {
    return (0, react_1.useContext)(isDeferringContext);
}
exports.useIsDeferring = useIsDeferring;
/**
 * Allow us to pause costly mounting (mounting) of components
 * So that transitions can occur
 */
function useIsPaused() {
    return (0, react_1.useContext)(isPausedContext);
}
exports.useIsPaused = useIsPaused;
/**
 * API compatible component with DeferredMount, but renders immediately
 */
function ImmediateMount({ children }) {
    return children;
}
exports.ImmediateMount = ImmediateMount;
const pushDeferUpdateContext = (0, react_1.createContext)(undefined);
const isDeferringContext = (0, react_1.createContext)((0, core_1.createFacet)({ initialValue: false }));
const isPausedContext = (0, react_1.createContext)(false);
/**
 * This pauses the mounting of children components.
 * Given it affects mounting, it should only happen the first time! Asking to pause again in the future is not possible
 */
function PauseMountProvider({ paused, children }) {
    const wasEverResumed = (0, react_1.useRef)(!paused);
    (0, react_1.useEffect)(() => {
        if (!paused) {
            wasEverResumed.current = true;
        }
    }, [paused]);
    return react_1.default.createElement(isPausedContext.Provider, { value: wasEverResumed.current ? false : paused }, children);
}
exports.PauseMountProvider = PauseMountProvider;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 36982:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFiberRoot = void 0;
/**
 * @private consider using render instead
 */
const createFiberRoot = (reconciler) => (container) => reconciler.createContainer({
    children: new Set(),
    element: container,
    styleUnsubscribers: new Map(),
    style: container.style,
}, false, false);
exports.createFiberRoot = createFiberRoot;
//# sourceMappingURL=createFiberRoot.js.map

/***/ }),

/***/ 70024:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createPortal = void 0;
// Extracted from React's codebase
const REACT_PORTAL_TYPE = Symbol.for('react.portal');
/**
 * Creates a React Portal.
 * More info: https://reactjs.org/docs/portals.html
 */
function createPortal(children, container, key) {
    return {
        $$typeof: REACT_PORTAL_TYPE,
        key,
        children,
        containerInfo: {
            children: new Set(),
            element: container,
            styleUnsubscribers: new Map(),
            style: container.style,
        },
    };
}
exports.createPortal = createPortal;
//# sourceMappingURL=createPortal.js.map

/***/ }),

/***/ 47811:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createReconciler = void 0;
const react_reconciler_1 = __importDefault(__webpack_require__(76525));
const setupHostConfig_1 = __webpack_require__(8446);
/**
 * @private consider using render instead
 */
const createReconciler = () => (0, react_reconciler_1.default)((0, setupHostConfig_1.setupHostConfig)());
exports.createReconciler = createReconciler;
//# sourceMappingURL=createReconciler.js.map

/***/ }),

/***/ 47154:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.render = void 0;
const createFiberRoot_1 = __webpack_require__(36982);
const createReconciler_1 = __webpack_require__(47811);
__exportStar(__webpack_require__(7358), exports);
__exportStar(__webpack_require__(70024), exports);
__exportStar(__webpack_require__(36982), exports);
__exportStar(__webpack_require__(47811), exports);
/**
 * Render the Facets as the root renderer
 */
function render(element, container) {
    if (container == null)
        return () => { };
    const reconcilerInstance = (0, createReconciler_1.createReconciler)();
    const fiberRoot = (0, createFiberRoot_1.createFiberRoot)(reconcilerInstance)(container);
    reconcilerInstance.updateContainer(element, fiberRoot, null, () => { });
    if (false) {}
    return () => {
        reconcilerInstance.updateContainer(null, fiberRoot, null, () => { });
    };
}
exports.render = render;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 92786:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setupAttributeUpdate = exports.setupViewBoxUpdate = exports.setupTextUpdate = exports.setupSrcUpdate = exports.setupValueUpdate = exports.setupRowsUpdate = exports.setupMaxLengthUpdate = exports.setupIdUpdate = exports.setupClassUpdate = void 0;
const core_1 = __webpack_require__(88572);
const setupClassUpdate = (className, element) => {
    const htmlElement = element;
    if ((0, core_1.isFacet)(className)) {
        return className.observe((className) => {
            htmlElement.className = className != null ? className : '';
        });
    }
    else {
        htmlElement.className = className != null ? className : '';
    }
};
exports.setupClassUpdate = setupClassUpdate;
const setupIdUpdate = (id, element) => {
    if ((0, core_1.isFacet)(id)) {
        return id.observe((id) => {
            element.id = id != null ? id : '';
        });
    }
    else {
        element.id = id != null ? id : '';
    }
};
exports.setupIdUpdate = setupIdUpdate;
const setupMaxLengthUpdate = (maxLength, element) => {
    if ((0, core_1.isFacet)(maxLength)) {
        return maxLength.observe((maxLength) => {
            const textElement = element;
            textElement.maxLength = maxLength != null ? maxLength : Number.MAX_SAFE_INTEGER;
        });
    }
    else {
        const textElement = element;
        textElement.maxLength = maxLength != null ? maxLength : Number.MAX_SAFE_INTEGER;
    }
};
exports.setupMaxLengthUpdate = setupMaxLengthUpdate;
const setupRowsUpdate = (rows, element) => {
    if ((0, core_1.isFacet)(rows)) {
        return rows.observe((rows) => {
            const textElement = element;
            textElement.rows = rows != null ? rows : Number.MAX_SAFE_INTEGER;
        });
    }
    else {
        const textElement = element;
        textElement.rows = rows != null ? rows : Number.MAX_SAFE_INTEGER;
    }
};
exports.setupRowsUpdate = setupRowsUpdate;
/**
 * The value attribute seems to behave differently to other
 * attributes. When using `setAttribute`, browsers and gameface
 * don't always update the element to have what's in the value,
 * so we need to set the `value` attribute directly to solve this.
 * ref: https://github.com/facebook/react/blob/master/packages/react-dom/src/client/ReactDOMInput.js
 */
const updateValue = (element, value) => {
    const inputElement = element;
    // Only accept numerical characters if the input type is number
    if (inputElement.type === 'number' && isNaN(Number(value)))
        return;
    if (value != null) {
        inputElement.value = value;
        inputElement.setAttribute('value', value);
    }
    else {
        inputElement.value = '';
        inputElement.removeAttribute('value');
    }
};
const setupValueUpdate = (value, element) => {
    if ((0, core_1.isFacet)(value)) {
        return value.observe((value) => updateValue(element, value));
    }
    else {
        updateValue(element, value);
    }
};
exports.setupValueUpdate = setupValueUpdate;
const setupSrcUpdate = (src, element) => {
    if ((0, core_1.isFacet)(src)) {
        return src.observe((src) => {
            const textElement = element;
            textElement.src = src != null ? src : '';
        });
    }
    else {
        const textElement = element;
        textElement.src = src != null ? src : '';
    }
};
exports.setupSrcUpdate = setupSrcUpdate;
const setupTextUpdate = (text, element) => {
    if ((0, core_1.isFacet)(text)) {
        return text.observe((text) => {
            const textElement = element;
            textElement.nodeValue = (text != null ? text : '');
        });
    }
    else {
        const textElement = element;
        textElement.nodeValue = (text != null ? text : '');
    }
};
exports.setupTextUpdate = setupTextUpdate;
/**
 * removeAttribute and setAttribute automatically convert the attribute name to lower case.
 * The DOM attribute viewBox is camel cased so setAttributeNS and removeAttributeNS are used
 */
const setupViewBoxUpdate = (viewBox, element) => {
    if ((0, core_1.isFacet)(viewBox)) {
        return viewBox.observe((value) => {
            if (value != null) {
                element.setAttributeNS(null, 'viewBox', value);
            }
            else {
                element.removeAttributeNS(null, 'viewBox');
            }
        });
    }
    else {
        if (viewBox != null) {
            element.setAttributeNS(null, 'viewBox', viewBox);
        }
        else {
            element.removeAttributeNS(null, 'viewBox');
        }
    }
};
exports.setupViewBoxUpdate = setupViewBoxUpdate;
const setupAttributeUpdate = (attribute, value, element) => {
    if ((0, core_1.isFacet)(value)) {
        return value.observe((value) => {
            if (value === true) {
                element.setAttribute(attribute, '');
            }
            else if (value === false) {
                element.removeAttribute(attribute);
            }
            else if (value != null) {
                element.setAttribute(attribute, value);
            }
            else {
                element.removeAttribute(attribute);
            }
        });
    }
    else {
        if (value === true) {
            element.setAttribute(attribute, '');
        }
        else if (value === false) {
            element.removeAttribute(attribute);
        }
        else if (value != null) {
            element.setAttribute(attribute, value);
        }
        else {
            element.removeAttribute(attribute);
        }
    }
};
exports.setupAttributeUpdate = setupAttributeUpdate;
//# sourceMappingURL=setupAttributes.js.map

/***/ }),

/***/ 8446:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setupHostConfig = void 0;
const types_1 = __webpack_require__(7358);
const core_1 = __webpack_require__(88572);
const setupAttributes_1 = __webpack_require__(92786);
/**
 * Custom React Renderer with support for Facets
 *
 * Based on https://blog.atulr.com/react-custom-renderer-1/
 * For more information check the official docs: https://github.com/facebook/react/tree/main/packages/react-reconciler
 */
const setupHostConfig = () => ({
    isPrimaryRenderer: true,
    supportsMutation: true,
    supportsPersistence: false,
    supportsHydration: false,
    now: Date.now,
    /**
     * We need to support setting up the host config in an environment where window is not available globally yet
     * Ex: screenshot testing
     */
    setTimeout: typeof window !== 'undefined'
        ? window.setTimeout
        : (handler, timeout) => window.setTimeout(handler, timeout),
    /**
     * We need to support setting up the host config in an environment where window is not available globally yet
     * Ex: screenshot testing
     */
    clearTimeout: typeof window !== 'undefined' ? window.clearTimeout : (id) => window.clearTimeout(id),
    noTimeout: noop,
    scheduleDeferredCallback: function (callback, options) {
        return window.setTimeout(callback, options ? options.timeout : 0);
    },
    cancelDeferredCallback: function (id) {
        return window.clearTimeout(id);
    },
    getRootHostContext: function () {
        return EMPTY;
    },
    getChildHostContext: function () {
        return EMPTY;
    },
    shouldSetTextContent: function () {
        return false;
    },
    createTextInstance: function (newText) {
        return {
            element: document.createTextNode(newText),
        };
    },
    createInstance: function (externalType, newProps) {
        var _a;
        if (externalType === 'fast-text') {
            const element = document.createTextNode('');
            return {
                children: new Set(),
                element,
                text: (0, setupAttributes_1.setupTextUpdate)(newProps.text, element),
            };
        }
        const typeHTML = (_a = fastTypeMapHTML[externalType]) !== null && _a !== void 0 ? _a : externalType;
        const typeSVG = fastTypeMapSVG[externalType];
        const element = typeSVG != null
            ? document.createElementNS('http://www.w3.org/2000/svg', typeSVG)
            : document.createElement(typeHTML);
        let style;
        let styleUnsubscribers;
        if (newProps.style != null) {
            style = element.style;
            styleUnsubscribers = new Map();
            // We know for sure here that style will never be null (we created it above)
            const notNullStyle = style;
            const notNullStyleUnsubscribers = styleUnsubscribers;
            const styleProp = newProps.style;
            for (const key in styleProp) {
                const value = styleProp[key];
                if (value != null) {
                    if ((0, core_1.isFacet)(value)) {
                        notNullStyleUnsubscribers.set(key, value.observe((value) => {
                            notNullStyle[key] = value;
                        }));
                    }
                    else {
                        notNullStyle[key] = value;
                    }
                }
            }
        }
        if (newProps.dangerouslySetInnerHTML != null) {
            element.innerHTML = newProps.dangerouslySetInnerHTML.__html;
        }
        if (newProps.onClick) {
            element.addEventListener('click', newProps.onClick);
        }
        if (newProps.onFocus) {
            element.addEventListener('focus', newProps.onFocus);
        }
        if (newProps.onBlur) {
            element.addEventListener('blur', newProps.onBlur);
        }
        if (newProps.onMouseDown) {
            element.addEventListener('mousedown', newProps.onMouseDown);
        }
        if (newProps.onMouseMove) {
            element.addEventListener('mousemove', newProps.onMouseMove);
        }
        if (newProps.onMouseUp) {
            element.addEventListener('mouseup', newProps.onMouseUp);
        }
        if (newProps.onTouchStart) {
            element.addEventListener('touchstart', newProps.onTouchStart);
        }
        if (newProps.onTouchMove) {
            element.addEventListener('touchmove', newProps.onTouchMove);
        }
        if (newProps.onTouchEnd) {
            element.addEventListener('touchend', newProps.onTouchEnd);
        }
        if (newProps.onMouseEnter) {
            element.addEventListener('mouseenter', newProps.onMouseEnter);
        }
        if (newProps.onMouseLeave) {
            element.addEventListener('mouseleave', newProps.onMouseLeave);
        }
        if (newProps.onKeyPress) {
            element.addEventListener('keypress', newProps.onKeyPress);
        }
        if (newProps.onKeyDown) {
            element.addEventListener('keydown', newProps.onKeyDown);
        }
        if (newProps.onKeyUp) {
            element.addEventListener('keyup', newProps.onKeyUp);
        }
        return {
            element,
            styleUnsubscribers,
            style,
            children: new Set(),
            className: newProps.className != null ? (0, setupAttributes_1.setupClassUpdate)(newProps.className, element) : undefined,
            id: newProps.id != null ? (0, setupAttributes_1.setupIdUpdate)(newProps.id, element) : undefined,
            autoPlay: newProps.autoPlay != null ? (0, setupAttributes_1.setupAttributeUpdate)('autoplay', newProps.autoPlay, element) : undefined,
            loop: newProps.loop != null ? (0, setupAttributes_1.setupAttributeUpdate)('loop', newProps.loop, element) : undefined,
            href: newProps.href != null ? (0, setupAttributes_1.setupAttributeUpdate)('href', newProps.href, element) : undefined,
            target: newProps.target != null ? (0, setupAttributes_1.setupAttributeUpdate)('target', newProps.target, element) : undefined,
            disabled: newProps.disabled != null ? (0, setupAttributes_1.setupAttributeUpdate)('disabled', newProps.disabled, element) : undefined,
            maxLength: newProps.maxLength != null ? (0, setupAttributes_1.setupMaxLengthUpdate)(newProps.maxLength, element) : undefined,
            rows: newProps.rows != null ? (0, setupAttributes_1.setupRowsUpdate)(newProps.rows, element) : undefined,
            type: newProps.type != null ? (0, setupAttributes_1.setupAttributeUpdate)('type', newProps.type, element) : undefined,
            value: newProps.value != null ? (0, setupAttributes_1.setupValueUpdate)(newProps.value, element) : undefined,
            src: newProps.src != null ? (0, setupAttributes_1.setupSrcUpdate)(newProps.src, element) : undefined,
            d: newProps.d != null ? (0, setupAttributes_1.setupAttributeUpdate)('d', newProps.d, element) : undefined,
            fill: newProps.fill != null ? (0, setupAttributes_1.setupAttributeUpdate)('fill', newProps.fill, element) : undefined,
            height: newProps.height != null ? (0, setupAttributes_1.setupAttributeUpdate)('height', newProps.height, element) : undefined,
            stroke: newProps.stroke != null ? (0, setupAttributes_1.setupAttributeUpdate)('stroke', newProps.stroke, element) : undefined,
            x: newProps.x != null ? (0, setupAttributes_1.setupAttributeUpdate)('x', newProps.x, element) : undefined,
            width: newProps.width != null ? (0, setupAttributes_1.setupAttributeUpdate)('width', newProps.width, element) : undefined,
            y: newProps.y != null ? (0, setupAttributes_1.setupAttributeUpdate)('y', newProps.y, element) : undefined,
            cx: newProps.cx != null ? (0, setupAttributes_1.setupAttributeUpdate)('cx', newProps.cx, element) : undefined,
            cy: newProps.cy != null ? (0, setupAttributes_1.setupAttributeUpdate)('cy', newProps.cy, element) : undefined,
            r: newProps.r != null ? (0, setupAttributes_1.setupAttributeUpdate)('r', newProps.r, element) : undefined,
            rx: newProps.rx != null ? (0, setupAttributes_1.setupAttributeUpdate)('rx', newProps.rx, element) : undefined,
            ry: newProps.ry != null ? (0, setupAttributes_1.setupAttributeUpdate)('ry', newProps.ry, element) : undefined,
            x1: newProps.x1 != null ? (0, setupAttributes_1.setupAttributeUpdate)('x1', newProps.x1, element) : undefined,
            x2: newProps.x2 != null ? (0, setupAttributes_1.setupAttributeUpdate)('x2', newProps.x2, element) : undefined,
            y1: newProps.y1 != null ? (0, setupAttributes_1.setupAttributeUpdate)('y1', newProps.y1, element) : undefined,
            y2: newProps.y2 != null ? (0, setupAttributes_1.setupAttributeUpdate)('y2', newProps.y2, element) : undefined,
            strokeWidth: newProps.strokeWidth != null ? (0, setupAttributes_1.setupAttributeUpdate)('stroke-width', newProps.strokeWidth, element) : undefined,
            viewBox: newProps.viewBox != null ? (0, setupAttributes_1.setupViewBoxUpdate)(newProps.viewBox, element) : undefined,
            xLinkHref: newProps.xLinkHref != null ? (0, setupAttributes_1.setupAttributeUpdate)('xlink:href', newProps.xLinkHref, element) : undefined,
            fillOpacity: newProps.fillOpacity != null ? (0, setupAttributes_1.setupAttributeUpdate)('fill-opacity', newProps.fillOpacity, element) : undefined,
            strokeOpacity: newProps.strokeOpacity != null
                ? (0, setupAttributes_1.setupAttributeUpdate)('stroke-opacity', newProps.strokeOpacity, element)
                : undefined,
            strokeLinecap: newProps.strokeLinecap != null
                ? (0, setupAttributes_1.setupAttributeUpdate)('stroke-linecap', newProps.strokeLinecap, element)
                : undefined,
            strokeLinejoin: newProps.strokeLinejoin != null
                ? (0, setupAttributes_1.setupAttributeUpdate)('stroke-linejoin', newProps.strokeLinejoin, element)
                : undefined,
            points: newProps.points != null ? (0, setupAttributes_1.setupAttributeUpdate)('points', newProps.points, element) : undefined,
            offset: newProps.offset != null ? (0, setupAttributes_1.setupAttributeUpdate)('offset', newProps.offset, element) : undefined,
            stopColor: newProps.stopColor != null ? (0, setupAttributes_1.setupAttributeUpdate)('stop-color', newProps.stopColor, element) : undefined,
            stopOpacity: newProps.stopOpacity != null ? (0, setupAttributes_1.setupAttributeUpdate)('stop-opacity', newProps.stopOpacity, element) : undefined,
            fontFamily: newProps.fontFamily != null ? (0, setupAttributes_1.setupAttributeUpdate)('font-family', newProps.fontFamily, element) : undefined,
            fontSize: newProps.fontSize != null ? (0, setupAttributes_1.setupAttributeUpdate)('font-size', newProps.fontSize, element) : undefined,
            ['data-droppable']: newProps['data-droppable'] != null
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-droppable', newProps['data-droppable'], element)
                : undefined,
            ['data-narrate']: newProps['data-narrate'] != null
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-narrate', newProps['data-narrate'], element)
                : undefined,
            ['data-narrate-as']: newProps['data-narrate-as'] != null
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-narrate-as', newProps['data-narrate-as'], element)
                : undefined,
            ['data-narrate-before']: newProps['data-narrate-before'] != null
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-narrate-before', newProps['data-narrate-before'], element)
                : undefined,
            ['data-narrate-after']: newProps['data-narrate-after'] != null
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-narrate-after', newProps['data-narrate-after'], element)
                : undefined,
            ['data-testid']: newProps['data-testid'] != null
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-testid', newProps['data-testid'], element)
                : undefined,
            ['data-x-ray']: newProps['data-x-ray'] != null
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-x-ray', newProps['data-x-ray'], element)
                : undefined,
        };
    },
    finalizeInitialChildren: function () {
        return false;
    },
    prepareForCommit: function () { },
    resetAfterCommit: function () { },
    commitMount: function () { },
    prepareUpdate: function () {
        return true;
    },
    commitUpdate: function (instance, updatePayload, type, oldProps, newProps) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25;
        const { element: uncastElement } = instance;
        if (type === 'fast-text') {
            const textElement = uncastElement;
            if (newProps.text !== oldProps.text) {
                (_a = instance.text) === null || _a === void 0 ? void 0 : _a.call(instance);
                instance.text = (0, setupAttributes_1.setupTextUpdate)(newProps.text, textElement);
            }
            return;
        }
        const element = uncastElement;
        if (newProps.style !== oldProps.style) {
            const style = instance.style || element.style;
            const styleUnsubscribers = instance.styleUnsubscribers || new Map();
            instance.style = style;
            instance.styleUnsubscribers = styleUnsubscribers;
            const notNullStyle = style;
            const oldStyleProp = oldProps.style;
            const newStyleProp = newProps.style;
            if (oldStyleProp != null) {
                for (const key in oldStyleProp) {
                    const oldValue = oldStyleProp[key];
                    const newValue = newStyleProp === null || newStyleProp === void 0 ? void 0 : newStyleProp[key];
                    if (oldValue !== newValue || newStyleProp == null) {
                        if ((0, core_1.isFacet)(oldValue)) {
                            (_b = styleUnsubscribers.get(key)) === null || _b === void 0 ? void 0 : _b();
                        }
                    }
                }
            }
            if (newStyleProp != null) {
                for (const key in newStyleProp) {
                    const oldValue = oldStyleProp === null || oldStyleProp === void 0 ? void 0 : oldStyleProp[key];
                    const newValue = newStyleProp[key];
                    if (oldValue !== newValue || oldStyleProp == null) {
                        if ((0, core_1.isFacet)(newValue)) {
                            styleUnsubscribers.set(key, newValue.observe((value) => {
                                notNullStyle[key] = value;
                            }));
                        }
                        else {
                            notNullStyle[key] = newValue;
                        }
                    }
                }
            }
        }
        if (newProps.dangerouslySetInnerHTML != oldProps.dangerouslySetInnerHTML) {
            if (newProps.dangerouslySetInnerHTML != null) {
                element.innerHTML = newProps.dangerouslySetInnerHTML.__html;
            }
            else {
                element.innerHTML = '';
            }
        }
        if (newProps.autoPlay !== oldProps.autoPlay) {
            (_c = instance.autoPlay) === null || _c === void 0 ? void 0 : _c.call(instance);
            if (newProps.autoPlay == null) {
                element.removeAttribute('autoplay');
            }
            else {
                instance.autoPlay = (0, setupAttributes_1.setupAttributeUpdate)('autoplay', newProps.autoPlay, element);
            }
        }
        if (newProps.className !== oldProps.className) {
            (_d = instance.className) === null || _d === void 0 ? void 0 : _d.call(instance);
            if (newProps.className == null) {
                element.className = '';
            }
            else {
                instance.className = (0, setupAttributes_1.setupClassUpdate)(newProps.className, element);
            }
        }
        if (newProps.d !== oldProps.d) {
            (_e = instance.d) === null || _e === void 0 ? void 0 : _e.call(instance);
            if (newProps.d == null) {
                element.removeAttribute('d');
            }
            else {
                instance.d = (0, setupAttributes_1.setupAttributeUpdate)('d', newProps.d, element);
            }
        }
        if (newProps['data-droppable'] !== oldProps['data-droppable']) {
            (_f = instance['data-droppable']) === null || _f === void 0 ? void 0 : _f.call(instance);
            if (newProps['data-droppable'] == null) {
                element.removeAttribute('data-droppable');
            }
            else {
                instance['data-droppable'] = (0, setupAttributes_1.setupAttributeUpdate)('data-droppable', newProps['data-droppable'], element);
            }
        }
        if (newProps['data-narrate'] !== oldProps['data-narrate']) {
            (_g = instance['data-narrate']) === null || _g === void 0 ? void 0 : _g.call(instance);
            if (newProps['data-narrate'] == null) {
                element.removeAttribute('data-narrate');
            }
            else {
                instance['data-narrate'] = (0, setupAttributes_1.setupAttributeUpdate)('data-narrate', newProps['data-narrate'], element);
            }
        }
        if (newProps['data-narrate-as'] !== oldProps['data-narrate-as']) {
            (_h = instance['data-narrate-as']) === null || _h === void 0 ? void 0 : _h.call(instance);
            if (newProps['data-narrate-as'] == null) {
                element.removeAttribute('data-narrate-as');
            }
            else {
                instance['data-narrate-as'] = (0, setupAttributes_1.setupAttributeUpdate)('data-narrate-as', newProps['data-narrate-as'], element);
            }
        }
        if (newProps['data-narrate-after'] !== oldProps['data-narrate-after']) {
            (_j = instance['data-narrate-after']) === null || _j === void 0 ? void 0 : _j.call(instance);
            if (newProps['data-narrate-after'] == null) {
                element.removeAttribute('data-narrate-after');
            }
            else {
                instance['data-narrate-after'] = (0, setupAttributes_1.setupAttributeUpdate)('data-narrate-after', newProps['data-narrate-after'], element);
            }
        }
        if (newProps['data-narrate-before'] !== oldProps['data-narrate-before']) {
            (_k = instance['data-narrate-before']) === null || _k === void 0 ? void 0 : _k.call(instance);
            if (newProps['data-narrate-before'] == null) {
                element.removeAttribute('data-narrate-before');
            }
            else {
                instance['data-narrate-before'] = (0, setupAttributes_1.setupAttributeUpdate)('data-narrate-before', newProps['data-narrate-before'], element);
            }
        }
        if (newProps['data-testid'] !== oldProps['data-testid']) {
            (_l = instance['data-testid']) === null || _l === void 0 ? void 0 : _l.call(instance);
            if (newProps['data-testid'] == null) {
                element.removeAttribute('data-testid');
            }
            else {
                instance['data-testid'] = (0, setupAttributes_1.setupAttributeUpdate)('data-testid', newProps['data-testid'], element);
            }
        }
        if (newProps['data-x-ray'] !== oldProps['data-x-ray']) {
            (_m = instance['data-x-ray']) === null || _m === void 0 ? void 0 : _m.call(instance);
            if (newProps['data-x-ray'] == null) {
                element.removeAttribute('data-x-ray');
            }
            else {
                instance['data-x-ray'] = (0, setupAttributes_1.setupAttributeUpdate)('data-x-ray', newProps['data-x-ray'], element);
            }
        }
        if (newProps.fill !== oldProps.fill) {
            (_o = instance.fill) === null || _o === void 0 ? void 0 : _o.call(instance);
            if (newProps.fill == null) {
                element.removeAttribute('fill');
            }
            else {
                instance.fill = (0, setupAttributes_1.setupAttributeUpdate)('fill', newProps.fill, element);
            }
        }
        if (newProps.id !== oldProps.id) {
            (_p = instance.id) === null || _p === void 0 ? void 0 : _p.call(instance);
            if (newProps.id == null) {
                element.id = '';
            }
            else {
                instance.id = (0, setupAttributes_1.setupIdUpdate)(newProps.id, element);
            }
        }
        if (newProps.loop !== oldProps.loop) {
            (_q = instance.loop) === null || _q === void 0 ? void 0 : _q.call(instance);
            if (newProps.loop == null) {
                element.removeAttribute('loop');
            }
            else {
                instance.loop = (0, setupAttributes_1.setupAttributeUpdate)('loop', newProps.loop, element);
            }
        }
        if (newProps.href !== oldProps.href) {
            (_r = instance.href) === null || _r === void 0 ? void 0 : _r.call(instance);
            if (newProps.href == null) {
                element.removeAttribute('href');
            }
            else {
                instance.href = (0, setupAttributes_1.setupAttributeUpdate)('href', newProps.href, element);
            }
        }
        if (newProps.target !== oldProps.target) {
            (_s = instance.target) === null || _s === void 0 ? void 0 : _s.call(instance);
            if (newProps.target == null) {
                element.removeAttribute('target');
            }
            else {
                instance.target = (0, setupAttributes_1.setupAttributeUpdate)('target', newProps.target, element);
            }
        }
        if (newProps.disabled !== oldProps.disabled) {
            (_t = instance.disabled) === null || _t === void 0 ? void 0 : _t.call(instance);
            if (newProps.disabled == null) {
                element.removeAttribute('disabled');
            }
            else {
                instance.disabled = (0, setupAttributes_1.setupAttributeUpdate)('disabled', newProps.disabled, element);
            }
        }
        if (newProps.height !== oldProps.height) {
            (_u = instance.height) === null || _u === void 0 ? void 0 : _u.call(instance);
            if (newProps.height == null) {
                element.removeAttribute('height');
            }
            else {
                instance.height = (0, setupAttributes_1.setupAttributeUpdate)('height', newProps.height, element);
            }
        }
        if (newProps.maxLength !== oldProps.maxLength) {
            (_v = instance.maxLength) === null || _v === void 0 ? void 0 : _v.call(instance);
            if (newProps.maxLength == null) {
                const textElement = element;
                textElement.removeAttribute('maxlength');
            }
            else {
                instance.maxLength = (0, setupAttributes_1.setupMaxLengthUpdate)(newProps.maxLength, element);
            }
        }
        if (newProps.rows !== oldProps.rows) {
            (_w = instance.rows) === null || _w === void 0 ? void 0 : _w.call(instance);
            if (newProps.rows == null) {
                const textElement = element;
                textElement.removeAttribute('rows');
            }
            else {
                instance.rows = (0, setupAttributes_1.setupRowsUpdate)(newProps.rows, element);
            }
        }
        if (newProps.stroke !== oldProps.stroke) {
            (_x = instance.stroke) === null || _x === void 0 ? void 0 : _x.call(instance);
            if (newProps.stroke == null) {
                element.removeAttribute('stroke');
            }
            else {
                instance.stroke = (0, setupAttributes_1.setupAttributeUpdate)('stroke', newProps.stroke, element);
            }
        }
        if (newProps.type !== oldProps.type) {
            (_y = instance.type) === null || _y === void 0 ? void 0 : _y.call(instance);
            if (newProps.type == null) {
                const textElement = element;
                textElement.removeAttribute('type');
            }
            else {
                instance.type = (0, setupAttributes_1.setupAttributeUpdate)('type', newProps.type, element);
            }
        }
        if (newProps.value !== oldProps.value) {
            (_z = instance.value) === null || _z === void 0 ? void 0 : _z.call(instance);
            if (newProps.value == null) {
                const textElement = element;
                textElement.removeAttribute('value');
            }
            else {
                instance.value = (0, setupAttributes_1.setupValueUpdate)(newProps.value, element);
            }
        }
        if (newProps.x !== oldProps.x) {
            (_0 = instance.x) === null || _0 === void 0 ? void 0 : _0.call(instance);
            if (newProps.x == null) {
                element.removeAttribute('x');
            }
            else {
                instance.x = (0, setupAttributes_1.setupAttributeUpdate)('x', newProps.x, element);
            }
        }
        if (newProps.width !== oldProps.width) {
            (_1 = instance.width) === null || _1 === void 0 ? void 0 : _1.call(instance);
            if (newProps.width == null) {
                element.removeAttribute('width');
            }
            else {
                instance.width = (0, setupAttributes_1.setupAttributeUpdate)('width', newProps.width, element);
            }
        }
        if (newProps.y !== oldProps.y) {
            (_2 = instance.y) === null || _2 === void 0 ? void 0 : _2.call(instance);
            if (newProps.y == null) {
                element.removeAttribute('y');
            }
            else {
                instance.y = (0, setupAttributes_1.setupAttributeUpdate)('y', newProps.y, element);
            }
        }
        if (newProps.cx !== oldProps.cx) {
            (_3 = instance.cx) === null || _3 === void 0 ? void 0 : _3.call(instance);
            if (newProps.cx == null) {
                element.removeAttribute('cx');
            }
            else {
                instance.cx = (0, setupAttributes_1.setupAttributeUpdate)('cx', newProps.cx, element);
            }
        }
        if (newProps.r !== oldProps.r) {
            (_4 = instance.r) === null || _4 === void 0 ? void 0 : _4.call(instance);
            if (newProps.r == null) {
                element.removeAttribute('r');
            }
            else {
                instance.r = (0, setupAttributes_1.setupAttributeUpdate)('r', newProps.r, element);
            }
        }
        if (newProps.cy !== oldProps.cy) {
            (_5 = instance.cy) === null || _5 === void 0 ? void 0 : _5.call(instance);
            if (newProps.cy == null) {
                element.removeAttribute('cy');
            }
            else {
                instance.cy = (0, setupAttributes_1.setupAttributeUpdate)('cy', newProps.cy, element);
            }
        }
        if (newProps.rx !== oldProps.rx) {
            (_6 = instance.rx) === null || _6 === void 0 ? void 0 : _6.call(instance);
            if (newProps.rx == null) {
                element.removeAttribute('rx');
            }
            else {
                instance.rx = (0, setupAttributes_1.setupAttributeUpdate)('rx', newProps.rx, element);
            }
        }
        if (newProps.ry !== oldProps.ry) {
            (_7 = instance.ry) === null || _7 === void 0 ? void 0 : _7.call(instance);
            if (newProps.ry == null) {
                element.removeAttribute('ry');
            }
            else {
                instance.ry = (0, setupAttributes_1.setupAttributeUpdate)('ry', newProps.ry, element);
            }
        }
        if (newProps.x1 !== oldProps.x1) {
            (_8 = instance.x1) === null || _8 === void 0 ? void 0 : _8.call(instance);
            if (newProps.x1 == null) {
                element.removeAttribute('x1');
            }
            else {
                instance.x1 = (0, setupAttributes_1.setupAttributeUpdate)('x1', newProps.x1, element);
            }
        }
        if (newProps.x2 !== oldProps.x2) {
            (_9 = instance.x2) === null || _9 === void 0 ? void 0 : _9.call(instance);
            if (newProps.x2 == null) {
                element.removeAttribute('x2');
            }
            else {
                instance.x2 = (0, setupAttributes_1.setupAttributeUpdate)('x2', newProps.x2, element);
            }
        }
        if (newProps.y1 !== oldProps.y1) {
            (_10 = instance.y1) === null || _10 === void 0 ? void 0 : _10.call(instance);
            if (newProps.y1 == null) {
                element.removeAttribute('y1');
            }
            else {
                instance.y1 = (0, setupAttributes_1.setupAttributeUpdate)('y1', newProps.y1, element);
            }
        }
        if (newProps.y2 !== oldProps.y2) {
            (_11 = instance.y2) === null || _11 === void 0 ? void 0 : _11.call(instance);
            if (newProps.y2 == null) {
                element.removeAttribute('y2');
            }
            else {
                instance.y2 = (0, setupAttributes_1.setupAttributeUpdate)('y2', newProps.y2, element);
            }
        }
        if (newProps.strokeWidth !== oldProps.strokeWidth) {
            (_12 = instance.strokeWidth) === null || _12 === void 0 ? void 0 : _12.call(instance);
            if (newProps.strokeWidth == null) {
                element.removeAttribute('strokeWidth');
            }
            else {
                instance.strokeWidth = (0, setupAttributes_1.setupAttributeUpdate)('stroke-width', newProps.strokeWidth, element);
            }
        }
        if (newProps.viewBox !== oldProps.viewBox) {
            (_13 = instance.viewBox) === null || _13 === void 0 ? void 0 : _13.call(instance);
            if (newProps.viewBox == null) {
                element.removeAttribute('viewBox');
            }
            else {
                instance.viewBox = (0, setupAttributes_1.setupViewBoxUpdate)(newProps.viewBox, element);
            }
        }
        if (newProps.xLinkHref !== oldProps.xLinkHref) {
            (_14 = instance.xLinkHref) === null || _14 === void 0 ? void 0 : _14.call(instance);
            if (newProps.xLinkHref == null) {
                element.removeAttribute('xlink:href');
            }
            else {
                instance.xLinkHref = (0, setupAttributes_1.setupAttributeUpdate)('xlink:href', newProps.xLinkHref, element);
            }
        }
        if (newProps.fillOpacity !== oldProps.fillOpacity) {
            (_15 = instance.fillOpacity) === null || _15 === void 0 ? void 0 : _15.call(instance);
            if (newProps.fillOpacity == null) {
                element.removeAttribute('fill-opacity');
            }
            else {
                instance.fillOpacity = (0, setupAttributes_1.setupAttributeUpdate)('fill-opacity', newProps.fillOpacity, element);
            }
        }
        if (newProps.strokeOpacity !== oldProps.strokeOpacity) {
            (_16 = instance.strokeOpacity) === null || _16 === void 0 ? void 0 : _16.call(instance);
            if (newProps.strokeOpacity == null) {
                element.removeAttribute('stroke-opacity');
            }
            else {
                instance.strokeOpacity = (0, setupAttributes_1.setupAttributeUpdate)('stroke-opacity', newProps.strokeOpacity, element);
            }
        }
        if (newProps.strokeLinecap !== oldProps.strokeLinecap) {
            (_17 = instance.strokeLinecap) === null || _17 === void 0 ? void 0 : _17.call(instance);
            if (newProps.strokeLinecap == null) {
                element.removeAttribute('stroke-linecap');
            }
            else {
                instance.strokeLinecap = (0, setupAttributes_1.setupAttributeUpdate)('stroke-linecap', newProps.strokeLinecap, element);
            }
        }
        if (newProps.strokeLinejoin !== oldProps.strokeLinejoin) {
            (_18 = instance.strokeLinejoin) === null || _18 === void 0 ? void 0 : _18.call(instance);
            if (newProps.strokeLinejoin == null) {
                element.removeAttribute('stroke-linejoin');
            }
            else {
                instance.strokeLinejoin = (0, setupAttributes_1.setupAttributeUpdate)('stroke-linejoin', newProps.strokeLinejoin, element);
            }
        }
        if (newProps.points !== oldProps.points) {
            (_19 = instance.points) === null || _19 === void 0 ? void 0 : _19.call(instance);
            if (newProps.points == null) {
                element.removeAttribute('points');
            }
            else {
                instance.points = (0, setupAttributes_1.setupAttributeUpdate)('points', newProps.points, element);
            }
        }
        if (newProps.offset !== oldProps.offset) {
            (_20 = instance.offset) === null || _20 === void 0 ? void 0 : _20.call(instance);
            if (newProps.offset == null) {
                element.removeAttribute('offset');
            }
            else {
                instance.offset = (0, setupAttributes_1.setupAttributeUpdate)('offset', newProps.offset, element);
            }
        }
        if (newProps.stopColor !== oldProps.stopColor) {
            (_21 = instance.stopColor) === null || _21 === void 0 ? void 0 : _21.call(instance);
            if (newProps.stopColor == null) {
                element.removeAttribute('stop-color');
            }
            else {
                instance.stopColor = (0, setupAttributes_1.setupAttributeUpdate)('stop-color', newProps.stopColor, element);
            }
        }
        if (newProps.stopOpacity !== oldProps.stopOpacity) {
            (_22 = instance.stopOpacity) === null || _22 === void 0 ? void 0 : _22.call(instance);
            if (newProps.stopOpacity == null) {
                element.removeAttribute('stop-opacity');
            }
            else {
                instance.stopOpacity = (0, setupAttributes_1.setupAttributeUpdate)('stop-opacity', newProps.stopOpacity, element);
            }
        }
        if (newProps.fontFamily !== oldProps.fontFamily) {
            (_23 = instance.fontFamily) === null || _23 === void 0 ? void 0 : _23.call(instance);
            if (newProps.fontFamily == null) {
                element.removeAttribute('font-family');
            }
            else {
                instance.fontFamily = (0, setupAttributes_1.setupAttributeUpdate)('font-family', newProps.fontFamily, element);
            }
        }
        if (newProps.fontSize !== oldProps.fontSize) {
            (_24 = instance.fontSize) === null || _24 === void 0 ? void 0 : _24.call(instance);
            if (newProps.fontSize == null) {
                element.removeAttribute('font-size');
            }
            else {
                instance.fontSize = (0, setupAttributes_1.setupAttributeUpdate)('font-size', newProps.fontSize, element);
            }
        }
        if (newProps.src !== oldProps.src) {
            (_25 = instance.src) === null || _25 === void 0 ? void 0 : _25.call(instance);
            if (newProps.src == null) {
                const textElement = element;
                textElement.removeAttribute('src');
            }
            else {
                instance.src = (0, setupAttributes_1.setupSrcUpdate)(newProps.src, element);
            }
        }
        if (newProps.onClick !== oldProps.onClick) {
            if (oldProps.onClick)
                element.removeEventListener('click', oldProps.onClick);
            if (newProps.onClick)
                element.addEventListener('click', newProps.onClick);
        }
        if (newProps.onFocus !== oldProps.onFocus) {
            if (oldProps.onFocus)
                element.removeEventListener('focus', oldProps.onFocus);
            if (newProps.onFocus)
                element.addEventListener('focus', newProps.onFocus);
        }
        if (newProps.onBlur !== oldProps.onBlur) {
            if (oldProps.onBlur)
                element.removeEventListener('blur', oldProps.onBlur);
            if (newProps.onBlur)
                element.addEventListener('blur', newProps.onBlur);
        }
        if (newProps.onMouseDown !== oldProps.onMouseDown) {
            if (oldProps.onMouseDown)
                element.removeEventListener('mousedown', oldProps.onMouseDown);
            if (newProps.onMouseDown)
                element.addEventListener('mousedown', newProps.onMouseDown);
        }
        if (newProps.onMouseMove !== oldProps.onMouseMove) {
            if (oldProps.onMouseMove)
                element.removeEventListener('mousemove', oldProps.onMouseMove);
            if (newProps.onMouseMove)
                element.addEventListener('mousemove', newProps.onMouseMove);
        }
        if (newProps.onMouseEnter !== oldProps.onMouseEnter) {
            if (oldProps.onMouseEnter)
                element.removeEventListener('mouseenter', oldProps.onMouseEnter);
            if (newProps.onMouseEnter)
                element.addEventListener('mouseenter', newProps.onMouseEnter);
        }
        if (newProps.onMouseLeave !== oldProps.onMouseLeave) {
            if (oldProps.onMouseLeave)
                element.removeEventListener('mouseleave', oldProps.onMouseLeave);
            if (newProps.onMouseLeave)
                element.addEventListener('mouseleave', newProps.onMouseLeave);
        }
        if (newProps.onMouseUp !== oldProps.onMouseUp) {
            if (oldProps.onMouseUp)
                element.removeEventListener('mouseup', oldProps.onMouseUp);
            if (newProps.onMouseUp)
                element.addEventListener('mouseup', newProps.onMouseUp);
        }
        if (newProps.onTouchStart !== oldProps.onTouchStart) {
            if (oldProps.onTouchStart)
                element.removeEventListener('touchstart', oldProps.onTouchStart);
            if (newProps.onTouchStart)
                element.addEventListener('touchstart', newProps.onTouchStart);
        }
        if (newProps.onTouchMove !== oldProps.onTouchMove) {
            if (oldProps.onTouchMove)
                element.removeEventListener('touchmove', oldProps.onTouchMove);
            if (newProps.onTouchMove)
                element.addEventListener('touchmove', newProps.onTouchMove);
        }
        if (newProps.onTouchEnd !== oldProps.onTouchEnd) {
            if (oldProps.onTouchEnd)
                element.removeEventListener('touchend', oldProps.onTouchEnd);
            if (newProps.onTouchEnd)
                element.addEventListener('touchend', newProps.onTouchEnd);
        }
        if (newProps.onTouchMove !== oldProps.onTouchMove) {
            if (oldProps.onTouchMove)
                element.removeEventListener('touchmove', oldProps.onTouchMove);
            if (newProps.onTouchMove)
                element.addEventListener('touchmove', newProps.onTouchMove);
        }
        if (newProps.onTouchEnd !== oldProps.onTouchEnd) {
            if (oldProps.onTouchEnd)
                element.removeEventListener('touchend', oldProps.onTouchEnd);
            if (newProps.onTouchEnd)
                element.addEventListener('touchend', newProps.onTouchEnd);
        }
        if (newProps.onKeyPress !== oldProps.onKeyPress) {
            if (oldProps.onKeyPress)
                element.removeEventListener('keypress', oldProps.onKeyPress);
            if (newProps.onKeyPress)
                element.addEventListener('keypress', newProps.onKeyPress);
        }
        if (newProps.onKeyDown !== oldProps.onKeyDown) {
            if (oldProps.onKeyDown)
                element.removeEventListener('keydown', oldProps.onKeyDown);
            if (newProps.onKeyDown)
                element.addEventListener('keydown', newProps.onKeyDown);
        }
        if (newProps.onKeyUp !== oldProps.onKeyUp) {
            if (oldProps.onKeyUp)
                element.removeEventListener('keyup', oldProps.onKeyUp);
            if (newProps.onKeyUp)
                element.addEventListener('keyup', newProps.onKeyUp);
        }
    },
    commitTextUpdate: function (textInstance, oldText, newText) {
        textInstance.element.nodeValue = newText;
    },
    appendInitialChild: function (parent, child) {
        if ((0, types_1.isElementContainer)(child)) {
            parent.children.add(child);
        }
        parent.element.appendChild(child.element);
    },
    appendChildToContainer: function (parent, child) {
        if ((0, types_1.isElementContainer)(child)) {
            parent.children.add(child);
        }
        parent.element.appendChild(child.element);
    },
    appendChild: function (parentInstance, child) {
        if ((0, types_1.isElementContainer)(child)) {
            parentInstance.children.add(child);
        }
        parentInstance.element.appendChild(child.element);
    },
    insertBefore: function (parentInstance, child, beforeChild) {
        parentInstance.element.insertBefore(child.element, beforeChild.element);
    },
    removeChild: function (parentInstance, child) {
        if ((0, types_1.isElementContainer)(child)) {
            cleanupElementContainer(parentInstance, child);
        }
        parentInstance.element.removeChild(child.element);
    },
    insertInContainerBefore: function (container, child, beforeChild) {
        container.element.insertBefore(child.element, beforeChild.element);
    },
    removeChildFromContainer: function (container, child) {
        if ((0, types_1.isElementContainer)(child)) {
            cleanupElementContainer(container, child);
        }
        container.element.removeChild(child.element);
    },
    resetTextContent: function (instance) {
        instance.element.textContent = '';
    },
    shouldDeprioritizeSubtree: function () {
        return false;
    },
    getPublicInstance: function (instance) {
        return instance.element;
    },
});
exports.setupHostConfig = setupHostConfig;
const cleanupElementContainer = (parent, instance) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    parent.children.delete(instance);
    (_a = instance.styleUnsubscribers) === null || _a === void 0 ? void 0 : _a.forEach((unsubscribe) => unsubscribe());
    (_b = instance.styleUnsubscribers) === null || _b === void 0 ? void 0 : _b.clear();
    instance.children.forEach(cleanupElementContainer);
    instance.children.clear();
    (_c = instance.className) === null || _c === void 0 ? void 0 : _c.call(instance);
    (_d = instance['data-droppable']) === null || _d === void 0 ? void 0 : _d.call(instance);
    (_e = instance['data-narrate']) === null || _e === void 0 ? void 0 : _e.call(instance);
    (_f = instance['data-narrate-as']) === null || _f === void 0 ? void 0 : _f.call(instance);
    (_g = instance['data-narrate-after']) === null || _g === void 0 ? void 0 : _g.call(instance);
    (_h = instance['data-narrate-before']) === null || _h === void 0 ? void 0 : _h.call(instance);
    (_j = instance['data-testid']) === null || _j === void 0 ? void 0 : _j.call(instance);
    (_k = instance['data-x-ray']) === null || _k === void 0 ? void 0 : _k.call(instance);
    (_l = instance.id) === null || _l === void 0 ? void 0 : _l.call(instance);
    (_m = instance.src) === null || _m === void 0 ? void 0 : _m.call(instance);
    (_o = instance.href) === null || _o === void 0 ? void 0 : _o.call(instance);
    (_p = instance.target) === null || _p === void 0 ? void 0 : _p.call(instance);
    (_q = instance.autoPlay) === null || _q === void 0 ? void 0 : _q.call(instance);
    (_r = instance.loop) === null || _r === void 0 ? void 0 : _r.call(instance);
    (_s = instance.disabled) === null || _s === void 0 ? void 0 : _s.call(instance);
    (_t = instance.maxLength) === null || _t === void 0 ? void 0 : _t.call(instance);
    (_u = instance.rows) === null || _u === void 0 ? void 0 : _u.call(instance);
    (_v = instance.value) === null || _v === void 0 ? void 0 : _v.call(instance);
    (_w = instance.type) === null || _w === void 0 ? void 0 : _w.call(instance);
    (_x = instance.text) === null || _x === void 0 ? void 0 : _x.call(instance);
};
const noop = () => { };
const EMPTY = {};
const fastTypeMapHTML = {
    'fast-a': 'a',
    'fast-div': 'div',
    'fast-p': 'p',
    'fast-img': 'img',
    'fast-input': 'input',
    'fast-span': 'span',
    'fast-textarea': 'textarea',
    'fast-text': 'span',
    a: 'a',
    div: 'div',
    p: 'p',
    img: 'img',
    textarea: 'textarea',
    input: 'input',
    style: 'style',
};
const fastTypeMapSVG = {
    'fast-circle': 'circle',
    'fast-ellipse': 'ellipse',
    'fast-line': 'line',
    'fast-path': 'path',
    'fast-rect': 'rect',
    'fast-svg': 'svg',
    'fast-use': 'use',
    'fast-polyline': 'polyline',
    'fast-polygon': 'polygon',
    'fast-linearGradient': 'linearGradient',
    'fast-radialGradient': 'radialGradient',
    'fast-stop': 'stop',
    'fast-svg-text': 'text',
    'fast-pattern': 'pattern',
    circle: 'circle',
    ellipse: 'ellipse',
    line: 'line',
    path: 'path',
    rect: 'rect',
    svg: 'svg',
    symbol: 'symbol',
    g: 'g',
    use: 'use',
    defs: 'defs',
    polyline: 'polyline',
    polygon: 'polygon',
    linearGradient: 'linearGradient',
    radialGradient: 'radialGradient',
    stop: 'stop',
    text: 'text',
    pattern: 'pattern',
};
//# sourceMappingURL=setupHostConfig.js.map

/***/ }),

/***/ 7358:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isElementContainer = void 0;
const isElementContainer = (value) => {
    return value != null && 'children' in value;
};
exports.isElementContainer = isElementContainer;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 3130:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useSharedFacet = exports.SharedFacetDriverProvider = exports.sharedFacetDriverContext = void 0;
const react_1 = __webpack_require__(67294);
const dummyConstructor = () => () => { };
exports.sharedFacetDriverContext = (0, react_1.createContext)(dummyConstructor);
exports.SharedFacetDriverProvider = exports.sharedFacetDriverContext.Provider;
const useSharedFacet = (sharedFacet) => {
    return sharedFacet((0, react_1.useContext)(exports.sharedFacetDriverContext));
};
exports.useSharedFacet = useSharedFacet;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ 30401:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(3130), exports);
__exportStar(__webpack_require__(37350), exports);
__exportStar(__webpack_require__(51090), exports);
__exportStar(__webpack_require__(15685), exports);
__exportStar(__webpack_require__(60815), exports);
__exportStar(__webpack_require__(20206), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5811:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Simple memoize implementation that supports a single argument
 *
 * TODO: handle cleaning up the cache.
 */
function memoize(fn) {
    const results = new Map();
    return (argument) => {
        const previousResult = results.get(argument);
        if (previousResult)
            return previousResult;
        const newResult = fn(argument);
        results.set(argument, newResult);
        return newResult;
    };
}
exports["default"] = memoize;
//# sourceMappingURL=memoize.js.map

/***/ }),

/***/ 37350:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sharedDynamicSelector = void 0;
const memoize_1 = __importDefault(__webpack_require__(5811));
const core_1 = __webpack_require__(88572);
const sharedSelector_1 = __webpack_require__(15685);
/**
 * Defines a selector that can take a parameter
 * For more information check the documentation on defining a selector.
 *
 * @param selectorFactory differently from a selector, this is a function that takes the parameter to return the selector
 * @param equalityCheck optional, has a default for immutable values
 */
function sharedDynamicSelector(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
selectorFactory, equalityCheck = core_1.defaultEqualityCheck) {
    return (0, memoize_1.default)((parameter) => {
        const [selector, facets] = selectorFactory(parameter);
        const definition = (0, memoize_1.default)((sharedFacetDriver) => {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return sharedSelector_1.sharedSelector(selector, facets, equalityCheck)(sharedFacetDriver);
        });
        definition.factory = core_1.FACET_FACTORY;
        return definition;
    });
}
exports.sharedDynamicSelector = sharedDynamicSelector;
//# sourceMappingURL=sharedDynamicSelector.js.map

/***/ }),

/***/ 51090:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sharedFacet = void 0;
const memoize_1 = __importDefault(__webpack_require__(5811));
const core_1 = __webpack_require__(88572);
/**
 * Defines a facet with shared data
 *
 * @param name the name of the facet (used to construct it with the sharedFacetDriver)
 * @param initialValue optional default value while constructor is not ready with the real value
 */
function sharedFacet(name, initialValue = core_1.NO_VALUE) {
    const definition = (0, memoize_1.default)((sharedFacetDriver) => (0, core_1.createFacet)({
        initialValue,
        startSubscription: (update) => {
            return sharedFacetDriver(name, update);
        },
    }));
    definition.factory = core_1.FACET_FACTORY;
    return definition;
}
exports.sharedFacet = sharedFacet;
//# sourceMappingURL=sharedFacet.js.map

/***/ }),

/***/ 15685:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sharedSelector = void 0;
const memoize_1 = __importDefault(__webpack_require__(5811));
const core_1 = __webpack_require__(88572);
/**
 * Defines a selector to transform/map data from a facet
 *
 * When used correctly, it can limit components being re-rendered if they only
 * care about a specific attribute/function of a facet.
 *
 * To take full advantage of a selector, it is important to choose a proper equalityCheck
 * with an IMPORTANT understanding of the source of the data (if it is mutable for example).
 *
 * If the source of the data is an object or array that is being mutated, then it would mean that
 * the current and previous values passed to the equalityCheck would be same reference, making it
 * impossible to run any equality check. We recommend only using an equality check if the values
 * returned by the selector are numbers, booleans, strings, or objects/arrays constructed by the selector.
 *
 * @param facets which facets to read the data from
 * @param selector a function to transform the data from the facets
 * @param equalityCheck optional, has a default for immutable values
 */
function sharedSelector(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
selector, facets, equalityCheck = core_1.defaultEqualityCheck) {
    const definition = (0, memoize_1.default)((sharedFacetDriver) => (0, core_1.mapFacetsCached)(facets.map((facet) => facet(sharedFacetDriver)), selector, equalityCheck));
    definition.factory = core_1.FACET_FACTORY;
    return definition;
}
exports.sharedSelector = sharedSelector;
//# sourceMappingURL=sharedSelector.js.map

/***/ }),

/***/ 60815:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 20206:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useSharedFacetPropSetter = void 0;
const core_1 = __webpack_require__(88572);
const context_1 = __webpack_require__(3130);
/**
 * Hook that returns a setter function to a specific property of a given sharedFacet
 * Ex:
 * 	- Given a shared facet { foo: 'bar' }
 *  - Could be used as useSharedFacetPropSetter(facet, 'foo')
 *  - And the setter would set the foo property
 *
 * @param sharedFacet
 * @param prop the name of the prop to set
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function useSharedFacetPropSetter(sharedFacet, prop) {
    return (0, core_1.useFacetCallback)((facet) => (newValue) => {
        facet[prop] = newValue;
    }, [prop], [(0, context_1.useSharedFacet)(sharedFacet)]);
}
exports.useSharedFacetPropSetter = useSharedFacetPropSetter;
//# sourceMappingURL=useSharedFacetPropSetter.js.map

/***/ }),

/***/ 52910:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

window.__globalDevCoreUISoundDefinitions = window.__globalDevCoreUISoundDefinitions || {};
Object.assign(window.__globalDevCoreUISoundDefinitions, {
  "tokens.vanilla.release": {
    "category": "ui",
    "sounds": [{
      "name": __webpack_require__(99373)
    }]
  },
  "tokens.vanilla.snes_pop": {
    "category": "ui",
    "sounds": [{
      "name": __webpack_require__(43464)
    }]
  },
  "tokens.vanilla.modal_hide": {
    "category": "ui",
    "sounds": [{
      "name": __webpack_require__(60197)
    }]
  }
});

/***/ }),

/***/ 35341:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*jslint browser: true, nomen: true, plusplus: true */
/// @file cohtml.js
/// @namespace engine
/// Coherent UI JavaScript interface.
/// The `engine` module contains all functions for communication between the UI and the game / application.
(function (factory) {
  console.log('Loading Client Side cohtml file...'); // This is a modified cohtml file so that it returns a function that calls the factory of the module,
  // allowing us to conditionally execute it from the outside.

  if ( true && module.exports) {
    module.exports = () => factory(__webpack_require__.g, __webpack_require__.g.engine, false);
  }
})(function (global, engine, hasOnLoad) {
  'use strict';

  var VERSION = [1, 5, 0, 8];
  /**
  * Event emitter
  *
  * @class Emitter
  */

  function Emitter() {
    this.events = {};
  }

  function Handler(code, context) {
    this.code = code;
    this.context = context;
  }

  Emitter.prototype._createClear = function (object, name, handler) {
    return function () {
      var handlers = object.events[name];

      if (handlers) {
        var index = -1; // this was in native previously

        if (handler == null) {
          for (var i = 0; i < handlers.length; ++i) {
            if (handlers[i].wasInCPP != null) {
              index = i;
              break;
            }
          }
        } else {
          index = handlers.indexOf(handler);
        }

        if (index != -1) {
          handlers.splice(index, 1);

          if (handlers.length === 0) {
            delete object.events[name];
          }
        }
      } else {
        if (engine.RemoveOnHandler != null) {
          engine.RemoveOnHandler(name);
        }
      }
    };
  };
  /**
  * Add a handler for an event
  *
  * @method on
  * @param name the event name
  * @param callback function to be called when the event is triggered
  * @param context this binding for executing the handler, defaults to the Emitter
  * @return connection object
  */


  Emitter.prototype.on = function (name, callback, context) {
    var handlers = this.events[name];
    if (handlers == null) handlers = this.events[name] = [];
    var handler = new Handler(callback, context || this);
    handlers.push(handler);
    return {
      clear: this._createClear(this, name, handler)
    };
  };
  /**
  * Remove a handler from an event
  *
  * @method off
  * @param name the event name
  * @param handler function to be called when the event is triggered
  * @param context this binding for executing the handler, defaults to the Emitter
  * @return connection object
  */


  Emitter.prototype.off = function (name, handler, context) {
    var handlers = this.events[name];

    if (handlers != null) {
      context = context || this;
      var index;
      var length = handlers.length;

      for (index = 0; index < length; ++index) {
        var reg = handlers[index];

        if (reg.code == handler && reg.context == context) {
          break;
        }
      }

      if (index < length) {
        handlers.splice(index, 1);

        if (handlers.length === 0) {
          delete this.events[name];
        }
      }
    } else {
      engine.RemoveOnHandler(name);
    }
  };

  var isAttached = engine != null;
  engine = engine || {}; /// @var {bool} engine.isAttached
  /// Indicates whether the script is currently running inside Cohtml

  engine.isAttached = isAttached;
  engine.onEventsReplayed = null;

  Emitter.prototype.trigger = function (name) {
    var handlers = this.events[name];

    if (handlers != null) {
      var args = Array.prototype.slice.call(arguments, 1);
      handlers.forEach(function (handler) {
        handler.code.apply(handler.context, args);
      });
      return true;
    }

    return false;
  };

  Emitter.prototype.merge = function (emitter) {
    var lhs = this.events,
        rhs = emitter.events,
        push = Array.prototype.push,
        events;

    for (var e in rhs) {
      events = lhs[e] = lhs[e] || [];
      push.apply(events, rhs[e]);
    }
  };

  var pending = 'pending';
  var fulfilled = 'fulfilled';
  var broken = 'broken';

  function callAsync(code, context, argument) {
    var async = function () {
      code.call(context, argument);
    };

    window.setTimeout(async, 1);
  }

  if (!engine.isAttached) {
    Emitter.prototype.on = function (name, callback, context) {
      var handlers = this.events[name];

      if (
      /** @type {any} */
      this.browserCallbackOn) {
        /** @type {any} */
        this.browserCallbackOn(name, callback, context);
      }

      if (handlers == null) {
        handlers = this.events[name] = [];
      }

      var handler = new Handler(callback, context || this);
      handlers.push(handler);
      return {
        clear: this._createClear(this, name, handler)
      };
    };

    Emitter.prototype.off = function (name, handler, context) {
      var handlers = this.events[name];

      if (handlers != null) {
        context = context || this;
        var index;
        var length = handlers.length;

        for (index = 0; index < length; ++index) {
          var reg = handlers[index];

          if (reg.code == handler && reg.context == context) {
            break;
          }
        }

        if (index < length) {
          handlers.splice(index, 1);

          if (handlers.length === 0) {
            delete this.events[name];

            if (
            /** @type {any} */
            this.browserCallbackOff) {
              /** @type {any} */
              this.browserCallbackOff(name, handler, context);
            }
          }
        }
      }
    };

    engine.SendMessage = function (name, id) {
      var args = Array.prototype.slice.call(arguments, 2);
      var deferred = engine._ActiveRequests[id];
      delete engine._ActiveRequests[id];

      var call = function () {
        var mock = engine._mocks[name];

        if (mock != null) {
          deferred.resolve(mock.apply(engine, args));
        }
      };

      window.setTimeout(call, 16);
    }; /// @function engine.TriggerEvent
    /// Tries to invoke handlers for an event.
    ///
    /// It will invoke any handler registered in C++ or the only handler registered in JavaScript.
    /// engine._trigger will handle the case where more than one event handler is registered in JavaScript
    /// or there are handlers from C++ and JavaScript at the same time.
    /// @param {String} name name of the event to be fired
    /// @param ... any extra parameters to be passed to event handlers
    /// @return true if any event handlers have been registered in C++ or exactly one in JavaScript
    /// @note this mock-mode version will return true if there is any event handler in JavaScript


    engine.TriggerEvent = function () {
      var args = Array.prototype.slice.call(arguments);

      var trigger = function () {
        var mock = engine._mocks[args[0]];

        if (mock != null) {
          mock.apply(engine, args.slice(1));
        }
      };

      window.setTimeout(trigger, 16);
      return engine._mocks[args[0]] != null;
    };

    engine.BindingsReady = function () {
      engine._OnReady();
    };

    engine.__observeLifetime = function () {};

    engine.beginEventRecording = engine.endEventRecording = engine.saveEventRecord = function () {
      console.warn("Event recording will not work in the browser!");
    };

    engine._mocks = {};

    engine._mockImpl = function (name, mock, isCppCall, isEvent) {
      if (mock) {
        this._mocks[name] = mock;
      } // Extract the name of the arguments from Function.prototype.toString


      var functionStripped = mock.toString().replace("function " + mock.name + "(", "");
      var rightParanthesis = functionStripped.indexOf(")");
      var args = functionStripped.substr(0, rightParanthesis);

      if (this.browserCallbackMock) {
        this.browserCallbackMock(name, args, isCppCall, Boolean(isEvent));
      }
    };

    engine.mock = function (name, mock, isEvent) {
      this._mockImpl(name, mock, true, isEvent);
    };
  }

  engine.events = {};

  for (var property in Emitter.prototype) {
    engine[property] = Emitter.prototype[property];
  }

  if (engine.isAttached) {
    /// @function engine.on
    /// Register handler for and event
    /// @param {String} name name of the event
    /// @param {Function} callback callback function to be executed when the event has been triggered
    /// @param context *this* context for the function, by default the engine object
    engine.on = function (name, callback, context) {
      var handlers = this.events[name];

      if (handlers == null && engine.AddOrRemoveOnHandler != null) {
        // Check where to cache the handler
        var prevEvent = engine.AddOrRemoveOnHandler(name, callback, context || engine); // handler cached in C++

        if (prevEvent == null) {
          return {
            clear: this._createClear(this, name, undefined)
          };
        }

        handlers = this.events[name] = []; // Add the previous handler

        var prevHandler = new Handler(prevEvent[0], prevEvent[1] || this);
        /** @type {any} */

        prevHandler.wasInCPP = true;
        handlers.push(prevHandler);
      } else if (handlers == null) {
        handlers = this.events[name] = [];
      }

      var handler = new Handler(callback, context || this);
      handlers.push(handler);
      return {
        clear: this._createClear(this, name, handler)
      };
    };
  }

  engine.whenReady = new Promise(resolve => {
    engine.on('Ready', resolve);
  }); /// @function engine.beginEventRecording
  /// Begins recording all events triggered using View::TriggerEvent from the game
  /// @function engine.endEventRecording
  /// Ends event recording
  /// @function engine.saveEventRecord
  /// Saves the events recorded in between the last calls to engine.beginEventRecording and engine.endEventRecording to a file
  /// @param {String} path The path to the file where to save the recorded events. Optional. Defaults to "eventRecord.json"
  /// @function engine.replayEvents
  /// Replays the events previously recorded and stored in path. If you need to be notified when all events
  /// are replayed, assign a callback to engine.onEventsReplayed
  /// @param {Number} timeScale The speed at which to replay the events (e.g. pass 2 to double the speed). Optional. Defaults to 1.
  /// @param {String} path The path to the file the recorded events are stored. Optional. Defaults to "eventRecord.json"
  /// @function engine.off
  /// Remove handler for an event
  /// @param {String} name name of the event, by default removes all events
  /// @param {Function} callback the callback function to be removed, by default removes all callbacks for a given event
  /// @param context *this* context for the function, by default all removes all callbacks, regardless of context
  /// @warning Removing all handlers for `engine` will remove some *Coherent UI* internal events, breaking some functionality.
  /// @function engine.trigger
  /// Trigger an event
  /// This function will trigger any C++ handler registered for this event with `Coherent::UI::View::RegisterForEvent`
  /// @param {String} name name of the event
  /// @param ... any extra arguments to be passed to the event handlers

  engine._trigger = Emitter.prototype.trigger;
  var concatArguments = Array.prototype.concat;

  engine.trigger = function (name) {
    if (!this._trigger.apply(this, arguments)) {
      this.TriggerEvent.apply(this, arguments);
    }

    if (this.events['all'] != null) {
      var allArguments = concatArguments.apply(['all'], arguments);

      this._trigger.apply(this, allArguments);
    }
  }; /// @function engine.showOverlay
  /// Shows the debugging overlay in the browser.
  /// Only works in the browser. Attempts to use it in Coherent UI will do nothing.


  engine.showOverlay = function () {}; /// @function engine.hideOverlay
  /// Hides the debugging overlay in the browser.
  /// Only works in the browser. Attempts to use it in Coherent UI will do nothing.


  engine.hideOverlay = function () {}; /// @function engine.mock
  /// Mocks a C++ function call with the specified function.
  /// Only works in the browser. Attempts to use it in Coherent UI will do nothing.
  /// @param {String} name name of the event
  /// @param {Function} mock a function to be called in-place of your native binding
  /// @param {Boolean} isEvent whether you are mocking an event or function call


  if (engine.isAttached) {
    engine.mock = function (name, mock, isEvent) {};
  }

  engine._BindingsReady = false;
  engine._WindowLoaded = false;
  engine._RequestId = 0;
  engine._ActiveRequests = {};

  if (global.engineCreateDeferred != null) {
    console.warn("engineCreateDeferred is depricated");
  } /// @function engine.call
  /// Call asynchronously a C++ handler and retrieve the result
  /// The C++ handler must have been registered with `Coherent::UI::View::BindCall`
  /// @param {String} name name of the C++ handler to be called
  /// @param ... any extra parameters to be passed to the C++ handler
  /// @return ECMAScript 6 promise


  engine.call = function () {
    engine._RequestId++;
    var id = engine._RequestId;
    var messageArguments = Array.prototype.slice.call(arguments);
    messageArguments.splice(1, 0, id);
    var promise = new Promise(function (resolve, reject) {
      engine._ActiveRequests[id] = {
        resolve: resolve,
        reject: reject
      };
      engine.SendMessage.apply(engine, messageArguments);
    });
    return promise;
  };

  engine._Result = function (requestId) {
    var deferred = engine._ActiveRequests[requestId];

    if (deferred != null) {
      delete engine._ActiveRequests[requestId];
      var resultArguments = Array.prototype.slice.call(arguments);
      resultArguments.shift();
      deferred.resolve.apply(deferred, resultArguments);
    }
  };

  engine._Errors = ['Success', 'ArgumentType', 'NoSuchMethod', 'NoResult'];

  engine._ForEachError = function (errors, callback) {
    var length = errors.length;

    for (var i = 0; i < length; ++i) {
      callback(errors[i].first, errors[i].second);
    }
  };

  engine._TriggerError = function (message) {
    engine.trigger('Error', message);
  };

  engine._OnError = function (requestId, errors) {
    if (requestId == null || requestId === 0) {
      engine._ForEachError(errors, engine._TriggerError);
    } else {
      var deferred = engine._ActiveRequests[requestId];
      delete engine._ActiveRequests[requestId];
      deferred.reject(new Error(errors[0].second));
    }

    if (errors.length) {
      throw new Error(errors[0].second);
    }
  };

  engine._eventHandles = {};

  engine._Register = function (eventName) {
    var trigger = function (name, engine) {
      return function () {
        var eventArguments = [name];
        eventArguments.push.apply(eventArguments, arguments);
        engine.TriggerEvent.apply(this, eventArguments);
      };
    }(eventName, engine);

    engine._eventHandles[eventName] = engine.on(eventName, trigger);
  };

  engine._removeEventThunk = function (name) {
    var handle = engine._eventHandles[name];
    handle.clear();
    delete engine._eventHandles[name];
  };

  engine._Unregister = function (name) {
    if (typeof name === 'string') {
      engine._removeEventThunk(name);
    } else {
      name.forEach(engine._removeEventThunk, engine);
    }
  };

  function createMethodStub(name) {
    var stub = function () {
      var args = Array.prototype.slice.call(arguments);
      args.splice(0, 0, name, this._id);
      return engine.call.apply(engine, args);
    };

    return stub;
  }

  engine._boundTypes = {};

  engine._createInstance = function (args) {
    var type = args[0],
        id = args[1],
        methods = args[2],
        constructor = engine._boundTypes[type];

    if (constructor == null) {
      constructor = function (id) {
        this._id = id;
      };

      constructor.prototype.__Type = type;
      methods.forEach(function (name) {
        constructor.prototype[name] = createMethodStub(type + '_' + name);
      });
      engine._boundTypes[type] = constructor;
    }

    var instance = new constructor(id);

    engine.__observeLifetime(instance);

    return instance;
  };

  engine._OnReady = function () {
    engine._BindingsReady = true;

    if (engine._WindowLoaded) {
      engine.trigger('Ready');
    }
  };

  engine._OnWindowLoaded = function () {
    engine._WindowLoaded = true;

    if (engine._BindingsReady) {
      engine.trigger('Ready');
    }
  };

  engine._ThrowError = function (error) {
    var prependTab = function (s) {
      return "\t" + s;
    };

    var errorString = error.name + ": " + error.message + "\n" + error.stack.split("\n").map(prependTab).join("\n");
    console.error(errorString);
  };

  if (hasOnLoad) {
    global.addEventListener("load", function () {
      engine._OnWindowLoaded();
    });
  } else {
    engine._WindowLoaded = true;
  }

  engine.on('_Result', engine._Result, engine);
  engine.on('_Register', engine._Register, engine);
  engine.on('_Unregister', engine._Unregister, engine);
  engine.on('_OnReady', engine._OnReady, engine);
  engine.on('_OnError', engine._OnError, engine);
  engine.on('__OnReplayRecordCompleted', function (jsonRecords) {
    if (engine.onEventsReplayed) {
      engine.onEventsReplayed();
    }
  }); //@ts-ignore

  engine.dependency = new WeakMap();
  engine.updateWholeModelCallbacks = [];
  engine.hasAttachedUpdateListner = false;

  engine.onUpdateWholeModel = object => {
    let deps = engine.dependency.get(object) || [];
    deps.forEach(dep => engine.updateWholeModel(dep));
  };

  engine.createObservableModel = observableName => {
    const handler = {
      set: (target, prop, value) => {
        engine.updateWholeModel(window[observableName]);
        target[prop] = value;
      }
    }; // @ts-ignore

    engine.createJSModel(observableName, new Proxy({}, handler));
  };

  engine.addSynchronizationDependency = (first, second) => {
    if (!engine.hasAttachedUpdateListner) {
      // will attach updateWholeModel callback for when there are one or more model dependencies
      engine.addDataBindEventListner("updateWholeModel", engine.onUpdateWholeModel);
      engine.hasAttachedUpdateListner = true;
    }

    let deps = engine.dependency.get(first);

    if (!deps) {
      deps = [];
      engine.dependency.set(first, deps);
    }

    deps.push(second);
  };

  engine.removeSynchronizationDependency = (first, second) => {
    let deps = engine.dependency.get(first) || [];
    deps.splice(deps.indexOf(first), 1);
  };

  engine.BindingsReady(VERSION[0], VERSION[1], VERSION[2], VERSION[3]);
  return engine;
});

/***/ }),

/***/ 35107:
/***/ (() => {



/***/ }),

/***/ 57811:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "facet": () => (/* binding */ facet),
/* harmony export */   "shallowObjectEqualityCheck": () => (/* binding */ shallowObjectEqualityCheck)
/* harmony export */ });
/* unused harmony exports strictShallowObjectEqualityCheck, localFacet, useFacet, useFacetSetter */
/* harmony import */ var _react_facet_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88572);
/* harmony import */ var _react_facet_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "Map")) __webpack_require__.d(__webpack_exports__, { "Map": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.Map; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "Mount")) __webpack_require__.d(__webpack_exports__, { "Mount": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.Mount; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "NO_VALUE")) __webpack_require__.d(__webpack_exports__, { "NO_VALUE": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.NO_VALUE; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "SharedFacetDriverProvider")) __webpack_require__.d(__webpack_exports__, { "SharedFacetDriverProvider": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.SharedFacetDriverProvider; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "With")) __webpack_require__.d(__webpack_exports__, { "With": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.With; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "createFacet")) __webpack_require__.d(__webpack_exports__, { "createFacet": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.createFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "createFacetContext")) __webpack_require__.d(__webpack_exports__, { "createFacetContext": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.createFacetContext; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "createStaticFacet")) __webpack_require__.d(__webpack_exports__, { "createStaticFacet": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.createStaticFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "isFacet")) __webpack_require__.d(__webpack_exports__, { "isFacet": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.isFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "multiObserve")) __webpack_require__.d(__webpack_exports__, { "multiObserve": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.multiObserve; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "render")) __webpack_require__.d(__webpack_exports__, { "render": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.render; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "shallowObjectArrayEqualityCheck")) __webpack_require__.d(__webpack_exports__, { "shallowObjectArrayEqualityCheck": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.shallowObjectArrayEqualityCheck; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "sharedDynamicSelector")) __webpack_require__.d(__webpack_exports__, { "sharedDynamicSelector": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.sharedDynamicSelector; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "sharedFacet")) __webpack_require__.d(__webpack_exports__, { "sharedFacet": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.sharedFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "sharedFacetDriverContext")) __webpack_require__.d(__webpack_exports__, { "sharedFacetDriverContext": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.sharedFacetDriverContext; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "sharedSelector")) __webpack_require__.d(__webpack_exports__, { "sharedSelector": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.sharedSelector; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetCallback")) __webpack_require__.d(__webpack_exports__, { "useFacetCallback": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetCallback; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetEffect")) __webpack_require__.d(__webpack_exports__, { "useFacetEffect": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetEffect; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetLayoutEffect")) __webpack_require__.d(__webpack_exports__, { "useFacetLayoutEffect": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetLayoutEffect; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetMap")) __webpack_require__.d(__webpack_exports__, { "useFacetMap": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetMap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetMemo")) __webpack_require__.d(__webpack_exports__, { "useFacetMemo": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetMemo; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetRef")) __webpack_require__.d(__webpack_exports__, { "useFacetRef": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetRef; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetState")) __webpack_require__.d(__webpack_exports__, { "useFacetState": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetState; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetUnwrap")) __webpack_require__.d(__webpack_exports__, { "useFacetUnwrap": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetUnwrap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetWrap")) __webpack_require__.d(__webpack_exports__, { "useFacetWrap": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetWrap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useSharedFacet")) __webpack_require__.d(__webpack_exports__, { "useSharedFacet": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useSharedFacet; } });
/* harmony import */ var _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47154);
/* harmony import */ var _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "Map")) __webpack_require__.d(__webpack_exports__, { "Map": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.Map; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "Mount")) __webpack_require__.d(__webpack_exports__, { "Mount": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.Mount; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "NO_VALUE")) __webpack_require__.d(__webpack_exports__, { "NO_VALUE": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.NO_VALUE; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "SharedFacetDriverProvider")) __webpack_require__.d(__webpack_exports__, { "SharedFacetDriverProvider": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.SharedFacetDriverProvider; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "With")) __webpack_require__.d(__webpack_exports__, { "With": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.With; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "createFacet")) __webpack_require__.d(__webpack_exports__, { "createFacet": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.createFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "createFacetContext")) __webpack_require__.d(__webpack_exports__, { "createFacetContext": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.createFacetContext; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "createStaticFacet")) __webpack_require__.d(__webpack_exports__, { "createStaticFacet": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.createStaticFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "isFacet")) __webpack_require__.d(__webpack_exports__, { "isFacet": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.isFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "multiObserve")) __webpack_require__.d(__webpack_exports__, { "multiObserve": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.multiObserve; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "render")) __webpack_require__.d(__webpack_exports__, { "render": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.render; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "shallowObjectArrayEqualityCheck")) __webpack_require__.d(__webpack_exports__, { "shallowObjectArrayEqualityCheck": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.shallowObjectArrayEqualityCheck; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "sharedDynamicSelector")) __webpack_require__.d(__webpack_exports__, { "sharedDynamicSelector": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.sharedDynamicSelector; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "sharedFacet")) __webpack_require__.d(__webpack_exports__, { "sharedFacet": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.sharedFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "sharedFacetDriverContext")) __webpack_require__.d(__webpack_exports__, { "sharedFacetDriverContext": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.sharedFacetDriverContext; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "sharedSelector")) __webpack_require__.d(__webpack_exports__, { "sharedSelector": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.sharedSelector; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetCallback")) __webpack_require__.d(__webpack_exports__, { "useFacetCallback": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetCallback; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetEffect")) __webpack_require__.d(__webpack_exports__, { "useFacetEffect": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetEffect; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetLayoutEffect")) __webpack_require__.d(__webpack_exports__, { "useFacetLayoutEffect": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetLayoutEffect; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetMap")) __webpack_require__.d(__webpack_exports__, { "useFacetMap": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetMap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetMemo")) __webpack_require__.d(__webpack_exports__, { "useFacetMemo": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetMemo; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetRef")) __webpack_require__.d(__webpack_exports__, { "useFacetRef": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetRef; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetState")) __webpack_require__.d(__webpack_exports__, { "useFacetState": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetState; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetUnwrap")) __webpack_require__.d(__webpack_exports__, { "useFacetUnwrap": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetUnwrap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetWrap")) __webpack_require__.d(__webpack_exports__, { "useFacetWrap": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetWrap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useSharedFacet")) __webpack_require__.d(__webpack_exports__, { "useSharedFacet": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useSharedFacet; } });
/* harmony import */ var _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30401);
/* harmony import */ var _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "Map")) __webpack_require__.d(__webpack_exports__, { "Map": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.Map; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "Mount")) __webpack_require__.d(__webpack_exports__, { "Mount": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.Mount; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "NO_VALUE")) __webpack_require__.d(__webpack_exports__, { "NO_VALUE": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.NO_VALUE; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "SharedFacetDriverProvider")) __webpack_require__.d(__webpack_exports__, { "SharedFacetDriverProvider": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.SharedFacetDriverProvider; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "With")) __webpack_require__.d(__webpack_exports__, { "With": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.With; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "createFacet")) __webpack_require__.d(__webpack_exports__, { "createFacet": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.createFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "createFacetContext")) __webpack_require__.d(__webpack_exports__, { "createFacetContext": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.createFacetContext; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "createStaticFacet")) __webpack_require__.d(__webpack_exports__, { "createStaticFacet": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.createStaticFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "isFacet")) __webpack_require__.d(__webpack_exports__, { "isFacet": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.isFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "multiObserve")) __webpack_require__.d(__webpack_exports__, { "multiObserve": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.multiObserve; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "render")) __webpack_require__.d(__webpack_exports__, { "render": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.render; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "shallowObjectArrayEqualityCheck")) __webpack_require__.d(__webpack_exports__, { "shallowObjectArrayEqualityCheck": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.shallowObjectArrayEqualityCheck; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "sharedDynamicSelector")) __webpack_require__.d(__webpack_exports__, { "sharedDynamicSelector": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.sharedDynamicSelector; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "sharedFacet")) __webpack_require__.d(__webpack_exports__, { "sharedFacet": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.sharedFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "sharedFacetDriverContext")) __webpack_require__.d(__webpack_exports__, { "sharedFacetDriverContext": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.sharedFacetDriverContext; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "sharedSelector")) __webpack_require__.d(__webpack_exports__, { "sharedSelector": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.sharedSelector; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetCallback")) __webpack_require__.d(__webpack_exports__, { "useFacetCallback": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetCallback; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetEffect")) __webpack_require__.d(__webpack_exports__, { "useFacetEffect": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetEffect; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetLayoutEffect")) __webpack_require__.d(__webpack_exports__, { "useFacetLayoutEffect": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetLayoutEffect; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetMap")) __webpack_require__.d(__webpack_exports__, { "useFacetMap": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetMap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetMemo")) __webpack_require__.d(__webpack_exports__, { "useFacetMemo": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetMemo; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetRef")) __webpack_require__.d(__webpack_exports__, { "useFacetRef": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetRef; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetState")) __webpack_require__.d(__webpack_exports__, { "useFacetState": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetState; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetUnwrap")) __webpack_require__.d(__webpack_exports__, { "useFacetUnwrap": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetUnwrap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetWrap")) __webpack_require__.d(__webpack_exports__, { "useFacetWrap": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetWrap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useSharedFacet")) __webpack_require__.d(__webpack_exports__, { "useSharedFacet": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useSharedFacet; } });







const strictShallowObjectEqualityCheck = (/* unused pure expression or super */ null && (originalShallowObjectEqualityCheck));
/**
 * @deprecated This object equality check has no guarantees that the keys of the object are Immutable.
 * Use `strictShallowObjectEqualityCheck` instead
 * */

const shallowObjectEqualityCheck = _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.shallowObjectEqualityCheck;

/**
 * @deprecated use sharedFacet instead
 */

const facet = _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.sharedFacet;
/**
 * @deprecated
 */

/**
 * @deprecated we recommend useFacetState instead
 */
function localFacet(initialValue) {
  const facet = createFacet({
    initialValue
  });

  const result = () => facet;

  result.factory = FACET_FACTORY;
  return result;
}
/**
 * @deprecated useFacetUnwrap and useSharedFacet instead
 */

function useFacet(sharedFacet) {
  const rawValue = useFacetUnwrap(useSharedFacet(sharedFacet));
  return rawValue === NO_VALUE ? undefined : rawValue;
}

const isSetterCallback = setter => {
  return typeof setter === 'function';
};
/**
 * @deprecated we recommend useFacetState instead
 */


function useFacetSetter(facet) {
  return setter => {
    if (isSetterCallback(setter)) {
      return facet().setWithCallback(setter);
    } else {
      return facet().set(setter);
    }
  };
}

/***/ }),

/***/ 79742:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ 48764:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(79742)
var ieee754 = __webpack_require__(80645)
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        Buffer.from(buf).copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (var i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()


/***/ }),

/***/ 94184:
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ 17187:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ 8679:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reactIs = __webpack_require__(59864);

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),

/***/ 80645:
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ 35717:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 91296:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;


/***/ }),

/***/ 27418:
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ 15523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var util = __webpack_require__(89539);

var tokenize = function(/*String*/ str, /*RegExp*/ re, /*Function?*/ parseDelim, /*Object?*/ instance){
  // summary:
  //    Split a string by a regular expression with the ability to capture the delimeters
  // parseDelim:
  //    Each group (excluding the 0 group) is passed as a parameter. If the function returns
  //    a value, it's added to the list of tokens.
  // instance:
  //    Used as the "this' instance when calling parseDelim
  var tokens = [];
  var match, content, lastIndex = 0;
  while((match = re.exec(str))){
    content = str.slice(lastIndex, re.lastIndex - match[0].length);
    if(content.length){
      tokens.push(content);
    }
    if(parseDelim){
      var parsed = parseDelim.apply(instance, match.slice(1).concat(tokens.length));
      if(typeof parsed != 'undefined'){
        if(parsed.specifier === '%'){
          tokens.push('%');
        }else{
          tokens.push(parsed);
        }
      }
    }
    lastIndex = re.lastIndex;
  }
  content = str.slice(lastIndex);
  if(content.length){
    tokens.push(content);
  }
  return tokens;
};

var Formatter = function(/*String*/ format){
  this._mapped = false;
  this._format = format;
  this._tokens = tokenize(format, this._re, this._parseDelim, this);
};

// The old regexp `/\%(?:\(([\w_.]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)(\*|\d+)?(\.)?(\*|\d+)?[hlL]?([\%bscdeEfFgGioOuxX])/` has a cubic worst-case time complexity behavior due to overlapping capture groups `([0 +\-\#]*)(\*|\d+)?(\.)?(\*|\d+)?`. And a pump string of 0 can be consumed by `([0 +\-\#]*), (\*|\d+)?, or (\*|\d+)?`.
// The solution replace the sub-regexp (\*|\d+)?(\.)?(\*|\d+)? with the sub-regexp `(\*|\d+)?(?:(\.)(\*|\d+)?)?`, see the figure in [#32](https://github.com/adaltas/node-printf/pull/32)
// There are also performance improvement, see in [#31](https://github.com/adaltas/node-printf/issues/31#issuecomment-776731490)
Formatter.prototype._re = /\%(?:\(([\w_.]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)(\*|\d+)?(?:(\.)(\*|\d+)?)?[hlL]?([\%bscdeEfFgGioOuxX])/g;
Formatter.prototype._parseDelim = function(mapping, intmapping, flags, minWidth, period, precision, specifier){
  if(mapping){
    this._mapped = true;
  }
  return {
    mapping: mapping,
    intmapping: intmapping,
    flags: flags,
    _minWidth: minWidth, // May be dependent on parameters
    period: period,
    _precision: precision, // May be dependent on parameters
    specifier: specifier
  };
};
Formatter.prototype._specifiers = {
  b: {
    base: 2,
    isInt: true
  },
  o: {
    base: 8,
    isInt: true
  },
  x: {
    base: 16,
    isInt: true
  },
  X: {
    extend: ['x'],
    toUpper: true
  },
  d: {
    base: 10,
    isInt: true
  },
  i: {
    extend: ['d']
  },
  u: {
    extend: ['d'],
    isUnsigned: true
  },
  c: {
    setArg: function(token){
      if(!isNaN(token.arg)){
        var num = parseInt(token.arg);
        if(num < 0 || num > 127){
          throw new Error('invalid character code passed to %c in printf');
        }
        token.arg = isNaN(num) ? '' + num : String.fromCharCode(num);
      }
    }
  },
  s: {
    setMaxWidth: function(token){
      token.maxWidth = (token.period == '.') ? token.precision : -1;
    }
  },
  e: {
    isDouble: true,
    doubleNotation: 'e'
  },
  E: {
    extend: ['e'],
    toUpper: true
  },
  f: {
    isDouble: true,
    doubleNotation: 'f'
  },
  F: {
    extend: ['f']
  },
  g: {
    isDouble: true,
    doubleNotation: 'g'
  },
  G: {
    extend: ['g'],
    toUpper: true
  },
  O: {
    isObject: true
  }
};
Formatter.prototype.format = function(/*mixed...*/ filler){
  if(this._mapped && typeof filler != 'object'){
    throw new Error('format requires a mapping');
  }

  var str = '';
  var position = 0;
  for(var i = 0, token; i < this._tokens.length; i++){
    token = this._tokens[i];

    if(typeof token == 'string'){
      str += token;
    }else{
      if(this._mapped){
        // Identify value of property defined in `token.mapping`
        var tokens = token.mapping.split('.');
        var value = filler;
        for (var j = 0, c = tokens.length; j < c; j++) {
          value = value[tokens[j]];
          if (typeof value === 'undefined') {
            break
          }
        }
        if(typeof value == 'undefined'){
          throw new Error('missing key \'' + token.mapping + '\'');
        }
        token.arg = value;
      }else{
        if(token.intmapping){
          position = parseInt(token.intmapping) - 1;
        }
        if(position >= arguments.length){
          throw new Error('got ' + arguments.length + ' printf arguments, insufficient for \'' + this._format + '\'');
        }
        token.arg = arguments[position++];
      }

      if(!token.compiled){
        token.compiled = true;
        token.sign = '';
        token.zeroPad = false;
        token.rightJustify = false;
        token.alternative = false;

        var flags = {};
        for(var fi = token.flags.length; fi--;){
          var flag = token.flags.charAt(fi);
          flags[flag] = true;
          switch(flag){
            case ' ':
              token.sign = ' ';
              break;
            case '+':
              token.sign = '+';
              break;
            case '0':
              token.zeroPad = (flags['-']) ? false : true;
              break;
            case '-':
              token.rightJustify = true;
              token.zeroPad = false;
              break;
            case '#':
              token.alternative = true;
              break;
            default:
              throw Error('bad formatting flag \'' + token.flags.charAt(fi) + '\'');
          }
        }

        token.minWidth = (token._minWidth) ? parseInt(token._minWidth) : 0;
        token.maxWidth = -1;
        token.toUpper = false;
        token.isUnsigned = false;
        token.isInt = false;
        token.isDouble = false;
        token.isObject = false;
        token.precision = 1;
        if(token.period == '.'){
          if(token._precision){
            token.precision = parseInt(token._precision);
          }else{
            token.precision = 0;
          }
        }

        var mixins = this._specifiers[token.specifier];
        if(typeof mixins == 'undefined'){
          throw new Error('unexpected specifier \'' + token.specifier + '\'');
        }
        if(mixins.extend){
          var s = this._specifiers[mixins.extend];
          for(var k in s){
            mixins[k] = s[k];
          }
          delete mixins.extend;
        }
        for(var l in mixins){
          token[l] = mixins[l];
        }
      }

      if(typeof token.setArg == 'function'){
        token.setArg(token);
      }

      if(typeof token.setMaxWidth == 'function'){
        token.setMaxWidth(token);
      }

      if(token._minWidth == '*'){
        if(this._mapped){
          throw new Error('* width not supported in mapped formats');
        }
        token.minWidth = parseInt(arguments[position++]);
        if(isNaN(token.minWidth)){
          throw new Error('the argument for * width at position ' + position + ' is not a number in ' + this._format);
        }
        // negative width means rightJustify
        if (token.minWidth < 0) {
          token.rightJustify = true;
          token.minWidth = -token.minWidth;
        }
      }

      if(token._precision == '*' && token.period == '.'){
        if(this._mapped){
          throw new Error('* precision not supported in mapped formats');
        }
        token.precision = parseInt(arguments[position++]);
        if(isNaN(token.precision)){
          throw Error('the argument for * precision at position ' + position + ' is not a number in ' + this._format);
        }
        // negative precision means unspecified
        if (token.precision < 0) {
          token.precision = 1;
          token.period = '';
        }
      }
      if(token.isInt){
        // a specified precision means no zero padding
        if(token.period == '.'){
          token.zeroPad = false;
        }
        this.formatInt(token);
      }else if(token.isDouble){
        if(token.period != '.'){
          token.precision = 6;
        }
        this.formatDouble(token);
      }else if(token.isObject){
        this.formatObject(token);
      }
      this.fitField(token);
      str += '' + token.arg;
    }
  }

  return str;
};
Formatter.prototype._zeros10 = '0000000000';
Formatter.prototype._spaces10 = '          ';
Formatter.prototype.formatInt = function(token) {
  var i = parseInt(token.arg);
  if(!isFinite(i)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)
    // allow this only if arg is number
    if(typeof token.arg != 'number'){
      throw new Error('format argument \'' + token.arg + '\' not an integer; parseInt returned ' + i);
    }
    //return '' + i;
    i = 0;
  }

  // if not base 10, make negatives be positive
  // otherwise, (-10).toString(16) is '-a' instead of 'fffffff6'
  if(i < 0 && (token.isUnsigned || token.base != 10)){
    i = 0xffffffff + i + 1;
  }

  if(i < 0){
    token.arg = (- i).toString(token.base);
    this.zeroPad(token);
    token.arg = '-' + token.arg;
  }else{
    token.arg = i.toString(token.base);
    // need to make sure that argument 0 with precision==0 is formatted as ''
    if(!i && !token.precision){
      token.arg = '';
    }else{
      this.zeroPad(token);
    }
    if(token.sign){
      token.arg = token.sign + token.arg;
    }
  }
  if(token.base == 16){
    if(token.alternative){
      token.arg = '0x' + token.arg;
    }
    token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
  }
  if(token.base == 8){
    if(token.alternative && token.arg.charAt(0) != '0'){
      token.arg = '0' + token.arg;
    }
  }
};
Formatter.prototype.formatDouble = function(token) {
  var f = parseFloat(token.arg);
  if(!isFinite(f)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)
    // allow this only if arg is number
    if(typeof token.arg != 'number'){
      throw new Error('format argument \'' + token.arg + '\' not a float; parseFloat returned ' + f);
    }
    // C99 says that for 'f':
    //   infinity -> '[-]inf' or '[-]infinity' ('[-]INF' or '[-]INFINITY' for 'F')
    //   NaN -> a string  starting with 'nan' ('NAN' for 'F')
    // this is not commonly implemented though.
    //return '' + f;
    f = 0;
  }

  switch(token.doubleNotation) {
    case 'e': {
      token.arg = f.toExponential(token.precision);
      break;
    }
    case 'f': {
      token.arg = f.toFixed(token.precision);
      break;
    }
    case 'g': {
      // C says use 'e' notation if exponent is < -4 or is >= prec
      // ECMAScript for toPrecision says use exponential notation if exponent is >= prec,
      // though step 17 of toPrecision indicates a test for < -6 to force exponential.
      if(Math.abs(f) < 0.0001){
        //print('forcing exponential notation for f=' + f);
        token.arg = f.toExponential(token.precision > 0 ? token.precision - 1 : token.precision);
      }else{
        token.arg = f.toPrecision(token.precision);
      }

      // In C, unlike 'f', 'gG' removes trailing 0s from fractional part, unless alternative format flag ('#').
      // But ECMAScript formats toPrecision as 0.00100000. So remove trailing 0s.
      if(!token.alternative){
        //print('replacing trailing 0 in \'' + s + '\'');
        token.arg = token.arg.replace(/(\..*[^0])0*e/, '$1e');
        // if fractional part is entirely 0, remove it and decimal point
        token.arg = token.arg.replace(/\.0*e/, 'e').replace(/\.0$/,'');
      }
      break;
    }
    default: throw new Error('unexpected double notation \'' + token.doubleNotation + '\'');
  }

  // C says that exponent must have at least two digits.
  // But ECMAScript does not; toExponential results in things like '1.000000e-8' and '1.000000e+8'.
  // Note that s.replace(/e([\+\-])(\d)/, 'e$10$2') won't work because of the '$10' instead of '$1'.
  // And replace(re, func) isn't supported on IE50 or Safari1.
  token.arg = token.arg.replace(/e\+(\d)$/, 'e+0$1').replace(/e\-(\d)$/, 'e-0$1');

  // if alt, ensure a decimal point
  if(token.alternative){
    token.arg = token.arg.replace(/^(\d+)$/,'$1.');
    token.arg = token.arg.replace(/^(\d+)e/,'$1.e');
  }

  if(f >= 0 && token.sign){
    token.arg = token.sign + token.arg;
  }

  token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
};
Formatter.prototype.formatObject = function(token) {
  // If no precision is specified, then reset it to null (infinite depth).
  var precision = (token.period === '.') ? token.precision : null;
  // Historically, inspect was called with 3 options
  // token.arg = util.inspect(token.arg, !token.alternative, precision, token.sign);
  // Now using an object but not sure colors make any sense here
  token.arg = util.inspect(token.arg, {
    showHidden: !token.alternative,
    depth: precision,
    colors: token.sign,
    compact: true
  });
};
Formatter.prototype.zeroPad = function(token, /*Int*/ length) {
  length = (arguments.length == 2) ? length : token.precision;
  var negative = false;
  if(typeof token.arg != "string"){
    token.arg = "" + token.arg;
  }
  if (token.arg.substr(0,1) === '-') {
    negative = true;
    token.arg = token.arg.substr(1);
  }

  var tenless = length - 10;
  while(token.arg.length < tenless){
    token.arg = (token.rightJustify) ? token.arg + this._zeros10 : this._zeros10 + token.arg;
  }
  var pad = length - token.arg.length;
  token.arg = (token.rightJustify) ? token.arg + this._zeros10.substring(0, pad) : this._zeros10.substring(0, pad) + token.arg;
  if (negative) token.arg = '-' + token.arg;
};
Formatter.prototype.fitField = function(token) {
  if(token.maxWidth >= 0 && token.arg.length > token.maxWidth){
    token.arg = token.arg.substring(0, token.maxWidth);
  }
  if(token.zeroPad){
    this.zeroPad(token, token.minWidth);
    return;
  }
  this.spacePad(token);
};
Formatter.prototype.spacePad = function(token, /*Int*/ length) {
  length = (arguments.length == 2) ? length : token.minWidth;
  if(typeof token.arg != 'string'){
    token.arg = '' + token.arg;
  }
  var tenless = length - 10;
  while(token.arg.length < tenless){
    token.arg = (token.rightJustify) ? token.arg + this._spaces10 : this._spaces10 + token.arg;
  }
  var pad = length - token.arg.length;
  token.arg = (token.rightJustify) ? token.arg + this._spaces10.substring(0, pad) : this._spaces10.substring(0, pad) + token.arg;
};

module.exports = function(){
  var args = Array.prototype.slice.call(arguments),
    stream, format;
  if(args[0] instanceof (__webpack_require__(42830).Stream)){
    stream = args.shift();
  }
  format = args.shift();
  var formatter = new Formatter(format);
  var string = formatter.format.apply(formatter, args);
  if(stream){
    stream.write(string);
  }else{
    return string;
  }
};

module.exports.Formatter = Formatter;


/***/ }),

/***/ 92703:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(50414);

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ 45697:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, ReactIs; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(92703)();
}


/***/ }),

/***/ 50414:
/***/ ((module) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ 63195:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _arity =
/*#__PURE__*/
__webpack_require__(7455);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);
/**
 * Creates a function that is bound to a context.
 * Note: `R.bind` does not provide the additional argument-binding capabilities of
 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @category Object
 * @sig (* -> *) -> {*} -> (* -> *)
 * @param {Function} fn The function to bind to context
 * @param {Object} thisObj The context to bind `fn` to
 * @return {Function} A function that will execute in the context of `thisObj`.
 * @see R.partial
 * @example
 *
 *      const log = R.bind(console.log, console);
 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
 *      // logs {a: 2}
 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
 */


var bind =
/*#__PURE__*/
_curry2(function bind(fn, thisObj) {
  return _arity(fn.length, function () {
    return fn.apply(thisObj, arguments);
  });
});

module.exports = bind;

/***/ }),

/***/ 50557:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var pipe =
/*#__PURE__*/
__webpack_require__(4603);

var reverse =
/*#__PURE__*/
__webpack_require__(65814);
/**
 * Performs right-to-left function composition. The last argument may have
 * any arity; the remaining arguments must be unary.
 *
 * **Note:** The result of compose is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
 * @param {...Function} ...functions The functions to compose
 * @return {Function}
 * @see R.pipe
 * @example
 *
 *      const classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
 *      const yellGreeting = R.compose(R.toUpper, classyGreeting);
 *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
 *
 *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
 *
 * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
 */


function compose() {
  if (arguments.length === 0) {
    throw new Error('compose requires at least one argument');
  }

  return pipe.apply(this, reverse(arguments));
}

module.exports = compose;

/***/ }),

/***/ 2220:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _arity =
/*#__PURE__*/
__webpack_require__(7455);

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _curryN =
/*#__PURE__*/
__webpack_require__(32738);
/**
 * Returns a curried equivalent of the provided function, with the specified
 * arity. The curried function has two unusual capabilities. First, its
 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
 * the following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curry
 * @example
 *
 *      const sumArgs = (...args) => R.sum(args);
 *
 *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
 *      const f = curriedAddFourNumbers(1, 2);
 *      const g = f(3);
 *      g(4); //=> 10
 */


var curryN =
/*#__PURE__*/
_curry2(function curryN(length, fn) {
  if (length === 1) {
    return _curry1(fn);
  }

  return _arity(length, _curryN(length, [], fn));
});

module.exports = curryN;

/***/ }),

/***/ 51481:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _equals =
/*#__PURE__*/
__webpack_require__(74023);
/**
 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
 * cyclical data structures.
 *
 * Dispatches symmetrically to the `equals` methods of both arguments, if
 * present.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> b -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      R.equals(1, 1); //=> true
 *      R.equals(1, '1'); //=> false
 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
 *
 *      const a = {}; a.v = a;
 *      const b = {}; b.v = b;
 *      R.equals(a, b); //=> true
 */


var equals =
/*#__PURE__*/
_curry2(function equals(a, b) {
  return _equals(a, b, [], []);
});

module.exports = equals;

/***/ }),

/***/ 51383:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _dispatchable =
/*#__PURE__*/
__webpack_require__(34793);

var _filter =
/*#__PURE__*/
__webpack_require__(34877);

var _isObject =
/*#__PURE__*/
__webpack_require__(8291);

var _reduce =
/*#__PURE__*/
__webpack_require__(39488);

var _xfilter =
/*#__PURE__*/
__webpack_require__(11383);

var keys =
/*#__PURE__*/
__webpack_require__(90368);
/**
 * Takes a predicate and a `Filterable`, and returns a new filterable of the
 * same type containing the members of the given filterable which satisfy the
 * given predicate. Filterable objects include plain objects or any object
 * that has a filter method such as `Array`.
 *
 * Dispatches to the `filter` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array} Filterable
 * @see R.reject, R.transduce, R.addIndex
 * @example
 *
 *      const isEven = n => n % 2 === 0;
 *
 *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */


var filter =
/*#__PURE__*/
_curry2(
/*#__PURE__*/
_dispatchable(['filter'], _xfilter, function (pred, filterable) {
  return _isObject(filterable) ? _reduce(function (acc, key) {
    if (pred(filterable[key])) {
      acc[key] = filterable[key];
    }

    return acc;
  }, {}, keys(filterable)) : // else
  _filter(pred, filterable);
}));

module.exports = filter;

/***/ }),

/***/ 46376:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _dispatchable =
/*#__PURE__*/
__webpack_require__(34793);

var _xfind =
/*#__PURE__*/
__webpack_require__(47855);
/**
 * Returns the first element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Dispatches to the `find` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 *        desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      const xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
 *      R.find(R.propEq('a', 4))(xs); //=> undefined
 */


var find =
/*#__PURE__*/
_curry2(
/*#__PURE__*/
_dispatchable(['find'], _xfind, function find(fn, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (fn(list[idx])) {
      return list[idx];
    }

    idx += 1;
  }
}));

module.exports = find;

/***/ }),

/***/ 53523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _dispatchable =
/*#__PURE__*/
__webpack_require__(34793);

var _xfindIndex =
/*#__PURE__*/
__webpack_require__(20834);
/**
 * Returns the index of the first element of the list which matches the
 * predicate, or `-1` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> Number
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Number} The index of the element found, or `-1`.
 * @see R.transduce
 * @example
 *
 *      const xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
 *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
 */


var findIndex =
/*#__PURE__*/
_curry2(
/*#__PURE__*/
_dispatchable([], _xfindIndex, function findIndex(fn, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (fn(list[idx])) {
      return idx;
    }

    idx += 1;
  }

  return -1;
}));

module.exports = findIndex;

/***/ }),

/***/ 9134:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var curryN =
/*#__PURE__*/
__webpack_require__(2220);
/**
 * Returns a new function much like the supplied one, except that the first two
 * arguments' order is reversed.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((a, b, c, ...) -> z) -> (b -> a -> c -> ... -> z)
 * @param {Function} fn The function to invoke with its first two parameters reversed.
 * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
 * @example
 *
 *      const mergeThree = (a, b, c) => [].concat(a, b, c);
 *
 *      mergeThree(1, 2, 3); //=> [1, 2, 3]
 *
 *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
 * @symb R.flip(f)(a, b, c) = f(b, a, c)
 */


var flip =
/*#__PURE__*/
_curry1(function flip(fn) {
  return curryN(fn.length, function (a, b) {
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = b;
    args[1] = a;
    return fn.apply(this, args);
  });
});

module.exports = flip;

/***/ }),

/***/ 69105:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _identity =
/*#__PURE__*/
__webpack_require__(50339);
/**
 * A function that does nothing but return the parameter supplied to it. Good
 * as a default or placeholder function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig a -> a
 * @param {*} x The value to return.
 * @return {*} The input value, `x`.
 * @example
 *
 *      R.identity(1); //=> 1
 *
 *      const obj = {};
 *      R.identity(obj) === obj; //=> true
 * @symb R.identity(a) = a
 */


var identity =
/*#__PURE__*/
_curry1(_identity);

module.exports = identity;

/***/ }),

/***/ 59270:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _includes =
/*#__PURE__*/
__webpack_require__(87243);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);
/**
 * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
 * terms, to at least one element of the given list; `false` otherwise.
 * Works also with strings.
 *
 * @func
 * @memberOf R
 * @since v0.26.0
 * @category List
 * @sig a -> [a] -> Boolean
 * @param {Object} a The item to compare against.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
 * @see R.any
 * @example
 *
 *      R.includes(3, [1, 2, 3]); //=> true
 *      R.includes(4, [1, 2, 3]); //=> false
 *      R.includes({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
 *      R.includes([42], [[42]]); //=> true
 *      R.includes('ba', 'banana'); //=>true
 */


var includes =
/*#__PURE__*/
_curry2(_includes);

module.exports = includes;

/***/ }),

/***/ 8876:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _includes =
/*#__PURE__*/
__webpack_require__(87243);

var _Set =
/*#__PURE__*/
function () {
  function _Set() {
    /* globals Set */
    this._nativeSet = typeof Set === 'function' ? new Set() : null;
    this._items = {};
  }

  // until we figure out why jsdoc chokes on this
  // @param item The item to add to the Set
  // @returns {boolean} true if the item did not exist prior, otherwise false
  //
  _Set.prototype.add = function (item) {
    return !hasOrAdd(item, true, this);
  }; //
  // @param item The item to check for existence in the Set
  // @returns {boolean} true if the item exists in the Set, otherwise false
  //


  _Set.prototype.has = function (item) {
    return hasOrAdd(item, false, this);
  }; //
  // Combines the logic for checking whether an item is a member of the set and
  // for adding a new item to the set.
  //
  // @param item       The item to check or add to the Set instance.
  // @param shouldAdd  If true, the item will be added to the set if it doesn't
  //                   already exist.
  // @param set        The set instance to check or add to.
  // @return {boolean} true if the item already existed, otherwise false.
  //


  return _Set;
}();

function hasOrAdd(item, shouldAdd, set) {
  var type = typeof item;
  var prevSize, newSize;

  switch (type) {
    case 'string':
    case 'number':
      // distinguish between +0 and -0
      if (item === 0 && 1 / item === -Infinity) {
        if (set._items['-0']) {
          return true;
        } else {
          if (shouldAdd) {
            set._items['-0'] = true;
          }

          return false;
        }
      } // these types can all utilise the native Set


      if (set._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set._nativeSet.size;

          set._nativeSet.add(item);

          newSize = set._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set._nativeSet.has(item);
        }
      } else {
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = {};
            set._items[type][item] = true;
          }

          return false;
        } else if (item in set._items[type]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type][item] = true;
          }

          return false;
        }
      }

    case 'boolean':
      // set._items['boolean'] holds a two element array
      // representing [ falseExists, trueExists ]
      if (type in set._items) {
        var bIdx = item ? 1 : 0;

        if (set._items[type][bIdx]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type][bIdx] = true;
          }

          return false;
        }
      } else {
        if (shouldAdd) {
          set._items[type] = item ? [false, true] : [true, false];
        }

        return false;
      }

    case 'function':
      // compare functions for reference equality
      if (set._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set._nativeSet.size;

          set._nativeSet.add(item);

          newSize = set._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set._nativeSet.has(item);
        }
      } else {
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = [item];
          }

          return false;
        }

        if (!_includes(item, set._items[type])) {
          if (shouldAdd) {
            set._items[type].push(item);
          }

          return false;
        }

        return true;
      }

    case 'undefined':
      if (set._items[type]) {
        return true;
      } else {
        if (shouldAdd) {
          set._items[type] = true;
        }

        return false;
      }

    case 'object':
      if (item === null) {
        if (!set._items['null']) {
          if (shouldAdd) {
            set._items['null'] = true;
          }

          return false;
        }

        return true;
      }

    /* falls through */

    default:
      // reduce the search size of heterogeneous sets by creating buckets
      // for each type.
      type = Object.prototype.toString.call(item);

      if (!(type in set._items)) {
        if (shouldAdd) {
          set._items[type] = [item];
        }

        return false;
      } // scan through all previously applied items


      if (!_includes(item, set._items[type])) {
        if (shouldAdd) {
          set._items[type].push(item);
        }

        return false;
      }

      return true;
  }
} // A simple Set type that honours R.equals semantics


module.exports = _Set;

/***/ }),

/***/ 7455:
/***/ ((module) => {

function _arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0:
      return function () {
        return fn.apply(this, arguments);
      };

    case 1:
      return function (a0) {
        return fn.apply(this, arguments);
      };

    case 2:
      return function (a0, a1) {
        return fn.apply(this, arguments);
      };

    case 3:
      return function (a0, a1, a2) {
        return fn.apply(this, arguments);
      };

    case 4:
      return function (a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };

    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };

    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };

    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };

    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };

    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };

    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };

    default:
      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
}

module.exports = _arity;

/***/ }),

/***/ 54118:
/***/ ((module) => {

function _arrayFromIterator(iter) {
  var list = [];
  var next;

  while (!(next = iter.next()).done) {
    list.push(next.value);
  }

  return list;
}

module.exports = _arrayFromIterator;

/***/ }),

/***/ 73542:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _isArray =
/*#__PURE__*/
__webpack_require__(20219);
/**
 * This checks whether a function has a [methodname] function. If it isn't an
 * array it will execute that function otherwise it will default to the ramda
 * implementation.
 *
 * @private
 * @param {Function} fn ramda implemtation
 * @param {String} methodname property to check for a custom implementation
 * @return {Object} Whatever the return value of the method is.
 */


function _checkForMethod(methodname, fn) {
  return function () {
    var length = arguments.length;

    if (length === 0) {
      return fn();
    }

    var obj = arguments[length - 1];
    return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
  };
}

module.exports = _checkForMethod;

/***/ }),

/***/ 48770:
/***/ ((module) => {

function _complement(f) {
  return function () {
    return !f.apply(this, arguments);
  };
}

module.exports = _complement;

/***/ }),

/***/ 14011:
/***/ ((module) => {

/**
 * Private `concat` function to merge two array-like objects.
 *
 * @private
 * @param {Array|Arguments} [set1=[]] An array-like object.
 * @param {Array|Arguments} [set2=[]] An array-like object.
 * @return {Array} A new, merged array.
 * @example
 *
 *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 */
function _concat(set1, set2) {
  set1 = set1 || [];
  set2 = set2 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set2.length;
  var result = [];
  idx = 0;

  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }

  idx = 0;

  while (idx < len2) {
    result[result.length] = set2[idx];
    idx += 1;
  }

  return result;
}

module.exports = _concat;

/***/ }),

/***/ 76224:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _isPlaceholder =
/*#__PURE__*/
__webpack_require__(36464);
/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}

module.exports = _curry1;

/***/ }),

/***/ 79002:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _isPlaceholder =
/*#__PURE__*/
__webpack_require__(36464);
/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;

      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
          return fn(a, _b);
        });

      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}

module.exports = _curry2;

/***/ }),

/***/ 16370:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _isPlaceholder =
/*#__PURE__*/
__webpack_require__(36464);
/**
 * Optimized internal three-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;

      case 1:
        return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        });

      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _curry1(function (_c) {
          return fn(a, b, _c);
        });

      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
          return fn(_a, _b, c);
        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b, c);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b, c);
        }) : _isPlaceholder(c) ? _curry1(function (_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
}

module.exports = _curry3;

/***/ }),

/***/ 32738:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _arity =
/*#__PURE__*/
__webpack_require__(7455);

var _isPlaceholder =
/*#__PURE__*/
__webpack_require__(36464);
/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curryN(length, received, fn) {
  return function () {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;

    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;

      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }

      combined[combinedIdx] = result;

      if (!_isPlaceholder(result)) {
        left -= 1;
      }

      combinedIdx += 1;
    }

    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
  };
}

module.exports = _curryN;

/***/ }),

/***/ 34793:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _isArray =
/*#__PURE__*/
__webpack_require__(20219);

var _isTransformer =
/*#__PURE__*/
__webpack_require__(69082);
/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a function with one of the given method names, it will
 * execute that function (functor case). Otherwise, if it is a transformer,
 * uses transducer [xf] to return a new transformer (transducer case).
 * Otherwise, it will default to executing [fn].
 *
 * @private
 * @param {Array} methodNames properties to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */


function _dispatchable(methodNames, xf, fn) {
  return function () {
    if (arguments.length === 0) {
      return fn();
    }

    var args = Array.prototype.slice.call(arguments, 0);
    var obj = args.pop();

    if (!_isArray(obj)) {
      var idx = 0;

      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === 'function') {
          return obj[methodNames[idx]].apply(obj, args);
        }

        idx += 1;
      }

      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }

    return fn.apply(this, arguments);
  };
}

module.exports = _dispatchable;

/***/ }),

/***/ 74023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _arrayFromIterator =
/*#__PURE__*/
__webpack_require__(54118);

var _includesWith =
/*#__PURE__*/
__webpack_require__(82976);

var _functionName =
/*#__PURE__*/
__webpack_require__(4931);

var _has =
/*#__PURE__*/
__webpack_require__(87684);

var _objectIs =
/*#__PURE__*/
__webpack_require__(21361);

var keys =
/*#__PURE__*/
__webpack_require__(90368);

var type =
/*#__PURE__*/
__webpack_require__(36433);
/**
 * private _uniqContentEquals function.
 * That function is checking equality of 2 iterator contents with 2 assumptions
 * - iterators lengths are the same
 * - iterators values are unique
 *
 * false-positive result will be returned for comparision of, e.g.
 * - [1,2,3] and [1,2,3,4]
 * - [1,1,1] and [1,2,3]
 * */


function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
  var a = _arrayFromIterator(aIterator);

  var b = _arrayFromIterator(bIterator);

  function eq(_a, _b) {
    return _equals(_a, _b, stackA.slice(), stackB.slice());
  } // if *a* array contains any element that is not included in *b*


  return !_includesWith(function (b, aItem) {
    return !_includesWith(eq, aItem, b);
  }, b, a);
}

function _equals(a, b, stackA, stackB) {
  if (_objectIs(a, b)) {
    return true;
  }

  var typeA = type(a);

  if (typeA !== type(b)) {
    return false;
  }

  if (a == null || b == null) {
    return false;
  }

  if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
    return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
  }

  if (typeof a.equals === 'function' || typeof b.equals === 'function') {
    return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
  }

  switch (typeA) {
    case 'Arguments':
    case 'Array':
    case 'Object':
      if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
        return a === b;
      }

      break;

    case 'Boolean':
    case 'Number':
    case 'String':
      if (!(typeof a === typeof b && _objectIs(a.valueOf(), b.valueOf()))) {
        return false;
      }

      break;

    case 'Date':
      if (!_objectIs(a.valueOf(), b.valueOf())) {
        return false;
      }

      break;

    case 'Error':
      return a.name === b.name && a.message === b.message;

    case 'RegExp':
      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
        return false;
      }

      break;
  }

  var idx = stackA.length - 1;

  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }

    idx -= 1;
  }

  switch (typeA) {
    case 'Map':
      if (a.size !== b.size) {
        return false;
      }

      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));

    case 'Set':
      if (a.size !== b.size) {
        return false;
      }

      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));

    case 'Arguments':
    case 'Array':
    case 'Object':
    case 'Boolean':
    case 'Number':
    case 'String':
    case 'Date':
    case 'Error':
    case 'RegExp':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'ArrayBuffer':
      break;

    default:
      // Values of other types are only equal if identical.
      return false;
  }

  var keysA = keys(a);

  if (keysA.length !== keys(b).length) {
    return false;
  }

  var extendedStackA = stackA.concat([a]);
  var extendedStackB = stackB.concat([b]);
  idx = keysA.length - 1;

  while (idx >= 0) {
    var key = keysA[idx];

    if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
      return false;
    }

    idx -= 1;
  }

  return true;
}

module.exports = _equals;

/***/ }),

/***/ 34877:
/***/ ((module) => {

function _filter(fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];

  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }

    idx += 1;
  }

  return result;
}

module.exports = _filter;

/***/ }),

/***/ 4931:
/***/ ((module) => {

function _functionName(f) {
  // String(x => x) evaluates to "x => x", so the pattern may not match.
  var match = String(f).match(/^function (\w*)/);
  return match == null ? '' : match[1];
}

module.exports = _functionName;

/***/ }),

/***/ 87684:
/***/ ((module) => {

function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = _has;

/***/ }),

/***/ 50339:
/***/ ((module) => {

function _identity(x) {
  return x;
}

module.exports = _identity;

/***/ }),

/***/ 87243:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _indexOf =
/*#__PURE__*/
__webpack_require__(96069);

function _includes(a, list) {
  return _indexOf(list, a, 0) >= 0;
}

module.exports = _includes;

/***/ }),

/***/ 82976:
/***/ ((module) => {

function _includesWith(pred, x, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (pred(x, list[idx])) {
      return true;
    }

    idx += 1;
  }

  return false;
}

module.exports = _includesWith;

/***/ }),

/***/ 96069:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var equals =
/*#__PURE__*/
__webpack_require__(51481);

function _indexOf(list, a, idx) {
  var inf, item; // Array.prototype.indexOf doesn't exist below IE9

  if (typeof list.indexOf === 'function') {
    switch (typeof a) {
      case 'number':
        if (a === 0) {
          // manually crawl the list to distinguish between +0 and -0
          inf = 1 / a;

          while (idx < list.length) {
            item = list[idx];

            if (item === 0 && 1 / item === inf) {
              return idx;
            }

            idx += 1;
          }

          return -1;
        } else if (a !== a) {
          // NaN
          while (idx < list.length) {
            item = list[idx];

            if (typeof item === 'number' && item !== item) {
              return idx;
            }

            idx += 1;
          }

          return -1;
        } // non-zero numbers can utilise Set


        return list.indexOf(a, idx);
      // all these types can utilise Set

      case 'string':
      case 'boolean':
      case 'function':
      case 'undefined':
        return list.indexOf(a, idx);

      case 'object':
        if (a === null) {
          // null can utilise Set
          return list.indexOf(a, idx);
        }

    }
  } // anything else not covered above, defer to R.equals


  while (idx < list.length) {
    if (equals(list[idx], a)) {
      return idx;
    }

    idx += 1;
  }

  return -1;
}

module.exports = _indexOf;

/***/ }),

/***/ 97587:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _has =
/*#__PURE__*/
__webpack_require__(87684);

var toString = Object.prototype.toString;

var _isArguments =
/*#__PURE__*/
function () {
  return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
    return toString.call(x) === '[object Arguments]';
  } : function _isArguments(x) {
    return _has('callee', x);
  };
}();

module.exports = _isArguments;

/***/ }),

/***/ 20219:
/***/ ((module) => {

/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
module.exports = Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
};

/***/ }),

/***/ 3219:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _isArray =
/*#__PURE__*/
__webpack_require__(20219);

var _isString =
/*#__PURE__*/
__webpack_require__(20190);
/**
 * Tests whether or not an object is similar to an array.
 *
 * @private
 * @category Type
 * @category List
 * @sig * -> Boolean
 * @param {*} x The object to test.
 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
 * @example
 *
 *      _isArrayLike([]); //=> true
 *      _isArrayLike(true); //=> false
 *      _isArrayLike({}); //=> false
 *      _isArrayLike({length: 10}); //=> false
 *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 */


var _isArrayLike =
/*#__PURE__*/
_curry1(function isArrayLike(x) {
  if (_isArray(x)) {
    return true;
  }

  if (!x) {
    return false;
  }

  if (typeof x !== 'object') {
    return false;
  }

  if (_isString(x)) {
    return false;
  }

  if (x.nodeType === 1) {
    return !!x.length;
  }

  if (x.length === 0) {
    return true;
  }

  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }

  return false;
});

module.exports = _isArrayLike;

/***/ }),

/***/ 8291:
/***/ ((module) => {

function _isObject(x) {
  return Object.prototype.toString.call(x) === '[object Object]';
}

module.exports = _isObject;

/***/ }),

/***/ 36464:
/***/ ((module) => {

function _isPlaceholder(a) {
  return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
}

module.exports = _isPlaceholder;

/***/ }),

/***/ 20190:
/***/ ((module) => {

function _isString(x) {
  return Object.prototype.toString.call(x) === '[object String]';
}

module.exports = _isString;

/***/ }),

/***/ 69082:
/***/ ((module) => {

function _isTransformer(obj) {
  return obj != null && typeof obj['@@transducer/step'] === 'function';
}

module.exports = _isTransformer;

/***/ }),

/***/ 21361:
/***/ ((module) => {

// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
function _objectIs(a, b) {
  // SameValue algorithm
  if (a === b) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return a !== 0 || 1 / a === 1 / b;
  } else {
    // Step 6.a: NaN == NaN
    return a !== a && b !== b;
  }
}

module.exports = typeof Object.is === 'function' ? Object.is : _objectIs;

/***/ }),

/***/ 56015:
/***/ ((module) => {

function _pipe(f, g) {
  return function () {
    return g.call(this, f.apply(this, arguments));
  };
}

module.exports = _pipe;

/***/ }),

/***/ 39488:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _isArrayLike =
/*#__PURE__*/
__webpack_require__(3219);

var _xwrap =
/*#__PURE__*/
__webpack_require__(39874);

var bind =
/*#__PURE__*/
__webpack_require__(63195);

function _arrayReduce(xf, acc, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    acc = xf['@@transducer/step'](acc, list[idx]);

    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }

    idx += 1;
  }

  return xf['@@transducer/result'](acc);
}

function _iterableReduce(xf, acc, iter) {
  var step = iter.next();

  while (!step.done) {
    acc = xf['@@transducer/step'](acc, step.value);

    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }

    step = iter.next();
  }

  return xf['@@transducer/result'](acc);
}

function _methodReduce(xf, acc, obj, methodName) {
  return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
}

var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';

function _reduce(fn, acc, list) {
  if (typeof fn === 'function') {
    fn = _xwrap(fn);
  }

  if (_isArrayLike(list)) {
    return _arrayReduce(fn, acc, list);
  }

  if (typeof list['fantasy-land/reduce'] === 'function') {
    return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
  }

  if (list[symIterator] != null) {
    return _iterableReduce(fn, acc, list[symIterator]());
  }

  if (typeof list.next === 'function') {
    return _iterableReduce(fn, acc, list);
  }

  if (typeof list.reduce === 'function') {
    return _methodReduce(fn, acc, list, 'reduce');
  }

  throw new TypeError('reduce: list must be array or iterable');
}

module.exports = _reduce;

/***/ }),

/***/ 22157:
/***/ ((module) => {

function _reduced(x) {
  return x && x['@@transducer/reduced'] ? x : {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
}

module.exports = _reduced;

/***/ }),

/***/ 93714:
/***/ ((module) => {

module.exports = {
  init: function () {
    return this.xf['@@transducer/init']();
  },
  result: function (result) {
    return this.xf['@@transducer/result'](result);
  }
};

/***/ }),

/***/ 11383:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _xfBase =
/*#__PURE__*/
__webpack_require__(93714);

var XFilter =
/*#__PURE__*/
function () {
  function XFilter(f, xf) {
    this.xf = xf;
    this.f = f;
  }

  XFilter.prototype['@@transducer/init'] = _xfBase.init;
  XFilter.prototype['@@transducer/result'] = _xfBase.result;

  XFilter.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
  };

  return XFilter;
}();

var _xfilter =
/*#__PURE__*/
_curry2(function _xfilter(f, xf) {
  return new XFilter(f, xf);
});

module.exports = _xfilter;

/***/ }),

/***/ 47855:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _reduced =
/*#__PURE__*/
__webpack_require__(22157);

var _xfBase =
/*#__PURE__*/
__webpack_require__(93714);

var XFind =
/*#__PURE__*/
function () {
  function XFind(f, xf) {
    this.xf = xf;
    this.f = f;
    this.found = false;
  }

  XFind.prototype['@@transducer/init'] = _xfBase.init;

  XFind.prototype['@@transducer/result'] = function (result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, void 0);
    }

    return this.xf['@@transducer/result'](result);
  };

  XFind.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf['@@transducer/step'](result, input));
    }

    return result;
  };

  return XFind;
}();

var _xfind =
/*#__PURE__*/
_curry2(function _xfind(f, xf) {
  return new XFind(f, xf);
});

module.exports = _xfind;

/***/ }),

/***/ 20834:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _reduced =
/*#__PURE__*/
__webpack_require__(22157);

var _xfBase =
/*#__PURE__*/
__webpack_require__(93714);

var XFindIndex =
/*#__PURE__*/
function () {
  function XFindIndex(f, xf) {
    this.xf = xf;
    this.f = f;
    this.idx = -1;
    this.found = false;
  }

  XFindIndex.prototype['@@transducer/init'] = _xfBase.init;

  XFindIndex.prototype['@@transducer/result'] = function (result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, -1);
    }

    return this.xf['@@transducer/result'](result);
  };

  XFindIndex.prototype['@@transducer/step'] = function (result, input) {
    this.idx += 1;

    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf['@@transducer/step'](result, this.idx));
    }

    return result;
  };

  return XFindIndex;
}();

var _xfindIndex =
/*#__PURE__*/
_curry2(function _xfindIndex(f, xf) {
  return new XFindIndex(f, xf);
});

module.exports = _xfindIndex;

/***/ }),

/***/ 39874:
/***/ ((module) => {

var XWrap =
/*#__PURE__*/
function () {
  function XWrap(fn) {
    this.f = fn;
  }

  XWrap.prototype['@@transducer/init'] = function () {
    throw new Error('init not implemented on XWrap');
  };

  XWrap.prototype['@@transducer/result'] = function (acc) {
    return acc;
  };

  XWrap.prototype['@@transducer/step'] = function (acc, x) {
    return this.f(acc, x);
  };

  return XWrap;
}();

function _xwrap(fn) {
  return new XWrap(fn);
}

module.exports = _xwrap;

/***/ }),

/***/ 90368:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _has =
/*#__PURE__*/
__webpack_require__(87684);

var _isArguments =
/*#__PURE__*/
__webpack_require__(97587); // cover IE < 9 keys issues


var hasEnumBug = !
/*#__PURE__*/
{
  toString: null
}.propertyIsEnumerable('toString');
var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug

var hasArgsEnumBug =
/*#__PURE__*/
function () {
  'use strict';

  return arguments.propertyIsEnumerable('length');
}();

var contains = function contains(list, item) {
  var idx = 0;

  while (idx < list.length) {
    if (list[idx] === item) {
      return true;
    }

    idx += 1;
  }

  return false;
};
/**
 * Returns a list containing the names of all the enumerable own properties of
 * the supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @see R.keysIn, R.values
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */


var keys = typeof Object.keys === 'function' && !hasArgsEnumBug ?
/*#__PURE__*/
_curry1(function keys(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
}) :
/*#__PURE__*/
_curry1(function keys(obj) {
  if (Object(obj) !== obj) {
    return [];
  }

  var prop, nIdx;
  var ks = [];

  var checkArgsLength = hasArgsEnumBug && _isArguments(obj);

  for (prop in obj) {
    if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
      ks[ks.length] = prop;
    }
  }

  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;

    while (nIdx >= 0) {
      prop = nonEnumerableProps[nIdx];

      if (_has(prop, obj) && !contains(ks, prop)) {
        ks[ks.length] = prop;
      }

      nIdx -= 1;
    }
  }

  return ks;
});
module.exports = keys;

/***/ }),

/***/ 57046:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var mergeDeepWithKey =
/*#__PURE__*/
__webpack_require__(39036);
/**
 * Creates a new object with the own properties of the first object merged with
 * the own properties of the second object. If a key exists in both objects:
 * - and both values are objects, the two values will be recursively merged
 * - otherwise the value from the second object will be used.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Object
 * @sig {a} -> {a} -> {a}
 * @param {Object} lObj
 * @param {Object} rObj
 * @return {Object}
 * @see R.merge, R.mergeDeepLeft, R.mergeDeepWith, R.mergeDeepWithKey
 * @example
 *
 *      R.mergeDeepRight({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
 *                       { age: 40, contact: { email: 'baa@example.com' }});
 *      //=> { name: 'fred', age: 40, contact: { email: 'baa@example.com' }}
 */


var mergeDeepRight =
/*#__PURE__*/
_curry2(function mergeDeepRight(lObj, rObj) {
  return mergeDeepWithKey(function (k, lVal, rVal) {
    return rVal;
  }, lObj, rObj);
});

module.exports = mergeDeepRight;

/***/ }),

/***/ 39036:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry3 =
/*#__PURE__*/
__webpack_require__(16370);

var _isObject =
/*#__PURE__*/
__webpack_require__(8291);

var mergeWithKey =
/*#__PURE__*/
__webpack_require__(56027);
/**
 * Creates a new object with the own properties of the two provided objects.
 * If a key exists in both objects:
 * - and both associated values are also objects then the values will be
 *   recursively merged.
 * - otherwise the provided function is applied to the key and associated values
 *   using the resulting value as the new value associated with the key.
 * If a key only exists in one object, the value will be associated with the key
 * of the resulting object.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Object
 * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} lObj
 * @param {Object} rObj
 * @return {Object}
 * @see R.mergeWithKey, R.mergeDeepWith
 * @example
 *
 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
 *      R.mergeDeepWithKey(concatValues,
 *                         { a: true, c: { thing: 'foo', values: [10, 20] }},
 *                         { b: true, c: { thing: 'bar', values: [15, 35] }});
 *      //=> { a: true, b: true, c: { thing: 'bar', values: [10, 20, 15, 35] }}
 */


var mergeDeepWithKey =
/*#__PURE__*/
_curry3(function mergeDeepWithKey(fn, lObj, rObj) {
  return mergeWithKey(function (k, lVal, rVal) {
    if (_isObject(lVal) && _isObject(rVal)) {
      return mergeDeepWithKey(fn, lVal, rVal);
    } else {
      return fn(k, lVal, rVal);
    }
  }, lObj, rObj);
});

module.exports = mergeDeepWithKey;

/***/ }),

/***/ 56027:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry3 =
/*#__PURE__*/
__webpack_require__(16370);

var _has =
/*#__PURE__*/
__webpack_require__(87684);
/**
 * Creates a new object with the own properties of the two provided objects. If
 * a key exists in both objects, the provided function is applied to the key
 * and the values associated with the key in each object, with the result being
 * used as the value associated with the key in the returned object.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.mergeDeepWithKey, R.merge, R.mergeWith
 * @example
 *
 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
 *      R.mergeWithKey(concatValues,
 *                     { a: true, thing: 'foo', values: [10, 20] },
 *                     { b: true, thing: 'bar', values: [15, 35] });
 *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
 * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
 */


var mergeWithKey =
/*#__PURE__*/
_curry3(function mergeWithKey(fn, l, r) {
  var result = {};
  var k;

  for (k in l) {
    if (_has(k, l)) {
      result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
    }
  }

  for (k in r) {
    if (_has(k, r) && !_has(k, result)) {
      result[k] = r[k];
    }
  }

  return result;
});

module.exports = mergeWithKey;

/***/ }),

/***/ 4603:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _arity =
/*#__PURE__*/
__webpack_require__(7455);

var _pipe =
/*#__PURE__*/
__webpack_require__(56015);

var reduce =
/*#__PURE__*/
__webpack_require__(20793);

var tail =
/*#__PURE__*/
__webpack_require__(43656);
/**
 * Performs left-to-right function composition. The first argument may have
 * any arity; the remaining arguments must be unary.
 *
 * In some libraries this function is named `sequence`.
 *
 * **Note:** The result of pipe is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.compose
 * @example
 *
 *      const f = R.pipe(Math.pow, R.negate, R.inc);
 *
 *      f(3, 4); // -(3^4) + 1
 * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
 */


function pipe() {
  if (arguments.length === 0) {
    throw new Error('pipe requires at least one argument');
  }

  return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
}

module.exports = pipe;

/***/ }),

/***/ 18371:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry3 =
/*#__PURE__*/
__webpack_require__(16370);

var equals =
/*#__PURE__*/
__webpack_require__(51481);
/**
 * Returns `true` if the specified object property is equal, in
 * [`R.equals`](#equals) terms, to the given value; `false` otherwise.
 * You can test multiple properties with [`R.whereEq`](#whereEq).
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig String -> a -> Object -> Boolean
 * @param {String} name
 * @param {*} val
 * @param {*} obj
 * @return {Boolean}
 * @see R.whereEq, R.propSatisfies, R.equals
 * @example
 *
 *      const abby = {name: 'Abby', age: 7, hair: 'blond'};
 *      const fred = {name: 'Fred', age: 12, hair: 'brown'};
 *      const rusty = {name: 'Rusty', age: 10, hair: 'brown'};
 *      const alois = {name: 'Alois', age: 15, disposition: 'surly'};
 *      const kids = [abby, fred, rusty, alois];
 *      const hasBrownHair = R.propEq('hair', 'brown');
 *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
 */


var propEq =
/*#__PURE__*/
_curry3(function propEq(name, val, obj) {
  return equals(val, obj[name]);
});

module.exports = propEq;

/***/ }),

/***/ 20793:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry3 =
/*#__PURE__*/
__webpack_require__(16370);

var _reduce =
/*#__PURE__*/
__webpack_require__(39488);
/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It may use
 * [`R.reduced`](#reduced) to shortcut the iteration.
 *
 * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
 * is *(value, acc)*.
 *
 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
 *
 * Dispatches to the `reduce` method of the third argument, if present. When
 * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
 * shortcuting, as this is not implemented by `reduce`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduced, R.addIndex, R.reduceRight
 * @example
 *
 *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
 *      //          -               -10
 *      //         / \              / \
 *      //        -   4           -6   4
 *      //       / \              / \
 *      //      -   3   ==>     -3   3
 *      //     / \              / \
 *      //    -   2           -1   2
 *      //   / \              / \
 *      //  0   1            0   1
 *
 * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
 */


var reduce =
/*#__PURE__*/
_curry3(_reduce);

module.exports = reduce;

/***/ }),

/***/ 63266:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _complement =
/*#__PURE__*/
__webpack_require__(48770);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var filter =
/*#__PURE__*/
__webpack_require__(51383);
/**
 * The complement of [`filter`](#filter).
 *
 * Acts as a transducer if a transformer is given in list position. Filterable
 * objects include plain objects or any object that has a filter method such
 * as `Array`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array}
 * @see R.filter, R.transduce, R.addIndex
 * @example
 *
 *      const isOdd = (n) => n % 2 === 1;
 *
 *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */


var reject =
/*#__PURE__*/
_curry2(function reject(pred, filterable) {
  return filter(_complement(pred), filterable);
});

module.exports = reject;

/***/ }),

/***/ 65814:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _isString =
/*#__PURE__*/
__webpack_require__(20190);
/**
 * Returns a new list or string with the elements or characters in reverse
 * order.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {Array|String} list
 * @return {Array|String}
 * @example
 *
 *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
 *      R.reverse([1, 2]);     //=> [2, 1]
 *      R.reverse([1]);        //=> [1]
 *      R.reverse([]);         //=> []
 *
 *      R.reverse('abc');      //=> 'cba'
 *      R.reverse('ab');       //=> 'ba'
 *      R.reverse('a');        //=> 'a'
 *      R.reverse('');         //=> ''
 */


var reverse =
/*#__PURE__*/
_curry1(function reverse(list) {
  return _isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
});

module.exports = reverse;

/***/ }),

/***/ 81753:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _checkForMethod =
/*#__PURE__*/
__webpack_require__(73542);

var _curry3 =
/*#__PURE__*/
__webpack_require__(16370);
/**
 * Returns the elements of the given list or string (or object with a `slice`
 * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
 *
 * Dispatches to the `slice` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @sig Number -> Number -> String -> String
 * @param {Number} fromIndex The start index (inclusive).
 * @param {Number} toIndex The end index (exclusive).
 * @param {*} list
 * @return {*}
 * @example
 *
 *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
 *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
 *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
 *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
 *      R.slice(0, 3, 'ramda');                     //=> 'ram'
 */


var slice =
/*#__PURE__*/
_curry3(
/*#__PURE__*/
_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
  return Array.prototype.slice.call(list, fromIndex, toIndex);
}));

module.exports = slice;

/***/ }),

/***/ 59241:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var slice =
/*#__PURE__*/
__webpack_require__(81753);
/**
 * Splits a collection into slices of the specified length.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [[a]]
 * @sig Number -> String -> [String]
 * @param {Number} n
 * @param {Array} list
 * @return {Array}
 * @example
 *
 *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
 *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
 */


var splitEvery =
/*#__PURE__*/
_curry2(function splitEvery(n, list) {
  if (n <= 0) {
    throw new Error('First argument to splitEvery must be a positive integer');
  }

  var result = [];
  var idx = 0;

  while (idx < list.length) {
    result.push(slice(idx, idx += n, list));
  }

  return result;
});

module.exports = splitEvery;

/***/ }),

/***/ 43656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _checkForMethod =
/*#__PURE__*/
__webpack_require__(73542);

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var slice =
/*#__PURE__*/
__webpack_require__(81753);
/**
 * Returns all but the first element of the given list or string (or object
 * with a `tail` method).
 *
 * Dispatches to the `slice` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.head, R.init, R.last
 * @example
 *
 *      R.tail([1, 2, 3]);  //=> [2, 3]
 *      R.tail([1, 2]);     //=> [2]
 *      R.tail([1]);        //=> []
 *      R.tail([]);         //=> []
 *
 *      R.tail('abc');  //=> 'bc'
 *      R.tail('ab');   //=> 'b'
 *      R.tail('a');    //=> ''
 *      R.tail('');     //=> ''
 */


var tail =
/*#__PURE__*/
_curry1(
/*#__PURE__*/
_checkForMethod('tail',
/*#__PURE__*/
slice(1, Infinity)));

module.exports = tail;

/***/ }),

/***/ 32250:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);
/**
 * Calls an input function `n` times, returning an array containing the results
 * of those function calls.
 *
 * `fn` is passed one argument: The current value of `n`, which begins at `0`
 * and is gradually incremented to `n - 1`.
 *
 * @func
 * @memberOf R
 * @since v0.2.3
 * @category List
 * @sig (Number -> a) -> Number -> [a]
 * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
 * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
 * @return {Array} An array containing the return values of all calls to `fn`.
 * @see R.repeat
 * @example
 *
 *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
 * @symb R.times(f, 0) = []
 * @symb R.times(f, 1) = [f(0)]
 * @symb R.times(f, 2) = [f(0), f(1)]
 */


var times =
/*#__PURE__*/
_curry2(function times(fn, n) {
  var len = Number(n);
  var idx = 0;
  var list;

  if (len < 0 || isNaN(len)) {
    throw new RangeError('n must be a non-negative number');
  }

  list = new Array(len);

  while (idx < len) {
    list[idx] = fn(idx);
    idx += 1;
  }

  return list;
});

module.exports = times;

/***/ }),

/***/ 36433:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);
/**
 * Gives a single-word string description of the (native) type of a value,
 * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
 * attempt to distinguish user Object types any further, reporting them all as
 * 'Object'.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 *      R.type(() => {}); //=> "Function"
 *      R.type(undefined); //=> "Undefined"
 */


var type =
/*#__PURE__*/
_curry1(function type(val) {
  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
});

module.exports = type;

/***/ }),

/***/ 30275:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _concat =
/*#__PURE__*/
__webpack_require__(14011);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var compose =
/*#__PURE__*/
__webpack_require__(50557);

var uniq =
/*#__PURE__*/
__webpack_require__(90086);
/**
 * Combines two lists into a set (i.e. no duplicates) composed of the elements
 * of each list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} as The first list.
 * @param {Array} bs The second list.
 * @return {Array} The first and second lists concatenated, with
 *         duplicates removed.
 * @example
 *
 *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
 */


var union =
/*#__PURE__*/
_curry2(
/*#__PURE__*/
compose(uniq, _concat));

module.exports = union;

/***/ }),

/***/ 90086:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity =
/*#__PURE__*/
__webpack_require__(69105);

var uniqBy =
/*#__PURE__*/
__webpack_require__(54025);
/**
 * Returns a new list containing only one copy of each element in the original
 * list. [`R.equals`](#equals) is used to determine equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
 *      R.uniq([1, '1']);     //=> [1, '1']
 *      R.uniq([[42], [42]]); //=> [[42]]
 */


var uniq =
/*#__PURE__*/
uniqBy(identity);
module.exports = uniq;

/***/ }),

/***/ 54025:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Set =
/*#__PURE__*/
__webpack_require__(8876);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);
/**
 * Returns a new list containing only one copy of each element in the original
 * list, based upon the value returned by applying the supplied function to
 * each list element. Prefers the first item if the supplied function produces
 * the same value on two items. [`R.equals`](#equals) is used for comparison.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> b) -> [a] -> [a]
 * @param {Function} fn A function used to produce a value to use during comparisons.
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
 */


var uniqBy =
/*#__PURE__*/
_curry2(function uniqBy(fn, list) {
  var set = new _Set();
  var result = [];
  var idx = 0;
  var appliedItem, item;

  while (idx < list.length) {
    item = list[idx];
    appliedItem = fn(item);

    if (set.add(appliedItem)) {
      result.push(item);
    }

    idx += 1;
  }

  return result;
});

module.exports = uniqBy;

/***/ }),

/***/ 76290:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _includes =
/*#__PURE__*/
__webpack_require__(87243);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var flip =
/*#__PURE__*/
__webpack_require__(9134);

var reject =
/*#__PURE__*/
__webpack_require__(63266);
/**
 * Returns a new list without values in the first argument.
 * [`R.equals`](#equals) is used to determine equality.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig [a] -> [a] -> [a]
 * @param {Array} list1 The values to be removed from `list2`.
 * @param {Array} list2 The array to remove values from.
 * @return {Array} The new array without values in `list1`.
 * @see R.transduce, R.difference, R.remove
 * @example
 *
 *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
 */


var without =
/*#__PURE__*/
_curry2(function (xs, list) {
  return reject(flip(_includes)(xs), list);
});

module.exports = without;

/***/ }),

/***/ 69921:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;
exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};
exports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};
exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;


/***/ }),

/***/ 59864:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(69921);
} else {}


/***/ }),

/***/ 67287:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** @license React v0.24.0
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
module.exports = function $$$reconciler($$$hostConfig) {
'use strict';var aa=__webpack_require__(27418),ba=__webpack_require__(67294),m=__webpack_require__(60373);function n(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var q=ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
q.hasOwnProperty("ReactCurrentDispatcher")||(q.ReactCurrentDispatcher={current:null});q.hasOwnProperty("ReactCurrentBatchConfig")||(q.ReactCurrentBatchConfig={suspense:null});
var u="function"===typeof Symbol&&Symbol.for,ca=u?Symbol.for("react.element"):60103,da=u?Symbol.for("react.portal"):60106,ea=u?Symbol.for("react.fragment"):60107,fa=u?Symbol.for("react.strict_mode"):60108,ha=u?Symbol.for("react.profiler"):60114,ia=u?Symbol.for("react.provider"):60109,ja=u?Symbol.for("react.context"):60110,ka=u?Symbol.for("react.concurrent_mode"):60111,la=u?Symbol.for("react.forward_ref"):60112,ma=u?Symbol.for("react.suspense"):60113,na=u?Symbol.for("react.suspense_list"):60120,oa=
u?Symbol.for("react.memo"):60115,pa=u?Symbol.for("react.lazy"):60116;u&&Symbol.for("react.fundamental");u&&Symbol.for("react.responder");u&&Symbol.for("react.scope");var qa="function"===typeof Symbol&&Symbol.iterator;function ra(a){if(null===a||"object"!==typeof a)return null;a=qa&&a[qa]||a["@@iterator"];return"function"===typeof a?a:null}
function sa(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}
function ta(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ea:return"Fragment";case da:return"Portal";case ha:return"Profiler";case fa:return"StrictMode";case ma:return"Suspense";case na:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case ja:return"Context.Consumer";case ia:return"Context.Provider";case la:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":
"ForwardRef");case oa:return ta(a.type);case pa:if(a=1===a._status?a._result:null)return ta(a)}return null}function ua(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function va(a){if(ua(a)!==a)throw Error(n(188));}
function wa(a){var b=a.alternate;if(!b){b=ua(a);if(null===b)throw Error(n(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return va(e),a;if(f===d)return va(e),b;f=f.sibling}throw Error(n(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,l=e.child;l;){if(l===c){g=!0;c=e;d=f;break}if(l===d){g=!0;d=e;c=f;break}l=l.sibling}if(!g){for(l=f.child;l;){if(l===
c){g=!0;c=f;d=e;break}if(l===d){g=!0;d=f;c=e;break}l=l.sibling}if(!g)throw Error(n(189));}}if(c.alternate!==d)throw Error(n(190));}if(3!==c.tag)throw Error(n(188));return c.stateNode.current===c?a:b}function xa(a){a=wa(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}
function ya(a){a=wa(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child&&4!==b.tag)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}
var za=$$$hostConfig.getPublicInstance,Aa=$$$hostConfig.getRootHostContext,Ba=$$$hostConfig.getChildHostContext,Ca=$$$hostConfig.prepareForCommit,Da=$$$hostConfig.resetAfterCommit,Ea=$$$hostConfig.createInstance,Fa=$$$hostConfig.appendInitialChild,Ga=$$$hostConfig.finalizeInitialChildren,Ia=$$$hostConfig.prepareUpdate,Ja=$$$hostConfig.shouldSetTextContent,Ka=$$$hostConfig.shouldDeprioritizeSubtree,La=$$$hostConfig.createTextInstance,Ma=$$$hostConfig.setTimeout,Na=$$$hostConfig.clearTimeout,Oa=$$$hostConfig.noTimeout,
Pa=$$$hostConfig.isPrimaryRenderer,Qa=$$$hostConfig.supportsMutation,Ra=$$$hostConfig.supportsPersistence,Sa=$$$hostConfig.supportsHydration,Ta=$$$hostConfig.appendChild,Ua=$$$hostConfig.appendChildToContainer,Va=$$$hostConfig.commitTextUpdate,Wa=$$$hostConfig.commitMount,Xa=$$$hostConfig.commitUpdate,Ya=$$$hostConfig.insertBefore,Za=$$$hostConfig.insertInContainerBefore,$a=$$$hostConfig.removeChild,ab=$$$hostConfig.removeChildFromContainer,bb=$$$hostConfig.resetTextContent,cb=$$$hostConfig.hideInstance,
db=$$$hostConfig.hideTextInstance,eb=$$$hostConfig.unhideInstance,fb=$$$hostConfig.unhideTextInstance,gb=$$$hostConfig.cloneInstance,hb=$$$hostConfig.createContainerChildSet,ib=$$$hostConfig.appendChildToContainerChildSet,kb=$$$hostConfig.finalizeContainerChildren,lb=$$$hostConfig.replaceContainerChildren,mb=$$$hostConfig.cloneHiddenInstance,nb=$$$hostConfig.cloneHiddenTextInstance,ob=$$$hostConfig.canHydrateInstance,pb=$$$hostConfig.canHydrateTextInstance,qb=$$$hostConfig.isSuspenseInstancePending,
rb=$$$hostConfig.isSuspenseInstanceFallback,sb=$$$hostConfig.getNextHydratableSibling,tb=$$$hostConfig.getFirstHydratableChild,ub=$$$hostConfig.hydrateInstance,vb=$$$hostConfig.hydrateTextInstance,wb=$$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance,xb=$$$hostConfig.commitHydratedContainer,yb=$$$hostConfig.commitHydratedSuspenseInstance,zb=/^(.*)[\\\/]/;
function Ab(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=ta(a.type);c=null;d&&(c=ta(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(zb,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}new Set;var Bb=[],Cb=-1;function y(a){0>Cb||(a.current=Bb[Cb],Bb[Cb]=null,Cb--)}function z(a,b){Cb++;Bb[Cb]=a.current;a.current=b}
var Db={},A={current:Db},B={current:!1},Eb=Db;function Fb(a,b){var c=a.type.contextTypes;if(!c)return Db;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function C(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Gb(a){y(B,a);y(A,a)}
function Hb(a){y(B,a);y(A,a)}function Ib(a,b,c){if(A.current!==Db)throw Error(n(168));z(A,b,a);z(B,c,a)}function Jb(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(n(108,ta(b)||"Unknown",e));return aa({},c,{},d)}function Kb(a){var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||Db;Eb=A.current;z(A,b,a);z(B,B.current,a);return!0}
function Lb(a,b,c){var d=a.stateNode;if(!d)throw Error(n(169));c?(b=Jb(a,b,Eb),d.__reactInternalMemoizedMergedChildContext=b,y(B,a),y(A,a),z(A,b,a)):y(B,a);z(B,c,a)}
var Mb=m.unstable_runWithPriority,Nb=m.unstable_scheduleCallback,Ob=m.unstable_cancelCallback,Pb=m.unstable_shouldYield,Qb=m.unstable_requestPaint,Rb=m.unstable_now,Ub=m.unstable_getCurrentPriorityLevel,Vb=m.unstable_ImmediatePriority,Wb=m.unstable_UserBlockingPriority,Xb=m.unstable_NormalPriority,Yb=m.unstable_LowPriority,Zb=m.unstable_IdlePriority,$b={},ac=void 0!==Qb?Qb:function(){},bc=null,cc=null,dc=!1,ec=Rb(),E=1E4>ec?Rb:function(){return Rb()-ec};
function fc(){switch(Ub()){case Vb:return 99;case Wb:return 98;case Xb:return 97;case Yb:return 96;case Zb:return 95;default:throw Error(n(332));}}function gc(a){switch(a){case 99:return Vb;case 98:return Wb;case 97:return Xb;case 96:return Yb;case 95:return Zb;default:throw Error(n(332));}}function hc(a,b){a=gc(a);return Mb(a,b)}function ic(a,b,c){a=gc(a);return Nb(a,b,c)}function jc(a){null===bc?(bc=[a],cc=Nb(Vb,kc)):bc.push(a);return $b}function F(){if(null!==cc){var a=cc;cc=null;Ob(a)}kc()}
function kc(){if(!dc&&null!==bc){dc=!0;var a=0;try{var b=bc;hc(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});bc=null}catch(c){throw null!==bc&&(bc=bc.slice(a+1)),Nb(Vb,F),c;}finally{dc=!1}}}var lc=3;function mc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function nc(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var oc="function"===typeof Object.is?Object.is:nc,pc=Object.prototype.hasOwnProperty;
function qc(a,b){if(oc(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!pc.call(b,c[d])||!oc(a[c[d]],b[c[d]]))return!1;return!0}function rc(a,b){if(a&&a.defaultProps){b=aa({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}var sc={current:null},tc=null,uc=null,vc=null;function wc(){vc=uc=tc=null}
function xc(a,b){var c=a.type._context;Pa?(z(sc,c._currentValue,a),c._currentValue=b):(z(sc,c._currentValue2,a),c._currentValue2=b)}function yc(a){var b=sc.current;y(sc,a);a=a.type._context;Pa?a._currentValue=b:a._currentValue2=b}function zc(a,b){for(;null!==a;){var c=a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}
function Ac(a,b){tc=a;vc=uc=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(Bc=!0),a.firstContext=null)}function Cc(a,b){if(vc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)vc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===uc){if(null===tc)throw Error(n(308));uc=b;tc.dependencies={expirationTime:0,firstContext:b,responders:null}}else uc=uc.next=b}return Pa?a._currentValue:a._currentValue2}var Dc=!1;
function Ec(a){return{baseState:a,firstUpdate:null,lastUpdate:null,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null}}function Fc(a){return{baseState:a.baseState,firstUpdate:a.firstUpdate,lastUpdate:a.lastUpdate,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null}}
function Gc(a,b){return{expirationTime:a,suspenseConfig:b,tag:0,payload:null,callback:null,next:null,nextEffect:null}}function Hc(a,b){null===a.lastUpdate?a.firstUpdate=a.lastUpdate=b:(a.lastUpdate.next=b,a.lastUpdate=b)}
function Ic(a,b){var c=a.alternate;if(null===c){var d=a.updateQueue;var e=null;null===d&&(d=a.updateQueue=Ec(a.memoizedState))}else d=a.updateQueue,e=c.updateQueue,null===d?null===e?(d=a.updateQueue=Ec(a.memoizedState),e=c.updateQueue=Ec(c.memoizedState)):d=a.updateQueue=Fc(e):null===e&&(e=c.updateQueue=Fc(d));null===e||d===e?Hc(d,b):null===d.lastUpdate||null===e.lastUpdate?(Hc(d,b),Hc(e,b)):(Hc(d,b),e.lastUpdate=b)}
function Jc(a,b){var c=a.updateQueue;c=null===c?a.updateQueue=Ec(a.memoizedState):Kc(a,c);null===c.lastCapturedUpdate?c.firstCapturedUpdate=c.lastCapturedUpdate=b:(c.lastCapturedUpdate.next=b,c.lastCapturedUpdate=b)}function Kc(a,b){var c=a.alternate;null!==c&&b===c.updateQueue&&(b=a.updateQueue=Fc(b));return b}
function Lc(a,b,c,d,e,f){switch(c.tag){case 1:return a=c.payload,"function"===typeof a?a.call(f,d,e):a;case 3:a.effectTag=a.effectTag&-4097|64;case 0:a=c.payload;e="function"===typeof a?a.call(f,d,e):a;if(null===e||void 0===e)break;return aa({},d,e);case 2:Dc=!0}return d}
function Nc(a,b,c,d,e){Dc=!1;b=Kc(a,b);for(var f=b.baseState,g=null,l=0,h=b.firstUpdate,k=f;null!==h;){var p=h.expirationTime;p<e?(null===g&&(g=h,f=k),l<p&&(l=p)):(Oc(p,h.suspenseConfig),k=Lc(a,b,h,k,c,d),null!==h.callback&&(a.effectTag|=32,h.nextEffect=null,null===b.lastEffect?b.firstEffect=b.lastEffect=h:(b.lastEffect.nextEffect=h,b.lastEffect=h)));h=h.next}p=null;for(h=b.firstCapturedUpdate;null!==h;){var D=h.expirationTime;D<e?(null===p&&(p=h,null===g&&(f=k)),l<D&&(l=D)):(k=Lc(a,b,h,k,c,d),null!==
h.callback&&(a.effectTag|=32,h.nextEffect=null,null===b.lastCapturedEffect?b.firstCapturedEffect=b.lastCapturedEffect=h:(b.lastCapturedEffect.nextEffect=h,b.lastCapturedEffect=h)));h=h.next}null===g&&(b.lastUpdate=null);null===p?b.lastCapturedUpdate=null:a.effectTag|=32;null===g&&null===p&&(f=k);b.baseState=f;b.firstUpdate=g;b.firstCapturedUpdate=p;Pc(l);a.expirationTime=l;a.memoizedState=k}
function Qc(a,b,c){null!==b.firstCapturedUpdate&&(null!==b.lastUpdate&&(b.lastUpdate.next=b.firstCapturedUpdate,b.lastUpdate=b.lastCapturedUpdate),b.firstCapturedUpdate=b.lastCapturedUpdate=null);Rc(b.firstEffect,c);b.firstEffect=b.lastEffect=null;Rc(b.firstCapturedEffect,c);b.firstCapturedEffect=b.lastCapturedEffect=null}function Rc(a,b){for(;null!==a;){var c=a.callback;if(null!==c){a.callback=null;var d=b;if("function"!==typeof c)throw Error(n(191,c));c.call(d)}a=a.nextEffect}}
var Sc=q.ReactCurrentBatchConfig,Tc=(new ba.Component).refs;function Uc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:aa({},b,c);a.memoizedState=c;d=a.updateQueue;null!==d&&0===a.expirationTime&&(d.baseState=c)}
var Xc={isMounted:function(a){return(a=a._reactInternalFiber)?ua(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=G(),e=Sc.suspense;d=Vc(d,a,e);e=Gc(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Ic(a,e);Wc(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=G(),e=Sc.suspense;d=Vc(d,a,e);e=Gc(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Ic(a,e);Wc(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=G(),d=Sc.suspense;
c=Vc(c,a,d);d=Gc(c,d);d.tag=2;void 0!==b&&null!==b&&(d.callback=b);Ic(a,d);Wc(a,c)}};function Yc(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!qc(c,d)||!qc(e,f):!0}
function Zc(a,b,c){var d=!1,e=Db;var f=b.contextType;"object"===typeof f&&null!==f?f=Cc(f):(e=C(b)?Eb:A.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Fb(a,e):Db);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Xc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function $c(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Xc.enqueueReplaceState(b,b.state,null)}
function ad(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Tc;var f=b.contextType;"object"===typeof f&&null!==f?e.context=Cc(f):(f=C(b)?Eb:A.current,e.context=Fb(a,f));f=a.updateQueue;null!==f&&(Nc(a,f,c,e,d),e.state=a.memoizedState);f=b.getDerivedStateFromProps;"function"===typeof f&&(Uc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==
typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Xc.enqueueReplaceState(e,e.state,null),f=a.updateQueue,null!==f&&(Nc(a,f,c,e,d),e.state=a.memoizedState));"function"===typeof e.componentDidMount&&(a.effectTag|=4)}var bd=Array.isArray;
function cd(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(n(309));var d=c.stateNode}if(!d)throw Error(n(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(b){var a=d.refs;a===Tc&&(a=d.refs={});null===b?delete a[e]:a[e]=b};b._stringRef=e;return b}if("string"!==typeof a)throw Error(n(284));if(!c._owner)throw Error(n(290,a));}return a}
function dd(a,b){if("textarea"!==a.type)throw Error(n(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}
function ed(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(b,a){for(b=new Map;null!==a;)null!==a.key?b.set(a.key,a):b.set(a.index,a),a=a.sibling;return b}function e(b,a,c){b=fd(b,a,c);b.index=0;b.sibling=null;return b}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function l(b,a,c,d){if(null===a||6!==a.tag)return a=gd(c,b.mode,d),a.return=b,a;a=e(a,c,d);a.return=b;return a}function h(b,a,c,d){if(null!==a&&a.elementType===c.type)return d=e(a,c.props,d),d.ref=cd(b,a,c),d.return=b,d;d=hd(c.type,c.key,c.props,null,b.mode,d);d.ref=cd(b,a,c);d.return=b;return d}function k(b,a,c,d){if(null===a||4!==a.tag||a.stateNode.containerInfo!==c.containerInfo||a.stateNode.implementation!==
c.implementation)return a=id(c,b.mode,d),a.return=b,a;a=e(a,c.children||[],d);a.return=b;return a}function p(b,a,c,d,f){if(null===a||7!==a.tag)return a=jd(c,b.mode,d,f),a.return=b,a;a=e(a,c,d);a.return=b;return a}function D(b,a,c){if("string"===typeof a||"number"===typeof a)return a=gd(""+a,b.mode,c),a.return=b,a;if("object"===typeof a&&null!==a){switch(a.$$typeof){case ca:return c=hd(a.type,a.key,a.props,null,b.mode,c),c.ref=cd(b,null,a),c.return=b,c;case da:return a=id(a,b.mode,c),a.return=b,a}if(bd(a)||
ra(a))return a=jd(a,b.mode,c,null),a.return=b,a;dd(b,a)}return null}function x(b,a,c,d){var e=null!==a?a.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:l(b,a,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case ca:return c.key===e?c.type===ea?p(b,a,c.props.children,d,e):h(b,a,c,d):null;case da:return c.key===e?k(b,a,c,d):null}if(bd(c)||ra(c))return null!==e?null:p(b,a,c,d,null);dd(b,c)}return null}function K(b,a,c,d,e){if("string"===typeof d||"number"===typeof d)return b=
b.get(c)||null,l(a,b,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case ca:return b=b.get(null===d.key?c:d.key)||null,d.type===ea?p(a,b,d.props.children,e,d.key):h(a,b,d,e);case da:return b=b.get(null===d.key?c:d.key)||null,k(a,b,d,e)}if(bd(d)||ra(d))return b=b.get(c)||null,p(a,b,d,e,null);dd(a,d)}return null}function Ha(e,g,h,l){for(var k=null,w=null,t=g,r=g=0,p=null;null!==t&&r<h.length;r++){t.index>r?(p=t,t=null):p=t.sibling;var v=x(e,t,h[r],l);if(null===v){null===t&&(t=p);break}a&&
t&&null===v.alternate&&b(e,t);g=f(v,g,r);null===w?k=v:w.sibling=v;w=v;t=p}if(r===h.length)return c(e,t),k;if(null===t){for(;r<h.length;r++)t=D(e,h[r],l),null!==t&&(g=f(t,g,r),null===w?k=t:w.sibling=t,w=t);return k}for(t=d(e,t);r<h.length;r++)p=K(t,e,r,h[r],l),null!==p&&(a&&null!==p.alternate&&t.delete(null===p.key?r:p.key),g=f(p,g,r),null===w?k=p:w.sibling=p,w=p);a&&t.forEach(function(a){return b(e,a)});return k}function O(e,g,h,l){var k=ra(h);if("function"!==typeof k)throw Error(n(150));h=k.call(h);
if(null==h)throw Error(n(151));for(var t=k=null,r=g,w=g=0,p=null,v=h.next();null!==r&&!v.done;w++,v=h.next()){r.index>w?(p=r,r=null):p=r.sibling;var N=x(e,r,v.value,l);if(null===N){null===r&&(r=p);break}a&&r&&null===N.alternate&&b(e,r);g=f(N,g,w);null===t?k=N:t.sibling=N;t=N;r=p}if(v.done)return c(e,r),k;if(null===r){for(;!v.done;w++,v=h.next())v=D(e,v.value,l),null!==v&&(g=f(v,g,w),null===t?k=v:t.sibling=v,t=v);return k}for(r=d(e,r);!v.done;w++,v=h.next())v=K(r,e,w,v.value,l),null!==v&&(a&&null!==
v.alternate&&r.delete(null===v.key?w:v.key),g=f(v,g,w),null===t?k=v:t.sibling=v,t=v);a&&r.forEach(function(a){return b(e,a)});return k}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===ea&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case ca:a:{l=f.key;for(k=d;null!==k;){if(k.key===l)if(7===k.tag?f.type===ea:k.elementType===f.type){c(a,k.sibling);d=e(k,f.type===ea?f.props.children:f.props,h);d.ref=cd(a,k,f);d.return=a;a=d;break a}else{c(a,
k);break}else b(a,k);k=k.sibling}f.type===ea?(d=jd(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=hd(f.type,f.key,f.props,null,a.mode,h),h.ref=cd(a,d,f),h.return=a,a=h)}return g(a);case da:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[],h);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=id(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===
typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f,h),d.return=a,a=d):(c(a,d),d=gd(f,a.mode,h),d.return=a,a=d),g(a);if(bd(f))return Ha(a,d,f,h);if(ra(f))return O(a,d,f,h);l&&dd(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 0:throw a=a.type,Error(n(152,a.displayName||a.name||"Component"));}return c(a,d)}}var kd=ed(!0),ld=ed(!1),md={},H={current:md},nd={current:md},od={current:md};function pd(a){if(a===md)throw Error(n(174));return a}
function qd(a,b){z(od,b,a);z(nd,a,a);z(H,md,a);b=Aa(b);y(H,a);z(H,b,a)}function rd(a){y(H,a);y(nd,a);y(od,a)}function sd(a){var b=pd(od.current),c=pd(H.current);b=Ba(c,a.type,b);c!==b&&(z(nd,a,a),z(H,b,a))}function td(a){nd.current===a&&(y(H,a),y(nd,a))}var I={current:0};
function ud(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||qb(c)||rb(c)))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function vd(a,b){return{responder:a,props:b}}
var wd=q.ReactCurrentDispatcher,J=q.ReactCurrentBatchConfig,xd=0,yd=null,L=null,zd=null,Ad=null,M=null,Bd=null,Cd=0,Dd=null,Ed=0,Fd=!1,Gd=null,Hd=0;function P(){throw Error(n(321));}function Id(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!oc(a[c],b[c]))return!1;return!0}
function Jd(a,b,c,d,e,f){xd=f;yd=b;zd=null!==a?a.memoizedState:null;wd.current=null===zd?Kd:Ld;b=c(d,e);if(Fd){do Fd=!1,Hd+=1,zd=null!==a?a.memoizedState:null,Bd=Ad,Dd=M=L=null,wd.current=Ld,b=c(d,e);while(Fd);Gd=null;Hd=0}wd.current=Md;a=yd;a.memoizedState=Ad;a.expirationTime=Cd;a.updateQueue=Dd;a.effectTag|=Ed;a=null!==L&&null!==L.next;xd=0;Bd=M=Ad=zd=L=yd=null;Cd=0;Dd=null;Ed=0;if(a)throw Error(n(300));return b}
function Nd(){wd.current=Md;xd=0;Bd=M=Ad=zd=L=yd=null;Cd=0;Dd=null;Ed=0;Fd=!1;Gd=null;Hd=0}function Od(){var a={memoizedState:null,baseState:null,queue:null,baseUpdate:null,next:null};null===M?Ad=M=a:M=M.next=a;return M}function Pd(){if(null!==Bd)M=Bd,Bd=M.next,L=zd,zd=null!==L?L.next:null;else{if(null===zd)throw Error(n(310));L=zd;var a={memoizedState:L.memoizedState,baseState:L.baseState,queue:L.queue,baseUpdate:L.baseUpdate,next:null};M=null===M?Ad=a:M.next=a;zd=L.next}return M}
function Qd(a,b){return"function"===typeof b?b(a):b}
function Rd(a){var b=Pd(),c=b.queue;if(null===c)throw Error(n(311));c.lastRenderedReducer=a;if(0<Hd){var d=c.dispatch;if(null!==Gd){var e=Gd.get(c);if(void 0!==e){Gd.delete(c);var f=b.memoizedState;do f=a(f,e.action),e=e.next;while(null!==e);oc(f,b.memoizedState)||(Bc=!0);b.memoizedState=f;b.baseUpdate===c.last&&(b.baseState=f);c.lastRenderedState=f;return[f,d]}}return[b.memoizedState,d]}d=c.last;var g=b.baseUpdate;f=b.baseState;null!==g?(null!==d&&(d.next=null),d=g.next):d=null!==d?d.next:null;if(null!==
d){var l=e=null,h=d,k=!1;do{var p=h.expirationTime;p<xd?(k||(k=!0,l=g,e=f),p>Cd&&(Cd=p,Pc(Cd))):(Oc(p,h.suspenseConfig),f=h.eagerReducer===a?h.eagerState:a(f,h.action));g=h;h=h.next}while(null!==h&&h!==d);k||(l=g,e=f);oc(f,b.memoizedState)||(Bc=!0);b.memoizedState=f;b.baseUpdate=l;b.baseState=e;c.lastRenderedState=f}return[b.memoizedState,c.dispatch]}
function Sd(a){var b=Od();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={last:null,dispatch:null,lastRenderedReducer:Qd,lastRenderedState:a};a=a.dispatch=Td.bind(null,yd,a);return[b.memoizedState,a]}function Ud(a){return Rd(Qd,a)}function Vd(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};null===Dd?(Dd={lastEffect:null},Dd.lastEffect=a.next=a):(b=Dd.lastEffect,null===b?Dd.lastEffect=a.next=a:(c=b.next,b.next=a,a.next=c,Dd.lastEffect=a));return a}
function Wd(a,b,c,d){var e=Od();Ed|=a;e.memoizedState=Vd(b,c,void 0,void 0===d?null:d)}function Xd(a,b,c,d){var e=Pd();d=void 0===d?null:d;var f=void 0;if(null!==L){var g=L.memoizedState;f=g.destroy;if(null!==d&&Id(d,g.deps)){Vd(0,c,f,d);return}}Ed|=a;e.memoizedState=Vd(b,c,f,d)}function Yd(a,b){return Wd(516,192,a,b)}function Zd(a,b){return Xd(516,192,a,b)}
function $d(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function ae(){}function be(a,b){Od().memoizedState=[a,void 0===b?null:b];return a}function ce(a,b){var c=Pd();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Id(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
function Td(a,b,c){if(!(25>Hd))throw Error(n(301));var d=a.alternate;if(a===yd||null!==d&&d===yd)if(Fd=!0,a={expirationTime:xd,suspenseConfig:null,action:c,eagerReducer:null,eagerState:null,next:null},null===Gd&&(Gd=new Map),c=Gd.get(b),void 0===c)Gd.set(b,a);else{for(b=c;null!==b.next;)b=b.next;b.next=a}else{var e=G(),f=Sc.suspense;e=Vc(e,a,f);f={expirationTime:e,suspenseConfig:f,action:c,eagerReducer:null,eagerState:null,next:null};var g=b.last;if(null===g)f.next=f;else{var l=g.next;null!==l&&(f.next=
l);g.next=f}b.last=f;if(0===a.expirationTime&&(null===d||0===d.expirationTime)&&(d=b.lastRenderedReducer,null!==d))try{var h=b.lastRenderedState,k=d(h,c);f.eagerReducer=d;f.eagerState=k;if(oc(k,h))return}catch(p){}finally{}Wc(a,e)}}
var Md={readContext:Cc,useCallback:P,useContext:P,useEffect:P,useImperativeHandle:P,useLayoutEffect:P,useMemo:P,useReducer:P,useRef:P,useState:P,useDebugValue:P,useResponder:P,useDeferredValue:P,useTransition:P},Kd={readContext:Cc,useCallback:be,useContext:Cc,useEffect:Yd,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Wd(4,36,$d.bind(null,b,a),c)},useLayoutEffect:function(a,b){return Wd(4,36,a,b)},useMemo:function(a,b){var c=Od();b=void 0===b?null:b;a=a();c.memoizedState=
[a,b];return a},useReducer:function(a,b,c){var d=Od();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={last:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=Td.bind(null,yd,a);return[d.memoizedState,a]},useRef:function(a){var b=Od();a={current:a};return b.memoizedState=a},useState:Sd,useDebugValue:ae,useResponder:vd,useDeferredValue:function(a,b){var c=Sd(a),d=c[0],e=c[1];Yd(function(){m.unstable_next(function(){var c=J.suspense;J.suspense=void 0===b?null:b;try{e(a)}finally{J.suspense=
c}})},[a,b]);return d},useTransition:function(a){var b=Sd(!1),c=b[0],d=b[1];return[be(function(b){d(!0);m.unstable_next(function(){var c=J.suspense;J.suspense=void 0===a?null:a;try{d(!1),b()}finally{J.suspense=c}})},[a,c]),c]}},Ld={readContext:Cc,useCallback:ce,useContext:Cc,useEffect:Zd,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Xd(4,36,$d.bind(null,b,a),c)},useLayoutEffect:function(a,b){return Xd(4,36,a,b)},useMemo:function(a,b){var c=Pd();b=void 0===b?
null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Id(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a},useReducer:Rd,useRef:function(){return Pd().memoizedState},useState:Ud,useDebugValue:ae,useResponder:vd,useDeferredValue:function(a,b){var c=Ud(a),d=c[0],e=c[1];Zd(function(){m.unstable_next(function(){var c=J.suspense;J.suspense=void 0===b?null:b;try{e(a)}finally{J.suspense=c}})},[a,b]);return d},useTransition:function(a){var b=Ud(!1),c=b[0],d=b[1];return[ce(function(b){d(!0);m.unstable_next(function(){var c=
J.suspense;J.suspense=void 0===a?null:a;try{d(!1),b()}finally{J.suspense=c}})},[a,c]),c]}},de=null,ee=null,fe=!1;function ge(a,b){var c=he(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}
function ie(a,b){switch(a.tag){case 5:return b=ob(b,a.type,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;case 6:return b=pb(b,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function je(a){if(fe){var b=ee;if(b){var c=b;if(!ie(a,b)){b=sb(c);if(!b||!ie(a,b)){a.effectTag=a.effectTag&-1025|2;fe=!1;de=a;return}ge(de,c)}de=a;ee=tb(b)}else a.effectTag=a.effectTag&-1025|2,fe=!1,de=a}}
function ke(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;de=a}function ne(a){if(!Sa||a!==de)return!1;if(!fe)return ke(a),fe=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!Ja(b,a.memoizedProps))for(b=ee;b;)ge(a,b),b=sb(b);ke(a);if(13===a.tag){if(!Sa)throw Error(n(316));a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(n(317));ee=wb(a)}else ee=de?sb(a.stateNode):null;return!0}function oe(){Sa&&(ee=de=null,fe=!1)}var pe=q.ReactCurrentOwner,Bc=!1;
function Q(a,b,c,d){b.child=null===a?ld(b,null,c,d):kd(b,a.child,c,d)}function qe(a,b,c,d,e){c=c.render;var f=b.ref;Ac(b,e);d=Jd(a,b,c,d,f,e);if(null!==a&&!Bc)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),re(a,b,e);b.effectTag|=1;Q(a,b,d,e);return b.child}
function se(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!te(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ue(a,b,g,d,e,f);a=hd(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:qc,c(e,d)&&a.ref===b.ref))return re(a,b,f);b.effectTag|=1;a=fd(g,d,f);a.ref=b.ref;a.return=b;return b.child=a}
function ue(a,b,c,d,e,f){return null!==a&&qc(a.memoizedProps,d)&&a.ref===b.ref&&(Bc=!1,e<f)?re(a,b,f):ve(a,b,c,d,f)}function we(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function ve(a,b,c,d,e){var f=C(c)?Eb:A.current;f=Fb(b,f);Ac(b,e);c=Jd(a,b,c,d,f,e);if(null!==a&&!Bc)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),re(a,b,e);b.effectTag|=1;Q(a,b,c,e);return b.child}
function xe(a,b,c,d,e){if(C(c)){var f=!0;Kb(b)}else f=!1;Ac(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Zc(b,c,d,e),ad(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,l=b.memoizedProps;g.props=l;var h=g.context,k=c.contextType;"object"===typeof k&&null!==k?k=Cc(k):(k=C(c)?Eb:A.current,k=Fb(b,k));var p=c.getDerivedStateFromProps,D="function"===typeof p||"function"===typeof g.getSnapshotBeforeUpdate;D||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&
"function"!==typeof g.componentWillReceiveProps||(l!==d||h!==k)&&$c(b,g,d,k);Dc=!1;var x=b.memoizedState;h=g.state=x;var K=b.updateQueue;null!==K&&(Nc(b,K,d,g,e),h=b.memoizedState);l!==d||x!==h||B.current||Dc?("function"===typeof p&&(Uc(b,c,p,d),h=b.memoizedState),(l=Dc||Yc(b,c,l,d,x,h,k))?(D||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&
g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=h),g.props=d,g.state=h,g.context=k,d=l):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,l=b.memoizedProps,g.props=b.type===b.elementType?l:rc(b.type,l),h=g.context,k=c.contextType,"object"===typeof k&&null!==k?k=Cc(k):(k=C(c)?Eb:A.current,k=Fb(b,k)),p=c.getDerivedStateFromProps,(D=
"function"===typeof p||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(l!==d||h!==k)&&$c(b,g,d,k),Dc=!1,h=b.memoizedState,x=g.state=h,K=b.updateQueue,null!==K&&(Nc(b,K,d,g,e),x=b.memoizedState),l!==d||h!==x||B.current||Dc?("function"===typeof p&&(Uc(b,c,p,d),x=b.memoizedState),(p=Dc||Yc(b,c,l,d,h,x,k))?(D||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||
("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,x,k),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,k)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||l===a.memoizedProps&&h===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||l===a.memoizedProps&&h===a.memoizedState||(b.effectTag|=256),b.memoizedProps=
d,b.memoizedState=x),g.props=d,g.state=x,g.context=k,d=p):("function"!==typeof g.componentDidUpdate||l===a.memoizedProps&&h===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||l===a.memoizedProps&&h===a.memoizedState||(b.effectTag|=256),d=!1);return ye(a,b,c,d,f,e)}
function ye(a,b,c,d,e,f){we(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Lb(b,c,!1),re(a,b,f);d=b.stateNode;pe.current=b;var l=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.effectTag|=1;null!==a&&g?(b.child=kd(b,a.child,null,f),b.child=kd(b,null,l,f)):Q(a,b,l,f);b.memoizedState=d.state;e&&Lb(b,c,!0);return b.child}function ze(a){var b=a.stateNode;b.pendingContext?Ib(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Ib(a,b.context,!1);qd(a,b.containerInfo)}
var Ae={dehydrated:null,retryTime:0};
function Be(a,b,c){var d=b.mode,e=b.pendingProps,f=I.current,g=!1,l;(l=0!==(b.effectTag&64))||(l=0!==(f&2)&&(null===a||null!==a.memoizedState));l?(g=!0,b.effectTag&=-65):null!==a&&null===a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);z(I,f&1,b);if(null===a){void 0!==e.fallback&&je(b);if(g){g=e.fallback;e=jd(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=jd(g,d,c,null);c.return=
b;e.sibling=c;b.memoizedState=Ae;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=ld(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;c=fd(a,a.pendingProps,0);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=fd(d,e,d.expirationTime);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Ae;b.child=c;return d}c=kd(b,a.child,e.children,c);b.memoizedState=
null;return b.child=c}a=a.child;if(g){g=e.fallback;e=jd(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=jd(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Ae;b.child=e;return c}b.memoizedState=null;return b.child=kd(b,a,e.children,c)}
function Ce(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);zc(a.return,b)}function De(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,last:d,tail:c,tailExpiration:0,tailMode:e,lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}
function Ee(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Q(a,b,d.children,c);d=I.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&Ce(a,c);else if(19===a.tag)Ce(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}z(I,d,b);if(0===(b.mode&2))b.memoizedState=
null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===ud(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);De(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===ud(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}De(b,!0,c,null,f,b.lastEffect);break;case "together":De(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}
function re(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Pc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(n(153));if(null!==b.child){a=b.child;c=fd(a,a.pendingProps,a.expirationTime);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=fd(a,a.pendingProps,a.expirationTime),c.return=b;c.sibling=null}return b.child}function Fe(a){a.effectTag|=4}var Ge,He,Ie,Je;
if(Qa)Ge=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)Fa(a,c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}},He=function(){},Ie=function(a,b,c,d,e){a=a.memoizedProps;if(a!==d){var f=b.stateNode,g=pd(H.current);c=Ia(f,c,a,d,e,g);(b.updateQueue=c)&&Fe(b)}},Je=function(a,b,c,d){c!==d&&Fe(b)};else if(Ra){Ge=function(a,
b,c,d){for(var e=b.child;null!==e;){if(5===e.tag){var f=e.stateNode;c&&d&&(f=mb(f,e.type,e.memoizedProps,e));Fa(a,f)}else if(6===e.tag)f=e.stateNode,c&&d&&(f=nb(f,e.memoizedProps,e)),Fa(a,f);else if(4!==e.tag){if(13===e.tag&&0!==(e.effectTag&4)&&(f=null!==e.memoizedState)){var g=e.child;if(null!==g&&(null!==g.child&&(g.child.return=g,Ge(a,g,!0,f)),f=g.sibling,null!==f)){f.return=e;e=f;continue}}if(null!==e.child){e.child.return=e;e=e.child;continue}}if(e===b)break;for(;null===e.sibling;){if(null===
e.return||e.return===b)return;e=e.return}e.sibling.return=e.return;e=e.sibling}};var Ke=function(a,b,c,d){for(var e=b.child;null!==e;){if(5===e.tag){var f=e.stateNode;c&&d&&(f=mb(f,e.type,e.memoizedProps,e));ib(a,f)}else if(6===e.tag)f=e.stateNode,c&&d&&(f=nb(f,e.memoizedProps,e)),ib(a,f);else if(4!==e.tag){if(13===e.tag&&0!==(e.effectTag&4)&&(f=null!==e.memoizedState)){var g=e.child;if(null!==g&&(null!==g.child&&(g.child.return=g,Ke(a,g,!0,f)),f=g.sibling,null!==f)){f.return=e;e=f;continue}}if(null!==
e.child){e.child.return=e;e=e.child;continue}}if(e===b)break;for(;null===e.sibling;){if(null===e.return||e.return===b)return;e=e.return}e.sibling.return=e.return;e=e.sibling}};He=function(a){var b=a.stateNode;if(null!==a.firstEffect){var c=b.containerInfo,d=hb(c);Ke(d,a,!1,!1);b.pendingChildren=d;Fe(a);kb(c,d)}};Ie=function(a,b,c,d,e){var f=a.stateNode,g=a.memoizedProps;if((a=null===b.firstEffect)&&g===d)b.stateNode=f;else{var l=b.stateNode,h=pd(H.current),k=null;g!==d&&(k=Ia(l,c,g,d,e,h));a&&null===
k?b.stateNode=f:(f=gb(f,k,c,g,d,b,a,l),Ga(f,c,d,e,h)&&Fe(b),b.stateNode=f,a?Fe(b):Ge(f,b,!1,!1))}};Je=function(a,b,c,d){c!==d&&(a=pd(od.current),c=pd(H.current),b.stateNode=La(d,a,c,b),Fe(b))}}else He=function(){},Ie=function(){},Je=function(){};
function Le(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}
function Me(a){switch(a.tag){case 1:C(a.type)&&Gb(a);var b=a.effectTag;return b&4096?(a.effectTag=b&-4097|64,a):null;case 3:rd(a);Hb(a);b=a.effectTag;if(0!==(b&64))throw Error(n(285));a.effectTag=b&-4097|64;return a;case 5:return td(a),null;case 13:return y(I,a),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return y(I,a),null;case 4:return rd(a),null;case 10:return yc(a),null;default:return null}}function Ne(a,b){return{value:a,source:b,stack:Ab(b)}}
var Oe="function"===typeof WeakSet?WeakSet:Set;function Pe(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Ab(c));null!==c&&ta(c.type);b=b.value;null!==a&&1===a.tag&&ta(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function Qe(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Re(a,c)}}function Se(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Re(a,c)}else b.current=null}
function Te(a,b){switch(b.tag){case 0:case 11:case 15:Ue(2,0,b);break;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:rc(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}break;case 3:case 5:case 6:case 4:case 17:break;default:throw Error(n(163));}}
function Ue(a,b,c){c=c.updateQueue;c=null!==c?c.lastEffect:null;if(null!==c){var d=c=c.next;do{if(0!==(d.tag&a)){var e=d.destroy;d.destroy=void 0;void 0!==e&&e()}0!==(d.tag&b)&&(e=d.create,d.destroy=e());d=d.next}while(d!==c)}}
function Ve(a,b,c){"function"===typeof We&&We(b);switch(b.tag){case 0:case 11:case 14:case 15:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;hc(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(l){Re(g,l)}}a=a.next}while(a!==d)})}break;case 1:Se(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&Qe(b,c);break;case 5:Se(b);break;case 4:Qa?Xe(a,b,c):Ra&&Ye(b)}}
function Ze(a,b,c){for(var d=b;;)if(Ve(a,d,c),null===d.child||Qa&&4===d.tag){if(d===b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return}d.sibling.return=d.return;d=d.sibling}else d.child.return=d,d=d.child}function $e(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;null!==b&&$e(b)}
function Ye(a){if(Ra){a=a.stateNode.containerInfo;var b=hb(a);lb(a,b)}}function af(a){return 5===a.tag||3===a.tag||4===a.tag}
function bf(a){if(Qa){a:{for(var b=a.return;null!==b;){if(af(b)){var c=b;break a}b=b.return}throw Error(n(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(n(161));}c.effectTag&16&&(bb(b),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||af(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;
if(null===c.child||4===c.tag)continue b;else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){var f=5===e.tag||6===e.tag;if(f)f=f?e.stateNode:e.stateNode.instance,c?d?Za(b,f,c):Ya(b,f,c):d?Ua(b,f):Ta(b,f);else if(4!==e.tag&&null!==e.child){e.child.return=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e.return||e.return===a)return;e=e.return}e.sibling.return=e.return;e=e.sibling}}}
function Xe(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(n(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag)Ze(a,d,c),g?ab(f,d.stateNode):$a(f,d.stateNode);else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ve(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===b)break;
for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}
function cf(a,b){if(Qa)switch(b.tag){case 0:case 11:case 14:case 15:Ue(4,8,b);break;case 1:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps;a=null!==a?a.memoizedProps:d;var e=b.type,f=b.updateQueue;b.updateQueue=null;null!==f&&Xa(c,f,e,a,d,b)}break;case 6:if(null===b.stateNode)throw Error(n(162));c=b.memoizedProps;Va(b.stateNode,null!==a?a.memoizedProps:c,c);break;case 3:Sa&&(b=b.stateNode,b.hydrate&&(b.hydrate=!1,xb(b.containerInfo)));break;case 12:break;case 13:df(b);ef(b);break;
case 19:ef(b);break;case 17:break;case 20:break;case 21:break;default:throw Error(n(163));}else{switch(b.tag){case 0:case 11:case 14:case 15:Ue(4,8,b);return;case 12:return;case 13:df(b);ef(b);return;case 19:ef(b);return;case 3:Sa&&(c=b.stateNode,c.hydrate&&(c.hydrate=!1,xb(c.containerInfo)))}a:if(Ra)switch(b.tag){case 1:case 5:case 6:case 20:break a;case 3:case 4:b=b.stateNode;lb(b.containerInfo,b.pendingChildren);break a;default:throw Error(n(163));}}}
function df(a){var b=a;if(null===a.memoizedState)var c=!1;else c=!0,b=a.child,ff=E();if(Qa&&null!==b)a:if(a=b,Qa)for(b=a;;){if(5===b.tag){var d=b.stateNode;c?cb(d):eb(b.stateNode,b.memoizedProps)}else if(6===b.tag)d=b.stateNode,c?db(d):fb(d,b.memoizedProps);else if(13===b.tag&&null!==b.memoizedState&&null===b.memoizedState.dehydrated){d=b.child.sibling;d.return=b;b=d;continue}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break a;for(;null===b.sibling;){if(null===b.return||b.return===
a)break a;b=b.return}b.sibling.return=b.return;b=b.sibling}}function ef(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Oe);b.forEach(function(b){var d=gf.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}var hf="function"===typeof WeakMap?WeakMap:Map;function jf(a,b,c){c=Gc(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){kf||(kf=!0,lf=d);Pe(a,b)};return c}
function mf(a,b,c){c=Gc(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Pe(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===nf?nf=new Set([this]):nf.add(this),Pe(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}
var of=Math.ceil,pf=q.ReactCurrentDispatcher,qf=q.ReactCurrentOwner,R=0,rf=8,S=16,sf=32,tf=0,uf=1,vf=2,wf=3,xf=4,yf=5,T=R,U=null,V=null,W=0,X=tf,zf=null,Af=1073741823,Bf=1073741823,Cf=null,Df=0,Ef=!1,ff=0,Ff=500,Y=null,kf=!1,lf=null,nf=null,Gf=!1,Hf=null,If=90,Jf=null,Kf=0,Lf=null,Mf=0;function G(){return(T&(S|sf))!==R?1073741821-(E()/10|0):0!==Mf?Mf:Mf=1073741821-(E()/10|0)}
function Vc(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=fc();if(0===(b&4))return 99===d?1073741823:1073741822;if((T&S)!==R)return W;if(null!==c)a=mc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=mc(a,150,100);break;case 97:case 96:a=mc(a,5E3,250);break;case 95:a=2;break;default:throw Error(n(326));}null!==U&&a===W&&--a;return a}
function Wc(a,b){if(50<Kf)throw Kf=0,Lf=null,Error(n(185));a=Nf(a,b);if(null!==a){var c=fc();1073741823===b?(T&rf)!==R&&(T&(S|sf))===R?Of(a):(Z(a),T===R&&F()):Z(a);(T&4)===R||98!==c&&99!==c||(null===Jf?Jf=new Map([[a,b]]):(c=Jf.get(a),(void 0===c||c>b)&&Jf.set(a,b)))}}
function Nf(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&(U===e&&(Pc(b),X===xf&&Pf(e,W)),Qf(e,b));return e}
function Rf(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Sf(a,b))return b;b=a.lastPingedTime;a=a.nextKnownPendingLevel;return b>a?b:a}
function Z(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=jc(Of.bind(null,a));else{var b=Rf(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=G();1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==$b&&Ob(c)}a.callbackExpirationTime=
b;a.callbackPriority=d;b=1073741823===b?jc(Of.bind(null,a)):ic(d,Tf.bind(null,a),{timeout:10*(1073741821-b)-E()});a.callbackNode=b}}}
function Tf(a,b){Mf=0;if(b)return b=G(),Uf(a,b),Z(a),null;var c=Rf(a);if(0!==c){b=a.callbackNode;if((T&(S|sf))!==R)throw Error(n(327));Vf();a===U&&c===W||Wf(a,c);if(null!==V){var d=T;T|=S;var e=Xf(a);do try{Yf();break}catch(l){Zf(a,l)}while(1);wc();T=d;pf.current=e;if(X===uf)throw b=zf,Wf(a,c),Pf(a,c),Z(a),b;if(null===V)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=X,U=null,d){case tf:case uf:throw Error(n(345));case vf:Uf(a,2<c?2:c);break;case wf:Pf(a,c);d=a.lastSuspendedTime;
c===d&&(a.nextKnownPendingLevel=$f(e));if(1073741823===Af&&(e=ff+Ff-E(),10<e)){if(Ef){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=c;Wf(a,c);break}}f=Rf(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=Ma(ag.bind(null,a),e);break}ag(a);break;case xf:Pf(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=$f(e));if(Ef&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;Wf(a,c);break}e=Rf(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=
d;break}1073741823!==Bf?d=10*(1073741821-Bf)-E():1073741823===Af?d=0:(d=10*(1073741821-Af)-5E3,e=E(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*of(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=Ma(ag.bind(null,a),d);break}ag(a);break;case yf:if(1073741823!==Af&&null!==Cf){f=Af;var g=Cf;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=E()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Pf(a,c);a.timeoutHandle=
Ma(ag.bind(null,a),d);break}}ag(a);break;default:throw Error(n(329));}Z(a);if(a.callbackNode===b)return Tf.bind(null,a)}}return null}
function Of(a){var b=a.lastExpiredTime;b=0!==b?b:1073741823;if(a.finishedExpirationTime===b)ag(a);else{if((T&(S|sf))!==R)throw Error(n(327));Vf();a===U&&b===W||Wf(a,b);if(null!==V){var c=T;T|=S;var d=Xf(a);do try{bg();break}catch(e){Zf(a,e)}while(1);wc();T=c;pf.current=d;if(X===uf)throw c=zf,Wf(a,b),Pf(a,b),Z(a),c;if(null!==V)throw Error(n(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ag(a);Z(a)}}return null}function cg(a,b){Uf(a,b);Z(a);(T&(S|sf))===R&&F()}
function dg(){if(null!==Jf){var a=Jf;Jf=null;a.forEach(function(a,c){Uf(c,a);Z(c)});F()}}function eg(a,b){if((T&(S|sf))!==R)throw Error(n(187));var c=T;T|=1;try{return hc(99,a.bind(null,b))}finally{T=c,F()}}
function Wf(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;c!==Oa&&(a.timeoutHandle=Oa,Na(c));if(null!==V)for(c=V.return;null!==c;){var d=c;switch(d.tag){case 1:var e=d.type.childContextTypes;null!==e&&void 0!==e&&Gb(d);break;case 3:rd(d);Hb(d);break;case 5:td(d);break;case 4:rd(d);break;case 13:y(I,d);break;case 19:y(I,d);break;case 10:yc(d)}c=c.return}U=a;V=fd(a.current,null,b);W=b;X=tf;zf=null;Bf=Af=1073741823;Cf=null;Df=0;Ef=!1}
function Zf(a,b){do{try{wc();Nd();if(null===V||null===V.return)return X=uf,zf=b,null;a:{var c=a,d=V.return,e=V,f=b;b=W;e.effectTag|=2048;e.firstEffect=e.lastEffect=null;if(null!==f&&"object"===typeof f&&"function"===typeof f.then){var g=f,l=0!==(I.current&1),h=d;do{var k;if(k=13===h.tag){var p=h.memoizedState;if(null!==p)k=null!==p.dehydrated?!0:!1;else{var D=h.memoizedProps;k=void 0===D.fallback?!1:!0!==D.unstable_avoidThisFallback?!0:l?!1:!0}}if(k){var x=h.updateQueue;if(null===x){var K=new Set;
K.add(g);h.updateQueue=K}else x.add(g);if(0===(h.mode&2)){h.effectTag|=64;e.effectTag&=-2981;if(1===e.tag)if(null===e.alternate)e.tag=17;else{var Ha=Gc(1073741823,null);Ha.tag=2;Ic(e,Ha)}e.expirationTime=1073741823;break a}f=void 0;e=b;var O=c.pingCache;null===O?(O=c.pingCache=new hf,f=new Set,O.set(g,f)):(f=O.get(g),void 0===f&&(f=new Set,O.set(g,f)));if(!f.has(e)){f.add(e);var w=fg.bind(null,c,g,e);g.then(w,w)}h.effectTag|=4096;h.expirationTime=b;break a}h=h.return}while(null!==h);f=Error((ta(e.type)||
"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+Ab(e))}X!==yf&&(X=vf);f=Ne(f,e);h=d;do{switch(h.tag){case 3:g=f;h.effectTag|=4096;h.expirationTime=b;var r=jf(h,g,b);Jc(h,r);break a;case 1:g=f;var t=h.type,N=h.stateNode;if(0===(h.effectTag&64)&&("function"===typeof t.getDerivedStateFromError||null!==N&&"function"===typeof N.componentDidCatch&&
(null===nf||!nf.has(N)))){h.effectTag|=4096;h.expirationTime=b;var Mc=mf(h,g,b);Jc(h,Mc);break a}}h=h.return}while(null!==h)}V=gg(V)}catch(Sb){b=Sb;continue}break}while(1)}function Xf(){var a=pf.current;pf.current=Md;return null===a?Md:a}function Oc(a,b){a<Af&&2<a&&(Af=a);null!==b&&a<Bf&&2<a&&(Bf=a,Cf=b)}function Pc(a){a>Df&&(Df=a)}function bg(){for(;null!==V;)V=hg(V)}function Yf(){for(;null!==V&&!Pb();)V=hg(V)}
function hg(a){var b=ig(a.alternate,a,W);a.memoizedProps=a.pendingProps;null===b&&(b=gg(a));qf.current=null;return b}
function gg(a){V=a;do{var b=V.alternate;a=V.return;if(0===(V.effectTag&2048)){a:{var c=b;b=V;var d=W,e=b.pendingProps;switch(b.tag){case 2:break;case 16:break;case 15:case 0:break;case 1:C(b.type)&&Gb(b);break;case 3:rd(b);Hb(b);e=b.stateNode;e.pendingContext&&(e.context=e.pendingContext,e.pendingContext=null);(null===c||null===c.child)&&ne(b)&&Fe(b);He(b);break;case 5:td(b);var f=pd(od.current);d=b.type;if(null!==c&&null!=b.stateNode)Ie(c,b,d,e,f),c.ref!==b.ref&&(b.effectTag|=128);else if(e){c=pd(H.current);
if(ne(b)){e=b;if(!Sa)throw Error(n(175));c=ub(e.stateNode,e.type,e.memoizedProps,f,c,e);e.updateQueue=c;c=null!==c?!0:!1;c&&Fe(b)}else{var g=Ea(d,e,f,c,b);Ge(g,b,!1,!1);b.stateNode=g;Ga(g,d,e,f,c)&&Fe(b)}null!==b.ref&&(b.effectTag|=128)}else if(null===b.stateNode)throw Error(n(166));break;case 6:if(c&&null!=b.stateNode)Je(c,b,c.memoizedProps,e);else{if("string"!==typeof e&&null===b.stateNode)throw Error(n(166));c=pd(od.current);f=pd(H.current);if(ne(b)){c=b;if(!Sa)throw Error(n(176));(c=vb(c.stateNode,
c.memoizedProps,c))&&Fe(b)}else b.stateNode=La(e,c,f,b)}break;case 11:break;case 13:y(I,b);e=b.memoizedState;if(0!==(b.effectTag&64)){b.expirationTime=d;break a}e=null!==e;f=!1;null===c?void 0!==b.memoizedProps.fallback&&ne(b):(d=c.memoizedState,f=null!==d,e||null===d||(d=c.child.sibling,null!==d&&(g=b.firstEffect,null!==g?(b.firstEffect=d,d.nextEffect=g):(b.firstEffect=b.lastEffect=d,d.nextEffect=null),d.effectTag=8)));if(e&&!f&&0!==(b.mode&2))if(null===c&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(I.current&1))X===tf&&(X=wf);else{if(X===tf||X===wf)X=xf;0!==Df&&null!==U&&(Pf(U,W),Qf(U,Df))}Ra&&e&&(b.effectTag|=4);Qa&&(e||f)&&(b.effectTag|=4);break;case 7:break;case 8:break;case 12:break;case 4:rd(b);He(b);break;case 10:yc(b);break;case 9:break;case 14:break;case 17:C(b.type)&&Gb(b);break;case 19:y(I,b);e=b.memoizedState;if(null===e)break;f=0!==(b.effectTag&64);g=e.rendering;if(null===g)if(f)Le(e,!1);else{if(X!==tf||null!==c&&0!==(c.effectTag&64))for(c=b.child;null!==c;){g=ud(c);if(null!==
g){b.effectTag|=64;Le(e,!1);c=g.updateQueue;null!==c&&(b.updateQueue=c,b.effectTag|=4);null===e.lastEffect&&(b.firstEffect=null);b.lastEffect=e.lastEffect;c=d;for(e=b.child;null!==e;)f=e,d=c,f.effectTag&=2,f.nextEffect=null,f.firstEffect=null,f.lastEffect=null,g=f.alternate,null===g?(f.childExpirationTime=0,f.expirationTime=d,f.child=null,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null):(f.childExpirationTime=g.childExpirationTime,f.expirationTime=g.expirationTime,
f.child=g.child,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,d=g.dependencies,f.dependencies=null===d?null:{expirationTime:d.expirationTime,firstContext:d.firstContext,responders:d.responders}),e=e.sibling;z(I,I.current&1|2,b);b=b.child;break a}c=c.sibling}}else{if(!f)if(c=ud(g),null!==c){if(b.effectTag|=64,f=!0,c=c.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),Le(e,!0),null===e.tail&&"hidden"===e.tailMode&&!g.alternate){b=b.lastEffect=e.lastEffect;
null!==b&&(b.nextEffect=null);break}}else E()>e.tailExpiration&&1<d&&(b.effectTag|=64,f=!0,Le(e,!1),b.expirationTime=b.childExpirationTime=d-1);e.isBackwards?(g.sibling=b.child,b.child=g):(c=e.last,null!==c?c.sibling=g:b.child=g,e.last=g)}if(null!==e.tail){0===e.tailExpiration&&(e.tailExpiration=E()+500);c=e.tail;e.rendering=c;e.tail=c.sibling;e.lastEffect=b.lastEffect;c.sibling=null;e=I.current;e=f?e&1|2:e&1;z(I,e,b);b=c;break a}break;case 20:break;case 21:break;default:throw Error(n(156,b.tag));
}b=null}c=V;if(1===W||1!==c.childExpirationTime){e=0;for(f=c.child;null!==f;)d=f.expirationTime,g=f.childExpirationTime,d>e&&(e=d),g>e&&(e=g),f=f.sibling;c.childExpirationTime=e}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=V.firstEffect),null!==V.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=V.firstEffect),a.lastEffect=V.lastEffect),1<V.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=V:a.firstEffect=V,a.lastEffect=V))}else{b=Me(V,
W);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=2048)}b=V.sibling;if(null!==b)return b;V=a}while(null!==V);X===tf&&(X=yf);return null}function $f(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ag(a){var b=fc();hc(99,jg.bind(null,a,b));return null}
function jg(a,b){do Vf();while(null!==Hf);if((T&(S|sf))!==R)throw Error(n(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(n(177));a.callbackNode=null;a.callbackExpirationTime=0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=$f(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=
d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(V=U=null,W=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=T;T|=sf;qf.current=null;Ca(a.containerInfo);Y=e;do try{kg()}catch(jb){if(null===Y)throw Error(n(330));Re(Y,jb);Y=Y.nextEffect}while(null!==Y);Y=e;do try{for(var g=a,l=b;null!==Y;){var h=Y.effectTag;h&16&&Qa&&bb(Y.stateNode);if(h&128){var k=Y.alternate;if(null!==k){var p=
k.ref;null!==p&&("function"===typeof p?p(null):p.current=null)}}switch(h&1038){case 2:bf(Y);Y.effectTag&=-3;break;case 6:bf(Y);Y.effectTag&=-3;cf(Y.alternate,Y);break;case 1024:Y.effectTag&=-1025;break;case 1028:Y.effectTag&=-1025;cf(Y.alternate,Y);break;case 4:cf(Y.alternate,Y);break;case 8:var D=g,x=Y,K=l;Qa?Xe(D,x,K):Ze(D,x,K);$e(x)}Y=Y.nextEffect}}catch(jb){if(null===Y)throw Error(n(330));Re(Y,jb);Y=Y.nextEffect}while(null!==Y);Da(a.containerInfo);a.current=c;Y=e;do try{for(h=d;null!==Y;){var Ha=
Y.effectTag;if(Ha&36){var O=Y.alternate;k=Y;p=h;switch(k.tag){case 0:case 11:case 15:Ue(16,32,k);break;case 1:var w=k.stateNode;if(k.effectTag&4)if(null===O)w.componentDidMount();else{var r=k.elementType===k.type?O.memoizedProps:rc(k.type,O.memoizedProps);w.componentDidUpdate(r,O.memoizedState,w.__reactInternalSnapshotBeforeUpdate)}var t=k.updateQueue;null!==t&&Qc(k,t,w,p);break;case 3:var N=k.updateQueue;if(null!==N){g=null;if(null!==k.child)switch(k.child.tag){case 5:g=za(k.child.stateNode);break;
case 1:g=k.child.stateNode}Qc(k,N,g,p)}break;case 5:var Mc=k.stateNode;null===O&&k.effectTag&4&&Wa(Mc,k.type,k.memoizedProps,k);break;case 6:break;case 4:break;case 12:break;case 13:if(Sa&&null===k.memoizedState){var Sb=k.alternate;if(null!==Sb){var le=Sb.memoizedState;if(null!==le){var me=le.dehydrated;null!==me&&yb(me)}}}break;case 19:case 17:case 20:case 21:break;default:throw Error(n(163));}}if(Ha&128){k=void 0;var Tb=Y.ref;if(null!==Tb){var v=Y.stateNode;switch(Y.tag){case 5:k=za(v);break;default:k=
v}"function"===typeof Tb?Tb(k):Tb.current=k}}Y=Y.nextEffect}}catch(jb){if(null===Y)throw Error(n(330));Re(Y,jb);Y=Y.nextEffect}while(null!==Y);Y=null;ac();T=f}else a.current=c;if(Gf)Gf=!1,Hf=a,If=b;else for(Y=e;null!==Y;)b=Y.nextEffect,Y.nextEffect=null,Y=b;b=a.firstPendingTime;0===b&&(nf=null);1073741823===b?a===Lf?Kf++:(Kf=0,Lf=a):Kf=0;"function"===typeof lg&&lg(c.stateNode,d);Z(a);if(kf)throw kf=!1,a=lf,lf=null,a;if((T&rf)!==R)return null;F();return null}
function kg(){for(;null!==Y;){var a=Y.effectTag;0!==(a&256)&&Te(Y.alternate,Y);0===(a&512)||Gf||(Gf=!0,ic(97,function(){Vf();return null}));Y=Y.nextEffect}}function Vf(){if(90!==If){var a=97<If?97:If;If=90;return hc(a,mg)}}
function mg(){if(null===Hf)return!1;var a=Hf;Hf=null;if((T&(S|sf))!==R)throw Error(n(331));var b=T;T|=sf;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:Ue(128,0,c),Ue(0,64,c)}}catch(d){if(null===a)throw Error(n(330));Re(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}T=b;F();return!0}function ng(a,b,c){b=Ne(c,b);b=jf(a,b,1073741823);Ic(a,b);a=Nf(a,1073741823);null!==a&&Z(a)}
function Re(a,b){if(3===a.tag)ng(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){ng(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===nf||!nf.has(d))){a=Ne(b,a);a=mf(c,a,1073741823);Ic(c,a);c=Nf(c,1073741823);null!==c&&Z(c);break}}c=c.return}}
function fg(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&W===c?X===xf||X===wf&&1073741823===Af&&E()-ff<Ff?Wf(a,W):Ef=!0:Sf(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,a.finishedExpirationTime===c&&(a.finishedExpirationTime=0,a.finishedWork=null),Z(a)))}function gf(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=G(),b=Vc(b,a,null));a=Nf(a,b);null!==a&&Z(a)}var ig;
ig=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||B.current)Bc=!0;else{if(d<c){Bc=!1;switch(b.tag){case 3:ze(b);oe();break;case 5:sd(b);if(b.mode&4&&1!==c&&Ka(b.type,e))return b.expirationTime=b.childExpirationTime=1,null;break;case 1:C(b.type)&&Kb(b);break;case 4:qd(b,b.stateNode.containerInfo);break;case 10:xc(b,b.memoizedProps.value);break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;if(0!==d&&d>=c)return Be(a,b,c);z(I,I.current&
1,b);b=re(a,b,c);return null!==b?b.sibling:null}z(I,I.current&1,b);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return Ee(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);z(I,I.current,b);if(!d)return null}return re(a,b,c)}Bc=!1}}else Bc=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=Fb(b,A.current);Ac(b,c);e=Jd(null,b,d,a,e,c);b.effectTag|=1;if("object"===
typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;Nd();if(C(d)){var f=!0;Kb(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;var g=d.getDerivedStateFromProps;"function"===typeof g&&Uc(b,d,g,a);e.updater=Xc;b.stateNode=e;e._reactInternalFiber=b;ad(b,d,a,c);b=ye(null,b,d,!0,f,c)}else b.tag=0,Q(null,b,e,c),b=b.child;return b;case 16:e=b.elementType;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;sa(e);if(1!==e._status)throw e._result;
e=e._result;b.type=e;f=b.tag=og(e);a=rc(e,a);switch(f){case 0:b=ve(null,b,e,a,c);break;case 1:b=xe(null,b,e,a,c);break;case 11:b=qe(null,b,e,a,c);break;case 14:b=se(null,b,e,rc(e.type,a),d,c);break;default:throw Error(n(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:rc(d,e),ve(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:rc(d,e),xe(a,b,d,e,c);case 3:ze(b);d=b.updateQueue;if(null===d)throw Error(n(282));e=b.memoizedState;e=null!==e?e.element:
null;Nc(b,d,b.pendingProps,null,c);d=b.memoizedState.element;if(d===e)oe(),b=re(a,b,c);else{if(e=b.stateNode.hydrate)Sa?(ee=tb(b.stateNode.containerInfo),de=b,e=fe=!0):e=!1;if(e)for(c=ld(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else Q(a,b,d,c),oe();b=b.child}return b;case 5:return sd(b),null===a&&je(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ja(d,e)?g=null:null!==f&&Ja(d,f)&&(b.effectTag|=16),we(a,b),b.mode&4&&1!==c&&Ka(d,e)?(b.expirationTime=
b.childExpirationTime=1,b=null):(Q(a,b,g,c),b=b.child),b;case 6:return null===a&&je(b),null;case 13:return Be(a,b,c);case 4:return qd(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=kd(b,null,d,c):Q(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:rc(d,e),qe(a,b,d,e,c);case 7:return Q(a,b,b.pendingProps,c),b.child;case 8:return Q(a,b,b.pendingProps.children,c),b.child;case 12:return Q(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;
e=b.pendingProps;g=b.memoizedProps;f=e.value;xc(b,f);if(null!==g){var l=g.value;f=oc(l,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(l,f):1073741823)|0;if(0===f){if(g.children===e.children&&!B.current){b=re(a,b,c);break a}}else for(l=b.child,null!==l&&(l.return=b);null!==l;){var h=l.dependencies;if(null!==h){g=l.child;for(var k=h.firstContext;null!==k;){if(k.context===d&&0!==(k.observedBits&f)){1===l.tag&&(k=Gc(c,null),k.tag=2,Ic(l,k));l.expirationTime<c&&(l.expirationTime=
c);k=l.alternate;null!==k&&k.expirationTime<c&&(k.expirationTime=c);zc(l.return,c);h.expirationTime<c&&(h.expirationTime=c);break}k=k.next}}else g=10===l.tag?l.type===b.type?null:l.child:l.child;if(null!==g)g.return=l;else for(g=l;null!==g;){if(g===b){g=null;break}l=g.sibling;if(null!==l){l.return=g.return;g=l;break}g=g.return}l=g}}Q(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,Ac(b,c),e=Cc(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,Q(a,b,d,c),b.child;
case 14:return e=b.type,f=rc(e,b.pendingProps),f=rc(e.type,f),se(a,b,e,f,d,c);case 15:return ue(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:rc(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,C(d)?(a=!0,Kb(b)):a=!1,Ac(b,c),Zc(b,d,e,c),ad(b,d,e,c),ye(null,b,d,!0,a,c);case 19:return Ee(a,b,c)}throw Error(n(156,b.tag));};var lg=null,We=null;
function pg(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);lg=function(a){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(e){}};We=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}
function qg(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function he(a,b,c,d){return new qg(a,b,c,d)}
function te(a){a=a.prototype;return!(!a||!a.isReactComponent)}function og(a){if("function"===typeof a)return te(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===la)return 11;if(a===oa)return 14}return 2}
function fd(a,b){var c=a.alternate;null===c?(c=he(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,
firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
function hd(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)te(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ea:return jd(c.children,e,f,b);case ka:g=8;e|=7;break;case fa:g=8;e|=1;break;case ha:return a=he(12,c,b,e|8),a.elementType=ha,a.type=ha,a.expirationTime=f,a;case ma:return a=he(13,c,b,e),a.type=ma,a.elementType=ma,a.expirationTime=f,a;case na:return a=he(19,c,b,e),a.elementType=na,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case ia:g=
10;break a;case ja:g=9;break a;case la:g=11;break a;case oa:g=14;break a;case pa:g=16;d=null;break a}throw Error(n(130,null==a?a:typeof a,""));}b=he(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function jd(a,b,c,d){a=he(7,a,d,b);a.expirationTime=c;return a}function gd(a,b,c){a=he(6,a,null,b);a.expirationTime=c;return a}
function id(a,b,c){b=he(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
function rg(a,b,c){this.tag=b;this.current=null;this.containerInfo=a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=Oa;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}
function Sf(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Pf(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}
function Qf(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Uf(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function sg(a){var b=a._reactInternalFiber;if(void 0===b){if("function"===typeof a.render)throw Error(n(188));throw Error(n(268,Object.keys(a)));}a=xa(b);return null===a?null:a.stateNode}function tg(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function ug(a,b){tg(a,b);(a=a.alternate)&&tg(a,b)}
var vg={createContainer:function(a,b,c){a=new rg(a,b,c);b=he(3,null,null,2===b?7:1===b?3:0);a.current=b;return b.stateNode=a},updateContainer:function(a,b,c,d){var e=b.current,f=G(),g=Sc.suspense;f=Vc(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(ua(c)!==c||1!==c.tag)throw Error(n(170));var l=c;do{switch(l.tag){case 3:l=l.stateNode.context;break b;case 1:if(C(l.type)){l=l.stateNode.__reactInternalMemoizedMergedChildContext;break b}}l=l.return}while(null!==l);throw Error(n(171));}if(1===c.tag){var h=
c.type;if(C(h)){c=Jb(c,h,l);break a}}c=l}else c=Db;null===b.context?b.context=c:b.pendingContext=c;b=Gc(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);Ic(e,b);Wc(e,f);return f},batchedEventUpdates:function(a,b){var c=T;T|=2;try{return a(b)}finally{T=c,T===R&&F()}},batchedUpdates:function(a,b){var c=T;T|=1;try{return a(b)}finally{T=c,T===R&&F()}},unbatchedUpdates:function(a,b){var c=T;T&=-2;T|=rf;try{return a(b)}finally{T=c,T===R&&F()}},deferredUpdates:function(a){return hc(97,
a)},syncUpdates:function(a,b,c,d){return hc(99,a.bind(null,b,c,d))},discreteUpdates:function(a,b,c,d){var e=T;T|=4;try{return hc(98,a.bind(null,b,c,d))}finally{T=e,T===R&&F()}},flushDiscreteUpdates:function(){(T&(1|S|sf))===R&&(dg(),Vf())},flushControlled:function(a){var b=T;T|=1;try{hc(99,a)}finally{T=b,T===R&&F()}},flushSync:eg,flushPassiveEffects:Vf,IsThisRendererActing:{current:!1},getPublicRootInstance:function(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return za(a.child.stateNode);
default:return a.child.stateNode}},attemptSynchronousHydration:function(a){switch(a.tag){case 3:var b=a.stateNode;b.hydrate&&cg(b,b.firstPendingTime);break;case 13:eg(function(){return Wc(a,1073741823)}),b=mc(G(),150,100),ug(a,b)}},attemptUserBlockingHydration:function(a){if(13===a.tag){var b=mc(G(),150,100);Wc(a,b);ug(a,b)}},attemptContinuousHydration:function(a){if(13===a.tag){G();var b=lc++;Wc(a,b);ug(a,b)}},attemptHydrationAtCurrentPriority:function(a){if(13===a.tag){var b=G();b=Vc(b,a,null);
Wc(a,b);ug(a,b)}},findHostInstance:sg,findHostInstanceWithWarning:function(a){return sg(a)},findHostInstanceWithNoPortals:function(a){a=ya(a);return null===a?null:20===a.tag?a.stateNode.instance:a.stateNode},shouldSuspend:function(){return!1},injectIntoDevTools:function(a){var b=a.findFiberByHostInstance;return pg(aa({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:q.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=xa(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))}};module.exports=vg.default||vg;

    var $$$renderer = module.exports;
    module.exports = $$$reconciler;
    return $$$renderer;
};


/***/ }),

/***/ 76525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(67287);
} else {}


/***/ }),

/***/ 52546:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v0.18.0
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

Object.defineProperty(exports, "__esModule", ({value:!0}));var f,g,h,k,l;
if("undefined"===typeof window||"function"!==typeof MessageChannel){var p=null,q=null,t=function(){if(null!==p)try{var a=exports.unstable_now();p(!0,a);p=null}catch(b){throw setTimeout(t,0),b;}},u=Date.now();exports.unstable_now=function(){return Date.now()-u};f=function(a){null!==p?setTimeout(f,0,a):(p=a,setTimeout(t,0))};g=function(a,b){q=setTimeout(a,b)};h=function(){clearTimeout(q)};k=function(){return!1};l=exports.unstable_forceFrameRate=function(){}}else{var w=window.performance,x=window.Date,
y=window.setTimeout,z=window.clearTimeout;if("undefined"!==typeof console){var A=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");"function"!==typeof A&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills")}if("object"===
typeof w&&"function"===typeof w.now)exports.unstable_now=function(){return w.now()};else{var B=x.now();exports.unstable_now=function(){return x.now()-B}}var C=!1,D=null,E=-1,F=5,G=0;k=function(){return exports.unstable_now()>=G};l=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):F=0<a?Math.floor(1E3/a):5};var H=new MessageChannel,I=H.port2;H.port1.onmessage=
function(){if(null!==D){var a=exports.unstable_now();G=a+F;try{D(!0,a)?I.postMessage(null):(C=!1,D=null)}catch(b){throw I.postMessage(null),b;}}else C=!1};f=function(a){D=a;C||(C=!0,I.postMessage(null))};g=function(a,b){E=y(function(){a(exports.unstable_now())},b)};h=function(){z(E);E=-1}}function J(a,b){var c=a.length;a.push(b);a:for(;;){var d=Math.floor((c-1)/2),e=a[d];if(void 0!==e&&0<K(e,b))a[d]=b,a[c]=e,c=d;else break a}}function L(a){a=a[0];return void 0===a?null:a}
function M(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>K(n,c))void 0!==r&&0>K(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m);else if(void 0!==r&&0>K(r,c))a[d]=r,a[v]=c,d=v;else break a}}return b}return null}function K(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var N=[],O=[],P=1,Q=null,R=3,S=!1,T=!1,U=!1;
function V(a){for(var b=L(O);null!==b;){if(null===b.callback)M(O);else if(b.startTime<=a)M(O),b.sortIndex=b.expirationTime,J(N,b);else break;b=L(O)}}function W(a){U=!1;V(a);if(!T)if(null!==L(N))T=!0,f(X);else{var b=L(O);null!==b&&g(W,b.startTime-a)}}
function X(a,b){T=!1;U&&(U=!1,h());S=!0;var c=R;try{V(b);for(Q=L(N);null!==Q&&(!(Q.expirationTime>b)||a&&!k());){var d=Q.callback;if(null!==d){Q.callback=null;R=Q.priorityLevel;var e=d(Q.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?Q.callback=e:Q===L(N)&&M(N);V(b)}else M(N);Q=L(N)}if(null!==Q)var m=!0;else{var n=L(O);null!==n&&g(W,n.startTime-b);m=!1}return m}finally{Q=null,R=c,S=!1}}
function Y(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var Z=l;exports.unstable_ImmediatePriority=1;exports.unstable_UserBlockingPriority=2;exports.unstable_NormalPriority=3;exports.unstable_IdlePriority=5;exports.unstable_LowPriority=4;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=R;R=a;try{return b()}finally{R=c}};
exports.unstable_next=function(a){switch(R){case 1:case 2:case 3:var b=3;break;default:b=R}var c=R;R=b;try{return a()}finally{R=c}};
exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();if("object"===typeof c&&null!==c){var e=c.delay;e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:Y(a)}else c=Y(a),e=d;c=e+c;a={id:P++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,J(O,a),null===L(N)&&a===L(O)&&(U?h():U=!0,g(W,e-d))):(a.sortIndex=c,J(N,a),T||S||(T=!0,f(X)));return a};exports.unstable_cancelCallback=function(a){a.callback=null};
exports.unstable_wrapCallback=function(a){var b=R;return function(){var c=R;R=b;try{return a.apply(this,arguments)}finally{R=c}}};exports.unstable_getCurrentPriorityLevel=function(){return R};exports.unstable_shouldYield=function(){var a=exports.unstable_now();V(a);var b=L(N);return b!==Q&&null!==Q&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<Q.expirationTime||k()};exports.unstable_requestPaint=Z;exports.unstable_continueExecution=function(){T||S||(T=!0,f(X))};
exports.unstable_pauseExecution=function(){};exports.unstable_getFirstCallbackNode=function(){return L(N)};exports.unstable_Profiling=null;


/***/ }),

/***/ 60373:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(52546);
} else {}


/***/ }),

/***/ 76585:
/***/ ((module) => {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ 39658:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isarray = __webpack_require__(76585)

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options), options)
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens, options) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options && options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}


/***/ }),

/***/ 72408:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var l=__webpack_require__(27418),n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.forward_ref"):60112,y=n?Symbol.for("react.suspense"):60113,z=n?Symbol.for("react.memo"):60115,A=n?Symbol.for("react.lazy"):
60116,B="function"===typeof Symbol&&Symbol.iterator;function C(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
var D={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},E={};function F(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}F.prototype.isReactComponent={};F.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(C(85));this.updater.enqueueSetState(this,a,b,"setState")};F.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};
function G(){}G.prototype=F.prototype;function H(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}var I=H.prototype=new G;I.constructor=H;l(I,F.prototype);I.isPureReactComponent=!0;var J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,c){var e,d={},g=null,k=null;if(null!=b)for(e in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,e)&&!L.hasOwnProperty(e)&&(d[e]=b[e]);var f=arguments.length-2;if(1===f)d.children=c;else if(1<f){for(var h=Array(f),m=0;m<f;m++)h[m]=arguments[m+2];d.children=h}if(a&&a.defaultProps)for(e in f=a.defaultProps,f)void 0===d[e]&&(d[e]=f[e]);return{$$typeof:p,type:a,key:g,ref:k,props:d,_owner:J.current}}
function N(a,b){return{$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g,Q=[];function R(a,b,c,e){if(Q.length){var d=Q.pop();d.result=a;d.keyPrefix=b;d.func=c;d.context=e;d.count=0;return d}return{result:a,keyPrefix:b,func:c,context:e,count:0}}
function S(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>Q.length&&Q.push(a)}
function T(a,b,c,e){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0}}if(g)return c(e,a,""===b?"."+U(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+U(d,k);g+=T(d,f,c,e)}else if(null===a||"object"!==typeof a?f=null:(f=B&&a[B]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),k=
0;!(d=a.next()).done;)d=d.value,f=b+U(d,k++),g+=T(d,f,c,e);else if("object"===d)throw c=""+a,Error(C(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return g}function V(a,b,c){return null==a?0:T(a,"",b,c)}function U(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function W(a,b){a.func.call(a.context,b,a.count++)}
function aa(a,b,c){var e=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?X(a,e,c,function(a){return a}):null!=a&&(O(a)&&(a=N(a,d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(P,"$&/")+"/")+c)),e.push(a))}function X(a,b,c,e,d){var g="";null!=c&&(g=(""+c).replace(P,"$&/")+"/");b=R(b,g,e,d);V(a,aa,b);S(b)}var Y={current:null};function Z(){var a=Y.current;if(null===a)throw Error(C(321));return a}
var ba={ReactCurrentDispatcher:Y,ReactCurrentBatchConfig:{suspense:null},ReactCurrentOwner:J,IsSomeRendererActing:{current:!1},assign:l};exports.Children={map:function(a,b,c){if(null==a)return a;var e=[];X(a,e,null,b,c);return e},forEach:function(a,b,c){if(null==a)return a;b=R(null,null,b,c);V(a,W,b);S(b)},count:function(a){return V(a,function(){return null},null)},toArray:function(a){var b=[];X(a,b,null,function(a){return a});return b},only:function(a){if(!O(a))throw Error(C(143));return a}};
exports.Component=F;exports.Fragment=r;exports.Profiler=u;exports.PureComponent=H;exports.StrictMode=t;exports.Suspense=y;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ba;
exports.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(C(267,a));var e=l({},a.props),d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=J.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)K.call(b,h)&&!L.hasOwnProperty(h)&&(e[h]=void 0===b[h]&&void 0!==f?f[h]:b[h])}var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){f=Array(h);for(var m=0;m<h;m++)f[m]=arguments[m+2];e.children=f}return{$$typeof:p,type:a.type,
key:d,ref:g,props:e,_owner:k}};exports.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};exports.forwardRef=function(a){return{$$typeof:x,render:a}};exports.isValidElement=O;
exports.lazy=function(a){return{$$typeof:A,_ctor:a,_status:-1,_result:null}};exports.memo=function(a,b){return{$$typeof:z,type:a,compare:void 0===b?null:b}};exports.useCallback=function(a,b){return Z().useCallback(a,b)};exports.useContext=function(a,b){return Z().useContext(a,b)};exports.useDebugValue=function(){};exports.useEffect=function(a,b){return Z().useEffect(a,b)};exports.useImperativeHandle=function(a,b,c){return Z().useImperativeHandle(a,b,c)};
exports.useLayoutEffect=function(a,b){return Z().useLayoutEffect(a,b)};exports.useMemo=function(a,b){return Z().useMemo(a,b)};exports.useReducer=function(a,b,c){return Z().useReducer(a,b,c)};exports.useRef=function(a){return Z().useRef(a)};exports.useState=function(a){return Z().useState(a)};exports.version="16.13.1";


/***/ }),

/***/ 67294:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(72408);
} else {}


/***/ }),

/***/ 23972:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var rtlDetect = __webpack_require__(6730);

module.exports = {

    isRtlLang: rtlDetect.isRtlLang,

    getLangDir: rtlDetect.getLangDir

};


/***/ }),

/***/ 6730:
/***/ ((module) => {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */



var self;
var RtlDetectLib = self = {  // eslint-disable-line consistent-this
    // Private vars - star
    _regexEscape: /([\.\*\+\^\$\[\]\\\(\)\|\{\}\,\-\:\?])/g, // eslint-disable-line no-useless-escape
    _regexParseLocale: /^([a-zA-Z]*)([_\-a-zA-Z]*)$/,
    // Private vars - end

    // Private functions - star
    _escapeRegExpPattern: function (str) {
        if (typeof str !== 'string') {
            return str;
        }
        return str.replace(self._regexEscape, '\\$1');
    },

    _toLowerCase: function (str, reserveReturnValue) {
        if (typeof str !== 'string') {
            return reserveReturnValue && str;
        }
        return str.toLowerCase();
    },

    _toUpperCase: function (str, reserveReturnValue) {
        if (typeof str !== 'string') {
            return reserveReturnValue && str;
        }
        return str.toUpperCase();
    },

    _trim: function (str, delimiter, reserveReturnValue) {
        var patterns = [];
        var regexp;
        var addPatterns = function (pattern) {
            // Build trim RegExp pattern and push it to patterns array
            patterns.push('^' + pattern + '+|' + pattern + '+$');
        };

        // fix reserveReturnValue value
        if (typeof delimiter === 'boolean') {
            reserveReturnValue = delimiter;
            delimiter = null;
        }

        if (typeof str !== 'string') {
            return reserveReturnValue && str;
        }

        // Trim based on delimiter array values
        if (Array.isArray(delimiter)) {
            // Loop through delimiter array
            delimiter.map(function (item) {
                // Escape delimiter to be valid RegExp Pattern
                var pattern = self._escapeRegExpPattern(item);
                // Push pattern to patterns array
                addPatterns(pattern);
            });
        }

        // Trim based on delimiter string value
        if (typeof delimiter === 'string') {
            // Escape delimiter to be valid RegExp Pattern
            var patternDelimiter = self._escapeRegExpPattern(delimiter);
            // push pattern to patterns array
            addPatterns(patternDelimiter);
        }

        // If delimiter  is not defined, Trim white spaces
        if (!delimiter) {
            // Push white space pattern to patterns array
            addPatterns('\\s');
        }

        // Build RegExp pattern
        var pattern = '(' + patterns.join('|') + ')';
        // Build RegExp object
        regexp = new RegExp(pattern, 'g');

        // trim string for all patterns
        while (str.match(regexp)) {
            str = str.replace(regexp, '');
        }

        // Return trim string
        return str;
    },

    _parseLocale : function (strLocale) {
        var matches =  self._regexParseLocale.exec(strLocale); // exec regex
        var parsedLocale;
        var lang;
        var countryCode;

        if (!strLocale || !matches) {
            return;
        }

        // fix countryCode string by trimming '-' and '_'
        matches[2] = self._trim(matches[2], ['-', '_']);

        lang = self._toLowerCase(matches[1]);
        countryCode = self._toUpperCase(matches[2]) || countryCode;

        // object with lang, countryCode properties
        parsedLocale = {
            lang: lang,
            countryCode: countryCode
        };

        // return parsed locale object
        return parsedLocale;
    },
    // Private functions - End

    // Public functions - star
    isRtlLang: function (strLocale) {
        var objLocale = self._parseLocale(strLocale);
        if (!objLocale) {
            return;
        }
        // return true if the intel string lang exists in the BID RTL LANGS array else return false
        return (self._BIDI_RTL_LANGS.indexOf(objLocale.lang) >= 0);
    },

    getLangDir: function (strLocale) {
        // return 'rtl' if the intel string lang exists in the BID RTL LANGS array else return 'ltr'
        return self.isRtlLang(strLocale) ? 'rtl' : 'ltr';
    }

    // Public functions - End
};

// Const BIDI_RTL_LANGS Array
// BIDI_RTL_LANGS ref: http://en.wikipedia.org/wiki/Right-to-left
// Table of scripts in Unicode: https://en.wikipedia.org/wiki/Script_(Unicode)
Object.defineProperty(self, '_BIDI_RTL_LANGS', {
    value: [
        'ae',	/* Avestan */
        'ar',   /* 'العربية', Arabic */
        'arc',  /* Aramaic */
        'bcc',  /* 'بلوچی مکرانی', Southern Balochi */
        'bqi',  /* 'بختياري', Bakthiari */
        'ckb',  /* 'Soranî / کوردی', Sorani */
        'dv',   /* Dhivehi */
        'fa',   /* 'فارسی', Persian */
        'glk',  /* 'گیلکی', Gilaki */
        'he',   /* 'עברית', Hebrew */
        'ku',   /* 'Kurdî / كوردی', Kurdish */
        'mzn',  /* 'مازِرونی', Mazanderani */
        'nqo',  /* N'Ko */
        'pnb',  /* 'پنجابی', Western Punjabi */
        'ps',   /* 'پښتو', Pashto, */
        'sd',   /* 'سنڌي', Sindhi */
        'ug',   /* 'Uyghurche / ئۇيغۇرچە', Uyghur */
        'ur',    /* 'اردو', Urdu */
        'yi'    /* 'ייִדיש', Yiddish */
    ],
    writable: false,
    enumerable: true,
    configurable: false
});


module.exports = RtlDetectLib;


/***/ }),

/***/ 89509:
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(48764)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 42830:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = (__webpack_require__(17187).EventEmitter);
var inherits = __webpack_require__(35717);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(56577);
Stream.Writable = __webpack_require__(20323);
Stream.Duplex = __webpack_require__(68656);
Stream.Transform = __webpack_require__(94473);
Stream.PassThrough = __webpack_require__(2366);
Stream.finished = __webpack_require__(81086)
Stream.pipeline = __webpack_require__(56472)

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),

/***/ 58106:
/***/ ((module) => {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.q = codes;


/***/ }),

/***/ 68656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = __webpack_require__(56577);

var Writable = __webpack_require__(20323);

__webpack_require__(35717)(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ 2366:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(94473);

__webpack_require__(35717)(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ 56577:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = (__webpack_require__(17187).EventEmitter);

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(83194);
/*</replacement>*/


var Buffer = (__webpack_require__(48764).Buffer);

var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = __webpack_require__(40964);

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__(39686);

var destroyImpl = __webpack_require__(71029);

var _require = __webpack_require__(30094),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = (__webpack_require__(58106)/* .codes */ .q),
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

__webpack_require__(35717)(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(68656);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(32553)/* .StringDecoder */ .s);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(68656);
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__webpack_require__(32553)/* .StringDecoder */ .s);
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(20828);
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __webpack_require__(31265);
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

/***/ }),

/***/ 94473:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var _require$codes = (__webpack_require__(58106)/* .codes */ .q),
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = __webpack_require__(68656);

__webpack_require__(35717)(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ 20323:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(94927)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(83194);
/*</replacement>*/


var Buffer = (__webpack_require__(48764).Buffer);

var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __webpack_require__(71029);

var _require = __webpack_require__(30094),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = (__webpack_require__(58106)/* .codes */ .q),
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

__webpack_require__(35717)(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(68656);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(68656); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ 20828:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = __webpack_require__(81086);

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ 39686:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(48764),
    Buffer = _require.Buffer;

var _require2 = __webpack_require__(69862),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

/***/ }),

/***/ 71029:
/***/ ((module) => {

"use strict";
 // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ 81086:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).


var ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(58106)/* .codes.ERR_STREAM_PREMATURE_CLOSE */ .q.ERR_STREAM_PREMATURE_CLOSE);

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

/***/ }),

/***/ 31265:
/***/ ((module) => {

module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};


/***/ }),

/***/ 56472:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).


var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = (__webpack_require__(58106)/* .codes */ .q),
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(81086);
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

/***/ }),

/***/ 30094:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = (__webpack_require__(58106)/* .codes.ERR_INVALID_OPT_VALUE */ .q.ERR_INVALID_OPT_VALUE);

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ 83194:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(17187).EventEmitter;


/***/ }),

/***/ 32553:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__webpack_require__(89509).Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ 94927:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!__webpack_require__.g.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = __webpack_require__.g.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}


/***/ }),

/***/ 91496:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ 20384:
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ 89539:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(__webpack_require__.g.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(20384);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(91496);

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}


/***/ }),

/***/ 14290:
/***/ (() => {



/***/ }),

/***/ 62052:
/***/ (() => {



/***/ }),

/***/ 89592:
/***/ (() => {



/***/ }),

/***/ 60197:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/modal_hide-2341f.ogg";

/***/ }),

/***/ 99373:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/release-7c974.ogg";

/***/ }),

/***/ 43464:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/snes_pop-7a6d3.ogg";

/***/ }),

/***/ 53603:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Acquire Hardware-11613.jpg";

/***/ }),

/***/ 73217:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Adventuring Time-70f23.jpg";

/***/ }),

/***/ 18376:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Ahoy-1bdfb.jpg";

/***/ }),

/***/ 43218:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Alternative Fuel-9fa05.jpg";

/***/ }),

/***/ 67464:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Archer-9f669.jpg";

/***/ }),

/***/ 827:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Artificial Selection-ecbd8.jpg";

/***/ }),

/***/ 52133:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Atlantis-c690d.jpg";

/***/ }),

/***/ 41988:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Bake Bread-46004.jpg";

/***/ }),

/***/ 81346:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Beaconator-9fcb5.jpg";

/***/ }),

/***/ 811:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Beam Me Up-4de6a.jpg";

/***/ }),

/***/ 67982:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Bee Our Guest-eea44.jpg";

/***/ }),

/***/ 19119:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Benchmaking-81738.jpg";

/***/ }),

/***/ 69501:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Body Guard-d2b59.jpg";

/***/ }),

/***/ 68592:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Bullseye-7f384.jpg";

/***/ }),

/***/ 47461:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Buy Low Sell High-6e453.jpg";

/***/ }),

/***/ 33732:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Camouflage-fdac2.jpg";

/***/ }),

/***/ 77563:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Castaway-87c1e.jpg";

/***/ }),

/***/ 86795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Cheating Death-962c3.jpg";

/***/ }),

/***/ 9071:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Chestful of Cobblestone-cfa59.jpg";

/***/ }),

/***/ 72844:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Cover Me in Debris-1c2af.jpg";

/***/ }),

/***/ 3139:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Cow Tipper-101c0.jpg";

/***/ }),

/***/ 8348:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/DIAMONDS-747fe.jpg";

/***/ }),

/***/ 67607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Delicious Fish-31f5d.jpg";

/***/ }),

/***/ 48677:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Diamonds To You-0d1f9.jpg";

/***/ }),

/***/ 33231:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Disenchanted-198d2.jpg";

/***/ }),

/***/ 18905:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Dispense With This-73ccf.jpg";

/***/ }),

/***/ 57098:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Do a Barrel Roll-7b2c5.jpg";

/***/ }),

/***/ 76844:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Dry Spell-5b906.jpg";

/***/ }),

/***/ 27149:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Echolocation-2379f.jpg";

/***/ }),

/***/ 16996:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Enchanter-24e86.jpg";

/***/ }),

/***/ 55671:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Feeling ill-45cc9.jpg";

/***/ }),

/***/ 84115:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Free Diver-58756.jpg";

/***/ }),

/***/ 6454:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Freight Station-17c07.jpg";

/***/ }),

/***/ 28110:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Fruit on the Loom-48969.jpg";

/***/ }),

/***/ 90796:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Getting Wood-27bf3.jpg";

/***/ }),

/***/ 94267:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Getting an Upgrade-48f3f.jpg";

/***/ }),

/***/ 29655:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Great View From Up Here-1af43.jpg";

/***/ }),

/***/ 57185:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Have a Shearful Day-d56db.jpg";

/***/ }),

/***/ 29199:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Hot Topic-5e947.jpg";

/***/ }),

/***/ 65975:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Hot Tourist Destination-05e2d.jpg";

/***/ }),

/***/ 32236:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Inception-a30bb.jpg";

/***/ }),

/***/ 92857:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Into Fire-282b4.jpg";

/***/ }),

/***/ 72312:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Into the Nether-97882.jpg";

/***/ }),

/***/ 32261:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Iron Belly-4bfd0.jpg";

/***/ }),

/***/ 66893:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Iron Man-28f8f.jpg";

/***/ }),

/***/ 36719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Its a sign-955a5.jpg";

/***/ }),

/***/ 72127:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Ive Got a Bad Feeling About This-3b4bb.jpg";

/***/ }),

/***/ 91731:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Kill the Beast-bbbe7.jpg";

/***/ }),

/***/ 7850:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Leader Of The Pack-05612.jpg";

/***/ }),

/***/ 55112:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Let it Go-e5f7f.jpg";

/***/ }),

/***/ 37:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Librarian-ffc9f.jpg";

/***/ }),

/***/ 93457:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Lion Hunter-4baac.jpg";

/***/ }),

/***/ 28556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Local Brewery-cf73b.jpg";

/***/ }),

/***/ 71507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/MOAR_Tools-f858a.jpg";

/***/ }),

/***/ 7424:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Map Room-12963.jpg";

/***/ }),

/***/ 61851:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Marine Biologist-905e5.jpg";

/***/ }),

/***/ 24273:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Master Trader-31d3e.jpg";

/***/ }),

/***/ 50459:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Me Gold-c1d48.jpg";

/***/ }),

/***/ 95541:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Missing Content-acdf5.jpg";

/***/ }),

/***/ 45981:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Monster Hunter-06656.jpg";

/***/ }),

/***/ 15168:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Moskstraumen-41d9e.jpg";

/***/ }),

/***/ 39216:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/On a Rail-b2aef.jpg";

/***/ }),

/***/ 81568:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/One Pickle Two Pickle Sea Pickle Four-2321c.jpg";

/***/ }),

/***/ 92011:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Oooh Shiny-cdce6.jpg";

/***/ }),

/***/ 75394:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Organizational Wizard-9595e.jpg";

/***/ }),

/***/ 96121:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Overkill-6fded.jpg";

/***/ }),

/***/ 91330:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Overpowered-63911.jpg";

/***/ }),

/***/ 49678:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Passing The Time-b1578.jpg";

/***/ }),

/***/ 66862:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Plethora of Cats-6cb9c.jpg";

/***/ }),

/***/ 3664:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Pork Chop-8a9b2.jpg";

/***/ }),

/***/ 45459:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Pot Planter-6fbb2.jpg";

/***/ }),

/***/ 16013:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Rabbit Season-50e3f.jpg";

/***/ }),

/***/ 73682:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Rainbow Collection-f3be4.jpg";

/***/ }),

/***/ 72486:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Renewable Energy-dc525.jpg";

/***/ }),

/***/ 48853:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Repopulation-1512c.jpg";

/***/ }),

/***/ 38735:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Return to Sender-27efb.jpg";

/***/ }),

/***/ 10068:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Saddle Up-648bf.jpg";

/***/ }),

/***/ 90261:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Sail the 7 Seas-f35c0.jpg";

/***/ }),

/***/ 8003:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Sleep With The Fishes-14e33.jpg";

/***/ }),

/***/ 46175:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Smelt Everything-bb2bf.jpg";

/***/ }),

/***/ 38537:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Sniper Duel-9112f.jpg";

/***/ }),

/***/ 96350:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/So I Got That Going for Me-27680.jpg";

/***/ }),

/***/ 34924:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Sound the Alarm-4774c.jpg";

/***/ }),

/***/ 57213:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Stayin Frosty-7d731.jpg";

/***/ }),

/***/ 8072:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Sticky Situation-38e18.jpg";

/***/ }),

/***/ 18460:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Super Fuel-f0ebd.jpg";

/***/ }),

/***/ 10988:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Super Sonic-1fdf2.jpg";

/***/ }),

/***/ 66570:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Taking Inventory-96cd8.jpg";

/***/ }),

/***/ 786:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Taste of Your Own Medicine-fcfb1.jpg";

/***/ }),

/***/ 90678:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The Beginning.-06a1b.jpg";

/***/ }),

/***/ 661:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The Beginning_-756c9.jpg";

/***/ }),

/***/ 78965:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The Deep End-1e509.jpg";

/***/ }),

/***/ 81023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The End... Again...-2210a.jpg";

/***/ }),

/***/ 56377:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The End-b4e77.jpg";

/***/ }),

/***/ 68956:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The End_-0d7cd.jpg";

/***/ }),

/***/ 47419:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The Haggler-34004.jpg";

/***/ }),

/***/ 42539:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The Lie-73ed5.jpg";

/***/ }),

/***/ 32539:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Tie Dye Outfit-a8a7d.jpg";

/***/ }),

/***/ 59906:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Time For Stew-cee86.jpg";

/***/ }),

/***/ 43450:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Time to Farm-b9d4e.jpg";

/***/ }),

/***/ 70040:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Time to Mine-1e5c7.jpg";

/***/ }),

/***/ 50611:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Time to Strike-60cb6.jpg";

/***/ }),

/***/ 93870:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Top of the World-b9b5b.jpg";

/***/ }),

/***/ 30280:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Total Beelocation-325f5.jpg";

/***/ }),

/***/ 29553:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Trampoline-c6bf4.jpg";

/***/ }),

/***/ 90104:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Treasure Hunter-44301.jpg";

/***/ }),

/***/ 13921:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Were being attacked-832ac.jpg";

/***/ }),

/***/ 93624:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/When Pigs Fly-bd98b.jpg";

/***/ }),

/***/ 18324:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Where Have You Been-61295.jpg";

/***/ }),

/***/ 41395:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/You Need A Mint-28c41.jpg";

/***/ }),

/***/ 87126:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Zombie Doctor-159ee.jpg";

/***/ }),

/***/ 94239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Zoologist-0f99d.jpg";

/***/ }),

/***/ 76243:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/placeholder1-55454.jpg";

/***/ }),

/***/ 54705:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/placeholder2-b6c97.jpg";

/***/ }),

/***/ 40949:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/hat_fisherman_thumbnail_0-90aea.png";

/***/ }),

/***/ 36577:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/skin_slime_thumbnail_0-3af42.png";

/***/ }),

/***/ 59001:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/toothpick_wheat_thumbnail_0-b93d5.png";

/***/ }),

/***/ 84984:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/animation-074ed.gif";

/***/ }),

/***/ 69862:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 40964:
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/hbui/";
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// extracted by mini-css-extract-plugin
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ({});
})();

// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
(() => {
// React tries to run `element instanceof win.HTMLIFrameElement`
// and crashes, because HTMLIFrameElement is undefined in HB
// see: https://github.com/facebook/react/blame/c954efa70f44a44be9c33c60c57f87bea6f40a10/packages/react-dom/src/client/ReactInputSelection.js#L46
window.HTMLIFrameElement = window.HTMLIFrameElement || function () {};
})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// UNUSED EXPORTS: default

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(67294);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(45697);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
function extends_extends() {
  extends_extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return extends_extends.apply(this, arguments);
}
;// CONCATENATED MODULE: ./node_modules/resolve-pathname/esm/resolve-pathname.js
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to, from) {
  if (from === undefined) from = '';

  var toParts = (to && to.split('/')) || [];
  var fromParts = (from && from.split('/')) || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) fromParts.unshift('..');

  if (
    mustEndAbs &&
    fromParts[0] !== '' &&
    (!fromParts[0] || !isAbsolute(fromParts[0]))
  )
    fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* harmony default export */ const resolve_pathname = (resolvePathname);

;// CONCATENATED MODULE: ./node_modules/history/esm/history.js






function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
}
function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
}
function hasBasename(path, prefix) {
  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;
}
function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
}
function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
}
function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';
  var hashIndex = pathname.indexOf('#');

  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');

  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
}
function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;
  var path = pathname || '/';
  if (search && search !== '?') path += search.charAt(0) === '?' ? search : "?" + search;
  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : "#" + hash;
  return path;
}

function history_createLocation(path, state, key, currentLocation) {
  var location;

  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = parsePath(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = extends_extends({}, path);
    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = resolve_pathname(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
}
function history_locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);
}

function createTransitionManager() {
  var prompt = null;

  function setPrompt(nextPrompt) {
     false ? 0 : void 0;
    prompt = nextPrompt;
    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  }

  function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
           false ? 0 : void 0;
          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }

  var listeners = [];

  function appendListener(fn) {
    var isActive = true;

    function listener() {
      if (isActive) fn.apply(void 0, arguments);
    }

    listeners.push(listener);
    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  }

  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(void 0, args);
    });
  }

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
}

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message)); // eslint-disable-line no-alert
}
/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */

function supportsHistory() {
  var ua = window.navigator.userAgent;
  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;
  return window.history && 'pushState' in window.history;
}
/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */

function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
}
/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */

function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
}
/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */

function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
}

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
}
/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */


function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ?  false ? 0 : invariant(false) : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props,
      _props$forceRefresh = _props.forceRefresh,
      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';

  function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;
    var path = pathname + search + hash;
     false ? 0 : void 0;
    if (basename) path = stripBasename(path, basename);
    return history_createLocation(path, state, key);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (isExtraneousPopstateEvent(event)) return;
    handlePop(getDOMLocation(event.state));
  }

  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }

  var forceNextPop = false;

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key]; // Public interface

  function createHref(location) {
    return basename + createPath(location);
  }

  function push(path, state) {
     false ? 0 : void 0;
    var action = 'PUSH';
    var location = history_createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.pushState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location.key);
          allKeys = nextKeys;
          setState({
            action: action,
            location: location
          });
        }
      } else {
         false ? 0 : void 0;
        window.location.href = href;
      }
    });
  }

  function replace(path, state) {
     false ? 0 : void 0;
    var action = 'REPLACE';
    var location = history_createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.replaceState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1) allKeys[prevIndex] = location.key;
          setState({
            action: action,
            location: location
          });
        }
      } else {
         false ? 0 : void 0;
        window.location.replace(href);
      }
    });
  }

  function go(n) {
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

var HashChangeEvent$1 = 'hashchange';
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
};

function stripHash(url) {
  var hashIndex = url.indexOf('#');
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}

function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
}

function pushHashPath(path) {
  window.location.hash = path;
}

function replaceHashPath(path) {
  window.location.replace(stripHash(window.location.href) + '#' + path);
}

function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ?  false ? 0 : invariant(false) : void 0;
  var globalHistory = window.history;
  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
  var _props = props,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$hashType = _props.hashType,
      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  function getDOMLocation() {
    var path = decodePath(getHashPath());
     false ? 0 : void 0;
    if (basename) path = stripBasename(path, basename);
    return history_createLocation(path);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  var forceNextPop = false;
  var ignorePath = null;

  function locationsAreEqual$$1(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
  }

  function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;
      handlePop(location);
    }
  }

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  } // Ensure the hash is encoded properly before doing anything else.


  var path = getHashPath();
  var encodedPath = encodePath(path);
  if (path !== encodedPath) replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)]; // Public interface

  function createHref(location) {
    var baseTag = document.querySelector('base');
    var href = '';

    if (baseTag && baseTag.getAttribute('href')) {
      href = stripHash(window.location.href);
    }

    return href + '#' + encodePath(basename + createPath(location));
  }

  function push(path, state) {
     false ? 0 : void 0;
    var action = 'PUSH';
    var location = history_createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path);
        allPaths = nextPaths;
        setState({
          action: action,
          location: location
        });
      } else {
         false ? 0 : void 0;
        setState();
      }
    });
  }

  function replace(path, state) {
     false ? 0 : void 0;
    var action = 'REPLACE';
    var location = history_createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1) allPaths[prevIndex] = path;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
     false ? 0 : void 0;
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}
/**
 * Creates a history object that stores locations in memory.
 */


function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }

  var _props = props,
      getUserConfirmation = _props.getUserConfirmation,
      _props$initialEntries = _props.initialEntries,
      initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,
      _props$initialIndex = _props.initialIndex,
      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();

  function setState(nextState) {
    extends_extends(history, nextState);

    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? history_createLocation(entry, undefined, createKey()) : history_createLocation(entry, undefined, entry.key || createKey());
  }); // Public interface

  var createHref = createPath;

  function push(path, state) {
     false ? 0 : void 0;
    var action = 'PUSH';
    var location = history_createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);

      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }

  function replace(path, state) {
     false ? 0 : void 0;
    var action = 'REPLACE';
    var location = history_createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      history.entries[history.index] = location;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
    var action = 'POP';
    var location = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    return transitionManager.setPrompt(prompt);
  }

  function listen(listener) {
    return transitionManager.appendListener(listener);
  }

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };
  return history;
}



;// CONCATENATED MODULE: ./node_modules/mini-create-react-context/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function setPrototypeOf_setPrototypeOf(o, p) {
  setPrototypeOf_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return setPrototypeOf_setPrototypeOf(o, p);
}
;// CONCATENATED MODULE: ./node_modules/mini-create-react-context/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js

function inheritsLoose_inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  setPrototypeOf_setPrototypeOf(subClass, superClass);
}
;// CONCATENATED MODULE: ./node_modules/mini-create-react-context/dist/esm/index.js





var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : {};

function getUniqueId() {
  var key = '__global_unique_id__';
  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
}

function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value, changedBits);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = '__create-react-context-' + getUniqueId() + '__';

  var Provider = /*#__PURE__*/function (_Component) {
    inheritsLoose_inheritsLoose(Provider, _Component);

    function Provider() {
      var _this;

      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }

    var _proto = Provider.prototype;

    _proto.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;

        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

          if (false) {}

          changedBits |= 0;

          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };

    _proto.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(react.Component);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = (prop_types_default()).object.isRequired, _Provider$childContex);

  var Consumer = /*#__PURE__*/function (_Component2) {
    inheritsLoose_inheritsLoose(Consumer, _Component2);

    function Consumer() {
      var _this2;

      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };

      _this2.onUpdate = function (newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;

        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };

      return _this2;
    }

    var _proto2 = Consumer.prototype;

    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }

      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    _proto2.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(react.Component);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = (prop_types_default()).object, _Consumer$contextType);
  return {
    Provider: Provider,
    Consumer: Consumer
  };
}

var index = react.createContext || createReactContext;

/* harmony default export */ const esm = (index);

;// CONCATENATED MODULE: ./node_modules/tiny-invariant/dist/tiny-invariant.esm.js
var isProduction = "production" === 'production';
var prefix = 'Invariant failed';
function tiny_invariant_esm_invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction) {
        throw new Error(prefix);
    }
    throw new Error(prefix + ": " + (message || ''));
}

/* harmony default export */ const tiny_invariant_esm = (tiny_invariant_esm_invariant);

// EXTERNAL MODULE: ./node_modules/react-router/node_modules/path-to-regexp/index.js
var path_to_regexp = __webpack_require__(39658);
var path_to_regexp_default = /*#__PURE__*/__webpack_require__.n(path_to_regexp);
// EXTERNAL MODULE: ./node_modules/react-is/index.js
var react_is = __webpack_require__(59864);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}
// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var hoist_non_react_statics_cjs = __webpack_require__(8679);
;// CONCATENATED MODULE: ./node_modules/react-router/esm/react-router.js













// TODO: Replace with React.createContext once we can assume React 16+

var createNamedContext = function createNamedContext(name) {
  var context = esm();
  context.displayName = name;
  return context;
};

var context =
/*#__PURE__*/
createNamedContext("Router");

/**
 * The public API for putting history on context.
 */

var Router =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Router, _React$Component);

  Router.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };

  function Router(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    }; // This is a bit of a hack. We have to start listening for location
    // changes here in the constructor in case there are any <Redirect>s
    // on the initial render. If there are, they will replace/push when
    // they mount and since cDM fires in children before parents, we may
    // get a new location before the <Router> is mounted.

    _this._isMounted = false;
    _this._pendingLocation = null;

    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function (location) {
        if (_this._isMounted) {
          _this.setState({
            location: location
          });
        } else {
          _this._pendingLocation = location;
        }
      });
    }

    return _this;
  }

  var _proto = Router.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this._isMounted = true;

    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) this.unlisten();
  };

  _proto.render = function render() {
    return react.createElement(context.Provider, {
      children: this.props.children || null,
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    });
  };

  return Router;
}(react.Component);

if (false) {}

/**
 * The public API for a <Router> that stores location in memory.
 */

var react_router_MemoryRouter =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }

  var _proto = MemoryRouter.prototype;

  _proto.render = function render() {
    return react.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };

  return MemoryRouter;
}(react.Component);

if (false) {}

var Lifecycle =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Lifecycle, _React$Component);

  function Lifecycle() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Lifecycle.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount) this.props.onMount.call(this, this);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount) this.props.onUnmount.call(this, this);
  };

  _proto.render = function render() {
    return null;
  };

  return Lifecycle;
}(react.Component);

/**
 * The public API for prompting the user before navigating away from a screen.
 */

function Prompt(_ref) {
  var message = _ref.message,
      _ref$when = _ref.when,
      when = _ref$when === void 0 ? true : _ref$when;
  return React.createElement(context.Consumer, null, function (context) {
    !context ?  false ? 0 : invariant(false) : void 0;
    if (!when || context.staticContext) return null;
    var method = context.history.block;
    return React.createElement(Lifecycle, {
      onMount: function onMount(self) {
        self.release = method(message);
      },
      onUpdate: function onUpdate(self, prevProps) {
        if (prevProps.message !== message) {
          self.release();
          self.release = method(message);
        }
      },
      onUnmount: function onUnmount(self) {
        self.release();
      },
      message: message
    });
  });
}

if (false) { var messageType; }

var cache = {};
var cacheLimit = 10000;
var cacheCount = 0;

function compilePath(path) {
  if (cache[path]) return cache[path];
  var generator = pathToRegexp.compile(path);

  if (cacheCount < cacheLimit) {
    cache[path] = generator;
    cacheCount++;
  }

  return generator;
}
/**
 * Public API for generating a URL pathname from a path and parameters.
 */


function generatePath(path, params) {
  if (path === void 0) {
    path = "/";
  }

  if (params === void 0) {
    params = {};
  }

  return path === "/" ? path : compilePath(path)(params, {
    pretty: true
  });
}

/**
 * The public API for navigating programmatically with a component.
 */

function Redirect(_ref) {
  var computedMatch = _ref.computedMatch,
      to = _ref.to,
      _ref$push = _ref.push,
      push = _ref$push === void 0 ? false : _ref$push;
  return React.createElement(context.Consumer, null, function (context) {
    !context ?  false ? 0 : invariant(false) : void 0;
    var history = context.history,
        staticContext = context.staticContext;
    var method = push ? history.push : history.replace;
    var location = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : _extends({}, to, {
      pathname: generatePath(to.pathname, computedMatch.params)
    }) : to); // When rendering in a static context,
    // set the new location immediately.

    if (staticContext) {
      method(location);
      return null;
    }

    return React.createElement(Lifecycle, {
      onMount: function onMount() {
        method(location);
      },
      onUpdate: function onUpdate(self, prevProps) {
        var prevLocation = createLocation(prevProps.to);

        if (!locationsAreEqual(prevLocation, _extends({}, location, {
          key: prevLocation.key
        }))) {
          method(location);
        }
      },
      to: to
    });
  });
}

if (false) {}

var cache$1 = {};
var cacheLimit$1 = 10000;
var cacheCount$1 = 0;

function compilePath$1(path, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path]) return pathCache[path];
  var keys = [];
  var regexp = path_to_regexp_default()(path, keys, options);
  var result = {
    regexp: regexp,
    keys: keys
  };

  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }

  return result;
}
/**
 * Public API for matching a URL pathname to a path.
 */


function matchPath(pathname, options) {
  if (options === void 0) {
    options = {};
  }

  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }

  var _options = options,
      path = _options.path,
      _options$exact = _options.exact,
      exact = _options$exact === void 0 ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === void 0 ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path);
  return paths.reduce(function (matched, path) {
    if (!path && path !== "") return null;
    if (matched) return matched;

    var _compilePath = compilePath$1(path, {
      end: exact,
      strict: strict,
      sensitive: sensitive
    }),
        regexp = _compilePath.regexp,
        keys = _compilePath.keys;

    var match = regexp.exec(pathname);
    if (!match) return null;
    var url = match[0],
        values = match.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact) return null;
    return {
      path: path,
      // the path used to match
      url: path === "/" && url === "" ? "/" : url,
      // the matched portion of the URL
      isExact: isExact,
      // whether or not we matched exactly
      params: keys.reduce(function (memo, key, index) {
        memo[key.name] = values[index];
        return memo;
      }, {})
    };
  }, null);
}

function isEmptyChildren(children) {
  return React.Children.count(children) === 0;
}

function evalChildrenDev(children, props, path) {
  var value = children(props);
   false ? 0 : void 0;
  return value || null;
}
/**
 * The public API for matching a single path and rendering.
 */


var react_router_Route =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Route, _React$Component);

  function Route() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Route.prototype;

  _proto.render = function render() {
    var _this = this;

    return react.createElement(context.Consumer, null, function (context$1) {
      !context$1 ?  false ? 0 : tiny_invariant_esm(false) : void 0;
      var location = _this.props.location || context$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch // <Switch> already computed the match for us
      : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;

      var props = extends_extends({}, context$1, {
        location: location,
        match: match
      });

      var _this$props = _this.props,
          children = _this$props.children,
          component = _this$props.component,
          render = _this$props.render; // Preact uses an empty array as children by
      // default, so use null if that's the case.

      if (Array.isArray(children) && children.length === 0) {
        children = null;
      }

      return react.createElement(context.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ?  false ? 0 : children(props) : children : component ? react.createElement(component, props) : render ? render(props) : null : typeof children === "function" ?  false ? 0 : children(props) : null);
    });
  };

  return Route;
}(react.Component);

if (false) {}

function react_router_addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}

function addBasename(basename, location) {
  if (!basename) return location;
  return extends_extends({}, location, {
    pathname: react_router_addLeadingSlash(basename) + location.pathname
  });
}

function react_router_stripBasename(basename, location) {
  if (!basename) return location;
  var base = react_router_addLeadingSlash(basename);
  if (location.pathname.indexOf(base) !== 0) return location;
  return extends_extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
}

function createURL(location) {
  return typeof location === "string" ? location : createPath(location);
}

function staticHandler(methodName) {
  return function () {
      false ? 0 : tiny_invariant_esm(false) ;
  };
}

function noop() {}
/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */


var StaticRouter =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(StaticRouter, _React$Component);

  function StaticRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _this.handlePush = function (location) {
      return _this.navigateTo(location, "PUSH");
    };

    _this.handleReplace = function (location) {
      return _this.navigateTo(location, "REPLACE");
    };

    _this.handleListen = function () {
      return noop;
    };

    _this.handleBlock = function () {
      return noop;
    };

    return _this;
  }

  var _proto = StaticRouter.prototype;

  _proto.navigateTo = function navigateTo(location, action) {
    var _this$props = this.props,
        _this$props$basename = _this$props.basename,
        basename = _this$props$basename === void 0 ? "" : _this$props$basename,
        _this$props$context = _this$props.context,
        context = _this$props$context === void 0 ? {} : _this$props$context;
    context.action = action;
    context.location = addBasename(basename, history_createLocation(location));
    context.url = createURL(context.location);
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        _this$props2$basename = _this$props2.basename,
        basename = _this$props2$basename === void 0 ? "" : _this$props2$basename,
        _this$props2$context = _this$props2.context,
        context = _this$props2$context === void 0 ? {} : _this$props2$context,
        _this$props2$location = _this$props2.location,
        location = _this$props2$location === void 0 ? "/" : _this$props2$location,
        rest = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(_this$props2, ["basename", "context", "location"]);

    var history = {
      createHref: function createHref(path) {
        return react_router_addLeadingSlash(basename + createURL(path));
      },
      action: "POP",
      location: react_router_stripBasename(basename, history_createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler("go"),
      goBack: staticHandler("goBack"),
      goForward: staticHandler("goForward"),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return react.createElement(Router, extends_extends({}, rest, {
      history: history,
      staticContext: context
    }));
  };

  return StaticRouter;
}(react.Component);

if (false) {}

/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Switch, _React$Component);

  function Switch() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Switch.prototype;

  _proto.render = function render() {
    var _this = this;

    return react.createElement(context.Consumer, null, function (context) {
      !context ?  false ? 0 : tiny_invariant_esm(false) : void 0;
      var location = _this.props.location || context.location;
      var element, match; // We use React.Children.forEach instead of React.Children.toArray().find()
      // here because toArray adds keys to all child elements and we do not want
      // to trigger an unmount/remount for two <Route>s that render the same
      // component at different URLs.

      react.Children.forEach(_this.props.children, function (child) {
        if (match == null && react.isValidElement(child)) {
          element = child;
          var path = child.props.path || child.props.from;
          match = path ? matchPath(location.pathname, extends_extends({}, child.props, {
            path: path
          })) : context.match;
        }
      });
      return match ? react.cloneElement(element, {
        location: location,
        computedMatch: match
      }) : null;
    });
  };

  return Switch;
}(react.Component);

if (false) {}

/**
 * A public higher-order component to access the imperative API
 */

function withRouter(Component) {
  var displayName = "withRouter(" + (Component.displayName || Component.name) + ")";

  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = _objectWithoutPropertiesLoose(props, ["wrappedComponentRef"]);

    return React.createElement(context.Consumer, null, function (context) {
      !context ?  false ? 0 : invariant(false) : void 0;
      return React.createElement(Component, _extends({}, remainingProps, context, {
        ref: wrappedComponentRef
      }));
    });
  };

  C.displayName = displayName;
  C.WrappedComponent = Component;

  if (false) {}

  return hoistStatics(C, Component);
}

var react_router_useContext = react.useContext;
function useHistory() {
  if (false) {}

  return react_router_useContext(context).history;
}
function useLocation() {
  if (false) {}

  return react_router_useContext(context).location;
}
function useParams() {
  if (false) {}

  var match = react_router_useContext(context).match;
  return match ? match.params : {};
}
function useRouteMatch(path) {
  if (false) {}

  return path ? matchPath(useLocation().pathname, path) : react_router_useContext(context).match;
}

if (false) { var secondaryBuildName, initialBuildName, buildNames, key, global; }


//# sourceMappingURL=react-router.js.map

// EXTERNAL MODULE: ./node_modules/ramda/src/without.js
var without = __webpack_require__(76290);
var without_default = /*#__PURE__*/__webpack_require__.n(without);
// EXTERNAL MODULE: ./packages/react-facet/src/index.ts
var react_facet_src = __webpack_require__(57811);
;// CONCATENATED MODULE: ./packages/engine/src/facets/routerFacet.ts


/**
 * Constant shared with the backend to indicate that even though the Gameface view is initialized,
 * we don't have any active routes.
 */
const ROUTER_INVALID_ROUTE = '/__INVALID_ROUTE__';
const ROUTER_FACET = 'core.router';
/**
 * React Hook that requests the facet
 */

const routerFacet = (0,react_facet_src.sharedFacet)(ROUTER_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/createEngineHistory.ts



function createEngineHistory(historyReadyCallback, sharedFacetDriver) {
  let proxy;

  const update = routerFacet => {
    if (proxy == null) {
      proxy = buildHistoryProxy(routerFacet);
      historyReadyCallback(proxy.history);
    } else {
      proxy.notifyListeners();
    }
  };

  sharedFacetDriver(ROUTER_FACET, update, undefined, error => {
    throw new Error(error);
  });
}

function buildHistoryProxy(routerFacet) {
  let listeners = []; // setup the engine transitions to a default value of 800

  routerFacet.engineUITransitionTime = 800;
  const history = {
    // --- Frontend methods ---
    createHref: createPath,
    block: () => () => {},
    listen: listener => {
      listeners = [...listeners, listener];
      return () => {
        listeners = without_default()([listener], listeners);
      };
    },

    //--- Backend methods ---
    get length() {
      return routerFacet.history.length;
    },

    get action() {
      return routerFacet.history.action;
    },

    get location() {
      // TODO: fix this is the backend
      return cleanLocation(routerFacet.history.location);
    },

    go: steps => {
      routerFacet.history.go(steps);
    },
    goBack: () => {
      routerFacet.history.goBack();
    },
    goForward: () => {
      routerFacet.history.goForward();
    },
    push: location => {
      if (typeof location === 'object') {
        const url = `${location.pathname}${location.search}${location.hash}`;
        routerFacet.history.push(url, '');
      } else if (typeof location === 'string') {
        routerFacet.history.push(location, '');
      }
    },
    replace: location => {
      if (typeof location === 'object') {
        const url = `${location.pathname}${location.search}${location.hash}`;
        routerFacet.history.replace(url, '');
      } else if (typeof location === 'string') {
        routerFacet.history.replace(location, '');
      }
    }
  };
  let previousPathname = null;

  const notifyListeners = () => {
    const newPathname = history.location.pathname; // Important to store the pathname here since it can change when running the listeners.

    if (previousPathname == null || previousPathname !== newPathname) {
      listeners.forEach(listener => listener(history.location, history.action));
    }

    previousPathname = newPathname;
  };

  return {
    history,
    notifyListeners
  };
}

function cleanLocation(location) {
  const [searchPathname, search] = location.pathname.split('?');
  const [pathname, hash] = searchPathname.split('#');
  return {
    hash: hash || location.hash || '',
    pathname: pathname,
    search: search || location.search || '',
    state: location.state
  };
}
;// CONCATENATED MODULE: ./node_modules/@ungap/url-search-params/esm/index.js
/*! (c) Andrea Giammarchi - ISC */
var esm_self = undefined || /* istanbul ignore next */ {};
try {
  (function (URLSearchParams, plus) {
    if (
      new URLSearchParams('q=%2B').get('q') !== plus ||
      new URLSearchParams({q: plus}).get('q') !== plus ||
      new URLSearchParams([['q', plus]]).get('q') !== plus ||
      new URLSearchParams('q=\n').toString() !== 'q=%0A' ||
      new URLSearchParams({q: ' &'}).toString() !== 'q=+%26' ||
      new URLSearchParams({q: '%zx'}).toString() !== 'q=%25zx'
    )
      throw URLSearchParams;
    esm_self.URLSearchParams = URLSearchParams;
  }(URLSearchParams, '+'));
} catch(URLSearchParams) {
  (function (Object, String, isArray) {'use strict';
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var find = /[!'\(\)~]|%20|%00/g;
    var findPercentSign = /%(?![0-9a-fA-F]{2})/g;
    var plus = /\+/g;
    var replace = {
      '!': '%21',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '~': '%7E',
      '%20': '+',
      '%00': '\x00'
    };
    var proto = {
      append: function (key, value) {
        appendTo(this._ungap, key, value);
      },
      delete: function (key) {
        delete this._ungap[key];
      },
      get: function (key) {
        return this.has(key) ? this._ungap[key][0] : null;
      },
      getAll: function (key) {
        return this.has(key) ? this._ungap[key].slice(0) : [];
      },
      has: function (key) {
        return key in this._ungap;
      },
      set: function (key, value) {
        this._ungap[key] = [String(value)];
      },
      forEach: function (callback, thisArg) {
        var self = this;
        for (var key in self._ungap)
          self._ungap[key].forEach(invoke, key);
        function invoke(value) {
          callback.call(thisArg, value, String(key), self);
        }
      },
      toJSON: function () {
        return {};
      },
      toString: function () {
        var query = [];
        for (var key in this._ungap) {
          var encoded = encode(key);
          for (var
            i = 0,
            value = this._ungap[key];
            i < value.length; i++
          ) {
            query.push(encoded + '=' + encode(value[i]));
          }
        }
        return query.join('&');
      }
    };
    for (var key in proto)
      defineProperty(URLSearchParams.prototype, key, {
        configurable: true,
        writable: true,
        value: proto[key]
      });
    esm_self.URLSearchParams = URLSearchParams;
    function URLSearchParams(query) {
      var dict = create(null);
      defineProperty(this, '_ungap', {value: dict});
      switch (true) {
        case !query:
          break;
        case typeof query === 'string':
          if (query.charAt(0) === '?') {
            query = query.slice(1);
          }
          for (var
            pairs = query.split('&'),
            i = 0,
            length = pairs.length; i < length; i++
          ) {
            var value = pairs[i];
            var index = value.indexOf('=');
            if (-1 < index) {
              appendTo(
                dict,
                decode(value.slice(0, index)),
                decode(value.slice(index + 1))
              );
            } else if (value.length){
              appendTo(
                dict,
                decode(value),
                ''
              );
            }
          }
          break;
        case isArray(query):
          for (var
            i = 0,
            length = query.length; i < length; i++
          ) {
            var value = query[i];
            appendTo(dict, value[0], value[1]);
          }
          break;
        case 'forEach' in query:
          query.forEach(addEach, dict);
          break;
        default:
          for (var key in query)
            appendTo(dict, key, query[key]);
      }
    }

    function addEach(value, key) {
      appendTo(this, key, value);
    }

    function appendTo(dict, key, value) {
      var res = isArray(value) ? value.join(',') : value;
      if (key in dict)
        dict[key].push(res);
      else
        dict[key] = [res];
    }

    function decode(str) {
      return decodeURIComponent(str.replace(findPercentSign, '%25').replace(plus, ' '));
    }

    function encode(str) {
      return encodeURIComponent(str).replace(find, replacer);
    }

    function replacer(match) {
      return replace[match];
    }

  }(Object, String, Array.isArray));
}

(function (URLSearchParamsProto) {

  var iterable = false;
  try { iterable = !!Symbol.iterator; } catch (o_O) {}

  /* istanbul ignore else */
  if (!('forEach' in URLSearchParamsProto)) {
    URLSearchParamsProto.forEach = function forEach(callback, thisArg) {
      var self = this;
      var names = Object.create(null);
      this.toString()
          .replace(/=[\s\S]*?(?:&|$)/g, '=')
          .split('=')
          .forEach(function (name) {
            if (!name.length || name in names)
              return;
            (names[name] = self.getAll(name)).forEach(function(value) {
              callback.call(thisArg, value, name, self);
            });
          });
    };
  }

  /* istanbul ignore else */
  if (!('keys' in URLSearchParamsProto)) {
    URLSearchParamsProto.keys = function keys() {
      return iterator(this, function(value, key) { this.push(key); });
    };
  }

   /* istanbul ignore else */
  if (!('values' in URLSearchParamsProto)) {
    URLSearchParamsProto.values = function values() {
      return iterator(this, function(value, key) { this.push(value); });
    };
  }

  /* istanbul ignore else */
  if (!('entries' in URLSearchParamsProto)) {
    URLSearchParamsProto.entries = function entries() {
      return iterator(this, function(value, key) { this.push([key, value]); });
    };
  }

  /* istanbul ignore else */
  if (iterable && !(Symbol.iterator in URLSearchParamsProto)) {
    URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;
  }

  /* istanbul ignore else */
  if (!('sort' in URLSearchParamsProto)) {
    URLSearchParamsProto.sort = function sort() {
      var
        entries = this.entries(),
        entry = entries.next(),
        done = entry.done,
        keys = [],
        values = Object.create(null),
        i, key, value
      ;
      while (!done) {
        value = entry.value;
        key = value[0];
        keys.push(key);
        if (!(key in values)) {
          values[key] = [];
        }
        values[key].push(value[1]);
        entry = entries.next();
        done = entry.done;
      }
      // not the champion in efficiency
      // but these two bits just do the job
      keys.sort();
      for (i = 0; i < keys.length; i++) {
        this.delete(keys[i]);
      }
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        this.append(key, values[key].shift());
      }
    };
  }

  function iterator(self, callback) {
    var items = [];
    self.forEach(callback, items);
    /* istanbul ignore next */
    return iterable ?
      items[Symbol.iterator]() :
      {
        next: function() {
          var value = items.shift();
          return {done: value === void 0, value: value};
        }
      };
  }

  /* istanbul ignore next */
  (function (Object) {
    var
      dP = Object.defineProperty,
      gOPD = Object.getOwnPropertyDescriptor,
      createSearchParamsPollute = function (search) {
        function append(name, value) {
          URLSearchParamsProto.append.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        function del(name) {
          URLSearchParamsProto.delete.call(this, name);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        function set(name, value) {
          URLSearchParamsProto.set.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        return function (sp, value) {
          sp.append = append;
          sp.delete = del;
          sp.set = set;
          return dP(sp, '_usp', {
            configurable: true,
            writable: true,
            value: value
          });
        };
      },
      createSearchParamsCreate = function (polluteSearchParams) {
        return function (obj, sp) {
          dP(
            obj, '_searchParams', {
              configurable: true,
              writable: true,
              value: polluteSearchParams(sp, obj)
            }
          );
          return sp;
        };
      },
      updateSearchParams = function (sp) {
        var append = sp.append;
        sp.append = URLSearchParamsProto.append;
        URLSearchParams.call(sp, sp._usp.search.slice(1));
        sp.append = append;
      },
      verifySearchParams = function (obj, Class) {
        if (!(obj instanceof Class)) throw new TypeError(
          "'searchParams' accessed on an object that " +
          "does not implement interface " + Class.name
        );
      },
      upgradeClass = function (Class) {
        var
          ClassProto = Class.prototype,
          searchParams = gOPD(ClassProto, 'searchParams'),
          href = gOPD(ClassProto, 'href'),
          search = gOPD(ClassProto, 'search'),
          createSearchParams
        ;
        if (!searchParams && search && search.set) {
          createSearchParams = createSearchParamsCreate(
            createSearchParamsPollute(search)
          );
          Object.defineProperties(
            ClassProto,
            {
              href: {
                get: function () {
                  return href.get.call(this);
                },
                set: function (value) {
                  var sp = this._searchParams;
                  href.set.call(this, value);
                  if (sp) updateSearchParams(sp);
                }
              },
              search: {
                get: function () {
                  return search.get.call(this);
                },
                set: function (value) {
                  var sp = this._searchParams;
                  search.set.call(this, value);
                  if (sp) updateSearchParams(sp);
                }
              },
              searchParams: {
                get: function () {
                  verifySearchParams(this, Class);
                  return this._searchParams || createSearchParams(
                    this,
                    new URLSearchParams(this.search.slice(1))
                  );
                },
                set: function (sp) {
                  verifySearchParams(this, Class);
                  createSearchParams(this, sp);
                }
              }
            }
          );
        }
      }
    ;
    try {
      upgradeClass(HTMLAnchorElement);
      if (/^function|object$/.test(typeof URL) && URL.prototype)
        upgradeClass(URL);
    } catch (meh) {}
  }(Object));

}(esm_self.URLSearchParams.prototype, Object));
/* harmony default export */ const url_search_params_esm = (esm_self.URLSearchParams);

;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/urlFocusedId.tsx
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * TODO: There is currently a bug with the router facet (on the back-end) which
 * doesn't behave correctly with hash URL fragments, so we will enforce using
 * query strings until it is fixed
 */

const isHashBugFixed = false;
const useHashForFocusState = isHashBugFixed && "gameface" === 'gameface';
function getFocusedIdFromLocation(location, useHash = useHashForFocusState) {
  const params = new url_search_params_esm(useHash ? location.hash : location.search);
  const alias = params.get('alias');
  if (typeof alias === 'string' && alias.length !== 0) return alias;
  const nodeId = params.get('nodeId');
  if (nodeId == null) return undefined;
  return parseInt(nodeId, 10);
}

function parseUrlHashParams(hash) {
  return hash.substr(1).split('&').reduce((res, item) => {
    const parts = item.split('=');
    res.set(parts[0], parts[1]);
    return res;
  }, new Map());
}

function encodeUrlHashParams(hashParams) {
  return Array.from(hashParams.entries()).filter(item => item[1] != null).map(([key, value]) => `${key}=${value}`).join('&');
}

function getURLWithFocusedId(location, newFocusedId, useHash = useHashForFocusState) {
  const hashParams = parseUrlHashParams(location.hash);
  hashParams.delete('nodeId');
  hashParams.delete('alias');
  const searchParams = new url_search_params_esm(location.search);
  searchParams.delete('nodeId');
  searchParams.delete('alias');
  const params = useHash ? hashParams : searchParams;

  if (typeof newFocusedId === 'string') {
    params.set('alias', newFocusedId);
  } else if (typeof newFocusedId === 'number') {
    params.set('nodeId', newFocusedId.toString());
  }

  const hashString = encodeUrlHashParams(hashParams);
  const searchString = searchParams.toString();
  return _objectSpread(_objectSpread({}, location), {}, {
    search: searchString.length ? `?${searchString}` : '',
    hash: hashString.length ? `#${hashString}` : ''
  });
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/types.ts
let ScreenType;

(function (ScreenType) {
  ScreenType[ScreenType["TV_SCREEN_TYPE"] = 0] = "TV_SCREEN_TYPE";
  ScreenType[ScreenType["DESKTOP_SCREEN_TYPE"] = 1] = "DESKTOP_SCREEN_TYPE";
  ScreenType[ScreenType["HANDHELD_SCREEN_TYPE"] = 2] = "HANDHELD_SCREEN_TYPE";
  ScreenType[ScreenType["VR_SCREEN_TYPE"] = 3] = "VR_SCREEN_TYPE";
})(ScreenType || (ScreenType = {}));

let HandheldDeviceType;

(function (HandheldDeviceType) {
  HandheldDeviceType[HandheldDeviceType["PHONE"] = 0] = "PHONE";
  HandheldDeviceType[HandheldDeviceType["TABLET"] = 1] = "TABLET";
})(HandheldDeviceType || (HandheldDeviceType = {}));

let types_InputMethod;

(function (InputMethod) {
  InputMethod[InputMethod["GAMEPAD"] = 0] = "GAMEPAD";
  InputMethod[InputMethod["TOUCH"] = 1] = "TOUCH";
  InputMethod[InputMethod["MOUSE"] = 2] = "MOUSE";
  InputMethod[InputMethod["MOTION"] = 3] = "MOTION";
  InputMethod[InputMethod["KEYBOARD"] = 4] = "KEYBOARD";
})(types_InputMethod || (types_InputMethod = {}));

let ARVRPlatform;

(function (ARVRPlatform) {
  ARVRPlatform[ARVRPlatform["ARVR_None"] = 0] = "ARVR_None";
  ARVRPlatform[ARVRPlatform["ARVR_Rift"] = 1] = "ARVR_Rift";
  ARVRPlatform[ARVRPlatform["ARVR_Holographic"] = 2] = "ARVR_Holographic";
  ARVRPlatform[ARVRPlatform["ARVR_WindowsMR"] = 3] = "ARVR_WindowsMR";
  ARVRPlatform[ARVRPlatform["ARVR_PSVR"] = 4] = "ARVR_PSVR";
  ARVRPlatform[ARVRPlatform["ARVR_GearVR"] = 5] = "ARVR_GearVR";
  ARVRPlatform[ARVRPlatform["ARVR_DesktopXR"] = 6] = "ARVR_DesktopXR";
})(ARVRPlatform || (ARVRPlatform = {}));

let Platform;

(function (Platform) {
  Platform[Platform["IOS"] = 0] = "IOS";
  Platform[Platform["GOOGLE"] = 1] = "GOOGLE";
  Platform[Platform["AMAZON_HANDHELD"] = 2] = "AMAZON_HANDHELD";
  Platform[Platform["UWP"] = 3] = "UWP";
  Platform[Platform["XBOX"] = 4] = "XBOX";
  Platform[Platform["NX_HANDHELD"] = 5] = "NX_HANDHELD";
  Platform[Platform["PS4"] = 6] = "PS4";
  Platform[Platform["GEARVR"] = 7] = "GEARVR";
  Platform[Platform["WIN32"] = 8] = "WIN32";
  Platform[Platform["MACOS"] = 9] = "MACOS";
  Platform[Platform["AMAZON_TV"] = 10] = "AMAZON_TV";
  Platform[Platform["NX_TV"] = 11] = "NX_TV";
  Platform[Platform["PS5"] = 12] = "PS5";
})(Platform || (Platform = {}));

let Scale;

(function (Scale) {
  Scale[Scale["SCALE_100_PERCENT"] = 4] = "SCALE_100_PERCENT";
  Scale[Scale["SCALE_125_PERCENT"] = 5] = "SCALE_125_PERCENT";
  Scale[Scale["SCALE_150_PERCENT"] = 6] = "SCALE_150_PERCENT";
  Scale[Scale["SCALE_175_PERCENT"] = 7] = "SCALE_175_PERCENT";
  Scale[Scale["SCALE_200_PERCENT"] = 8] = "SCALE_200_PERCENT";
})(Scale || (Scale = {}));

let Controller;

(function (Controller) {
  Controller[Controller["XBOX"] = 0] = "XBOX";
  Controller[Controller["PS"] = 1] = "PS";
  Controller[Controller["STEAM"] = 2] = "STEAM";
  Controller[Controller["SWITCH"] = 3] = "SWITCH";
  Controller[Controller["QUEST"] = 4] = "QUEST";
})(Controller || (Controller = {}));
;// CONCATENATED MODULE: ./packages/react-device-information/src/context.tsx



const InputMethodsContext = (0,react.createContext)({
  isPointerInputMouse: (0,react_facet_src.createStaticFacet)(false),
  isPointerInputTouch: (0,react_facet_src.createStaticFacet)(false),
  isPointerInputAvailable: (0,react_facet_src.createStaticFacet)(false),
  isFocusInputGamepad: (0,react_facet_src.createStaticFacet)(false),
  isFocusInputKeyboard: (0,react_facet_src.createStaticFacet)(false),
  isFocusInputAvailable: (0,react_facet_src.createStaticFacet)(false),
  isLastInputMouse: (0,react_facet_src.createStaticFacet)(false),
  isLastInputTouch: (0,react_facet_src.createStaticFacet)(false),
  isLastInputGamepad: (0,react_facet_src.createStaticFacet)(false),
  isLastInputKeyboard: (0,react_facet_src.createStaticFacet)(false),
  isLastInputPointer: (0,react_facet_src.createStaticFacet)(false),
  isLastInputFocus: (0,react_facet_src.createStaticFacet)(false),
  isGamepadSupported: (0,react_facet_src.createStaticFacet)(false),
  isKeyboardSupported: (0,react_facet_src.createStaticFacet)(false),
  isMouseSupported: (0,react_facet_src.createStaticFacet)(false),
  isTouchSupported: (0,react_facet_src.createStaticFacet)(false),
  isPointerSupported: (0,react_facet_src.createStaticFacet)(false),
  isFocusSupported: (0,react_facet_src.createStaticFacet)(false)
});
const platformContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)(Platform.XBOX));
const VRPlatformContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)(ARVRPlatform.ARVR_None));
const screenTypeContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)(ScreenType.TV_SCREEN_TYPE));
const controllerContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)(Controller.XBOX)); // Hooks for last used pointer input method (mouse or touch)

const useIsPointerInputMouse = () => (0,react.useContext)(InputMethodsContext).isPointerInputMouse;
const useIsPointerInputTouch = () => useContext(InputMethodsContext).isPointerInputTouch;
const useIsPointerInputAvailable = () => useContext(InputMethodsContext).isPointerInputAvailable; // Hooks for last used focus input method (keyboard or gamepad)

const useIsFocusInputGamepad = () => (0,react.useContext)(InputMethodsContext).isFocusInputGamepad;
const useIsFocusInputKeyboard = () => (0,react.useContext)(InputMethodsContext).isFocusInputKeyboard;
const useIsFocusInputAvailable = () => (0,react.useContext)(InputMethodsContext).isFocusInputAvailable; // Hooks for last used input method of any type

const useIsLastInputMouse = () => (0,react.useContext)(InputMethodsContext).isLastInputMouse;
const useIsLastInputTouch = () => (0,react.useContext)(InputMethodsContext).isLastInputTouch;
const useIsLastInputGamepad = () => (0,react.useContext)(InputMethodsContext).isLastInputGamepad;
const useIsLastInputKeyboard = () => (0,react.useContext)(InputMethodsContext).isLastInputKeyboard;
const useIsLastInputPointer = () => (0,react.useContext)(InputMethodsContext).isLastInputPointer;
const useIsLastInputFocus = () => (0,react.useContext)(InputMethodsContext).isLastInputFocus; // Hooks for what input methods are supported by the platform

const useIsGamepadSupported = () => useContext(InputMethodsContext).isGamepadSupported;
const useIsKeyboardSupported = () => useContext(InputMethodsContext).isKeyboardSupported;
const useIsMouseSupported = () => useContext(InputMethodsContext).isMouseSupported;
const useIsTouchSupported = () => useContext(InputMethodsContext).isTouchSupported;
const useIsPointerSupported = () => (0,react.useContext)(InputMethodsContext).isPointerSupported;
const useIsFocusSupported = () => useContext(InputMethodsContext).isFocusSupported;
const usePlatformSelected = () => (0,react.useContext)(platformContext);
const useVRPlatform = () => (0,react.useContext)(VRPlatformContext);
const useDeviceScreenType = () => (0,react.useContext)(screenTypeContext);
const useControllerSelected = () => (0,react.useContext)(controllerContext);
// EXTERNAL MODULE: ./node_modules/ramda/src/union.js
var union = __webpack_require__(30275);
var union_default = /*#__PURE__*/__webpack_require__.n(union);
;// CONCATENATED MODULE: ./packages/react-gamepad-driver/src/types.ts
// TODO Create a interface for the button_map with backend
let ButtonType;

(function (ButtonType) {
  ButtonType["A"] = "A";
  ButtonType["B"] = "B";
  ButtonType["X"] = "X";
  ButtonType["Y"] = "Y";
  ButtonType["START"] = "START";
  ButtonType["SELECT"] = "SELECT";
  ButtonType["XBOX"] = "XBOX";
  ButtonType["RIGHT_TRIGGER"] = "RT";
  ButtonType["LEFT_TRIGGER"] = "LT";
  ButtonType["LEFT_BUMPER"] = "LB";
  ButtonType["RIGHT_BUMPER"] = "RB";
  ButtonType["L3"] = "L3";
  ButtonType["R3"] = "R3";
  ButtonType["LEFT"] = "LEFT";
  ButtonType["RIGHT"] = "RIGHT";
  ButtonType["UP"] = "UP";
  ButtonType["DOWN"] = "DOWN";
  ButtonType["NEXT"] = "NEXT";
  ButtonType["PREV"] = "PREV";
  ButtonType["LEFT_ANALOG_LEFT"] = "L_LEFT";
  ButtonType["LEFT_ANALOG_RIGHT"] = "L_RIGHT";
  ButtonType["LEFT_ANALOG_UP"] = "L_UP";
  ButtonType["LEFT_ANALOG_DOWN"] = "L_DOWN";
  ButtonType["RIGHT_ANALOG_LEFT"] = "R_LEFT";
  ButtonType["RIGHT_ANALOG_RIGHT"] = "R_RIGHT";
  ButtonType["RIGHT_ANALOG_UP"] = "R_UP";
  ButtonType["RIGHT_ANALOG_DOWN"] = "R_DOWN";
  ButtonType[ButtonType["LEFT_HORIZONTAL_AXIS"] = 0] = "LEFT_HORIZONTAL_AXIS";
  ButtonType[ButtonType["LEFT_VERTICAL_AXIS"] = 1] = "LEFT_VERTICAL_AXIS";
  ButtonType[ButtonType["RIGHT_HORIZONTAL_AXIS"] = 2] = "RIGHT_HORIZONTAL_AXIS";
  ButtonType[ButtonType["RIGHT_VERTICAL_AXIS"] = 3] = "RIGHT_VERTICAL_AXIS";
  ButtonType["PSEUDO_BUTTON_1"] = "PSEUDO_BUTTON_1";
  ButtonType["PSEUDO_BUTTON_2"] = "PSEUDO_BUTTON_2";
  ButtonType["PSEUDO_BUTTON_3"] = "PSEUDO_BUTTON_3";
  ButtonType["PSEUDO_BUTTON_4"] = "PSEUDO_BUTTON_4";
  ButtonType["PSEUDO_BUTTON_5"] = "PSEUDO_BUTTON_5";
  ButtonType["PSEUDO_BUTTON_6"] = "PSEUDO_BUTTON_6";
  ButtonType["PSEUDO_BUTTON_7"] = "PSEUDO_BUTTON_7";
  ButtonType["PSEUDO_BUTTON_8"] = "PSEUDO_BUTTON_8";
  ButtonType["PSEUDO_BUTTON_9"] = "PSEUDO_BUTTON_9";
  ButtonType["PSEUDO_BUTTON_10"] = "PSEUDO_BUTTON_10";
})(ButtonType || (ButtonType = {}));

const AXIS_MAP = [[ButtonType.LEFT_ANALOG_LEFT, ButtonType.LEFT_ANALOG_RIGHT], [ButtonType.LEFT_ANALOG_UP, ButtonType.LEFT_ANALOG_DOWN], [ButtonType.RIGHT_ANALOG_LEFT, ButtonType.RIGHT_ANALOG_RIGHT], [ButtonType.RIGHT_ANALOG_UP, ButtonType.RIGHT_ANALOG_DOWN]];
/**
 * Type for buttons which can be mapped to a keyboard key
 */

const KEYBOARD_MAPPABLE_BUTTON = [ButtonType.A, ButtonType.B, ButtonType.X, ButtonType.Y, ButtonType.START, ButtonType.SELECT, ButtonType.XBOX, ButtonType.RIGHT_TRIGGER, ButtonType.LEFT_TRIGGER, ButtonType.LEFT_BUMPER, ButtonType.RIGHT_BUMPER, ButtonType.L3, ButtonType.R3, ButtonType.LEFT, ButtonType.RIGHT, ButtonType.UP, ButtonType.DOWN, ButtonType.PSEUDO_BUTTON_1, ButtonType.PSEUDO_BUTTON_2, ButtonType.PSEUDO_BUTTON_3, ButtonType.PSEUDO_BUTTON_4, ButtonType.PSEUDO_BUTTON_5, ButtonType.PSEUDO_BUTTON_6, ButtonType.PSEUDO_BUTTON_7, ButtonType.PSEUDO_BUTTON_8, ButtonType.PSEUDO_BUTTON_9, ButtonType.PSEUDO_BUTTON_10];
/**
 * Type for buttons which can be displayed on input legends
 */

const INPUT_LEGEND_BUTTONS = [ButtonType.A, ButtonType.B, ButtonType.X, ButtonType.Y, ButtonType.START, ButtonType.SELECT, ButtonType.LEFT, ButtonType.RIGHT, ButtonType.UP, ButtonType.DOWN, ButtonType.L3, ButtonType.R3, ButtonType.LEFT_ANALOG_LEFT, ButtonType.RIGHT_ANALOG_LEFT, ButtonType.LEFT_BUMPER, ButtonType.RIGHT_BUMPER, ButtonType.LEFT_TRIGGER, ButtonType.RIGHT_TRIGGER];
const ACTION_BUTTONS = [ButtonType.A, ButtonType.B, ButtonType.X, ButtonType.Y, ButtonType.START, ButtonType.SELECT, ButtonType.LEFT_BUMPER, ButtonType.RIGHT_BUMPER, ButtonType.LEFT_TRIGGER, ButtonType.RIGHT_TRIGGER, ButtonType.R3, ButtonType.L3];
const BUTTON_MAP = [ButtonType.A, ButtonType.B, ButtonType.X, ButtonType.Y, ButtonType.LEFT_BUMPER, ButtonType.RIGHT_BUMPER, ButtonType.LEFT_TRIGGER, ButtonType.RIGHT_TRIGGER, ButtonType.SELECT, ButtonType.START, ButtonType.L3, ButtonType.R3, ButtonType.UP, ButtonType.DOWN, ButtonType.LEFT, ButtonType.RIGHT, ButtonType.XBOX];
const DIRECTIONAL_BUTTONS = [ButtonType.LEFT, ButtonType.RIGHT, ButtonType.UP, ButtonType.DOWN];
const ACTION_BUTTONS_INDEX = ACTION_BUTTONS.map(string => BUTTON_MAP.indexOf(string));
const DIRECTIONAL_BUTTONS_INDEX = DIRECTIONAL_BUTTONS.map(string => BUTTON_MAP.indexOf(string));
let KeyboardKey;

(function (KeyboardKey) {
  KeyboardKey[KeyboardKey["BACKSPACE"] = 8] = "BACKSPACE";
  KeyboardKey[KeyboardKey["TAB"] = 9] = "TAB";
  KeyboardKey[KeyboardKey["ENTER"] = 13] = "ENTER";
  KeyboardKey[KeyboardKey["SHIFT"] = 16] = "SHIFT";
  KeyboardKey[KeyboardKey["CTRL"] = 17] = "CTRL";
  KeyboardKey[KeyboardKey["ALT"] = 18] = "ALT";
  KeyboardKey[KeyboardKey["CAPS_LOCK"] = 20] = "CAPS_LOCK";
  KeyboardKey[KeyboardKey["ESCAPE"] = 27] = "ESCAPE";
  KeyboardKey[KeyboardKey["SPACE"] = 32] = "SPACE";
  KeyboardKey[KeyboardKey["PG_UP"] = 33] = "PG_UP";
  KeyboardKey[KeyboardKey["PG_DOWN"] = 34] = "PG_DOWN";
  KeyboardKey[KeyboardKey["END"] = 35] = "END";
  KeyboardKey[KeyboardKey["LEFT"] = 37] = "LEFT";
  KeyboardKey[KeyboardKey["UP"] = 38] = "UP";
  KeyboardKey[KeyboardKey["RIGHT"] = 39] = "RIGHT";
  KeyboardKey[KeyboardKey["DOWN"] = 40] = "DOWN";
  KeyboardKey[KeyboardKey["INSERT"] = 45] = "INSERT";
  KeyboardKey[KeyboardKey["DELETE"] = 46] = "DELETE";
  KeyboardKey[KeyboardKey["KEY_0"] = 48] = "KEY_0";
  KeyboardKey[KeyboardKey["KEY_1"] = 49] = "KEY_1";
  KeyboardKey[KeyboardKey["KEY_2"] = 50] = "KEY_2";
  KeyboardKey[KeyboardKey["KEY_3"] = 51] = "KEY_3";
  KeyboardKey[KeyboardKey["KEY_4"] = 52] = "KEY_4";
  KeyboardKey[KeyboardKey["KEY_5"] = 53] = "KEY_5";
  KeyboardKey[KeyboardKey["KEY_6"] = 54] = "KEY_6";
  KeyboardKey[KeyboardKey["KEY_7"] = 55] = "KEY_7";
  KeyboardKey[KeyboardKey["KEY_8"] = 56] = "KEY_8";
  KeyboardKey[KeyboardKey["KEY_9"] = 57] = "KEY_9";
  KeyboardKey[KeyboardKey["SEMICOLON"] = 59] = "SEMICOLON";
  KeyboardKey[KeyboardKey["EQUALS"] = 61] = "EQUALS";
  KeyboardKey[KeyboardKey["KEY_A"] = 65] = "KEY_A";
  KeyboardKey[KeyboardKey["KEY_B"] = 66] = "KEY_B";
  KeyboardKey[KeyboardKey["KEY_C"] = 67] = "KEY_C";
  KeyboardKey[KeyboardKey["KEY_D"] = 68] = "KEY_D";
  KeyboardKey[KeyboardKey["KEY_E"] = 69] = "KEY_E";
  KeyboardKey[KeyboardKey["KEY_F"] = 70] = "KEY_F";
  KeyboardKey[KeyboardKey["KEY_G"] = 71] = "KEY_G";
  KeyboardKey[KeyboardKey["KEY_H"] = 72] = "KEY_H";
  KeyboardKey[KeyboardKey["KEY_I"] = 73] = "KEY_I";
  KeyboardKey[KeyboardKey["KEY_J"] = 74] = "KEY_J";
  KeyboardKey[KeyboardKey["KEY_K"] = 75] = "KEY_K";
  KeyboardKey[KeyboardKey["KEY_L"] = 76] = "KEY_L";
  KeyboardKey[KeyboardKey["KEY_M"] = 77] = "KEY_M";
  KeyboardKey[KeyboardKey["KEY_N"] = 78] = "KEY_N";
  KeyboardKey[KeyboardKey["KEY_O"] = 79] = "KEY_O";
  KeyboardKey[KeyboardKey["KEY_P"] = 80] = "KEY_P";
  KeyboardKey[KeyboardKey["KEY_Q"] = 81] = "KEY_Q";
  KeyboardKey[KeyboardKey["KEY_R"] = 82] = "KEY_R";
  KeyboardKey[KeyboardKey["KEY_S"] = 83] = "KEY_S";
  KeyboardKey[KeyboardKey["KEY_T"] = 84] = "KEY_T";
  KeyboardKey[KeyboardKey["KEY_U"] = 85] = "KEY_U";
  KeyboardKey[KeyboardKey["KEY_V"] = 86] = "KEY_V";
  KeyboardKey[KeyboardKey["KEY_W"] = 87] = "KEY_W";
  KeyboardKey[KeyboardKey["KEY_X"] = 88] = "KEY_X";
  KeyboardKey[KeyboardKey["KEY_Y"] = 89] = "KEY_Y";
  KeyboardKey[KeyboardKey["KEY_Z"] = 90] = "KEY_Z";
  KeyboardKey[KeyboardKey["NUMPAD_0"] = 96] = "NUMPAD_0";
  KeyboardKey[KeyboardKey["NUMPAD_1"] = 97] = "NUMPAD_1";
  KeyboardKey[KeyboardKey["NUMPAD_2"] = 98] = "NUMPAD_2";
  KeyboardKey[KeyboardKey["NUMPAD_3"] = 99] = "NUMPAD_3";
  KeyboardKey[KeyboardKey["NUMPAD_4"] = 100] = "NUMPAD_4";
  KeyboardKey[KeyboardKey["NUMPAD_5"] = 101] = "NUMPAD_5";
  KeyboardKey[KeyboardKey["NUMPAD_6"] = 102] = "NUMPAD_6";
  KeyboardKey[KeyboardKey["NUMPAD_7"] = 103] = "NUMPAD_7";
  KeyboardKey[KeyboardKey["NUMPAD_8"] = 104] = "NUMPAD_8";
  KeyboardKey[KeyboardKey["NUMPAD_9"] = 105] = "NUMPAD_9";
  KeyboardKey[KeyboardKey["MINUS"] = 109] = "MINUS";
  KeyboardKey[KeyboardKey["F1"] = 112] = "F1";
  KeyboardKey[KeyboardKey["F2"] = 113] = "F2";
  KeyboardKey[KeyboardKey["F3"] = 114] = "F3";
  KeyboardKey[KeyboardKey["F4"] = 115] = "F4";
  KeyboardKey[KeyboardKey["F5"] = 116] = "F5";
  KeyboardKey[KeyboardKey["F6"] = 117] = "F6";
  KeyboardKey[KeyboardKey["F7"] = 118] = "F7";
  KeyboardKey[KeyboardKey["F8"] = 119] = "F8";
  KeyboardKey[KeyboardKey["F9"] = 120] = "F9";
  KeyboardKey[KeyboardKey["F10"] = 121] = "F10";
  KeyboardKey[KeyboardKey["F11"] = 122] = "F11";
  KeyboardKey[KeyboardKey["F12"] = 123] = "F12";
  KeyboardKey[KeyboardKey["COMMA"] = 188] = "COMMA";
  KeyboardKey[KeyboardKey["PERIOD"] = 190] = "PERIOD";
  KeyboardKey[KeyboardKey["SLASH"] = 191] = "SLASH";
  KeyboardKey[KeyboardKey["GRAVE"] = 192] = "GRAVE";
  KeyboardKey[KeyboardKey["MOUSE_MOVEMENT"] = 195] = "MOUSE_MOVEMENT";
  KeyboardKey[KeyboardKey["MOUSE_BUTTON_LEFT"] = 196] = "MOUSE_BUTTON_LEFT";
  KeyboardKey[KeyboardKey["MOUSE_BUTTON_MIDDLE"] = 197] = "MOUSE_BUTTON_MIDDLE";
  KeyboardKey[KeyboardKey["MOUSE_BUTTON_RIGHT"] = 198] = "MOUSE_BUTTON_RIGHT";
  KeyboardKey[KeyboardKey["MOUSE_WHEEL"] = 199] = "MOUSE_WHEEL";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_1"] = 201] = "PSEUDO_KEY_1";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_2"] = 202] = "PSEUDO_KEY_2";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_3"] = 203] = "PSEUDO_KEY_3";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_4"] = 204] = "PSEUDO_KEY_4";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_5"] = 205] = "PSEUDO_KEY_5";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_6"] = 206] = "PSEUDO_KEY_6";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_7"] = 207] = "PSEUDO_KEY_7";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_8"] = 208] = "PSEUDO_KEY_8";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_9"] = 209] = "PSEUDO_KEY_9";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_10"] = 210] = "PSEUDO_KEY_10";
  KeyboardKey[KeyboardKey["BRACKET_OPEN"] = 219] = "BRACKET_OPEN";
  KeyboardKey[KeyboardKey["BACKSLASH"] = 220] = "BACKSLASH";
  KeyboardKey[KeyboardKey["BRACKET_CLOSE"] = 221] = "BRACKET_CLOSE";
  KeyboardKey[KeyboardKey["APOSTROPHE"] = 222] = "APOSTROPHE";
})(KeyboardKey || (KeyboardKey = {}));

let MouseButton;

(function (MouseButton) {
  MouseButton[MouseButton["Left"] = 0] = "Left";
  MouseButton[MouseButton["Middle"] = 1] = "Middle";
  MouseButton[MouseButton["Right"] = 2] = "Right";
  MouseButton[MouseButton["Back"] = 3] = "Back";
  MouseButton[MouseButton["Forward"] = 4] = "Forward";
})(MouseButton || (MouseButton = {}));
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/types.ts
/**
 * Custom alias provided by the user to identify a node in the focus tree
 * ie: "batata-frita"
 */

/**
 * This is the internal id of a node within the focus tree
 * ie: 2
 */

/**
 * This is the id set by the user to signal which node should be focused
 */
let FocusOrigin;

(function (FocusOrigin) {
  FocusOrigin[FocusOrigin["Unknown"] = -1] = "Unknown";
  FocusOrigin[FocusOrigin["Initial"] = 0] = "Initial";
  FocusOrigin[FocusOrigin["FocusInput"] = 1] = "FocusInput";
  FocusOrigin[FocusOrigin["PointerInput"] = 2] = "PointerInput";
  FocusOrigin[FocusOrigin["FocusTreeMutation"] = 3] = "FocusTreeMutation";
  FocusOrigin[FocusOrigin["URL"] = 4] = "URL";
  FocusOrigin[FocusOrigin["DebugTool"] = 5] = "DebugTool";
  FocusOrigin[FocusOrigin["ImperativeSetFocus"] = 6] = "ImperativeSetFocus";
})(FocusOrigin || (FocusOrigin = {}));

let types_ButtonType;

(function (ButtonType) {
  ButtonType["A"] = "A";
  ButtonType["B"] = "B";
  ButtonType["X"] = "X";
  ButtonType["Y"] = "Y";
  ButtonType["START"] = "START";
  ButtonType["SELECT"] = "SELECT";
  ButtonType["XBOX"] = "XBOX";
  ButtonType["RIGHT_TRIGGER"] = "RT";
  ButtonType["LEFT_TRIGGER"] = "LT";
  ButtonType["LEFT_BUMPER"] = "LB";
  ButtonType["RIGHT_BUMPER"] = "RB";
  ButtonType["L3"] = "L3";
  ButtonType["R3"] = "R3";
  ButtonType["LEFT"] = "LEFT";
  ButtonType["RIGHT"] = "RIGHT";
  ButtonType["UP"] = "UP";
  ButtonType["DOWN"] = "DOWN";
  ButtonType["NEXT"] = "NEXT";
  ButtonType["PREV"] = "PREV";
  ButtonType["LEFT_ANALOG_LEFT"] = "L_LEFT";
  ButtonType["LEFT_ANALOG_RIGHT"] = "L_RIGHT";
  ButtonType["LEFT_ANALOG_UP"] = "L_UP";
  ButtonType["LEFT_ANALOG_DOWN"] = "L_DOWN";
  ButtonType["RIGHT_ANALOG_LEFT"] = "R_LEFT";
  ButtonType["RIGHT_ANALOG_RIGHT"] = "R_RIGHT";
  ButtonType["RIGHT_ANALOG_UP"] = "R_UP";
  ButtonType["RIGHT_ANALOG_DOWN"] = "R_DOWN";
  ButtonType[ButtonType["LEFT_HORIZONTAL_AXIS"] = 0] = "LEFT_HORIZONTAL_AXIS";
  ButtonType[ButtonType["LEFT_VERTICAL_AXIS"] = 1] = "LEFT_VERTICAL_AXIS";
  ButtonType[ButtonType["RIGHT_HORIZONTAL_AXIS"] = 2] = "RIGHT_HORIZONTAL_AXIS";
  ButtonType[ButtonType["RIGHT_VERTICAL_AXIS"] = 3] = "RIGHT_VERTICAL_AXIS";
  ButtonType["PSEUDO_BUTTON_1"] = "PSEUDO_BUTTON_1";
  ButtonType["PSEUDO_BUTTON_2"] = "PSEUDO_BUTTON_2";
  ButtonType["PSEUDO_BUTTON_3"] = "PSEUDO_BUTTON_3";
  ButtonType["PSEUDO_BUTTON_4"] = "PSEUDO_BUTTON_4";
  ButtonType["PSEUDO_BUTTON_5"] = "PSEUDO_BUTTON_5";
  ButtonType["PSEUDO_BUTTON_6"] = "PSEUDO_BUTTON_6";
  ButtonType["PSEUDO_BUTTON_7"] = "PSEUDO_BUTTON_7";
  ButtonType["PSEUDO_BUTTON_8"] = "PSEUDO_BUTTON_8";
  ButtonType["PSEUDO_BUTTON_9"] = "PSEUDO_BUTTON_9";
  ButtonType["PSEUDO_BUTTON_10"] = "PSEUDO_BUTTON_10";
})(types_ButtonType || (types_ButtonType = {}));

const DATA_LANDMARK_ID = 'data-landmark-id';
const types_DATA_FOCUSABLE_ID = 'data-focusable-id';
const DATA_FOCUSABLE_DEBUG_ID = 'data-focusable-debug-id';
let types_FocusableType;

(function (FocusableType) {
  FocusableType[FocusableType["ITEM"] = 0] = "ITEM";
  FocusableType[FocusableType["LANDMARK"] = 1] = "LANDMARK";
  FocusableType[FocusableType["ROOT"] = 2] = "ROOT";
})(types_FocusableType || (types_FocusableType = {}));

let ScrollAxis;

(function (ScrollAxis) {
  ScrollAxis[ScrollAxis["HORIZONTAL"] = 0] = "HORIZONTAL";
  ScrollAxis[ScrollAxis["VERTICAL"] = 1] = "VERTICAL";
})(ScrollAxis || (ScrollAxis = {}));

const DEFAULT_ACTIONS = [types_ButtonType.A, types_ButtonType.B, types_ButtonType.LEFT, types_ButtonType.DOWN, types_ButtonType.RIGHT, types_ButtonType.UP];
let Arrows;

(function (Arrows) {
  Arrows[Arrows["UP"] = 0] = "UP";
  Arrows[Arrows["RIGHT"] = 1] = "RIGHT";
  Arrows[Arrows["DOWN"] = 2] = "DOWN";
  Arrows[Arrows["LEFT"] = 3] = "LEFT";
})(Arrows || (Arrows = {}));

const mapButtonToArrow = {
  [types_ButtonType.LEFT_ANALOG_UP]: Arrows.UP,
  [types_ButtonType.UP]: Arrows.UP,
  [types_ButtonType.LEFT_ANALOG_DOWN]: Arrows.DOWN,
  [types_ButtonType.DOWN]: Arrows.DOWN,
  [types_ButtonType.LEFT_ANALOG_LEFT]: Arrows.LEFT,
  [types_ButtonType.LEFT]: Arrows.LEFT,
  [types_ButtonType.LEFT_ANALOG_RIGHT]: Arrows.RIGHT,
  [types_ButtonType.RIGHT]: Arrows.RIGHT
};
const mapMouseButtonToButtonType = {
  3: types_ButtonType.B
};
let Direction;

(function (Direction) {
  Direction[Direction["NEXT"] = -1] = "NEXT";
  Direction[Direction["PREVIOUS"] = 1] = "PREVIOUS";
})(Direction || (Direction = {}));

let NewFocusSuggestionReason;

(function (NewFocusSuggestionReason) {
  NewFocusSuggestionReason[NewFocusSuggestionReason["DefaultDelegation"] = 0] = "DefaultDelegation";
  NewFocusSuggestionReason[NewFocusSuggestionReason["FirstFoundDelegation"] = 1] = "FirstFoundDelegation";
  NewFocusSuggestionReason[NewFocusSuggestionReason["AliasDelegation"] = 2] = "AliasDelegation";
  NewFocusSuggestionReason[NewFocusSuggestionReason["MemoryDelegation"] = 3] = "MemoryDelegation";
  NewFocusSuggestionReason[NewFocusSuggestionReason["FocusableAliasMutation"] = 4] = "FocusableAliasMutation";
})(NewFocusSuggestionReason || (NewFocusSuggestionReason = {}));

const isAvailableFocusable = element => !element.disabled && !element.hidden && element.ref != null;
const isRoot = focusable => focusable != null && focusable.type === types_FocusableType.ROOT;
const isDelegatingLandmark = focusable => focusable != null && focusable.type === types_FocusableType.LANDMARK && 'getDelegatedFocus' in focusable;
const isBindingLandmark = element => isDelegatingLandmark(element) && 'shouldBindFocus' in element && element.shouldBindFocus === true;
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/focusTree.tsx



function getFreshTree() {
  return {
    focusableCount: 0,
    parentShortcutCount: 0,
    metadata: new Map(),
    focusableChildren: new Map(),
    containerChildren: new Map(),
    shortcutChildren: new Map(),
    parents: new Map(),
    aliases: new Map(),
    globalShortcuts: []
  };
}

function updateCount(focusTree, node, increment) {
  if (node.type === 'focusable') {
    focusTree.focusableCount += increment;
  }

  if (node.type === 'shortcut' && node.scope === 'parent') {
    focusTree.parentShortcutCount += increment;
  }
}

function hasInteractiveNode(focusTree) {
  return focusTree.focusableCount > 0 || focusTree.parentShortcutCount > 0 || focusTree.globalShortcuts.length > 0;
}
/**
 *
 * @returns true if was added
 */

function addOrUpdateNode(focusTree, node) {
  const previousNode = getNode(focusTree, node.id);

  if (previousNode) {
    if (node.type === 'focusable') {
      const originalAlias = getAlias(focusTree, node.id);
      const newAlias = node.alias;

      if (originalAlias !== newAlias) {
        // remove old alias
        if (originalAlias != null) {
          focusTree.aliases.delete(originalAlias);
        } // new alias


        if (newAlias != null) {
          focusTree.aliases.set(newAlias, node.id);
        }
      }
    }

    focusTree.metadata.set(node.id, node);
    return false;
  } else {
    if (false) {}

    focusTree.metadata.set(node.id, node);
    updateCount(focusTree, node, 1);

    if (node.type === 'focusable' && node.alias != null) {
      focusTree.aliases.set(node.alias, node.id);
    }

    if (node.type === 'shortcut' && node.scope === 'global') {
      focusTree.globalShortcuts = union_default()([node.id], focusTree.globalShortcuts);
      return true;
    }

    node.path.forEach((id, index) => {
      const childrenGroup = index < node.path.length - 1 ? 'containerChildren' : node.type === 'focusable' ? 'focusableChildren' : node.type === 'shortcut' ? 'shortcutChildren' : 'containerChildren';
      const children = focusTree[childrenGroup].get(id) || [];
      const nextChild = index === node.path.length - 1 ? node.id : node.path[index + 1];
      focusTree[childrenGroup].set(id, union_default()(children, [nextChild]));
      focusTree.parents.set(nextChild, id);
    });
    return true;
  }
}

const logErrorOnDuplicatedAlias = (focusTree, alias) => {
  for (const entry of focusTree.metadata) {
    if (entry[1].type === 'focusable' && entry[1].alias === alias) {
      console.warn(`The gamepad focus alias ${alias} is duplicated. Duplicated aliases might causes issues with focus and gamepad navigation.`);
    }
  }
};

function removeNode(focusTree, nodeId) {
  const node = getNode(focusTree, nodeId);
  if (!node) return;
  updateCount(focusTree, node, -1);
  const parent = getParentId(focusTree, nodeId);

  if (node.type === 'focusable' && node.alias != null) {
    focusTree.aliases.delete(node.alias);
  }

  if (node.type === 'shortcut' && node.scope === 'global') {
    focusTree.globalShortcuts = without_default()([nodeId], focusTree.globalShortcuts);
  } else if (parent != null) {
    if (node.type === 'shortcut' && node.scope === 'parent') {
      const parentChildren = focusTree.shortcutChildren.get(parent);

      if (parentChildren) {
        focusTree.shortcutChildren.set(parent, without_default()([nodeId], parentChildren));
      }
    } else if (node.type === 'focusable') {
      const parentChildren = focusTree.focusableChildren.get(parent);

      if (parentChildren) {
        focusTree.focusableChildren.set(parent, without_default()([nodeId], parentChildren));
      }
    } else {
      const parentChildren = focusTree.containerChildren.get(parent);

      if (parentChildren) {
        focusTree.containerChildren.set(parent, without_default()([nodeId], parentChildren));
      }
    }
  }

  focusTree.parents.delete(nodeId);
  focusTree.metadata.delete(nodeId);
}
function getAlias(focusTree, nodeId) {
  const focusable = getFocusable(focusTree, nodeId);
  if (focusable) return focusable.alias;
}
/**
 * Given a focusedId, it uses the alias information to find the NodeId of what should be considered focused
 */

function findNodeIdFromFocusedId(focusTree, focusedId) {
  if (focusedId == null) {
    return undefined;
  } // convert from an alias (if provided)


  const nodeId = typeof focusedId === 'string' ? focusTree.aliases.get(focusedId) : focusedId; // check if the node exists, and if it is enabled

  if (nodeId != null && isNodeEnabled(focusTree, nodeId)) return nodeId;
  return undefined;
}
/**
 * Finds a fallback NodeId that can hold focus
 *
 * To be used when a provided focusedId doesn't resolve in a valid NodeID
 * which could cause the UI to be stuck.
 *
 * Having a fallback NodeId allows the user to navigate if something goes wrong
 */

function findFallbackNodeId(focusTree) {
  const anythingElse = find(focusTree.metadata, (node, id) => {
    return node.type === 'focusable' && isNodeEnabled(focusTree, id);
  });

  if (anythingElse) {
    return anythingElse.id;
  }
}

function find(map, predicate) {
  for (const [key, value] of map) {
    if (predicate(value, key)) return value;
  }
}

function findClickableFocusableAtPoint(focusTree, x, y) {
  return findNode(focusTree, metadata => {
    if (metadata.type !== 'focusable' || metadata.disabled || !metadata.onClick || !metadata.ref || !metadata.ref.current) return false;
    const rect = metadata.ref.current.getBoundingClientRect();
    return x >= rect.left && x <= rect.left + rect.width && y >= rect.top && y <= rect.top + rect.height;
  });
}
function isNodeEnabled(focusTree, nodeId) {
  const node = getNode(focusTree, nodeId);
  if (node == null) return false;
  if (node.disabled) return false;
  const ancestors = getAncestorIds(focusTree, nodeId);

  for (let i = 0; i < ancestors.length; i++) {
    const node = getNode(focusTree, ancestors[i]);

    if (node == null || !!node.disabled) {
      return false;
    }
  }

  return true;
}
function getNode(focusTree, nodeId) {
  return focusTree.metadata.get(nodeId);
}
function getFocusable(focusTree, nodeId) {
  const node = getNode(focusTree, nodeId);

  if (node && node.type === 'focusable') {
    return node;
  }
}
const containerTypes = ['column', 'row'];
function isContainer(node) {
  return containerTypes.includes(node.type);
}
function getShortcut(focusTree, nodeId) {
  const node = getNode(focusTree, nodeId);

  if (node && node.type === 'shortcut') {
    return node;
  }
}
function getParentId(focusTree, nodeId) {
  return focusTree.parents.get(nodeId);
}
function getAncestorIds(focusTree, nodeId) {
  const parent = getParentId(focusTree, nodeId);

  if (parent == null) {
    return [];
  }

  return [parent, ...getAncestorIds(focusTree, parent)];
}
function getAncestorNodes(focusTree, nodeId) {
  return getAncestorIds(focusTree, nodeId).map(id => getNode(focusTree, id)).filter(node => node != null);
}
function getChildrenIds(focusTree, nodeId) {
  return [...(focusTree.containerChildren.get(nodeId) || []), ...(focusTree.focusableChildren.get(nodeId) || [])];
}
function getLeafIds(focusTree, nodeId) {
  const children = getChildrenIds(focusTree, nodeId);
  if (children.length === 0) return [nodeId];
  return children.map(childId => getLeafIds(focusTree, childId)).reduce((leaves, all) => [...leaves, ...all], []);
}
function findNode(focusTree, predicate) {
  return find(focusTree.metadata, predicate);
}
/**
 * Find shortcuts as well as the current focused node
 * to be displayed as hints in the InputLegend.
 *
 * Note that the nodes without an inputLegend are not included in the output.
 */

function findInputLegends(focusTree, nodeId) {
  const focusable = nodeId != null ? getFocusable(focusTree, nodeId) : undefined;
  const result = {};

  for (const buttonType of INPUT_LEGEND_BUTTONS) {
    var _findInputLegendNode$, _findInputLegendNode;

    result[buttonType] = (_findInputLegendNode$ = (_findInputLegendNode = findInputLegendNode(focusTree, nodeId, buttonType)) === null || _findInputLegendNode === void 0 ? void 0 : _findInputLegendNode.inputLegend) !== null && _findInputLegendNode$ !== void 0 ? _findInputLegendNode$ : buttonType === types_ButtonType.A ? focusable === null || focusable === void 0 ? void 0 : focusable.inputLegend : undefined;
  }

  return result;
}
function findInputLegendNode(focusTree, nodeId, button) {
  const predicate = node => node.shortcut === button && node.inputLegend != null && !node.disabled;

  const shortcutId = findShortcutId(focusTree, nodeId, predicate);
  if (shortcutId == null) return;
  const shortcut = getNode(focusTree, shortcutId);
  if (shortcut == null || !('shortcut' in shortcut) || shortcut.inputLegend == null) return;
  return shortcut;
}
function findShortcut(focusTree, nodeId, button) {
  const predicate = node => node.shortcut === button && !node.disabled;

  const shortcutId = findShortcutId(focusTree, nodeId, predicate);
  if (shortcutId == null) return;
  const shortcut = getNode(focusTree, shortcutId);
  if (shortcut == null || !('shortcut' in shortcut)) return;
  return shortcut;
}
function findShortcutId(focusTree, nodeId, predicate) {
  const parentShortcutId = nodeId != null ? findParentShortcutId(focusTree, nodeId, predicate) : undefined;
  return parentShortcutId !== null && parentShortcutId !== void 0 ? parentShortcutId : findGlobalShortcutId(focusTree, predicate);
}

function findParentShortcutId(focusTree, nodeId, predicate) {
  const parentId = getParentId(focusTree, nodeId);
  if (parentId == null) return undefined;
  const shortcutChildren = focusTree.shortcutChildren.get(parentId);
  if (shortcutChildren == null) return findParentShortcutId(focusTree, parentId, predicate);
  const shortcutId = shortcutChildren.find(id => {
    const shortcut = getShortcut(focusTree, id);
    return shortcut ? predicate(shortcut) : undefined;
  });
  return shortcutId != null ? shortcutId : findParentShortcutId(focusTree, parentId, predicate);
}

function findGlobalShortcutId(focusTree, predicate) {
  return focusTree.globalShortcuts.find(id => {
    const shortcut = getNode(focusTree, id);
    return shortcut != null ? predicate(shortcut) : undefined;
  });
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/apiContext.tsx


const logWarning = () => {
  if (false) {}
};

const GamepadAPIContext = (0,react.createContext)({
  runAddNodeEffect: () => {},
  isFocusableFocused: () => {
    logWarning();
    return false;
  },
  addOrUpdateNode: logWarning,
  removeNode: logWarning,
  requestAutofocus: logWarning,
  requestFocus: logWarning,
  addAnalogListener: () => {
    logWarning();
    return () => {};
  },
  addDigitalListener: () => {
    logWarning();
    return () => {};
  },
  clickFocusableAtPoint: logWarning,
  focusFocusableAtPoint: logWarning,
  getCurrentFocusable: () => undefined
});
const {
  Provider,
  Consumer
} = GamepadAPIContext;
const GamepadAPIProvider = Provider;
const GamepadAPIConsumer = (/* unused pure expression or super */ null && (Consumer));
;// CONCATENATED MODULE: ./packages/react-gamepad-driver-visual/src/types.ts
// TODO Create a interface for the button_map with backend

const types_AXIS_MAP = [[types_ButtonType.LEFT_ANALOG_LEFT, types_ButtonType.LEFT_ANALOG_RIGHT], [types_ButtonType.LEFT_ANALOG_UP, types_ButtonType.LEFT_ANALOG_DOWN], [types_ButtonType.RIGHT_ANALOG_LEFT, types_ButtonType.RIGHT_ANALOG_RIGHT], [types_ButtonType.RIGHT_ANALOG_UP, types_ButtonType.RIGHT_ANALOG_DOWN]];
/**
 * Type for buttons which can be mapped to a keyboard key
 */

const types_KEYBOARD_MAPPABLE_BUTTON = [types_ButtonType.A, types_ButtonType.B, types_ButtonType.X, types_ButtonType.Y, types_ButtonType.START, types_ButtonType.SELECT, types_ButtonType.XBOX, types_ButtonType.RIGHT_TRIGGER, types_ButtonType.LEFT_TRIGGER, types_ButtonType.LEFT_BUMPER, types_ButtonType.RIGHT_BUMPER, types_ButtonType.L3, types_ButtonType.R3, types_ButtonType.LEFT, types_ButtonType.RIGHT, types_ButtonType.UP, types_ButtonType.DOWN, types_ButtonType.PSEUDO_BUTTON_1, types_ButtonType.PSEUDO_BUTTON_2, types_ButtonType.PSEUDO_BUTTON_3, types_ButtonType.PSEUDO_BUTTON_4, types_ButtonType.PSEUDO_BUTTON_5, types_ButtonType.PSEUDO_BUTTON_6, types_ButtonType.PSEUDO_BUTTON_7, types_ButtonType.PSEUDO_BUTTON_8, types_ButtonType.PSEUDO_BUTTON_9, types_ButtonType.PSEUDO_BUTTON_10];
/**
 * Type for buttons which can be displayed on input legends
 */

const types_INPUT_LEGEND_BUTTONS = [types_ButtonType.A, types_ButtonType.B, types_ButtonType.X, types_ButtonType.Y, types_ButtonType.START, types_ButtonType.SELECT, types_ButtonType.LEFT, types_ButtonType.RIGHT, types_ButtonType.UP, types_ButtonType.DOWN, types_ButtonType.L3, types_ButtonType.R3, types_ButtonType.LEFT_ANALOG_LEFT, types_ButtonType.RIGHT_ANALOG_LEFT, types_ButtonType.LEFT_BUMPER, types_ButtonType.RIGHT_BUMPER, types_ButtonType.LEFT_TRIGGER, types_ButtonType.RIGHT_TRIGGER];
const types_ACTION_BUTTONS = [types_ButtonType.A, types_ButtonType.B, types_ButtonType.X, types_ButtonType.Y, types_ButtonType.START, types_ButtonType.SELECT, types_ButtonType.LEFT_BUMPER, types_ButtonType.RIGHT_BUMPER, types_ButtonType.LEFT_TRIGGER, types_ButtonType.RIGHT_TRIGGER, types_ButtonType.R3, types_ButtonType.L3];
const types_BUTTON_MAP = [types_ButtonType.A, types_ButtonType.B, types_ButtonType.X, types_ButtonType.Y, types_ButtonType.LEFT_BUMPER, types_ButtonType.RIGHT_BUMPER, types_ButtonType.LEFT_TRIGGER, types_ButtonType.RIGHT_TRIGGER, types_ButtonType.SELECT, types_ButtonType.START, types_ButtonType.L3, types_ButtonType.R3, types_ButtonType.UP, types_ButtonType.DOWN, types_ButtonType.LEFT, types_ButtonType.RIGHT, types_ButtonType.XBOX];
const types_DIRECTIONAL_BUTTONS = [types_ButtonType.LEFT, types_ButtonType.RIGHT, types_ButtonType.UP, types_ButtonType.DOWN];
const types_ACTION_BUTTONS_INDEX = types_ACTION_BUTTONS.map(string => types_BUTTON_MAP.indexOf(string));
const types_DIRECTIONAL_BUTTONS_INDEX = types_DIRECTIONAL_BUTTONS.map(string => types_BUTTON_MAP.indexOf(string));
let types_KeyboardKey;

(function (KeyboardKey) {
  KeyboardKey[KeyboardKey["BACKSPACE"] = 8] = "BACKSPACE";
  KeyboardKey[KeyboardKey["TAB"] = 9] = "TAB";
  KeyboardKey[KeyboardKey["ENTER"] = 13] = "ENTER";
  KeyboardKey[KeyboardKey["SHIFT"] = 16] = "SHIFT";
  KeyboardKey[KeyboardKey["CTRL"] = 17] = "CTRL";
  KeyboardKey[KeyboardKey["ALT"] = 18] = "ALT";
  KeyboardKey[KeyboardKey["CAPS_LOCK"] = 20] = "CAPS_LOCK";
  KeyboardKey[KeyboardKey["ESCAPE"] = 27] = "ESCAPE";
  KeyboardKey[KeyboardKey["SPACE"] = 32] = "SPACE";
  KeyboardKey[KeyboardKey["PG_UP"] = 33] = "PG_UP";
  KeyboardKey[KeyboardKey["PG_DOWN"] = 34] = "PG_DOWN";
  KeyboardKey[KeyboardKey["END"] = 35] = "END";
  KeyboardKey[KeyboardKey["LEFT"] = 37] = "LEFT";
  KeyboardKey[KeyboardKey["UP"] = 38] = "UP";
  KeyboardKey[KeyboardKey["RIGHT"] = 39] = "RIGHT";
  KeyboardKey[KeyboardKey["DOWN"] = 40] = "DOWN";
  KeyboardKey[KeyboardKey["INSERT"] = 45] = "INSERT";
  KeyboardKey[KeyboardKey["DELETE"] = 46] = "DELETE";
  KeyboardKey[KeyboardKey["KEY_0"] = 48] = "KEY_0";
  KeyboardKey[KeyboardKey["KEY_1"] = 49] = "KEY_1";
  KeyboardKey[KeyboardKey["KEY_2"] = 50] = "KEY_2";
  KeyboardKey[KeyboardKey["KEY_3"] = 51] = "KEY_3";
  KeyboardKey[KeyboardKey["KEY_4"] = 52] = "KEY_4";
  KeyboardKey[KeyboardKey["KEY_5"] = 53] = "KEY_5";
  KeyboardKey[KeyboardKey["KEY_6"] = 54] = "KEY_6";
  KeyboardKey[KeyboardKey["KEY_7"] = 55] = "KEY_7";
  KeyboardKey[KeyboardKey["KEY_8"] = 56] = "KEY_8";
  KeyboardKey[KeyboardKey["KEY_9"] = 57] = "KEY_9";
  KeyboardKey[KeyboardKey["SEMICOLON"] = 59] = "SEMICOLON";
  KeyboardKey[KeyboardKey["EQUALS"] = 61] = "EQUALS";
  KeyboardKey[KeyboardKey["KEY_A"] = 65] = "KEY_A";
  KeyboardKey[KeyboardKey["KEY_B"] = 66] = "KEY_B";
  KeyboardKey[KeyboardKey["KEY_C"] = 67] = "KEY_C";
  KeyboardKey[KeyboardKey["KEY_D"] = 68] = "KEY_D";
  KeyboardKey[KeyboardKey["KEY_E"] = 69] = "KEY_E";
  KeyboardKey[KeyboardKey["KEY_F"] = 70] = "KEY_F";
  KeyboardKey[KeyboardKey["KEY_G"] = 71] = "KEY_G";
  KeyboardKey[KeyboardKey["KEY_H"] = 72] = "KEY_H";
  KeyboardKey[KeyboardKey["KEY_I"] = 73] = "KEY_I";
  KeyboardKey[KeyboardKey["KEY_J"] = 74] = "KEY_J";
  KeyboardKey[KeyboardKey["KEY_K"] = 75] = "KEY_K";
  KeyboardKey[KeyboardKey["KEY_L"] = 76] = "KEY_L";
  KeyboardKey[KeyboardKey["KEY_M"] = 77] = "KEY_M";
  KeyboardKey[KeyboardKey["KEY_N"] = 78] = "KEY_N";
  KeyboardKey[KeyboardKey["KEY_O"] = 79] = "KEY_O";
  KeyboardKey[KeyboardKey["KEY_P"] = 80] = "KEY_P";
  KeyboardKey[KeyboardKey["KEY_Q"] = 81] = "KEY_Q";
  KeyboardKey[KeyboardKey["KEY_R"] = 82] = "KEY_R";
  KeyboardKey[KeyboardKey["KEY_S"] = 83] = "KEY_S";
  KeyboardKey[KeyboardKey["KEY_T"] = 84] = "KEY_T";
  KeyboardKey[KeyboardKey["KEY_U"] = 85] = "KEY_U";
  KeyboardKey[KeyboardKey["KEY_V"] = 86] = "KEY_V";
  KeyboardKey[KeyboardKey["KEY_W"] = 87] = "KEY_W";
  KeyboardKey[KeyboardKey["KEY_X"] = 88] = "KEY_X";
  KeyboardKey[KeyboardKey["KEY_Y"] = 89] = "KEY_Y";
  KeyboardKey[KeyboardKey["KEY_Z"] = 90] = "KEY_Z";
  KeyboardKey[KeyboardKey["NUMPAD_0"] = 96] = "NUMPAD_0";
  KeyboardKey[KeyboardKey["NUMPAD_1"] = 97] = "NUMPAD_1";
  KeyboardKey[KeyboardKey["NUMPAD_2"] = 98] = "NUMPAD_2";
  KeyboardKey[KeyboardKey["NUMPAD_3"] = 99] = "NUMPAD_3";
  KeyboardKey[KeyboardKey["NUMPAD_4"] = 100] = "NUMPAD_4";
  KeyboardKey[KeyboardKey["NUMPAD_5"] = 101] = "NUMPAD_5";
  KeyboardKey[KeyboardKey["NUMPAD_6"] = 102] = "NUMPAD_6";
  KeyboardKey[KeyboardKey["NUMPAD_7"] = 103] = "NUMPAD_7";
  KeyboardKey[KeyboardKey["NUMPAD_8"] = 104] = "NUMPAD_8";
  KeyboardKey[KeyboardKey["NUMPAD_9"] = 105] = "NUMPAD_9";
  KeyboardKey[KeyboardKey["MINUS"] = 109] = "MINUS";
  KeyboardKey[KeyboardKey["F1"] = 112] = "F1";
  KeyboardKey[KeyboardKey["F2"] = 113] = "F2";
  KeyboardKey[KeyboardKey["F3"] = 114] = "F3";
  KeyboardKey[KeyboardKey["F4"] = 115] = "F4";
  KeyboardKey[KeyboardKey["F5"] = 116] = "F5";
  KeyboardKey[KeyboardKey["F6"] = 117] = "F6";
  KeyboardKey[KeyboardKey["F7"] = 118] = "F7";
  KeyboardKey[KeyboardKey["F8"] = 119] = "F8";
  KeyboardKey[KeyboardKey["F9"] = 120] = "F9";
  KeyboardKey[KeyboardKey["F10"] = 121] = "F10";
  KeyboardKey[KeyboardKey["F11"] = 122] = "F11";
  KeyboardKey[KeyboardKey["F12"] = 123] = "F12";
  KeyboardKey[KeyboardKey["COMMA"] = 188] = "COMMA";
  KeyboardKey[KeyboardKey["PERIOD"] = 190] = "PERIOD";
  KeyboardKey[KeyboardKey["SLASH"] = 191] = "SLASH";
  KeyboardKey[KeyboardKey["GRAVE"] = 192] = "GRAVE";
  KeyboardKey[KeyboardKey["MOUSE_MOVEMENT"] = 195] = "MOUSE_MOVEMENT";
  KeyboardKey[KeyboardKey["MOUSE_BUTTON_LEFT"] = 196] = "MOUSE_BUTTON_LEFT";
  KeyboardKey[KeyboardKey["MOUSE_BUTTON_MIDDLE"] = 197] = "MOUSE_BUTTON_MIDDLE";
  KeyboardKey[KeyboardKey["MOUSE_BUTTON_RIGHT"] = 198] = "MOUSE_BUTTON_RIGHT";
  KeyboardKey[KeyboardKey["MOUSE_WHEEL"] = 199] = "MOUSE_WHEEL";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_1"] = 201] = "PSEUDO_KEY_1";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_2"] = 202] = "PSEUDO_KEY_2";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_3"] = 203] = "PSEUDO_KEY_3";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_4"] = 204] = "PSEUDO_KEY_4";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_5"] = 205] = "PSEUDO_KEY_5";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_6"] = 206] = "PSEUDO_KEY_6";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_7"] = 207] = "PSEUDO_KEY_7";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_8"] = 208] = "PSEUDO_KEY_8";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_9"] = 209] = "PSEUDO_KEY_9";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_10"] = 210] = "PSEUDO_KEY_10";
  KeyboardKey[KeyboardKey["BRACKET_OPEN"] = 219] = "BRACKET_OPEN";
  KeyboardKey[KeyboardKey["BACKSLASH"] = 220] = "BACKSLASH";
  KeyboardKey[KeyboardKey["BRACKET_CLOSE"] = 221] = "BRACKET_CLOSE";
  KeyboardKey[KeyboardKey["APOSTROPHE"] = 222] = "APOSTROPHE";
})(types_KeyboardKey || (types_KeyboardKey = {}));

let types_MouseButton;

(function (MouseButton) {
  MouseButton[MouseButton["Left"] = 0] = "Left";
  MouseButton[MouseButton["Middle"] = 1] = "Middle";
  MouseButton[MouseButton["Right"] = 2] = "Right";
  MouseButton[MouseButton["Back"] = 3] = "Back";
  MouseButton[MouseButton["Forward"] = 4] = "Forward";
})(types_MouseButton || (types_MouseButton = {}));
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/keyboardGamepadMap.ts




/*
 * Default mapping of keyboard keys to gamepad buttons
 */

const DEFAULT_KEYBOARD_GAMEPAD_MAP = {
  [types_ButtonType.UP]: [types_KeyboardKey.UP],
  [types_ButtonType.DOWN]: [types_KeyboardKey.DOWN],
  [types_ButtonType.LEFT]: [types_KeyboardKey.LEFT],
  [types_ButtonType.RIGHT]: [types_KeyboardKey.RIGHT],
  [types_ButtonType.X]: [types_KeyboardKey.KEY_X],
  [types_ButtonType.Y]: [types_KeyboardKey.KEY_Y],
  [types_ButtonType.A]: [types_KeyboardKey.ENTER, types_KeyboardKey.SPACE],
  [types_ButtonType.B]: [types_KeyboardKey.ESCAPE, types_KeyboardKey.BACKSPACE],
  [types_ButtonType.LEFT_TRIGGER]: [types_KeyboardKey.KEY_Q],
  [types_ButtonType.RIGHT_TRIGGER]: [types_KeyboardKey.KEY_Z],
  [types_ButtonType.LEFT_BUMPER]: [types_KeyboardKey.BRACKET_OPEN],
  [types_ButtonType.RIGHT_BUMPER]: [types_KeyboardKey.BRACKET_CLOSE],
  // TODO: Consolidate how to display joystick input legend without adding
  //       the joystick left movement to the KeyboardMappableButton list. and once that's done remove LEFT_ANALOG_LEFT and RIGHT_ANALOG_RIGHT.
  [types_ButtonType.LEFT_ANALOG_LEFT]: [types_KeyboardKey.KEY_9],
  [types_ButtonType.RIGHT_ANALOG_LEFT]: [types_KeyboardKey.KEY_0],
  [types_ButtonType.START]: [types_KeyboardKey.F10],
  [types_ButtonType.SELECT]: [types_KeyboardKey.F11],
  [types_ButtonType.XBOX]: [types_KeyboardKey.F1],
  [types_ButtonType.L3]: [types_KeyboardKey.F2],
  [types_ButtonType.R3]: [types_KeyboardKey.F3],
  [types_ButtonType.PSEUDO_BUTTON_1]: [types_KeyboardKey.PSEUDO_KEY_1],
  [types_ButtonType.PSEUDO_BUTTON_2]: [types_KeyboardKey.PSEUDO_KEY_2],
  [types_ButtonType.PSEUDO_BUTTON_3]: [types_KeyboardKey.PSEUDO_KEY_3],
  [types_ButtonType.PSEUDO_BUTTON_4]: [types_KeyboardKey.PSEUDO_KEY_4],
  [types_ButtonType.PSEUDO_BUTTON_5]: [types_KeyboardKey.PSEUDO_KEY_5],
  [types_ButtonType.PSEUDO_BUTTON_6]: [types_KeyboardKey.PSEUDO_KEY_6],
  [types_ButtonType.PSEUDO_BUTTON_7]: [types_KeyboardKey.PSEUDO_KEY_7],
  [types_ButtonType.PSEUDO_BUTTON_8]: [types_KeyboardKey.PSEUDO_KEY_8],
  [types_ButtonType.PSEUDO_BUTTON_9]: [types_KeyboardKey.PSEUDO_KEY_9],
  [types_ButtonType.PSEUDO_BUTTON_10]: [types_KeyboardKey.PSEUDO_KEY_10]
};
const defaultFacet = (0,react_facet_src.createStaticFacet)(DEFAULT_KEYBOARD_GAMEPAD_MAP);
const keyboardGamepadMapContext = (0,react.createContext)([defaultFacet, () => {}]);
const useKeyboardGamepadMap = () => (0,react.useContext)(keyboardGamepadMapContext);
/**
 * Hook that sets up a new keyboardGamepadMap.
 * This hook will update the keyboardGamepadMap on mount, so any changes
 * to the keyboardGamepadMap after the component is mounted will be ignored.
 *
 * @param keyboardGamepadMap the new keyboardGamepadMap
 */

const useSetKeyboardGamepadMap = (keyboardGamepadMap, hidden) => {
  const [, setKeyboardGamepadMap] = useKeyboardGamepadMap();
  useFacetEffect(hidden => {
    if (hidden !== true) {
      // This is an example of how a particular Screen can override the
      // keyboardGamepadMap set in the Application. The hook will update
      // the keyboardGamepadMap when this component is mounted.
      setKeyboardGamepadMap(keyboardGamepadMap);
    } // We disable the exhaustive-deps linting rule because we do not want to set
    // the keyboardGamepadMap again if it changes. We only want to set it on mount
    // or when being shown
    // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [setKeyboardGamepadMap, keyboardGamepadMap], [hidden]);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/buttonMap.ts

const Context = (0,react.createContext)({
  swapABButtons: false,
  swapXYButtons: false
});
const useButtonMap = () => (0,react.useContext)(Context);
const ButtonMapProvider = Context.Provider;
const ButtonMapConsumer = Context.Consumer;
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/availableInputLegends.tsx


const availableInputLegendsContext = (0,react_facet_src.createFacetContext)({});
const useAvailableInputLegends = () => (0,react.useContext)(availableInputLegendsContext);
const AvailableInputLegendsProvider = ({
  value,
  children
}) => {
  return /*#__PURE__*/react.createElement(availableInputLegendsContext.Provider, {
    value: value
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/invokeCurrentCallback.tsx

const invokeCurrentCallbackContext = (0,react.createContext)(undefined);
const useInputLegendCallback = () => (0,react.useContext)(invokeCurrentCallbackContext);
const InvokeCurrentCallbackProvider = ({
  value,
  children
}) => {
  return /*#__PURE__*/react.createElement(invokeCurrentCallbackContext.Provider, {
    value: value
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/useSetFocusedId.tsx


const setFocusedIdContext = (0,react.createContext)(() => () => {});
/**
 * Hook that allows access to a function to imperatively set the focused id
 * On setting a focusedId, it returns a "restore" function that can be called to restore the focus to a previous state
 */

const useSetFocusedId_useSetFocusedId = () => (0,react.useContext)(setFocusedIdContext);

/**
 * Provider to be used internally in the GamepadProvider
 * (not a public API)
 */
const SetFocusedIdProvider = ({
  onFocusedIdChange,
  children,
  focusedId
}) => {
  const setFocusedId = (0,react_facet_src.useFacetCallback)(oldFocusedId => newFocusedId => {
    onFocusedIdChange(newFocusedId);
    return () => onFocusedIdChange(oldFocusedId);
  }, [onFocusedIdChange], [focusedId]);
  return /*#__PURE__*/react.createElement(setFocusedIdContext.Provider, {
    value: setFocusedId
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/hooks/useInputLegends.ts



/**
 * Hook that keeps the logic to re-calculate the "input legends" given the currently focused node
 *
 * Because the "input legends" can also change if the "focus tree" changes, this also keeps track lastKnownTreeUpdate
 */
function useInputLegends(providerState, focusedId, lastKnownTreeUpdate) {
  return (0,react_facet_src.useFacetMemo)(focusedId => {
    const focusedNodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedId);
    return findInputLegends(providerState.focusTree, focusedNodeId);
  }, [providerState], // listen for the lastKnownTreeUpdate so we can recalculate the input legends when a component gets mounted, for example
  [focusedId, lastKnownTreeUpdate], equalInputLegends);
}
/**
 * Purposefully made comparison function done for performance reasons
 */

const equalInputLegends = () => {
  /**
   * We need to set the initial value as uninitialized otherwise the equalityCheck will prevent the
   * initial value of the input legends facet (everything with undefined) to be propagated.
   */
  let A = '---uninitialized---';
  let B = '---uninitialized---';
  let START = '---uninitialized---';
  let X = '---uninitialized---';
  let Y = '---uninitialized---';
  return current => {
    if (current.A === A && current.B === B && current.START === START && current.X === X && current.Y === Y) return true;
    A = current.A;
    B = current.B;
    START = current.START;
    X = current.X;
    Y = current.Y;
    return false;
  };
};
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/hooks/useInvokeCurrentCallback.ts


function useInvokeCurrentCallback(providerState, focusedId) {
  return (0,react_facet_src.useFacetCallback)(focusedId => actionButton => {
    const focusedNodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedId);
    const node = findShortcut(providerState.focusTree, focusedNodeId, actionButton);
    node === null || node === void 0 ? void 0 : node.onClick();
  }, [providerState], [focusedId]);
}
// EXTERNAL MODULE: ./node_modules/ramda/src/findIndex.js
var findIndex = __webpack_require__(53523);
var findIndex_default = /*#__PURE__*/__webpack_require__.n(findIndex);
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/navigate.tsx



function canNavigate(type, direction) {
  if (type === 'column' && (direction === 'right' || direction === 'left')) {
    return false;
  }

  if (type === 'row' && (direction === 'up' || direction === 'down')) {
    return false;
  }

  return true;
}

function isStartDirection(direction) {
  return direction === 'left' || direction === 'up' || direction === 'prev';
}

function getDirectionOffset(direction) {
  return isStartDirection(direction) ? -1 : 1;
}

function searchForNextNodeInDirection(currentNodeId, indexableChildren, direction) {
  const focusedIndex = findIndex_default()(node => node.id === currentNodeId, indexableChildren);

  const siblingIndex = focusedIndex + getDirectionOffset(direction);
  return indexableChildren[siblingIndex];
}

const searchForNextNodeByFocusChildBehavior = (parentId, focusState, focusTree, siblings, gridIndex, direction) => {
  const container = getNode(focusTree, parentId);
  const defaultFocusedChildBehavior = container.defaultFocusedChildBehavior;
  const defaultFocusedChildAlias = container.defaultFocusedChildAlias; // When the defaultFocusedChildBehavior is set to remember we're potentially
  // taking a shortcut to a focusable further down in the tree. We need to make
  // sure that the part of the tree that the focusable resides in haven't been
  // disabled since the last time we visited it.

  if (defaultFocusedChildBehavior === 'remember') {
    const cachedNodeId = focusState.get(parentId);

    if (cachedNodeId != null) {
      let isInDisabledBranch = false;
      let nextAncestorId = getParentId(focusTree, cachedNodeId);

      while (nextAncestorId != null && !isInDisabledBranch) {
        const parentNode = getNode(focusTree, nextAncestorId);
        isInDisabledBranch = !!(parentNode !== null && parentNode !== void 0 && parentNode.disabled);
        nextAncestorId = getParentId(focusTree, nextAncestorId);
      }

      if (!isInDisabledBranch) {
        return getNode(focusTree, cachedNodeId);
      }
    }
  }

  if (defaultFocusedChildAlias != null) {
    return siblings.find(sibling => sibling.type === 'focusable' && sibling.alias != null && sibling.alias !== '' && sibling.alias === defaultFocusedChildAlias);
  }

  if (defaultFocusedChildBehavior === 'grid') {
    return siblings.find(sibling => sibling.index === gridIndex);
  }

  if (defaultFocusedChildBehavior === 'last') {
    return siblings[siblings.length - 1];
  }

  if (defaultFocusedChildBehavior === 'first') {
    return siblings[0];
  } // If we didn't match any of the previous behavior, it means it should be sequential.
  // NOTE: The behavior "remember" will also use this as a fallback.


  const siblingIndex = isStartDirection(direction) ? siblings.length - 1 : 0;
  return siblings[siblingIndex];
};

function depthFirstSearch({
  focusTree,
  parentId,
  shouldFindDefaultFocusedChild,
  direction,
  currentNodeId,
  focusState,
  gridIndex,
  stack = [],
  visisted = {}
}) {
  var _nextItem, _nextItem$id, _nextItem3;

  // Get all the indexable nodes from the parent container and sort them based
  // on their sequential index.
  const indexableChildren = getChildrenIds(focusTree, parentId).map(id => getNode(focusTree, id)).filter(node => (node === null || node === void 0 ? void 0 : node.type) != 'shortcut' && !(node !== null && node !== void 0 && node.disabled)).sort((a, b) => a.index - b.index); // If we're searching based on focus child behavior it means that we've found
  // a branch in the correct direction to explore.

  let nextItem;

  if (shouldFindDefaultFocusedChild) {
    nextItem = searchForNextNodeByFocusChildBehavior(parentId, focusState, focusTree, indexableChildren, gridIndex, direction);
  }

  if (nextItem == null) {
    nextItem = searchForNextNodeInDirection(currentNodeId, indexableChildren, direction);
  } // If the nextItem is a focusable we've found what we were looking for and
  // can end the recursion.


  if (((_nextItem = nextItem) === null || _nextItem === void 0 ? void 0 : _nextItem.type) === 'focusable') {
    return nextItem.id;
  } // If the nextItem is a container we'll add its siblings to the stack of
  // nodes that we'll potentially have to explore.


  if (nextItem != null && isContainer(nextItem)) {
    var _getChildrenIds$filte, _getChildrenIds;

    const nextItemSiblings = (_getChildrenIds$filte = (_getChildrenIds = getChildrenIds(focusTree, parentId)) === null || _getChildrenIds === void 0 ? void 0 : _getChildrenIds.filter(id => {
      var _nextItem2;

      return id != ((_nextItem2 = nextItem) === null || _nextItem2 === void 0 ? void 0 : _nextItem2.id);
    })) !== null && _getChildrenIds$filte !== void 0 ? _getChildrenIds$filte : [];
    stack.push(...nextItemSiblings);
  } // All the children (if there were any) are now in the stack. Therefore,
  // we'll mark this branch as having been visisted.


  visisted[parentId] = true; // If the nextItem is a container we'll drill down. If it's undefined we'll
  // pick the next branch to explore from the stack of nodes.

  const nextBranchToSearch = (_nextItem$id = (_nextItem3 = nextItem) === null || _nextItem3 === void 0 ? void 0 : _nextItem3.id) !== null && _nextItem$id !== void 0 ? _nextItem$id : stack.filter(id => !visisted[id]).pop();
  return nextBranchToSearch != null ? depthFirstSearch({
    focusTree,
    parentId: nextBranchToSearch,
    shouldFindDefaultFocusedChild: true,
    direction,
    currentNodeId,
    focusState,
    gridIndex,
    stack,
    visisted
  }) : undefined;
}

function navigateToDirection(focusTree, nodeId, focusState, direction) {
  // This gets the path all the way down to the node we're currently focused on.
  const ancestryPath = [nodeId, ...getAncestorIds(focusTree, nodeId)]; // This gets the sequential index of the currently focused node within its container.

  const sequentialIndex = getNode(focusTree, nodeId).index;
  let nextNodeToFocus; // We'll walk up the ancestryPath to try and find the next focusable to move
  // to. We don't have to explore the root node because it won't have a parent
  // or siblings (hence the "< length - 1").

  for (let i = 0; i < ancestryPath.length - 1; i++) {
    const currentId = ancestryPath[i];
    const currentNode = getNode(focusTree, currentId); // Bounded means that the focus is trapped within a certain container. It
    // could, for example, be a modal and we don't want the user to be able to
    // move the focus outside of it.

    if (isContainer(currentNode) && !!currentNode.bounded) {
      break;
    }

    const parentId = ancestryPath[i + 1];
    const parentNode = getNode(focusTree, parentId); // Lets say our closest parent is a row inside of a column. If we press
    // down our nearest parent (the row) wont be able to find a focusable in
    // that direction - rows only supports left/right movement. Therefore,
    // we'll continue the loop. In the next iteration the parentNode will be
    // the column (our parents parent) and we'll get to explore that node to
    // see if our closest parent had any siblings below.

    if (!canNavigate(parentNode.type, direction)) {
      continue;
    } // If we reach this point it means that we've found an ancestor that
    // supports navigation in the direction we want (and the focus isn't
    // bound). We can then explore this ancestor to try and find the next node
    // to focus.


    nextNodeToFocus = depthFirstSearch({
      focusTree,
      parentId,
      // The first node in the *ancestryPath* is the focusable we're currently
      // standing on. Let's say it's node B in the example below.
      //            +-------+  +-------+  +-------+
      // ROW1 ----->|   A   |  |   B   |  |   C   |
      //            +-------+  +-------+  +-------+
      //            +-------+  +-------+
      // ROW2 ----->|   D   |  |   E   |
      //            +-------+  +-------+
      // We'll never want to find the defaultFocusChild for ROW1 (which is the
      // first ancestor of node B). We want the next node in the correct
      // direction. Now let's say that we pressed UP. Rows does not support
      // navigation in that direction so we'll have to climb up the tree until
      // we find an ancestor of type *column*. When we've found that ancestor
      // we don't want to find it's default focus child either. What if its set
      // to last? In that case we could end up at a focusable below us even
      // though we pressed UP. We'll always do direction based navigation
      // first. When we have chosen a node in the correct direction -- and that
      // node is a container -- we'll drill down further by performing
      // recursive calls in the *depthFirstSearch* function where we take the
      // default focus child behavior into consideration.
      shouldFindDefaultFocusedChild: false,
      direction,
      currentNodeId: currentId,
      focusState,
      gridIndex: sequentialIndex,
      // The property below looks a little strange. You usually don't have to
      // keep track of any visisted nodes while traversing trees. Instead, it's
      // a common way to avoid infinite loops while doing DFS or BFS in a
      // cyclical graph. In this case it's needed though because we're
      // traversing the tree bottoms up, and then drilling down using a DFS.
      visisted: {
        [currentId]: true
      },
      stack: []
    });

    if (nextNodeToFocus != null) {
      return nextNodeToFocus;
    }
  } // If we weren't able to find a node to focus we're probably trying to move
  // outside the bounds of a container. In that case we want to keep the focus
  // where it is.


  return nodeId;
} // This function is used by scroll views where we have a loading state and want
// to autofocus something once the loading is completed. We'll then drill down
// into that scroll view to find the first focusable.

function findFirstFocusableChildNode(id, focusTree, focusState) {
  const parentId = getParentId(focusTree, id);
  const gridIndex = getNode(focusTree, id).index;

  if (parentId == null) {
    return;
  }

  const currentNodeId = depthFirstSearch({
    focusTree,
    parentId,
    shouldFindDefaultFocusedChild: true,
    direction: 'next',
    currentNodeId: id,
    focusState,
    gridIndex
  });
  return currentNodeId;
}
;// CONCATENATED MODULE: ./node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

;// CONCATENATED MODULE: ./packages/scrolling-animation/src/index.ts

const ease = cubicOut;
function createScrollingManager({
  disabledTransition = false,
  speedFactor = 1,
  align = 'center',
  scrollOffset = 0,
  axis = 'y'
} = {}) {
  let currentElement;
  let currentScrollElement;
  let initialScrollPosition;
  let deltaPixels;
  let animationStart;
  const animationDuration = 500 / speedFactor;

  const animate = () => {
    if (!currentScrollElement) return;
    const currentTime = Date.now() - animationStart;
    const t = currentTime / animationDuration;
    const shouldStop = currentTime > animationDuration || disabledTransition;
    currentScrollElement[axis === 'x' ? 'scrollLeft' : 'scrollTop'] = Math.round(initialScrollPosition + ease(shouldStop ? 1 : t) * deltaPixels);
    if (shouldStop) return;
    window.requestAnimationFrame(animate);
  };

  return {
    scrollIntoView(scrollElement, element) {
      currentScrollElement = scrollElement;
      currentElement = element;
      const scrollElementRect = currentScrollElement.getBoundingClientRect();
      const scrollSize = scrollElementRect[axis === 'x' ? 'width' : 'height'];
      const rect = currentElement.getBoundingClientRect();
      const padding = align === 'center' ? scrollSize / 2 : 0;
      deltaPixels = (axis === 'x' ? rect.left : rect.top) - (axis === 'x' ? scrollElementRect.left : scrollElementRect.top) + (align === 'center' ? rect[axis === 'x' ? 'width' : 'height'] / 2 : 0) - padding + scrollOffset;
      initialScrollPosition = currentScrollElement[axis === 'x' ? 'scrollLeft' : 'scrollTop'];
      animationStart = Date.now();

      if (Math.abs(deltaPixels) < 5) {
        // animation would be too small, just ignore
        return;
      }

      window.requestAnimationFrame(animate);
    },

    scrollTo(scrollElement, scrollValue) {
      currentScrollElement = scrollElement;
      initialScrollPosition = currentScrollElement[axis === 'x' ? 'scrollLeft' : 'scrollTop'];
      deltaPixels = scrollValue - initialScrollPosition;
      animationStart = Date.now();
      window.requestAnimationFrame(animate);
    },

    stopScrolling() {
      currentScrollElement = null;
      currentElement = null;
    }

  };
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/setupScrollIntoView.tsx


/**
 * Setups the scrollIntoView function
 * It keeps a local state of previous running animations so that it cancel between scroll requests
 */
function setupScrollIntoView() {
  const runningAnimations = new Map();
  /**
   * Implementation that takes a list with a focusable and its ancestors and triggers animations
   * It supports:
   * - multiple levels of nesting (column inside a row, for example)
   * - animations to continue when switching between different sections of the focus tree
   *
   * Returns a cleanup function that can be used to stop all previously running animations
   */

  return (focusable, ancestors, disabledTransition) => {
    ancestors.forEach(containerNode => {
      var _ref, _focusable$scrollSpee, _container$scrollInto, _focusable$scrollOffs;

      const container = containerNode;

      if (!container.scrollIntoView || focusable.disableScrollIntoView) {
        return;
      }

      if (!focusable.ref || !focusable.ref.current) {
        if (false) {}

        return;
      }

      if (!container.ref || !container.ref.current) {
        if (false) {}

        return;
      }

      const existingStop = runningAnimations.get(container.id);

      if (existingStop) {
        existingStop();
        runningAnimations.delete(container.id);
      }

      const {
        scrollIntoView,
        stopScrolling
      } = createScrollingManager({
        disabledTransition,
        speedFactor: (_ref = (_focusable$scrollSpee = focusable.scrollSpeedFactor) !== null && _focusable$scrollSpee !== void 0 ? _focusable$scrollSpee : container.scrollIntoViewSpeedFactor) !== null && _ref !== void 0 ? _ref : 1,
        align: (focusable.scrollAlign ? focusable.scrollAlign : container.scrollIntoViewAlign) || 'center',
        scrollOffset: ((_container$scrollInto = container.scrollIntoViewOffset) !== null && _container$scrollInto !== void 0 ? _container$scrollInto : 0) + ((_focusable$scrollOffs = focusable.scrollOffset) !== null && _focusable$scrollOffs !== void 0 ? _focusable$scrollOffs : 0),
        axis: container.type === 'row' ? 'x' : 'y'
      });
      scrollIntoView(container.ref.current, focusable.ref.current);
      runningAnimations.set(container.id, stopScrolling);
    });
    /**
     * Cleanup function that stops all running animations
     */

    return () => {
      for (const stopScrolling of runningAnimations.values()) {
        stopScrolling();
      }

      runningAnimations.clear();
    };
  };
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/hooks/useInput.ts






const scrollIntoView = setupScrollIntoView();
/**
 * Hook that listens for user input (gamepad and keyboard) to trigger navigation and other events
 */

function useInput(providerState, focusedId, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons, disabledTransition, keyboardGamepadMap, driver) {
  const [isInputEnabled, setInputEnabled] = (0,react.useState)(false);
  const focusedIdRef = (0,react_facet_src.useFacetRef)(focusedId);
  const disabledNavigationRef = (0,react_facet_src.useFacetRef)(providerState.disabledNavigation);
  const ANALOG_SCROLL_MAX_SPEED = 20;
  const cancelScrollRef = (0,react.useRef)(undefined);
  (0,react_facet_src.useFacetEffect)((focusedId, disabledNavigation) => {
    if (disabledNavigation) return;
    if (focusedId == null) return;
    const focusedNodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedId);
    if (focusedNodeId == null) return;
    const focusable = getFocusable(providerState.focusTree, focusedNodeId);
    if (!focusable) return;
    const ancestors = getAncestorNodes(providerState.focusTree, focusedNodeId);
    cancelScrollRef.current = scrollIntoView(focusable, ancestors, disabledTransition);
  }, [providerState, disabledTransition], [focusedId, providerState.disabledNavigation]);
  (0,react.useLayoutEffect)(() => {
    const handleClick = () => {
      if (disabledNavigationRef.current === true) return;
      const focusedNodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedIdRef.current === react_facet_src.NO_VALUE ? undefined : focusedIdRef.current);
      if (focusedNodeId == null) return;
      const focusable = getFocusable(providerState.focusTree, focusedNodeId);

      if (focusable != null && focusable.onClick) {
        focusable.onClick();
      }
    };

    const handleShortcut = (button, focusedNodeId) => {
      // TODO unify this and the useInvokeCurrentCallback
      // if (providerState.disabledShortcuts) return fals
      const shortcut = findShortcut(providerState.focusTree, focusedNodeId, button);

      if ((shortcut === null || shortcut === void 0 ? void 0 : shortcut.onClick) != null) {
        shortcut.onClick();
        return true;
      }

      return false;
    };

    const handleDirection = (direction, focusedNodeId) => {
      var _getAlias2;

      if (providerState.isRtl) {
        if (direction === 'left') {
          direction = 'right';
        } else if (direction === 'right') {
          direction = 'left';
        }
      }

      if (disabledNavigationRef.current === true) return; // If the provided focusedId didn't resolve into any Node, we need to try to find
      // a fallback nodeId so that the UI doesn't get stuck

      if (focusedNodeId == null) {
        var _getAlias;

        const fallbackNodeId = findFallbackNodeId(providerState.focusTree);
        const fallbackAliasOrNodeId = fallbackNodeId != null ? (_getAlias = getAlias(providerState.focusTree, fallbackNodeId)) !== null && _getAlias !== void 0 ? _getAlias : fallbackNodeId : undefined;

        if (fallbackAliasOrNodeId != null) {
          providerState.onFocusedIdChange(fallbackAliasOrNodeId);
        }

        return;
      }

      const focusedNode = getFocusable(providerState.focusTree, focusedNodeId);

      if (focusedNode) {
        switch (direction) {
          case 'left':
            if (focusedNode.onLeft) {
              if (focusedNode.onLeft()) return;
            }

            break;

          case 'right':
            if (focusedNode.onRight) {
              if (focusedNode.onRight()) return;
            }

            break;

          case 'up':
            if (focusedNode.onUp) {
              if (focusedNode.onUp()) return;
            }

            break;

          case 'down':
            if (focusedNode.onDown) {
              if (focusedNode.onDown()) return;
            }

        }
      }

      const newFocusedId = navigateToDirection(providerState.focusTree, focusedNodeId, providerState.focusState, direction);
      const newAliasOrNodeId = (_getAlias2 = getAlias(providerState.focusTree, newFocusedId)) !== null && _getAlias2 !== void 0 ? _getAlias2 : newFocusedId;

      if (focusedIdRef.current !== newAliasOrNodeId) {
        providerState.onFocusedIdChange(newAliasOrNodeId);
      } else {
        var _providerState$onFocu;

        (_providerState$onFocu = providerState.onFocusedIdChangeFail) === null || _providerState$onFocu === void 0 ? void 0 : _providerState$onFocu.call(providerState);
      }
    };

    const handleAnalog = axes => {
      if (disabledNavigationRef.current === true) return;
      providerState.analogListeners.forEach(analogListener => analogListener(axes));
      if (focusedIdRef.current == react_facet_src.NO_VALUE || focusedIdRef.current == null) return;
      const verticalValue = axes[types_ButtonType.RIGHT_VERTICAL_AXIS];
      const horizontalValue = axes[types_ButtonType.RIGHT_HORIZONTAL_AXIS];
      if (verticalValue === 0 && horizontalValue === 0) return;
      const focusedNodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedIdRef.current);
      if (focusedNodeId == null) return;
      const nodes = getAncestorNodes(providerState.focusTree, focusedNodeId);
      const parents = nodes.filter(node => node.scrollWithAnalog);
      if (parents.length === 0) return;
      if (cancelScrollRef.current) cancelScrollRef.current();
      parents.forEach(parent => {
        const value = parent.type === 'row' ? horizontalValue : verticalValue;
        const scrollProperty = parent.type === 'row' ? 'scrollLeft' : 'scrollTop';
        if (!parent.ref || !parent.ref.current) return;
        parent.ref.current[scrollProperty] += value * ANALOG_SCROLL_MAX_SPEED;
      });
    };

    const handleDigital = button => {
      providerState.digitalListeners.forEach(digitalListener => digitalListener(button));
      const focusedNodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedIdRef.current === react_facet_src.NO_VALUE ? undefined : focusedIdRef.current);
      if (handleShortcut(button, focusedNodeId)) return;

      switch (button) {
        case types_ButtonType.A:
          return handleClick();

        case types_ButtonType.LEFT_ANALOG_UP:
        case types_ButtonType.UP:
          return handleDirection('up', focusedNodeId);

        case types_ButtonType.LEFT_ANALOG_DOWN:
        case types_ButtonType.DOWN:
          return handleDirection('down', focusedNodeId);

        case types_ButtonType.LEFT_ANALOG_LEFT:
        case types_ButtonType.LEFT:
          return handleDirection('left', focusedNodeId);

        case types_ButtonType.LEFT_ANALOG_RIGHT:
        case types_ButtonType.RIGHT:
          return handleDirection('right', focusedNodeId);

        case types_ButtonType.NEXT:
          return handleDirection('next', focusedNodeId);

        case types_ButtonType.PREV:
          return handleDirection('prev', focusedNodeId);
      }
    };

    return isInputEnabled ? driver(handleDigital, handleAnalog, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons, keyboardGamepadMap) : undefined;
  }, [isInputEnabled, providerState, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons, keyboardGamepadMap, focusedIdRef, disabledNavigationRef, driver]);
  return setInputEnabled;
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/hooks/useRerenderNodes.ts




/**
 * Allows us to notify specific nodes in the tree to change their focus state
 * without using a value in a React's context API (which would cause everything to re-render).
 */
function useRerenderNodes(providerState, newFocusedId) {
  const previousNodeIdRef = (0,react.useRef)();
  const previousFocusedIdRef = (0,react.useRef)();
  (0,react_facet_src.useFacetEffect)(newFocusedId => {
    /**
     * Delays checking re-rendering nodes until the end of the current frame so that React has time to apply reconciliation changes
     * before this Facet effect gets executed.
     */
    const timerId = setTimeout(() => {
      // Get previous values
      const previousFocusedId = previousFocusedIdRef.current;
      const previousNodeId = previousNodeIdRef.current;
      const focusTree = providerState.focusTree;
      const refreshedPreviousNodeId = findNodeIdFromFocusedId(focusTree, previousFocusedId);
      const refreshedPreviousNode = refreshedPreviousNodeId != null ? getFocusable(focusTree, refreshedPreviousNodeId) : null;

      if (previousNodeId !== refreshedPreviousNodeId) {
        const previousNode = previousNodeId != null ? getFocusable(focusTree, previousNodeId) : null;

        if (previousNode) {
          previousNode.onFocusedChange(false);
        }
      }

      const newNodeId = findNodeIdFromFocusedId(focusTree, newFocusedId);
      const newNode = newNodeId != null ? getFocusable(focusTree, newNodeId) : null;

      if (refreshedPreviousNode && refreshedPreviousNode !== newNode) {
        refreshedPreviousNode.onFocusedChange(false);
      }

      if (newNode) {
        newNode.onFocusedChange(true);
      } // Store current values as the next previous values


      previousFocusedIdRef.current = newFocusedId;
      previousNodeIdRef.current = newNodeId;
    }, 0);
    return () => {
      clearTimeout(timerId);
    };
  }, [providerState], [newFocusedId]);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/hooks/useApi.ts





/**
 * Hook that setups the API passed down to React components that construct the focus tree (focusable, row, column, shortcut)
 */
function useApi(providerState, setInputEnabled, focusedId, setLastKnownTreeUpdate) {
  const focusedIdRef = (0,react_facet_src.useFacetRef)(focusedId);
  /**
   * Debounce to batch a bunch of updates in a single timestamp.
   */

  const debounceSetLastKnownTreeUpdate = (0,react.useMemo)(() => debounce(setLastKnownTreeUpdate), [setLastKnownTreeUpdate]);
  return (0,react.useMemo)(() => {
    const updateInputEnabled = () => {
      setInputEnabled(hasInteractiveNode(providerState.focusTree));
    };

    return {
      // The force flag is used when we move focus with VR
      requestFocus(nodeId, force = false) {
        const alias = getAlias(providerState.focusTree, nodeId);

        if (force || alias !== focusedIdRef.current) {
          providerState.onFocusedIdChange(alias !== null && alias !== void 0 ? alias : nodeId);
        }
      },

      requestAutofocus(nodeId) {
        const isFocusedIdSet = typeof focusedIdRef.current === 'number' || typeof focusedIdRef.current === 'string';
        const focusedIdNodeId = isFocusedIdSet ? findNodeIdFromFocusedId(providerState.focusTree, focusedIdRef.current) : null; // Don't trigger autofocus if something is already focused

        if (focusedIdNodeId != null && isNodeEnabled(providerState.focusTree, focusedIdNodeId)) return; // Don't focus the given node if it isn't enabled

        if (!isNodeEnabled(providerState.focusTree, nodeId)) return;
        const alias = getAlias(providerState.focusTree, nodeId);

        if (alias != null && alias !== focusedIdRef.current || nodeId !== focusedIdRef.current) {
          providerState.onFocusedIdChange(alias !== null && alias !== void 0 ? alias : nodeId);
        }
      },

      runAddNodeEffect() {
        updateInputEnabled();
      },

      addOrUpdateNode(metadata) {
        addOrUpdateNode(providerState.focusTree, metadata);
        debounceSetLastKnownTreeUpdate(Date.now());
      },

      removeNode(nodeId) {
        removeNode(providerState.focusTree, nodeId);
        updateInputEnabled();
      },

      isFocusableFocused(nodeId, alias) {
        return nodeId === focusedIdRef.current || alias != null && alias === focusedIdRef.current;
      },

      addAnalogListener: analogListener => {
        providerState.analogListeners = [...providerState.analogListeners, analogListener];
        return () => {
          providerState.analogListeners = without_default()([analogListener], providerState.analogListeners);
        };
      },
      addDigitalListener: digitalListener => {
        providerState.digitalListeners = [...providerState.digitalListeners, digitalListener];
        return () => {
          providerState.digitalListeners = without_default()([digitalListener], providerState.digitalListeners);
        };
      },
      clickFocusableAtPoint: (x, y) => {
        const focusable = findClickableFocusableAtPoint(providerState.focusTree, x, y);

        if (focusable && focusable.onClick) {
          focusable.onClick();
        }
      },
      focusFocusableAtPoint: (x, y) => {
        const focusable = findClickableFocusableAtPoint(providerState.focusTree, x, y);
        const {
          onFocusedIdChange
        } = providerState;
        const focusedId = focusedIdRef.current; // If the focus has changed, a clickable focusable has been found, and there is nothing currently focused
        // _or_ the clickable focusable is different then the currently focused node
        // --> Give focus to the clickable focusable
        // If the focus has changed, a node was previously focused and there was no clickable focusable found
        // --> Give focus to undefined (meaning a sane default)

        if (focusable && (focusedId == null || !(focusable.id === focusedId || focusable.alias === focusedId))) {
          var _focusable$alias;

          onFocusedIdChange((_focusable$alias = focusable.alias) !== null && _focusable$alias !== void 0 ? _focusable$alias : focusable.id);
        } else if (!focusable && focusedId != null) {
          onFocusedIdChange(undefined);
        }
      },
      getCurrentFocusable: () => {
        if (focusedIdRef.current === react_facet_src.NO_VALUE) {
          return undefined;
        }

        const nodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedIdRef.current);

        if (nodeId == null) {
          return undefined;
        }

        return getFocusable(providerState.focusTree, nodeId);
      }
    };
  }, [focusedIdRef, providerState, setInputEnabled, debounceSetLastKnownTreeUpdate]);
}
/**
 * Simple debounce function that works just for numbers.
 */

const debounce = (fn, timeout = 100) => {
  let id;
  return value => {
    clearTimeout(id);
    id = setTimeout(() => fn(value), timeout);
  };
};
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/hooks/useUpdateFocusState.ts



/**
 * It takes the parent of the current focused node, and updates the information in the focusState that it is now focused.
 */
function useUpdateFocusState(providerState, focusedId) {
  (0,react_facet_src.useFacetEffect)(focusedId => {
    const focusTree = providerState.focusTree;
    const focusState = providerState.focusState;
    const focusedNodeId = findNodeIdFromFocusedId(focusTree, focusedId);
    if (focusedNodeId == null) return;
    let currentParentId = getParentId(focusTree, focusedNodeId);

    while (currentParentId != null) {
      focusState.set(currentParentId, focusedNodeId);
      currentParentId = getParentId(focusTree, currentParentId);
    }
  }, [providerState], [focusedId]);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/useFocusProvider.tsx

const useFocusProvider_context = (0,react.createContext)(undefined);
const FocusProvider = ({
  value,
  children
}) => {
  return /*#__PURE__*/react.createElement(useFocusProvider_context.Provider, {
    value: value
  }, children);
};
function useGamepadAPI() {
  return (0,react.useContext)(useFocusProvider_context);
}
;// CONCATENATED MODULE: ./packages/gamepad-polyfill/src/index.ts
const getGamepadsPolyfill = () => {
  if (navigator == null) {
    return [];
  }

  const navigatorGamepads = navigator.getGamepads();

  if (Array.isArray(navigatorGamepads)) {
    return navigatorGamepads;
  }

  return Array.from(navigatorGamepads);
};

const isFirefox = () => {
  var _navigator$userAgent$, _navigator, _navigator$userAgent;

  return  false && 0;
};

let gamepads = [];
const getGamepads = () => {
  if (false) {}

  return gamepads;
};
/* navigator.getGamepads() is a relatively expensive call and should be avoided to be called each frame.
 * The ideal solution is to always use the gamepadconnected and gamepaddisconnected events to update the gamepad list.
 * However, Chrome behaves differently than other environments (eg. Gameface and Firefox) and doesn't update the
 * reference to the gamepad that is passed to the gamepadconnected and gamepaddisconnected events on each frame.
 * That is the reason why we fallback to polling for all environments that except Gameface and Firefox
 *
 * Read this for more info regarding how Chrome behaves differently:
 * https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API#using_button_information
 */

const src_noop = () => undefined;

let cleanupHandler = src_noop;

const cleanup = () => {
  gamepads = [];
  cleanupHandler();
  cleanupHandler = src_noop;
};

const initialize = () => {
  if (isInitialized()) return cleanup;

  if (true) {
    if (true) {
      // Get initial state of gamepads. We don't want to make this call when running tests since the
      // navigator.getGamepads API is not available in that environment.
      gamepads = getGamepadsPolyfill();
    }

    const handleGamepadConnected = event => {
      if (event.gamepad.index >= gamepads.length) {
        const updatedGamepads = [...gamepads];
        const inBetweenIndexCount = gamepads.length - event.gamepad.index;

        for (let i = 0; i < inBetweenIndexCount; i++) {
          updatedGamepads.push(null);
        }

        updatedGamepads.push(event.gamepad);
        gamepads = updatedGamepads;
      } else if (event.gamepad.index >= 0) {
        const updatedGamepads = [...gamepads];
        updatedGamepads[event.gamepad.index] = event.gamepad;
        gamepads = updatedGamepads;
      }
    };

    const handleGamepadDisconnected = event => {
      if (gamepads.length - 1 >= event.gamepad.index) {
        const updatedGamepads = [...gamepads];
        updatedGamepads[event.gamepad.index] = null;
        gamepads = updatedGamepads;
      }
    };

    window.addEventListener('gamepadconnected', handleGamepadConnected);
    window.addEventListener('gamepaddisconnected', handleGamepadDisconnected);

    cleanupHandler = () => {
      window.removeEventListener('gamepadconnected', handleGamepadConnected);
      window.removeEventListener('gamepaddisconnected', handleGamepadDisconnected);
    };
  } else {}

  return cleanup;
};
const isInitialized = () => cleanupHandler !== src_noop;
;// CONCATENATED MODULE: ./packages/react-gamepad-driver/src/throttleByName.ts

const FIRST_THROTTLE_DELAY = 400;
const MEDIUM_THROTTLE_RATE = 100;
const FAST_THROTTLE_RATE = 40;
/**
 * How many presses we should have triggered before going to fast speed
 */

const FAST_REPETITION_COUNT_WAIT = 16;
function throttleByName(fn) {
  const timestamps = initMetrics();
  const pressCounts = initMetrics(); // @TODO: Rewrite without gamepadIndex

  return (buttonType, pressed, gamepadIndex) => {
    if (!pressed) {
      timestamps[gamepadIndex][buttonType] = 0;
      pressCounts[gamepadIndex][buttonType] = 0;
    } else {
      const now = Date.now();
      const timestamp = timestamps[gamepadIndex][buttonType] || 0;
      const pressCount = pressCounts[gamepadIndex][buttonType] || 0;
      const delta = now - timestamp;

      if (pressCount === 0) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = 1;
        return fn(buttonType);
      }

      if (pressCount === 1 && delta > FIRST_THROTTLE_DELAY) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = 2;
        return fn(buttonType);
      }

      if (pressCount > 1 && pressCount < FAST_REPETITION_COUNT_WAIT && delta > MEDIUM_THROTTLE_RATE) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = pressCount + 1;
        return fn(buttonType);
      }

      if (pressCount > FAST_REPETITION_COUNT_WAIT - 1 && delta > FAST_THROTTLE_RATE) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = pressCount + 1;
        return fn(buttonType);
      }
    }
  };
}

const initMetrics = () => {
  const metrics = {
    0: initButtons(),
    1: initButtons(),
    2: initButtons(),
    3: initButtons()
  };
  return metrics;
};

const initButtons = () => {
  return {
    [ButtonType.A]: 0,
    [ButtonType.B]: 0,
    [ButtonType.X]: 0,
    [ButtonType.Y]: 0,
    [ButtonType.START]: 0,
    [ButtonType.SELECT]: 0,
    [ButtonType.XBOX]: 0,
    [ButtonType.RIGHT_TRIGGER]: 0,
    [ButtonType.LEFT_TRIGGER]: 0,
    [ButtonType.LEFT_BUMPER]: 0,
    [ButtonType.RIGHT_BUMPER]: 0,
    [ButtonType.L3]: 0,
    [ButtonType.R3]: 0,
    [ButtonType.LEFT]: 0,
    [ButtonType.RIGHT]: 0,
    [ButtonType.UP]: 0,
    [ButtonType.DOWN]: 0,
    [ButtonType.NEXT]: 0,
    [ButtonType.PREV]: 0,
    [ButtonType.LEFT_ANALOG_LEFT]: 0,
    [ButtonType.LEFT_ANALOG_RIGHT]: 0,
    [ButtonType.LEFT_ANALOG_UP]: 0,
    [ButtonType.LEFT_ANALOG_DOWN]: 0,
    [ButtonType.RIGHT_ANALOG_LEFT]: 0,
    [ButtonType.RIGHT_ANALOG_RIGHT]: 0,
    [ButtonType.RIGHT_ANALOG_UP]: 0,
    [ButtonType.RIGHT_ANALOG_DOWN]: 0,
    [ButtonType.LEFT_HORIZONTAL_AXIS]: 0,
    [ButtonType.LEFT_VERTICAL_AXIS]: 0,
    [ButtonType.RIGHT_HORIZONTAL_AXIS]: 0,
    [ButtonType.RIGHT_VERTICAL_AXIS]: 0,
    [ButtonType.PSEUDO_BUTTON_1]: 0,
    [ButtonType.PSEUDO_BUTTON_2]: 0,
    [ButtonType.PSEUDO_BUTTON_3]: 0,
    [ButtonType.PSEUDO_BUTTON_4]: 0,
    [ButtonType.PSEUDO_BUTTON_5]: 0,
    [ButtonType.PSEUDO_BUTTON_6]: 0,
    [ButtonType.PSEUDO_BUTTON_7]: 0,
    [ButtonType.PSEUDO_BUTTON_8]: 0,
    [ButtonType.PSEUDO_BUTTON_9]: 0,
    [ButtonType.PSEUDO_BUTTON_10]: 0
  };
};
;// CONCATENATED MODULE: ./packages/react-gamepad-driver/src/setupGamepads.ts



/**
 * Setup pooling for the gamepad button states.
 *
 * This code is extremely performance sensitive, so be mindful of any changes and measure the performance
 * on a performance sensitive device (ex: Xbox One)
 */

function setupGamepads(handleDigitalInput, handleAnalogInput, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons) {
  const throttledCb = throttleByName(handleDigitalInput);
  const toggleCb = toggleByName(handleDigitalInput);
  const actionButtonsIndex = ACTION_BUTTONS.map(name => BUTTON_MAP.indexOf(name));
  const mappedActionButtonsIndex = ACTION_BUTTONS.map(name => BUTTON_MAP.indexOf(mapButton(name, swapABButtons, swapXYButtons)));
  const directionalButtonsIndex = DIRECTIONAL_BUTTONS.map(name => BUTTON_MAP.indexOf(name));
  /**
   * Check an individual gamepad for its presses states and axes values and fire the
   * throttled or toggles callbacks
   */

  function checkGamepad(gamepad) {
    const buttons = gamepad.buttons;
    const gamepadIndex = gamepad.index;

    for (let index = 0; index < actionButtonsIndex.length; index++) {
      toggleCb(BUTTON_MAP[mappedActionButtonsIndex[index]], buttons[actionButtonsIndex[index]].pressed, gamepadIndex);
    }

    for (let index = 0; index < directionalButtonsIndex.length; index++) {
      const buttonIndex = directionalButtonsIndex[index];
      throttledCb(BUTTON_MAP[buttonIndex], buttons[buttonIndex].pressed, gamepadIndex);
    }

    const axes = gamepad.axes.map((value, index) => {
      if (value > -0.16 && value < 0.16) {
        return 0;
      }

      const map = AXIS_MAP[index];
      throttledCb(map[0], value < -AXIS_TRIGGER_LIMIT, gamepadIndex);
      throttledCb(map[1], value > AXIS_TRIGGER_LIMIT, gamepadIndex);
      return value;
    });
    handleAnalogInput(axes);
  }
  /**
   * Tick that runs every frame and can either be
   * - Accepting input from all controllers
   * - Accept input from one specific controller
   */


  const tick = acceptInputFromAllControllers ? function () {
    try {
      const gamepads = getGamepads();
      const first = gamepads[0];
      const second = gamepads[1];
      const third = gamepads[2];
      const fourth = gamepads[3];
      if (first != null) checkGamepad(first);
      if (second != null) checkGamepad(second);
      if (third != null) checkGamepad(third);
      if (fourth != null) checkGamepad(fourth);
      handler = requestAnimationFrame(tick);
    } catch (e) {
      console.log('Error handling gamepad input', e);
    }
  } : function () {
    try {
      // We use a regular for loop here instead of a for of loop
      // since it's measurably faster. More context here:
      // https://github.com/Mojang/minecraft-ui/pull/2155
      const gamepads = getGamepads();

      for (let i = 0; i < gamepads.length; i++) {
        const gamepad = gamepads[i];

        if (gamepad != null && controllerId === gamepad.id) {
          checkGamepad(gamepad);
          break;
        }
      }

      handler = requestAnimationFrame(tick);
    } catch (e) {
      console.log('Error handling gamepad input', e);
    }
  };
  let handler = requestAnimationFrame(tick);
  return () => {
    cancelAnimationFrame(handler);
  };
}
const AXIS_TRIGGER_LIMIT = 0.5;

const toggleByName = fn => {
  const pressStates = {
    0: {},
    1: {},
    2: {},
    3: {}
  };
  return (name, pressed, index) => {
    const wasPressed = pressStates[index][name];

    if (pressed === wasPressed) {
      return;
    }

    if (pressed) {
      pressStates[index][name] = true;

      if (wasPressed != null) {
        fn(name);
      }
    } else {
      pressStates[index][name] = false;
    }
  };
};

const mapButton = (button, swapABButtons, swapXYButtons) => {
  if (button === ButtonType.Y && swapXYButtons) return ButtonType.X;
  if (button === ButtonType.X && swapXYButtons) return ButtonType.Y;
  if (button === ButtonType.A && swapABButtons) return ButtonType.B;
  if (button === ButtonType.B && swapABButtons) return ButtonType.A;
  return button;
};
;// CONCATENATED MODULE: ./packages/react-gamepad-driver/src/setupKeyboard.ts

function setupKeyboard(handleDigitalInput, keyToGamepad) {
  const handler = event => {
    // If an element in the DOM is focused, stop navigation from the keyboard input
    if (document.activeElement !== document.body || keyToGamepad == null) return; // Gameface does not support the new standard `key`, so we read the `keyCode` instead

    const key = event.keyCode;
    const buttonType = keyToGamepad[key];

    if (buttonType) {
      event.preventDefault();
      return handleDigitalInput(buttonType);
    } // Support for using the "tab" key to navigate the focus.
    // Key is being fired as a string on Jest.


    if (key === KeyboardKey.TAB) {
      event.preventDefault();
      return handleDigitalInput(event.shiftKey ? ButtonType.PREV : ButtonType.NEXT);
    }
  };

  document.addEventListener('keydown', handler);
  return () => {
    document.removeEventListener('keydown', handler);
  };
}
;// CONCATENATED MODULE: ./packages/react-gamepad-driver/src/setupMouse.ts

const MOUSE_BACK_BUTTON = 3;
/**
 * Maps the mouse "back button" to the B button
 */

function setupMouse(handleDigitalInput) {
  const handleEvent = event => {
    if (event.button === MOUSE_BACK_BUTTON) {
      handleDigitalInput(ButtonType.B);
    }
  };

  document.addEventListener('mousedown', handleEvent);
  return () => {
    document.removeEventListener('mousedown', handleEvent);
  };
}
;// CONCATENATED MODULE: ./packages/react-gamepad-driver/src/driver.ts




const driver_driver = (handleDigitalInput, handleAnalogInput, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons, keyToGamepad) => {
  const handleDigitalFocusInput = button => handleDigitalInput(button, FocusOrigin.FocusInput);

  const handleDigitalPointerInput = button => handleDigitalInput(button, FocusOrigin.PointerInput);

  const disposeGamepads = setupGamepads(handleDigitalFocusInput, handleAnalogInput, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons);
  const disposeKeyboard = setupKeyboard(handleDigitalFocusInput, keyToGamepad.current);
  const disposeMouse =  true ? setupMouse(handleDigitalPointerInput) : 0;
  return () => {
    disposeKeyboard();
    disposeGamepads();
    disposeMouse();
  };
};
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/GamepadProvider.tsx










// Hook that take a FacetProp and returns a Facet where changes to the value have been delayed by a frame.
const useDelayedFacetState = prop => {
  const propAsFacet = (0,react_facet_src.useFacetWrap)(prop);
  const [delayedState, setDelayedState] = (0,react_facet_src.useFacetState)(propAsFacet.get());
  (0,react_facet_src.useFacetEffect)(value => {
    let requestId = requestAnimationFrame(() => {
      setDelayedState(value);
      requestId = 0;
    });
    return () => {
      if (requestId !== 0) {
        cancelAnimationFrame(requestId);
      }
    };
  }, [setDelayedState], [propAsFacet]);
  return delayedState;
}; // We want to delay changes to the disabled state by a frame in order to make sure
// that all other effects in the GamepadProvider has been run before committing
// to the change, eg setup of the Driver.

const useDisabledNavigation = disabledNavigationFacetProp => {
  return useDelayedFacetState(typeof disabledNavigationFacetProp === 'undefined' ? false : disabledNavigationFacetProp);
};
/**
 * Provider that enables the gamepad focus capability around a React component tree.
 */


function GamepadProvider({
  children,
  focusedId: focusedIdFacetProp,
  onFocusedIdChange,
  onFocusedIdChangeFail,
  gameControllerId = '0',
  acceptInputFromAllControllers = false,
  swapABButtons = false,
  swapXYButtons = false,
  disabledNavigation: disabledNavigationFacetProp,
  disabledTransition = false,
  isInputLegendClickable = false,
  isRtl = false,
  keyboardGamepadMap,
  driver = driver_driver,
  mostRecentlyFocusedId = focusedIdFacetProp
}) {
  const disabledNavigation = useDisabledNavigation(disabledNavigationFacetProp);
  const focusedId = (0,react_facet_src.useFacetWrap)(focusedIdFacetProp);
  const keyToGamepadFacet = (0,react_facet_src.useFacetMap)(keyboardGamepadMap => {
    const keyboardGamepadEntries = Object.entries(keyboardGamepadMap);
    const keyToGamepad = {};

    for (let i = 0; i < keyboardGamepadEntries.length; i++) {
      const entry = keyboardGamepadEntries[i];
      const buttonType = entry[0];
      const buttonValues = entry[1];

      for (let j = 0; j < buttonValues.length; j++) {
        keyToGamepad[buttonValues[j]] = buttonType;
      }
    }

    return keyToGamepad;
  }, [], [(0,react_facet_src.useFacetWrap)(keyboardGamepadMap)]);
  const keyToGamepadRef = (0,react.useRef)(undefined);
  (0,react_facet_src.useFacetEffect)(keyToGamepad => {
    keyToGamepadRef.current = keyToGamepad;
  }, [], [keyToGamepadFacet]);
  /**
   * Stores a timestamp of the last time the Focus Tree was updated.
   * Useful to recalculate Input Legends after components have been mounted.
   */

  const [lastKnownTreeUpdate, setLastKnownTreeUpdate] = (0,react_facet_src.useFacetState)(0);
  const defaultProviderState = (0,react.useMemo)(() => ({
    disabledNavigation,
    focusedId,
    onFocusedIdChange,
    focusState: new Map(),
    //
    focusTree: getFreshTree(),
    analogListeners: [],
    digitalListeners: [],
    isRtl
  }),
  /**
   * We useMemo here to call the expensive functions (getFreshTree, new Map) only once at the boot of GamepadProvider
   */
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  const providerStateRef = (0,react.useRef)(defaultProviderState);
  providerStateRef.current.disabledNavigation = disabledNavigation;
  providerStateRef.current.onFocusedIdChange = onFocusedIdChange;
  providerStateRef.current.onFocusedIdChangeFail = onFocusedIdChangeFail;
  providerStateRef.current.isRtl = isRtl;
  const inputLegends = useInputLegends(providerStateRef.current, focusedId, lastKnownTreeUpdate);
  const invokeCurrentCallback = useInvokeCurrentCallback(providerStateRef.current, focusedId);
  const setInputEnabled = useInput(providerStateRef.current, focusedId, gameControllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons, disabledTransition, keyToGamepadRef, driver);
  useRerenderNodes(providerStateRef.current, (0,react_facet_src.useFacetWrap)(mostRecentlyFocusedId));
  const api = useApi(providerStateRef.current, setInputEnabled, focusedId, setLastKnownTreeUpdate);
  useUpdateFocusState(providerStateRef.current, focusedId); // Prevent buttonMap to be created on every render by using useMemo,
  // which would trigger an update on any consumer of the ButtonMapProvider context provider below

  const buttonMap = (0,react.useMemo)(() => ({
    swapABButtons,
    swapXYButtons
  }), [swapABButtons, swapXYButtons]);

  const navigateToDefaultFocusChild = parentId => {
    const node = getNode(providerStateRef.current.focusTree, parentId);

    if ((node === null || node === void 0 ? void 0 : node.type) === 'focusable') {
      var _getAlias;

      const focusId = (_getAlias = getAlias(providerStateRef.current.focusTree, parentId)) !== null && _getAlias !== void 0 ? _getAlias : parentId;
      return providerStateRef.current.onFocusedIdChange(focusId);
    }

    const childId = findFirstFocusableChildNode(parentId, providerStateRef.current.focusTree, providerStateRef.current.focusState);

    if (childId != null) {
      var _getAlias2;

      const newAliasOrNodeId = (_getAlias2 = getAlias(providerStateRef.current.focusTree, childId)) !== null && _getAlias2 !== void 0 ? _getAlias2 : childId;
      providerStateRef.current.onFocusedIdChange(newAliasOrNodeId);
    }
  };

  const clearRememberCache = nodeId => {
    const node = getNode(providerStateRef.current.focusTree, nodeId);

    if (node != null && isContainer(node) && node.defaultFocusedChildBehavior === 'remember') {
      providerStateRef.current.focusState.delete(nodeId);
    }
  }; // We know that the keyboardGamepadMap is set "statically" as a prop, and if it changes it will be by having a new instance
  // So for this implementation of the GamepadProvider that is soon to be replaced by the visual implementation, we can safelly
  // do a strictEqualityCheck assuming the data to be immutable.
  // This is an optimization to prevent unnecessary updates to the context.


  const keyboardGamepadMap_ = (0,react_facet_src.useFacetWrap)(keyboardGamepadMap, immutableStrictEqualityCheck);
  const value = (0,react.useMemo)(() => [keyboardGamepadMap_, () => {}], [keyboardGamepadMap_]);
  return (
    /*#__PURE__*/
    // We pass keyboardGamepadMap as a read-only Facet, with a fake setter, just to match the new API
    // of the keyboardGamepadMapContext in the visual package (which we are using here)
    react.createElement(keyboardGamepadMapContext.Provider, {
      value: value
    }, /*#__PURE__*/react.createElement(SetFocusedIdProvider, {
      onFocusedIdChange: onFocusedIdChange,
      focusedId: focusedId
    }, /*#__PURE__*/react.createElement(ButtonMapProvider, {
      value: buttonMap
    }, /*#__PURE__*/react.createElement(GamepadAPIProvider, {
      value: api
    }, /*#__PURE__*/react.createElement(AvailableInputLegendsProvider, {
      value: inputLegends
    }, /*#__PURE__*/react.createElement(InvokeCurrentCallbackProvider, {
      value: isInputLegendClickable ? invokeCurrentCallback : undefined
    }, /*#__PURE__*/react.createElement(FocusProvider, {
      value: {
        focusedId,
        navigate: navigateToDefaultFocusChild,
        clearRememberCache
      }
    }, children)))))))
  );
}

function immutableStrictEqualityCheck() {
  let previous = react_facet_src.NO_VALUE;
  return current => {
    if (previous !== current) {
      previous = current;
      return false;
    }

    return true;
  };
}
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/path.tsx

const path_Context = (0,react.createContext)([]);
const {
  Provider: path_Provider,
  Consumer: path_Consumer
} = path_Context;

const PathContext = path_Context;
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/setFocusedId.ts

const setFocusedId_setFocusedIdContext = (0,react.createContext)(() => () => {});
/**
 * Hook that allows access to a function to imperatively set the focused id
 * On setting a focusedId, it returns a "restore" function that can be called to restore the focus to a previous state
 */

const setFocusedId_useSetFocusedId = () => (0,react.useContext)(setFocusedId_setFocusedIdContext);
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/lastFocusOriginContext.tsx



const lastFocusOriginContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)(FocusOrigin.Initial));
const useLastFocusOrigin = () => (0,react.useContext)(lastFocusOriginContext);
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/focusTreeAPI.tsx


const focusTreeAPI_logWarning = () => {
  if (false) {}
};

const FocusTreeAPIContext = (0,react.createContext)({
  press: () => undefined,
  isFocused: () => {
    focusTreeAPI_logWarning();
    return false;
  },
  isFocusable: () => {
    focusTreeAPI_logWarning();
    return false;
  },
  putNode: focusTreeAPI_logWarning,
  putShortcut: focusTreeAPI_logWarning,
  removeNode: focusTreeAPI_logWarning,
  removeShortcut: focusTreeAPI_logWarning,
  getElement: () => {
    focusTreeAPI_logWarning();
    return undefined;
  },
  isAncestorOf: () => {
    focusTreeAPI_logWarning();
    return false;
  },
  getDynasty: () => {
    focusTreeAPI_logWarning();
    return undefined;
  },
  getEnabledBindingLandmarkDescendant: () => {
    focusTreeAPI_logWarning();
    return undefined;
  }
});
const {
  Provider: focusTreeAPI_Provider,
  Consumer: focusTreeAPI_Consumer
} = FocusTreeAPIContext;
const FocusTreeAPIProvider = focusTreeAPI_Provider;
const FocusTreeAPIConsumer = (/* unused pure expression or super */ null && (focusTreeAPI_Consumer));
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/cursorAPI.tsx

const CursorAPIContext = (0,react.createContext)({
  addAnalogListener: () => () => {},
  addDigitalListener: () => () => {},
  clickAtPoint: () => {},
  focusAtPoint: () => {}
});
const {
  Provider: cursorAPI_Provider,
  Consumer: cursorAPI_Consumer
} = CursorAPIContext;
const CursorAPIProvider = cursorAPI_Provider;
const CursorAPIConsumer = (/* unused pure expression or super */ null && (cursorAPI_Consumer));
// EXTERNAL MODULE: ./node_modules/ramda/src/includes.js
var includes = __webpack_require__(59270);
var includes_default = /*#__PURE__*/__webpack_require__.n(includes);
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/treeQueries.tsx



function treeQueries_getAlias(focusTree, focusableId) {
  var _focusTree$elements$g;

  return (_focusTree$elements$g = focusTree.elements.get(focusableId)) === null || _focusTree$elements$g === void 0 ? void 0 : _focusTree$elements$g.alias;
}
function landmarkHasEnabledItems(tree, landmark) {
  var _tree$children$get;

  const childIds = (_tree$children$get = tree.children.get(landmark.id)) !== null && _tree$children$get !== void 0 ? _tree$children$get : [];

  for (const childId of childIds) {
    const child = tree.elements.get(childId);

    if (!child) {
      continue;
    }

    if (child.type === FocusableType.LANDMARK) {
      if (child.disabled || child.hidden) {
        continue;
      }

      const enabled = landmarkHasEnabledItems(tree, child);

      if (enabled) {
        return true;
      }
    } else {
      if (!child.disabled && !child.hidden) {
        return true;
      }
    }
  }

  return false;
}
function getIdFromAliasOrId(focusTree, aliasOrId) {
  if (typeof aliasOrId === 'string') {
    return focusTree.aliases.get(aliasOrId);
  }

  if (aliasOrId != null && focusTree.elements.has(aliasOrId)) {
    return aliasOrId;
  }

  return undefined;
}
function getElement(focusTree, aliasOrId) {
  const id = getIdFromAliasOrId(focusTree, aliasOrId);
  if (id == null) return;
  const element = focusTree.elements.get(id);
  return element;
}
function treeQueries_getAncestorIds(focusTree, elementId) {
  const parentId = focusTree.parents.get(elementId);

  if (parentId == null) {
    return [];
  }

  return [parentId, ...treeQueries_getAncestorIds(focusTree, parentId)];
}
function isAncestorOf(focusTree, parentId, elementId) {
  const parentElementId = focusTree.parents.get(elementId);

  if (parentElementId === parentId) {
    return true;
  }

  if (parentElementId == null) {
    return false;
  }

  return isAncestorOf(focusTree, parentId, parentElementId);
}
function getClosestDelegatingAncestor(focusTree, elementId) {
  const parentId = focusTree.parents.get(elementId);

  if (parentId == null) {
    return null;
  }

  const parentElement = focusTree.elements.get(parentId);

  if (parentElement == null) {
    return null;
  }

  if (isDelegatingLandmark(parentElement) || isRoot(parentElement)) {
    return parentElement;
  }

  return getClosestDelegatingAncestor(focusTree, parentId);
}
function doesDynastyHaveAnyEnabledItems(focusTree, dynasty) {
  for (const id of dynasty) {
    const element = focusTree.elements.get(id);

    if (!element) {
      continue;
    }

    if (isDelegatingLandmark(element) && treeQueries_isNodeEnabled(focusTree, id)) {
      return true;
    }

    if (element.type === types_FocusableType.ITEM && treeQueries_isNodeEnabled(focusTree, id)) {
      return true;
    }
  }

  return false;
}
function getClosestAncestor(focusTree, elementId, test) {
  const parentId = focusTree.parents.get(elementId);

  if (parentId == null) {
    return null;
  }

  const parentElement = focusTree.elements.get(parentId);

  if (parentElement == null) {
    return null;
  }

  if (test(parentElement)) {
    return parentElement;
  }

  return getClosestDelegatingAncestor(focusTree, parentId);
}
const getRootNodes = focusTree => {
  const rootNodes = [];

  for (const [id] of focusTree.elements) {
    if (!focusTree.parents.has(id)) {
      rootNodes.push(id);
    }
  }

  return rootNodes;
};
const getClosestAncestorIdGetter = test => {
  const getClosestParentId = (tree, elementId) => {
    const parentId = tree.parents.get(elementId);

    if (parentId == null) {
      return null;
    }

    const parent = tree.elements.get(parentId);

    if (parent == null) {
      return null;
    }

    if (test(parent)) {
      return parentId;
    }

    return getClosestParentId(tree, parentId);
  };

  return getClosestParentId;
};
const doesAnyNonSharedAncestorDelegateFocus = (tree, candidateElementId, currentFocusedElementID) => {
  const pathForCurrentFocusedElement = treeQueries_getAncestorIds(tree, currentFocusedElementID);
  const testResult = getClosestAncestorIdGetter(element => isDelegatingLandmark(element) && !includes_default()(element.id, pathForCurrentFocusedElement))(tree, candidateElementId);
  return testResult != null;
};
const getDisabledAncestor = getClosestAncestorIdGetter(parent => parent.disabled || parent.hidden);
const treeQueries_isAnyAncestorDisabled = (tree, elementId) => getDisabledAncestor(tree, elementId) != null;
const getBindingAncestorId = getClosestAncestorIdGetter(isBindingLandmark);
const getScrollableAncestorId = getClosestAncestorIdGetter(parent => parent.type === types_FocusableType.LANDMARK && parent.scrollAxis != null);
const hasAnyAncestorWithId = (tree, elementId, targetParentId) => {
  const parentId = tree.parents.get(elementId);

  if (parentId == null) {
    return false;
  }

  if (parentId === targetParentId) {
    return true;
  }

  return hasAnyAncestorWithId(tree, parentId, targetParentId);
};
const getEnabledBindingLandmarkDescendant = (focusTree, elementId) => {
  const enabledBindingLandmarksDescendantIds = getEnabledBindingLandmarkDescendantIds(focusTree, elementId);

  if (enabledBindingLandmarksDescendantIds != null && enabledBindingLandmarksDescendantIds.length > 0) {
    const enabledBindingLandmarksDescendantId = enabledBindingLandmarksDescendantIds[0];
    const enabledBindingLandmarksDescendant = getElement(focusTree, enabledBindingLandmarksDescendantId);
    return enabledBindingLandmarksDescendant != null && isBindingLandmark(enabledBindingLandmarksDescendant) ? enabledBindingLandmarksDescendant : undefined;
  }
};
const getEnabledBindingLandmarkDescendantIds = (focusTree, elementId) => {
  const bindingLandmarkDescendants = focusTree.bindingLandmarkDescendants.get(elementId);

  if (bindingLandmarkDescendants == null) {
    return;
  }

  const enabledBindingLandmarkDescendants = [];

  for (const itemId of bindingLandmarkDescendants) {
    if (treeQueries_isNodeEnabled(focusTree, itemId)) {
      enabledBindingLandmarkDescendants.push(itemId);
    }
  }

  if (false) {}

  return enabledBindingLandmarkDescendants;
};
function treeQueries_isNodeEnabled(focusTree, elementId) {
  const node = getElement(focusTree, elementId);
  if (node == null) return false;
  if (node.type === types_FocusableType.ROOT) return true;
  if (!isAvailableFocusable(node)) return false;
  const ancestorIds = treeQueries_getAncestorIds(focusTree, node.id);

  for (const id of ancestorIds) {
    const node = getElement(focusTree, id);
    if (node == null) return false;
    if (!isRoot(node) && !isAvailableFocusable(node)) return false;
  }

  return true;
}
const getDelegatedFocusFromAncestor = (focusTree, elementId) => {
  const id = getIdFromAliasOrId(focusTree, elementId);

  if (id == null) {
    return undefined;
  }

  const element = focusTree.elements.get(id);

  if (element == null) {
    return undefined;
  }

  if (element.type === types_FocusableType.ROOT || isDelegatingLandmark(element) && treeQueries_isNodeEnabled(focusTree, id)) {
    const delegatedFocus = element.getDelegatedFocus();
    return delegatedFocus != react_facet_src.NO_VALUE ? delegatedFocus : undefined;
  }

  return getDelegatedFocusFromAncestor(focusTree, focusTree.parents.get(id));
};
function getShortcutsFor(focusTree, aliasOrId) {
  const elementId = getIdFromAliasOrId(focusTree, aliasOrId);

  if (elementId == null) {
    return;
  }

  return focusTree.shortcuts.get(elementId);
}
function treeQueries_getShortcut(focusTree, elementId, buttonType) {
  const focusable = focusTree.elements.get(elementId);

  if (!focusable) {
    return;
  }

  if (treeQueries_isNodeEnabled(focusTree, elementId)) {
    var _focusTree$shortcuts$;

    const shortcut = (_focusTree$shortcuts$ = focusTree.shortcuts.get(elementId)) === null || _focusTree$shortcuts$ === void 0 ? void 0 : _focusTree$shortcuts$.get(buttonType);

    if (shortcut != null) {
      return shortcut;
    }
  }

  const parentId = focusTree.parents.get(elementId);

  if (parentId == null) {
    return;
  }

  return treeQueries_getShortcut(focusTree, parentId, buttonType);
}
function getShortcutHandler(focusTree, elementId, actionButton) {
  var _getShortcut;

  return (_getShortcut = treeQueries_getShortcut(focusTree, elementId, actionButton)) === null || _getShortcut === void 0 ? void 0 : _getShortcut.callback;
}
function treeQueries_getAncestorNodes(focusTree, elementId) {
  const ancestors = [];
  const ancestorIds = treeQueries_getAncestorIds(focusTree, elementId);

  for (const id of ancestorIds) {
    const ancestor = getElement(focusTree, id);
    if (ancestor == null) return ancestors;

    if (ancestor.type !== types_FocusableType.ITEM) {
      ancestors.push(ancestor);
    }
  }

  return ancestors;
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/treeInitialization.ts



const ROOT_NODE_ID = 1;

const createIsElementAncestorOf = (focusTree, id) => element => {
  var _element$getAttribute;

  const idAttribute = (_element$getAttribute = element.getAttribute(types_DATA_FOCUSABLE_ID)) !== null && _element$getAttribute !== void 0 ? _element$getAttribute : element.getAttribute(DATA_LANDMARK_ID);
  if (idAttribute == null) return false;
  const elementId = parseInt(idAttribute, 10);
  return id === elementId || isAncestorOf(focusTree, id, elementId);
};

const createGetDelegatedFocus = (focusTree, id) => () => {
  var _window$document$body;

  const enabledBindingLandmarkDescendant = getEnabledBindingLandmarkDescendant(focusTree, id); // We start by looking at enabled binding landmark descendants.
  // Binding landmarks take priority over any other behavior

  if (enabledBindingLandmarkDescendant != null) {
    const delegatedFocus = enabledBindingLandmarkDescendant.getDelegatedFocus();

    if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
      return delegatedFocus;
    }
  }

  const defaultDelegatedFocus = {
    id,
    reason: NewFocusSuggestionReason.DefaultDelegation
  };
  const dynasty = focusTree.dynasty.get(id);
  const elements = Array.from((_window$document$body = window.document.body.querySelectorAll(`[${types_DATA_FOCUSABLE_ID}], [${DATA_LANDMARK_ID}]`)) !== null && _window$document$body !== void 0 ? _window$document$body : []);

  if (elements.length === 0) {
    return defaultDelegatedFocus;
  }

  for (let i = 0; i < elements.length; i++) {
    const landmarkIdAttribute = elements[i].getAttribute(DATA_LANDMARK_ID);
    const focusableIdAttribute = elements[i].getAttribute(types_DATA_FOCUSABLE_ID);

    if (landmarkIdAttribute != null) {
      const landmarkId = parseInt(landmarkIdAttribute, 10);

      if (!(dynasty !== null && dynasty !== void 0 && dynasty.has(landmarkId))) {
        continue;
      }

      const landmarkElement = getElement(focusTree, landmarkId);

      if (!isDelegatingLandmark(landmarkElement)) {
        continue;
      }

      if (!treeQueries_isNodeEnabled(focusTree, landmarkId)) {
        continue;
      }

      const isElementAncestorOfLandmark = createIsElementAncestorOf(focusTree, landmarkId);
      const landmarkDecedentElements = elements.filter(isElementAncestorOfLandmark);
      const delegatedFocus = landmarkElement.getDelegatedFocus(landmarkDecedentElements);

      if (delegatedFocus != react_facet_src.NO_VALUE && delegatedFocus != null) {
        return delegatedFocus;
      }
    } else if (focusableIdAttribute != null) {
      const focusableId = parseInt(focusableIdAttribute, 10);

      if (dynasty !== null && dynasty !== void 0 && dynasty.has(focusableId) && treeQueries_isNodeEnabled(focusTree, focusableId)) {
        return {
          id: focusableId,
          reason: NewFocusSuggestionReason.FirstFoundDelegation
        };
      }
    }
  }

  return defaultDelegatedFocus;
};

const treeInitialization_getFreshTree = () => {
  const focusTree = {
    elements: new Map(),
    children: new Map(),
    parents: new Map(),
    aliases: new Map(),
    shortcuts: new Map(),
    history: [],
    bindingLandmarkStack: [],
    dynasty: new Map(),
    bindingLandmarkDescendants: new Map()
  };
  const rootElement = {
    type: types_FocusableType.ROOT,
    id: ROOT_NODE_ID,
    alias: undefined,
    disabled: false,
    hidden: false,
    ref: null,
    scrollAxis: null,
    onDown: undefined,
    onUp: undefined,
    onRight: undefined,
    onLeft: undefined,
    onBlur: undefined,
    onFocus: undefined,
    disableScrollIntoView: undefined,
    getDelegatedFocus: createGetDelegatedFocus(focusTree, ROOT_NODE_ID)
  };
  focusTree.elements.set(ROOT_NODE_ID, rootElement);
  return focusTree;
};
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/navigate/geometry.ts

const mapArrowToDirection = {
  [Arrows.UP]: Direction.PREVIOUS,
  [Arrows.DOWN]: Direction.NEXT,
  [Arrows.LEFT]: Direction.PREVIOUS,
  [Arrows.RIGHT]: Direction.NEXT
};
const mapArrowToOppositeArrow = {
  [Arrows.UP]: Arrows.DOWN,
  [Arrows.DOWN]: Arrows.UP,
  [Arrows.LEFT]: Arrows.RIGHT,
  [Arrows.RIGHT]: Arrows.LEFT
};
const getEdgeCoordinate = (position, arrow) => {
  switch (arrow) {
    case Arrows.DOWN:
      {
        return position.top + position.height;
      }

    case Arrows.UP:
      {
        return position.top;
      }

    case Arrows.RIGHT:
      {
        return position.left + position.width;
      }

    case Arrows.LEFT:
      {
        return position.left;
      }
  }
};
const isSameAxis = (oldArrow, newArrow) => {
  switch (oldArrow) {
    case Arrows.DOWN:
    case Arrows.UP:
      {
        return newArrow === Arrows.UP || newArrow === Arrows.DOWN;
      }

    case Arrows.RIGHT:
    case Arrows.LEFT:
      {
        return newArrow === Arrows.LEFT || newArrow === Arrows.RIGHT;
      }
  }
};
const getTheCenterOfPostion = position => {
  return [position.top + position.height / 2, position.left + position.width / 2];
};
const getProjectionOverlap = (startingDimensions, targetDimensions, arrow) => {
  switch (arrow) {
    case Arrows.DOWN:
    case Arrows.UP:
      {
        const startingDimensionsRight = startingDimensions.left + startingDimensions.width;
        const targetDimensionsRight = targetDimensions.left + targetDimensions.width;
        const leftHandSideDiff = Math.max(targetDimensions.left - startingDimensions.left, 0);
        const rightHandSideDiff = Math.max(startingDimensionsRight - targetDimensionsRight, 0);
        const difference = leftHandSideDiff + rightHandSideDiff;
        const overlapInPixels = Math.max(startingDimensions.width - difference, 0);
        return overlapInPixels / startingDimensions.width;
      }

    case Arrows.LEFT:
    case Arrows.RIGHT:
      {
        const startingDimensionsBottom = startingDimensions.top + startingDimensions.height;
        const targetDimensionsBottom = targetDimensions.top + targetDimensions.height;
        const topHandSideDiff = Math.max(targetDimensions.top - startingDimensions.top, 0);
        const bottomHandSideDiff = Math.max(startingDimensionsBottom - targetDimensionsBottom, 0);
        const difference = topHandSideDiff + bottomHandSideDiff;
        const overlapInPixels = Math.max(startingDimensions.height - difference, 0);
        return overlapInPixels / startingDimensions.height;
      }
  }
};
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/visualQueries.tsx



function getBoundingClientRectById(focusTree, id) {
  var _focusTree$elements$g, _focusTree$elements$g2;

  return (_focusTree$elements$g = focusTree.elements.get(id)) === null || _focusTree$elements$g === void 0 ? void 0 : (_focusTree$elements$g2 = _focusTree$elements$g.ref) === null || _focusTree$elements$g2 === void 0 ? void 0 : _focusTree$elements$g2.getBoundingClientRect();
}
function visualQueries_findClickableFocusableAtPoint(focusTree, x, y) {
  for (const entry of focusTree.elements) {
    var _focusTree$shortcuts$, _focusTree$shortcuts$2;

    const element = entry[1];
    if (element.type !== types_FocusableType.ITEM || !isAvailableFocusable(element) || ((_focusTree$shortcuts$ = focusTree.shortcuts.get(element.id)) === null || _focusTree$shortcuts$ === void 0 ? void 0 : (_focusTree$shortcuts$2 = _focusTree$shortcuts$.get(types_ButtonType.A)) === null || _focusTree$shortcuts$2 === void 0 ? void 0 : _focusTree$shortcuts$2.callback) == null) continue;
    const rect = element.ref.getBoundingClientRect();

    if (x >= rect.left && x <= rect.left + rect.width && y >= rect.top && y <= rect.top + rect.height) {
      return element;
    }
  }
}
const getTopLeftElementId = tree => {
  let bestCandidateId = null;
  let bestCandidateCoordinates = [Infinity, Infinity];

  for (const [id, element] of tree.elements) {
    var _element$ref;

    const position = (_element$ref = element.ref) === null || _element$ref === void 0 ? void 0 : _element$ref.getBoundingClientRect();

    if (position == null) {
      continue;
    }

    if (element.type !== types_FocusableType.ITEM) {
      continue;
    }

    if (treeQueries_isAnyAncestorDisabled(tree, element.id)) {
      continue;
    }

    const center = getTheCenterOfPostion(position);
    const candidateMoreTop = center[0] < bestCandidateCoordinates[0];
    const candidateSameTopButMoreLeft = center[0] === bestCandidateCoordinates[0] && center[1] < bestCandidateCoordinates[1];

    if (candidateMoreTop || candidateSameTopButMoreLeft) {
      bestCandidateId = id;
      bestCandidateCoordinates = center;
    }
  }

  return bestCandidateId;
};
const getCurrentDomElementIndex = (currentDomElement, allElements) => {
  for (let i = 0; i < allElements.length; i++) {
    if (currentDomElement === allElements[i]) {
      return i;
    }
  }

  return null;
};
const getFocusedIdFromDomElement = currentDomElement => {
  const stringElementId = currentDomElement.getAttribute(types_DATA_FOCUSABLE_ID);

  if (stringElementId != null) {
    return parseInt(stringElementId);
  }

  return;
};
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/operations.ts



const clickFocusableAtPoint = (focusTree, x, y) => {
  const focusable = visualQueries_findClickableFocusableAtPoint(focusTree, x, y);

  if (focusable != null && focusable.type === types_FocusableType.ITEM) {
    var _shortcuts$get;

    const shortcuts = focusTree.shortcuts.get(focusable.id);
    shortcuts === null || shortcuts === void 0 ? void 0 : (_shortcuts$get = shortcuts.get(types_ButtonType.A)) === null || _shortcuts$get === void 0 ? void 0 : _shortcuts$get.callback();
  }
};
const notifyAncestorsOfDecedentFocus = (focusTree, focusedId, origin) => {
  const focusedNumberId = getIdFromAliasOrId(focusTree, focusedId);
  if (focusedNumberId == null) return;
  let lastDelegatingAncestorId = undefined;

  for (let ancestorId = focusTree.parents.get(focusedNumberId); ancestorId != null; ancestorId = focusTree.parents.get(ancestorId)) {
    const ancestorElement = focusTree.elements.get(ancestorId);

    if (!isDelegatingLandmark(ancestorElement)) {
      continue;
    }

    if (lastDelegatingAncestorId == null) {
      ancestorElement.onFocusableOfDynastyFocused(focusedId, origin); // Use focusedId here since we want to pass the alias if there is one
    } else {
      var _lastDelegatingAncest;

      const lastDelegatingAncestorElement = focusTree.elements.get(lastDelegatingAncestorId);
      ancestorElement.onFocusableOfDynastyFocused( // Prefer passing the alias over the number id
      (_lastDelegatingAncest = lastDelegatingAncestorElement === null || lastDelegatingAncestorElement === void 0 ? void 0 : lastDelegatingAncestorElement.alias) !== null && _lastDelegatingAncest !== void 0 ? _lastDelegatingAncest : lastDelegatingAncestorId, origin);
    }

    lastDelegatingAncestorId = ancestorId;
  }
};
const nofifyNodesOfBlurAndFocus = (focusTree, previousElementId, focusedId) => {
  const newNodeId = getIdFromAliasOrId(focusTree, focusedId);
  const previousNode = previousElementId != null ? focusTree.elements.get(previousElementId) : undefined;

  if (previousNode != null && previousElementId !== newNodeId && previousElementId != null) {
    var _previousNode$onBlur;

    (_previousNode$onBlur = previousNode.onBlur) === null || _previousNode$onBlur === void 0 ? void 0 : _previousNode$onBlur.call(previousNode);
  }

  if (focusedId == null || newNodeId == null) return;
  const newNode = focusTree.elements.get(newNodeId);

  if (previousNode != null && previousNode !== newNode) {
    var _previousNode$onBlur2;

    (_previousNode$onBlur2 = previousNode.onBlur) === null || _previousNode$onBlur2 === void 0 ? void 0 : _previousNode$onBlur2.call(previousNode);
  }

  if (newNode != null) {
    var _newNode$onFocus;

    (_newNode$onFocus = newNode.onFocus) === null || _newNode$onFocus === void 0 ? void 0 : _newNode$onFocus.call(newNode);
  }
};
const click = (focusTree, focusedId) => {
  if (focusedId == null) return undefined;
  const focusable = focusTree.elements.get(focusedId);

  if (focusable != null && focusable.type === types_FocusableType.ITEM) {
    var _focusTree$shortcuts$, _focusTree$shortcuts$2;

    (_focusTree$shortcuts$ = focusTree.shortcuts.get(focusedId)) === null || _focusTree$shortcuts$ === void 0 ? void 0 : (_focusTree$shortcuts$2 = _focusTree$shortcuts$.get(types_ButtonType.A)) === null || _focusTree$shortcuts$2 === void 0 ? void 0 : _focusTree$shortcuts$2.callback();
  }

  return;
};
const fireShortcut = (focusTree, focusedId, button) => {
  const focusedNodeId = typeof focusedId === 'string' ? focusTree.aliases.get(focusedId) : focusedId;
  if (focusedNodeId == null) return false;
  const handler = getShortcutHandler(focusTree, focusedNodeId, button);

  if (handler != null) {
    handler();
    return true;
  }

  return false;
};
const fireHandler = (focusTree, focusedId, arrow) => {
  const focusedNodeId = typeof focusedId === 'string' ? focusTree.aliases.get(focusedId) : focusedId;
  if (focusedNodeId == null) return false;
  const focusedNode = focusTree.elements.get(focusedNodeId);
  if (focusedNode == null) return false;

  switch (arrow) {
    case Arrows.LEFT:
      if (focusedNode.onLeft) {
        if (focusedNode.onLeft()) return true;
      }

      break;

    case Arrows.RIGHT:
      if (focusedNode.onRight) {
        if (focusedNode.onRight()) return true;
      }

      break;

    case Arrows.UP:
      if (focusedNode.onUp) {
        if (focusedNode.onUp()) return true;
      }

      break;

    case Arrows.DOWN:
      if (focusedNode.onDown) {
        if (focusedNode.onDown()) return true;
      }

  }

  return false;
};
const wiggleScrollables = (focusTree, focusedId, axes, analogScrollMaxSpeed) => {
  if (focusedId == null) return false;
  const verticalValue = axes[types_ButtonType.RIGHT_VERTICAL_AXIS];
  const horizontalValue = axes[types_ButtonType.RIGHT_HORIZONTAL_AXIS];
  if (verticalValue === 0 && horizontalValue === 0) return false;
  const focusedNodeId = getIdFromAliasOrId(focusTree, focusedId);
  if (focusedNodeId == null) return false;
  const nodes = treeQueries_getAncestorNodes(focusTree, focusedNodeId);
  const parents = nodes.filter(node => node.scrollAxis != null);
  if (parents.length === 0) return false;
  parents.forEach(parent => {
    const value = parent.scrollAxis === ScrollAxis.HORIZONTAL ? horizontalValue : verticalValue;
    const scrollProperty = parent.scrollAxis === ScrollAxis.HORIZONTAL ? 'scrollLeft' : 'scrollTop';
    if (parent.ref == null) return;
    parent.ref[scrollProperty] += value * analogScrollMaxSpeed;
  });
  return true;
};
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/mutations.ts




function resetNavigationDirection(focusTree) {
  focusTree.lastDirectionChange = undefined;
}
function putShortcut(focusTree, elementId, actionButton, shortcut) {
  var _shortcuts$get;

  const {
    shortcuts
  } = focusTree;

  if (!shortcuts.get(elementId)) {
    shortcuts.set(elementId, new Map());
  }

  (_shortcuts$get = shortcuts.get(elementId)) === null || _shortcuts$get === void 0 ? void 0 : _shortcuts$get.set(actionButton, shortcut);
}
const delegateToBindingLandmark = (focusTree, maybeBindingLandmark) => {
  if (!isBindingLandmark(maybeBindingLandmark)) return;
  focusTree.bindingLandmarkStack.push(maybeBindingLandmark.id);
  const delegatedFocus = maybeBindingLandmark.getDelegatedFocus(); // Not getting a `delegatedId` in this case should be impossible.
  // `getDelegatedFocus` should be implemented so that, if no other child
  // is available, the delegating Landmark will return its own id.

  return delegatedFocus === react_facet_src.NO_VALUE ? undefined : delegatedFocus;
};
function putFocusable(focusTree, focusable, parentId, focused, shouldSuggestNewFocus) {
  const focusedId = focused.id;
  const focusedNumberId = getIdFromAliasOrId(focusTree, focusedId);
  const isFocusableFocused = focusedNumberId === focusable.id;
  const previousFocusable = focusTree.elements.get(focusable.id);
  const parentFocusable = parentId != null ? focusTree.elements.get(parentId) : undefined;
  const stringId = focusable.id.toString();
  const isLandmark = focusable.type === types_FocusableType.LANDMARK;
  const isItem = focusable.type === types_FocusableType.ITEM;
  const isFocusableEnabled = isAvailableFocusable(focusable) && treeQueries_isNodeEnabled(focusTree, parentId);
  const isFocusableBecomingEnabled = previousFocusable != null && isFocusableEnabled && !isAvailableFocusable(previousFocusable);
  const isFocusableBeingAddedEnabled = previousFocusable == null && isFocusableEnabled;
  const isLandmarkBecomingEnabled = isLandmark && isFocusableBecomingEnabled;
  const isLandmarkBecomingDisabled = isLandmark && previousFocusable != null && !isAvailableFocusable(focusable) && isAvailableFocusable(previousFocusable);
  const isLandmarkBeingAddedEnabled = isLandmark && isFocusableBeingAddedEnabled;
  const isItemBecomingEnabled = isItem && isFocusableBecomingEnabled;
  const isItemBeingAddedEnabled = isItem && isFocusableBeingAddedEnabled; // Note that if the `ref` is ever updated, we are not setting these again.
  // This could be a problem, but as far as we know, there is nowhere in the
  // current minecraft-ui code a mechanism to listen to changes in the ref
  // object. That is something that we should address more generally: potentially
  // adding a callback to the `ref` prop when putting it into a `<div />`, for
  // example, instead of using a `useRef`

  if (isItem) {
    var _focusable$ref, _focusable$ref2;

    (_focusable$ref = focusable.ref) === null || _focusable$ref === void 0 ? void 0 : _focusable$ref.removeAttribute(DATA_LANDMARK_ID);
    (_focusable$ref2 = focusable.ref) === null || _focusable$ref2 === void 0 ? void 0 : _focusable$ref2.setAttribute(types_DATA_FOCUSABLE_ID, stringId);
  } else if (isLandmark) {
    var _focusable$ref3, _focusable$ref4;

    (_focusable$ref3 = focusable.ref) === null || _focusable$ref3 === void 0 ? void 0 : _focusable$ref3.removeAttribute(types_DATA_FOCUSABLE_ID);
    (_focusable$ref4 = focusable.ref) === null || _focusable$ref4 === void 0 ? void 0 : _focusable$ref4.setAttribute(DATA_LANDMARK_ID, stringId);
  } // This is for debugging the focus tree using the focus tree dev tools extension


  if (window.__REACT_FACET_DEVTOOLS_GLOBAL_HOOK__ != null) {
    var _focusable$ref5;

    (_focusable$ref5 = focusable.ref) === null || _focusable$ref5 === void 0 ? void 0 : _focusable$ref5.setAttribute(DATA_FOCUSABLE_DEBUG_ID, stringId);
  }

  const closestDelegatingAncestor = previousFocusable == null && parentFocusable != null && (isDelegatingLandmark(parentFocusable) || isRoot(parentFocusable)) ? parentFocusable : getClosestDelegatingAncestor(focusTree, previousFocusable == null && parentId != null ? parentId : focusable.id);
  const maybeDynasty = closestDelegatingAncestor != null ? focusTree.dynasty.get(closestDelegatingAncestor.id) : undefined;
  const dynastyHaveNoEnabledItems = maybeDynasty == null || !doesDynastyHaveAnyEnabledItems(focusTree, maybeDynasty);
  const closestDelegatingLandmark = isDelegatingLandmark(closestDelegatingAncestor) ? closestDelegatingAncestor : undefined;
  let updatedIdAfterAliasMutation = undefined;

  if (previousFocusable) {
    const originalAlias = treeQueries_getAlias(focusTree, focusable.id);
    const newAlias = focusable.alias;

    if (originalAlias !== newAlias) {
      if (originalAlias != null) {
        focusTree.aliases.delete(originalAlias);
      }

      const isNewAliasDefined = newAlias != null;

      if (isNewAliasDefined) {
        focusTree.aliases.set(newAlias, focusable.id);
      }

      updatedIdAfterAliasMutation = isNewAliasDefined ? newAlias : focusable.id; // NOTE: We are deliberately not updating the delegation memory stack of the
      // closest delegating landmark here. The reason is that we might change alias on
      // an item when the landmark key changes, i.e. the items is considered to be a
      // new item. We therefore want to keep the old alias in memory and not add the
      // the new one to memory.
    }

    focusTree.elements.set(focusable.id, focusable);
  } else {
    if (false) {}

    focusTree.elements.set(focusable.id, focusable);

    if (focusable.alias != null) {
      focusTree.aliases.set(focusable.alias, focusable.id);
    }

    if (parentId != null) {
      var _focusTree$children$g;

      // Update parent's children
      const siblings = (_focusTree$children$g = focusTree.children.get(parentId)) !== null && _focusTree$children$g !== void 0 ? _focusTree$children$g : new Set();
      siblings.add(focusable.id);
      focusTree.children.set(parentId, siblings); // Update parents

      focusTree.parents.set(focusable.id, parentId); // Update dynasty

      if (closestDelegatingAncestor != null) {
        const dynasty = maybeDynasty !== null && maybeDynasty !== void 0 ? maybeDynasty : new Set();
        dynasty.add(focusable.id);
        focusTree.dynasty.set(closestDelegatingAncestor.id, dynasty);
      } // Update binding landmark descendants


      if (isBindingLandmark(focusable)) {
        for (let currentId = parentId; currentId != null; currentId = focusTree.parents.get(currentId)) {
          var _focusTree$bindingLan;

          const current = focusTree.elements.get(currentId);

          if (current == null) {
            break;
          }

          const descendants = (_focusTree$bindingLan = focusTree.bindingLandmarkDescendants.get(current.id)) !== null && _focusTree$bindingLan !== void 0 ? _focusTree$bindingLan : new Set();
          descendants.add(focusable.id);
          focusTree.bindingLandmarkDescendants.set(current.id, descendants);

          if (isBindingLandmark(current)) {
            break;
          }
        }
      }
    } // If a delegating landmark is added after its children, we update its dynasty.


    if (isLandmark && isDelegatingLandmark(focusable)) {
      const landmarkChildren = focusTree.children.get(focusable.id);

      if (landmarkChildren != null) {
        var _focusTree$dynasty$ge;

        const dynasty = (_focusTree$dynasty$ge = focusTree.dynasty.get(focusable.id)) !== null && _focusTree$dynasty$ge !== void 0 ? _focusTree$dynasty$ge : new Set();

        const updateDynastyRecursively = children => {
          if (children == null) return;

          for (const childId of children) {
            if (!dynasty.has(childId)) {
              dynasty.add(childId);
            }

            const child = focusTree.elements.get(childId);

            if (!isDelegatingLandmark(child)) {
              const grandChildren = focusTree.children.get(childId);
              updateDynastyRecursively(grandChildren);
            }
          }
        };

        updateDynastyRecursively(landmarkChildren);
        focusTree.dynasty.set(focusable.id, dynasty);
      }
    }
  }

  if (shouldSuggestNewFocus && (isLandmarkBecomingEnabled || isLandmarkBeingAddedEnabled)) {
    // If `focusable` is not a binding landmark, the delegated id will be undefined
    const delegatedFocus = delegateToBindingLandmark(focusTree, focusable);

    if (delegatedFocus != null) {
      return delegatedFocus;
    }

    const enabledBindingLandmarkDescendants = getEnabledBindingLandmarkDescendantIds(focusTree, focusable.id);

    if (enabledBindingLandmarkDescendants != null && enabledBindingLandmarkDescendants.length > 0) {
      const enabledBindingLandmarkId = enabledBindingLandmarkDescendants[0];
      const enabledBindingLandmark = getElement(focusTree, enabledBindingLandmarkId);

      if (enabledBindingLandmark != null) {
        return delegateToBindingLandmark(focusTree, enabledBindingLandmark);
      }
    }
  }

  if (isLandmarkBecomingDisabled) {
    const newStack = [];
    const discardedStack = new Set();

    for (let i = 0; i < focusTree.bindingLandmarkStack.length; i++) {
      const elementId = focusTree.bindingLandmarkStack[i];

      if (isAncestorOf(focusTree, focusable.id, elementId) || focusable.id === elementId) {
        discardedStack.add(elementId);
      } else {
        newStack.push(elementId);
      }
    } // Replace the old stack with the new stack


    focusTree.bindingLandmarkStack = newStack;

    if (shouldSuggestNewFocus) {
      if (focusedNumberId != null) {
        for (const discardedId of discardedStack) {
          if (isAncestorOf(focusTree, discardedId, focusedNumberId) && focusTree.bindingLandmarkStack.length > 0) {
            const topOfStack = getElement(focusTree, focusTree.bindingLandmarkStack[focusTree.bindingLandmarkStack.length - 1]);

            if (topOfStack != null && isBindingLandmark(topOfStack)) {
              const delegatedFocus = topOfStack.getDelegatedFocus();

              if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
                return delegatedFocus;
              }
            }
          }
        }
      }

      const isFocusableAncestorOfFocusedId = focusedNumberId != null && isAncestorOf(focusTree, focusable.id, focusedNumberId);

      if (isFocusableAncestorOfFocusedId || isFocusableFocused) {
        const delegatedFocus = getDelegatedFocusFromAncestor(focusTree, focusable.id);

        if (delegatedFocus != null) {
          return delegatedFocus;
        }
      }
    }
  } // Re-delegate focus of a Landmark if:
  // 1a) Alias for delegation changed and focused origin is from a tree mutation
  // 1b) OR landmark key changed
  // 2a) The Landmark itself is focused
  // 2b) OR a decedent item of the Landmark is currently focused and is the previous alias


  if (shouldSuggestNewFocus && isLandmark && focusedNumberId != null && previousFocusable != null && isDelegatingLandmark(focusable) && isDelegatingLandmark(previousFocusable)) {
    const aliasForDelegationDidChange = previousFocusable.delegateFocusByAlias !== focusable.delegateFocusByAlias;
    const focusedOriginIsFromTreeMutation = focused.origin === FocusOrigin.FocusTreeMutation;
    const landmarkKeyDidChange = focusable.landmarkKey !== previousFocusable.landmarkKey;

    if (aliasForDelegationDidChange && focusedOriginIsFromTreeMutation || landmarkKeyDidChange) {
      if (isFocusableFocused || isAncestorOf(focusTree, focusable.id, focusedNumberId)) {
        const delegatedFocus = focusable.getDelegatedFocus();

        if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
          return delegatedFocus;
        }
      }
    }
  } // Re-delegate if alias for an focusable changes and if:
  // 1) Current focused originates from a tree mutation
  // 2) The focusable is in the closest delegating Landmark's dynasty
  // 3) The closest delegating Landmark is delegating by alias or delegating by memory (memory stores aliases)
  // 4a) The closest delegating Landmark is focused
  // 4b) OR the focused id is a decedent of the closest delegating Landmark


  if (shouldSuggestNewFocus && isFocusableEnabled && focused.origin === FocusOrigin.FocusTreeMutation && focusedNumberId != null) {
    const hasAliasChanged = previousFocusable == null || previousFocusable.alias !== focusable.alias;

    if (hasAliasChanged && closestDelegatingLandmark != null && (closestDelegatingLandmark.delegateFocusByAlias != null || closestDelegatingLandmark.delegationMemoryStack != null)) {
      if (closestDelegatingLandmark.id === focusedNumberId || isAncestorOf(focusTree, closestDelegatingLandmark.id, focusedNumberId)) {
        const delegatedFocus = closestDelegatingLandmark.getDelegatedFocus();

        if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
          return delegatedFocus;
        }
      }
    }
  }

  if (shouldSuggestNewFocus && (isItemBecomingEnabled || isItemBeingAddedEnabled || isLandmarkBecomingEnabled || isLandmarkBeingAddedEnabled) && dynastyHaveNoEnabledItems && closestDelegatingAncestor != null && focusedId != null && closestDelegatingAncestor.id === focusedId) {
    const delegatedFocus = closestDelegatingAncestor.getDelegatedFocus();

    if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
      return delegatedFocus;
    }
  }

  if (shouldSuggestNewFocus && isFocusableFocused && updatedIdAfterAliasMutation != null) {
    return {
      id: updatedIdAfterAliasMutation,
      reason: NewFocusSuggestionReason.FocusableAliasMutation
    };
  }
}
function removeShortcut(focusTree, elementId, actionButton) {
  const shortcuts = focusTree.shortcuts.get(elementId);

  if (!shortcuts) {
    return;
  }

  shortcuts.delete(actionButton);

  if (shortcuts.size === 0) {
    focusTree.shortcuts.delete(elementId);
  }
}
function removeFocusable(focusTree, focusableId, focused) {
  const focusable = focusTree.elements.get(focusableId);
  if (!focusable) return;
  const focusedId = focused.id;
  const focusedNumberId = getIdFromAliasOrId(focusTree, focusedId);
  const parentId = focusTree.parents.get(focusableId);

  if (focusable.alias != null) {
    focusTree.aliases.delete(focusable.alias);
  }

  if (parentId != null) {
    // Update the children of the parent
    const siblings = focusTree.children.get(parentId);

    if (siblings != null) {
      siblings.delete(focusableId);
    } // Update parents


    focusTree.parents.delete(focusableId); // Update dynasty

    const closestDelegatingAncestor = getClosestDelegatingAncestor(focusTree, focusableId);

    if (closestDelegatingAncestor != null) {
      const coDescendants = focusTree.dynasty.get(closestDelegatingAncestor.id);

      if (coDescendants != null) {
        coDescendants.delete(focusableId);
      }
    } // Update delegation memory of closest delegating landmark
    // NOTE: if ths focusable has been stored as an alias in the
    // closest delegating landmark's memory stack, we are deliberately
    // not removing that. The reason is that we might want to remember
    // the alias if a new focus item gets mounted with that alias, eg.
    // when going back and forth between tabs having the same landmark,
    // but with different landmark keys. An example of this is the mount
    // tabs in badger's character select screen.


    if (closestDelegatingAncestor != null && closestDelegatingAncestor.type !== types_FocusableType.ROOT && closestDelegatingAncestor.delegationMemoryStack != null) {
      closestDelegatingAncestor.delegationMemoryStack.forEach(memoryStack => {
        const indexInStack = memoryStack.indexOf(focusableId);
        memoryStack.splice(indexInStack, 1);
      });
    } // Update binding landmark descendants


    if (focusable.type === types_FocusableType.LANDMARK) {
      focusTree.bindingLandmarkDescendants.delete(focusable.id);

      if (isBindingLandmark(focusable)) {
        for (const [_, bindingLandmarkDescendants] of focusTree.bindingLandmarkDescendants) {
          bindingLandmarkDescendants.delete(focusable.id);
        }
      }
    }
  }

  focusTree.parents.delete(focusableId);
  focusTree.elements.delete(focusableId);
  focusTree.shortcuts.delete(focusableId);

  if (isBindingLandmark(focusable)) {
    const indexInStack = focusTree.bindingLandmarkStack.indexOf(focusable.id);

    if (indexInStack !== -1) {
      const wasTopOfStack = indexInStack === focusTree.bindingLandmarkStack.length - 1;
      focusTree.bindingLandmarkStack.splice(indexInStack);

      if (wasTopOfStack && focusTree.bindingLandmarkStack.length > 0) {
        const nextBindingLandmarkInStack = getElement(focusTree, focusTree.bindingLandmarkStack[focusTree.bindingLandmarkStack.length - 1]);

        if (nextBindingLandmarkInStack != null && isBindingLandmark(nextBindingLandmarkInStack)) {
          const delegatedFocus = nextBindingLandmarkInStack.getDelegatedFocus();

          if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
            return delegatedFocus;
          }
        }
      }
    }
  }

  const wasFocusableAncestorOfFocusedId = focusedNumberId != null && isAncestorOf(focusTree, focusable.id, focusedNumberId);
  const wasSameAsFocusedId = focusedNumberId === focusable.id;

  if (parentId != null && (wasFocusableAncestorOfFocusedId || wasSameAsFocusedId)) {
    const delegatedId = getDelegatedFocusFromAncestor(focusTree, parentId);

    if (delegatedId != null) {
      return delegatedId;
    }
  }
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/navigate/logit.ts
/**
 * logit.
 *
 * 	- Non-linear, continuous, and differentiable logistic function. Inverse of sigmoid
 *
 * https://en.wikipedia.org/wiki/Logit
 *
 * @param number z
 */
function logit(z) {
  return Math.log(z / (1 - z));
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/navigate/weights.ts


const weights = {
  matchScrollableDirectionWeight: 0.000001,
  noWeight: 1,
  projectionOverlapWeightMax: 10000
};
const getScrollableAncestorMultiplier = (tree, scrollableAncestorId, currentCandidateId, navigationAxis) => {
  if (scrollableAncestorId == null) {
    return weights.noWeight;
  }

  const scrollableAncestor = tree.elements.get(scrollableAncestorId);

  if (scrollableAncestor == null || scrollableAncestor.type !== types_FocusableType.LANDMARK) {
    return weights.noWeight;
  }

  if (hasAnyAncestorWithId(tree, currentCandidateId, scrollableAncestorId) && scrollableAncestor.scrollAxis == navigationAxis) {
    return weights.matchScrollableDirectionWeight;
  }

  return weights.noWeight;
};
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/navigate/navigate.ts








const NINETY_DEGREES_IN_RADIANS = Math.PI / 2;
const SEVENTY_FIVE_DEGREES_IN_RADIANS = 5 * (Math.PI / 12);
function navigateToAdjacentElement(focusTree, focusedId, reverse = false) {
  const parentId = focusTree.parents.get(focusedId);

  if (parentId == null) {
    return null;
  }

  const parent = focusTree.elements.get(parentId);
  const focusedElement = focusTree.elements.get(focusedId);

  if (parent == null || parent.ref == null || focusedElement == null) {
    return null;
  }

  const htmlElements = parent.ref.querySelectorAll(`[${DATA_FOCUSABLE_ID}]`);

  for (let i = 0; i < htmlElements.length; i++) {
    const element = htmlElements[i];

    if (element === focusedElement.ref) {
      var _htmlElements$nextInd;

      let nextIndex = i + (reverse ? -1 : 1);

      if (nextIndex < 0) {
        nextIndex = htmlElements.length - 1;
      } else if (nextIndex >= htmlElements.length) {
        nextIndex = 0;
      }

      const adjacentElementId = (_htmlElements$nextInd = htmlElements[nextIndex]) === null || _htmlElements$nextInd === void 0 ? void 0 : _htmlElements$nextInd.getAttribute(DATA_FOCUSABLE_ID);

      if (adjacentElementId == null) {
        return null;
      }

      const adjacentElement = focusTree.elements.get(parseInt(adjacentElementId));

      if (adjacentElement == null) {
        return null;
      }

      if (isAnyAncestorDisabled(focusTree, adjacentElement.id)) {
        continue;
      }

      return adjacentElement.id;
    }
  }

  return null;
}
function legacyNavigateToAdjacentElement(focusTree, focusedId, reverse = false) {
  if (focusedId == null) return undefined;
  const htmlElements = document.body.querySelectorAll(`[${types_DATA_FOCUSABLE_ID}]`);
  const currentDomElement = document.body.querySelector(`[${types_DATA_FOCUSABLE_ID}='${focusedId}']`);

  if (currentDomElement == null) {
    const focusedId = getFocusedIdFromDomElement(htmlElements[0]);

    if (focusedId == null) {
      return undefined;
    }

    if (treeQueries_isAnyAncestorDisabled(focusTree, focusedId)) {
      return undefined;
    }

    return focusedId;
  }

  const currentDomElementIndex = getCurrentDomElementIndex(currentDomElement, htmlElements);

  if (currentDomElementIndex == null) {
    return getFocusedIdFromDomElement(htmlElements[0]);
  }

  let startingIndex = reverse ? currentDomElementIndex - 1 : currentDomElementIndex + 1;

  while (currentDomElementIndex !== startingIndex) {
    if (startingIndex < 0) {
      startingIndex = htmlElements.length - 1;
    }

    if (startingIndex > htmlElements.length - 1) {
      startingIndex = 0;
    }

    const focusedId = getFocusedIdFromDomElement(htmlElements[startingIndex]);

    if (focusedId != null) {
      const element = focusTree.elements.get(focusedId);

      if (element != null && !treeQueries_isAnyAncestorDisabled(focusTree, focusedId)) {
        if (element.type !== types_FocusableType.LANDMARK && element.disabled !== true && element.hidden !== true) {
          return focusedId;
        }
      }
    }

    if (reverse) {
      startingIndex--;
    } else {
      startingIndex++;
    }
  }

  return;
}
/**
 * Ideally is supposed to be a minimizing score function where distance can infinitely increase your score
 * (which makes you a worse candidate) and angle should exponentially increase your score the higher it is
 * to favor smaller angles more in relation to closeness + bad angle.
 *
 * Projection overlap (that is, if the target box is facing the current focusable from the side where the
 * motion is going to) also is taken into account. If there is overlap, then the score is improved to
 * account for the intuitive perception that overlapping targets should be preferred.
 *
 * @param tree
 * @param focusedId
 * @param arrow
 * @returns
 */

const navigate_navigateToDirection = (tree, focusedId, arrow) => {
  var _tree$elements$get, _tree$elements$get$re;

  if (focusedId == null) {
    var _getTopLeftElementId;

    return (_getTopLeftElementId = getTopLeftElementId(tree)) !== null && _getTopLeftElementId !== void 0 ? _getTopLeftElementId : ROOT_NODE_ID;
  }

  const startingElementPosition = (_tree$elements$get = tree.elements.get(focusedId)) === null || _tree$elements$get === void 0 ? void 0 : (_tree$elements$get$re = _tree$elements$get.ref) === null || _tree$elements$get$re === void 0 ? void 0 : _tree$elements$get$re.getBoundingClientRect();

  if (startingElementPosition == null) {
    var _getTopLeftElementId2;

    return (_getTopLeftElementId2 = getTopLeftElementId(tree)) !== null && _getTopLeftElementId2 !== void 0 ? _getTopLeftElementId2 : focusedId;
  }

  const startingElementCenter = getTheCenterOfPostion(startingElementPosition);
  let bestCandidateId = focusedId;
  let bestCandidateScore = Infinity;
  const mainAxis = arrow === Arrows.LEFT || arrow === Arrows.RIGHT ? 1 : 0;
  const navigationAxis = arrow === Arrows.LEFT || arrow === Arrows.RIGHT ? ScrollAxis.HORIZONTAL : ScrollAxis.VERTICAL;
  const crossAxis = mainAxis === 1 ? 0 : 1;
  const bindingAncestorId = getBindingAncestorId(tree, focusedId);
  const scrollableAncestorId = getScrollableAncestorId(tree, focusedId);

  if (tree.lastDirectionChange == null || !isSameAxis(tree.lastDirectionChange[0], arrow) && focusedId != null) {
    tree.lastDirectionChange = [arrow, focusedId];
  }

  for (const [id, element] of tree.elements) {
    var _element$ref, _getBoundingClientRec;

    if (id === focusedId) {
      continue;
    }

    if (element.type === types_FocusableType.LANDMARK && (element.scrollAxis == null || element.id === scrollableAncestorId) && !isDelegatingLandmark(element)) {
      continue;
    }

    if (element.type === types_FocusableType.LANDMARK && isAncestorOf(tree, id, focusedId)) {
      continue;
    }

    if (element.disabled || element.hidden) {
      continue;
    }

    if (treeQueries_isAnyAncestorDisabled(tree, id)) {
      continue;
    }

    if (doesAnyNonSharedAncestorDelegateFocus(tree, id, focusedId)) {
      continue;
    }

    if (element.type === types_FocusableType.LANDMARK && !isDelegatingLandmark(element)) {
      continue;
    }

    const currentElementPosition = (_element$ref = element.ref) === null || _element$ref === void 0 ? void 0 : _element$ref.getBoundingClientRect();

    if (currentElementPosition == null) {
      continue;
    }

    const positionOfLastDirectionChange = (_getBoundingClientRec = getBoundingClientRectById(tree, tree.lastDirectionChange[1])) !== null && _getBoundingClientRec !== void 0 ? _getBoundingClientRec : getBoundingClientRectById(tree, focusedId);

    if (positionOfLastDirectionChange == null) {
      continue;
    }

    const centerOfLastDirectionChange = getTheCenterOfPostion(positionOfLastDirectionChange);
    const currentElementCenter = getTheCenterOfPostion(currentElementPosition);
    const differenceMainAxisCenters = (startingElementCenter[mainAxis] - currentElementCenter[mainAxis]) * mapArrowToDirection[arrow];
    const differenceMainAxisEdges = (getEdgeCoordinate(startingElementPosition, arrow) - getEdgeCoordinate(currentElementPosition, mapArrowToOppositeArrow[arrow])) * mapArrowToDirection[arrow];
    const virtualDistanceInMainAxisCoordinate = differenceMainAxisEdges < 0 && differenceMainAxisCenters > 0 ? 0 : differenceMainAxisEdges;

    if (virtualDistanceInMainAxisCoordinate < 0) {
      continue;
    }

    const differenceCrossAxisCentersLastDirectionChange = centerOfLastDirectionChange[crossAxis] - currentElementCenter[crossAxis];
    const differenceCrossAxisCentersFocusedElement = startingElementCenter[crossAxis] - currentElementCenter[crossAxis];

    if (bindingAncestorId != null && !hasAnyAncestorWithId(tree, id, bindingAncestorId)) {
      continue;
    }

    const distanceMainAxisEdges = Math.max(virtualDistanceInMainAxisCoordinate, 1);
    const distanceMainAxisCenter = Math.abs(differenceMainAxisCenters); // unsignedTangentEdge is used as an exponential penalty depending on how wide the angle is for
    // navigating to the candidate element from current element, the idea is if a candidate has 0 angle
    // it should be way more preferred than a candidate with 10

    const unsignedTangentLastDirectionChangeEdge = Math.abs(differenceCrossAxisCentersLastDirectionChange / (virtualDistanceInMainAxisCoordinate === 0 ? 1 : virtualDistanceInMainAxisCoordinate));
    const radianAngleLastDirectionChangeEdge = Math.atan(unsignedTangentLastDirectionChangeEdge); // We don't want angles equal or wider than 90 degrees

    if (radianAngleLastDirectionChangeEdge >= NINETY_DEGREES_IN_RADIANS) {
      continue;
    } // Projection overlap: it's how much of the candidate box overlaps when you draw a projection of the
    // current box along the direction of motion, it's a value from 0 to 1 which is later inverted
    // for calculation purposes
    // In the end it's passed through a logit function
    // You can read about the logit function on Wikipedia https://en.wikipedia.org/wiki/Logit,
    // which exponentially adds a penalty depending on how much overlap you have, with total overlap adding
    // 0 penalty and no overlap capped at 10,000 penalty, in the end the magic number 10,000 doesn't matter so much
    // since in the situation where all candidates have 0 overlap, they all get the same penalty so it self-equalizes
    // and the number 10,000 was used because it's guaranteed to be above distance + unsignedTangent is supposed
    // to be in most cases


    const projectionOverlap = getProjectionOverlap(startingElementPosition, currentElementPosition, arrow);
    const invertedProjectionOverlap = 1 - projectionOverlap;
    const lowOrNoProjectionOverlapPenalty = Math.min(logit(invertedProjectionOverlap / 2 + 0.5), weights.projectionOverlapWeightMax); // WeightedTangent is unsignedTangent but with ties to overlap, so we apply a hueristic so that if a candidate has total overlap
    // then we treat it as if it's at angle 0, because we don't want to delve into the complications of
    // calculating the precise closest points between the two candidates to calculate a proper angle.

    const weightedTangentLastDirectionChange = unsignedTangentLastDirectionChangeEdge * invertedProjectionOverlap;
    const weightedRadianAngleLastDirectionChange = radianAngleLastDirectionChangeEdge * invertedProjectionOverlap; // We also need the angle as measured from the center of both components, instead of the edge,
    // to cover the special case when the target box is very close along main axis (distance ~1)
    // but to the side, without cross axis overlap, and it is also very large. In that case,
    // the angle as measured from the edge will be very, very wide (>89 degrees) but we don't
    // want to cut it out of the calculation if the center is not also at a very wide angle,
    // because a big enough box should intuitively get focus even if the edge angle is wide.

    const unsignedTangentCenterFocusedElement = Math.abs(differenceCrossAxisCentersFocusedElement / distanceMainAxisCenter);
    const radianAngleCenterFocusedElement = Math.atan(unsignedTangentCenterFocusedElement);

    if (weightedRadianAngleLastDirectionChange >= SEVENTY_FIVE_DEGREES_IN_RADIANS && radianAngleCenterFocusedElement >= SEVENTY_FIVE_DEGREES_IN_RADIANS) {
      continue;
    }

    const scrollableAncestorMultiplier = getScrollableAncestorMultiplier(tree, scrollableAncestorId, id, navigationAxis); // The score is basically a bunch of penalties you get depending on distnace, unsignedTangent, projection overlap
    // and whether or not you're inside the same scrollable parent

    const currentCandidateScore = (distanceMainAxisEdges + weightedTangentLastDirectionChange + lowOrNoProjectionOverlapPenalty) * scrollableAncestorMultiplier;

    if (bestCandidateScore > currentCandidateScore) {
      bestCandidateScore = currentCandidateScore;
      bestCandidateId = id;
    }
  }

  const bestCandidate = tree.elements.get(bestCandidateId);

  if (isDelegatingLandmark(bestCandidate)) {
    const delegatedFocus = bestCandidate.getDelegatedFocus();

    if (delegatedFocus !== react_facet_src.NO_VALUE && delegatedFocus != null) {
      // Make sure the delegated id exists in the focus tree before trying to navigate there.
      // A landmark can delegate for example to an alias that is not yet present in the tree,
      // similar to a deep link via URL.
      const delegatedId = getIdFromAliasOrId(tree, delegatedFocus.id);

      if (delegatedId != null) {
        return delegatedId;
      }
    }
  }

  return bestCandidateId;
};
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/debugExtension/adapter.ts
function adapter_getElement(id, tree) {
  var _tree$elements$find;

  const [, element] = (_tree$elements$find = tree.elements.find(mapItem => mapItem[0] === id)) !== null && _tree$elements$find !== void 0 ? _tree$elements$find : [];
  return element;
}

function expandTree(parentId, tree) {
  const childrenMap = tree.children.find(mapItem => mapItem[0] === parentId);
  if (childrenMap == null) return [];
  const [, childrenIds] = childrenMap;
  const childrenBodies = childrenIds.map(childId => {
    const grandChildren = expandTree(childId, tree);
    const childBody = adapter_getElement(childId, tree);
    return {
      id: `${childId}`,
      data: childBody,
      children: grandChildren
    };
  });
  return childrenBodies;
}

function focusTreeToGeneralTree(focusTree) {
  const startingPointIds = focusTree.children.filter(currentElement => {
    const currentElementId = currentElement[0];
    const isOrphanAncestor = focusTree.parents.every(item => item[0] !== currentElementId);
    return isOrphanAncestor;
  }, []);
  const generalTree = getGeneralTree(startingPointIds, focusTree);
  return {
    id: '0',
    data: {
      id: 0,
      ref: false,
      type: 0,
      isFocused: false,
      shortcuts: []
    },
    children: generalTree
  };
}

function getGeneralTree(startPointIds, focusTree) {
  if (startPointIds.length === 0) return [];
  const [head, ...rest] = startPointIds;
  const headId = head[0];
  const headElement = adapter_getElement(headId, focusTree);

  if (headElement == null) {
    return getGeneralTree(rest, focusTree);
  }

  return [{
    id: `${headElement.id}`,
    data: headElement,
    children: expandTree(headElement.id, focusTree)
  }, ...getGeneralTree(rest, focusTree)];
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/debugExtension/types.ts
let DEBUG_MESSAGE_TYPE;

(function (DEBUG_MESSAGE_TYPE) {
  DEBUG_MESSAGE_TYPE["TREE_UPDATE"] = "TREE_UPDATE";
  DEBUG_MESSAGE_TYPE["BROWSER_ON_FOCUS"] = "BROWSER_ON_FOCUS";
  DEBUG_MESSAGE_TYPE["BROWSER_ON_FOCUS_HANDLER"] = "BROWSER_ON_FOCUS_HANDLER";
  DEBUG_MESSAGE_TYPE["BROWSER_ON_BLUR_HANDLER"] = "BROWSER_ON_BLUR_HANDLER";
  DEBUG_MESSAGE_TYPE["BROWSER_ON_DELEGATE"] = "BROWSER_ON_DELEGATE";
  DEBUG_MESSAGE_TYPE["BROWSER_ON_INSPECT_DOM_REF"] = "BROWSER_ON_INSPECT_DOM_REF";
  DEBUG_MESSAGE_TYPE["BROWSER_ON_NAVIGATE_LEFT"] = "BROWSER_ON_NAVIGATE_LEFT";
  DEBUG_MESSAGE_TYPE["BROWSER_ON_NAVIGATE_UP"] = "BROWSER_ON_NAVIGATE_UP";
  DEBUG_MESSAGE_TYPE["BROWSER_ON_NAVIGATE_DOWN"] = "BROWSER_ON_NAVIGATE_DOWN";
  DEBUG_MESSAGE_TYPE["BROWSER_ON_NAVIGATE_RIGHT"] = "BROWSER_ON_NAVIGATE_RIGHT";
  DEBUG_MESSAGE_TYPE["BROWSER_ON_SHORTCUT"] = "BROWSER_ON_SHORTCUT";
  DEBUG_MESSAGE_TYPE["BACKGROUND_ON_INSPECT_DOM_REF"] = "BACKGROUND_ON_INSPECT_DOM_REF";
  DEBUG_MESSAGE_TYPE["BACKGROUND_ON_UNINSPECT_DOM_REF"] = "BACKGROUND_ON_UNINSPECT_DOM_REF";
  DEBUG_MESSAGE_TYPE["BROWSER_ACTIVATE_KEYBOARD"] = "BROWSER_ACTIVATE_KEYBOARD";
  DEBUG_MESSAGE_TYPE["BROWSER_ACTIVATE_GAMEPAD"] = "BROWSER_ACTIVATE_GAMEPAD";
  DEBUG_MESSAGE_TYPE["BROWSER_ACTIVATE_MOUSE"] = "BROWSER_ACTIVATE_MOUSE";
  DEBUG_MESSAGE_TYPE["BROWSER_ACTIVATE_TOUCH"] = "BROWSER_ACTIVATE_TOUCH";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_A"] = "BROWSER_INPUT_SIMULATE_A";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_B"] = "BROWSER_INPUT_SIMULATE_B";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_X"] = "BROWSER_INPUT_SIMULATE_X";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_Y"] = "BROWSER_INPUT_SIMULATE_Y";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_SELECT"] = "BROWSER_INPUT_SIMULATE_SELECT";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_START"] = "BROWSER_INPUT_SIMULATE_START";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_LT"] = "BROWSER_INPUT_SIMULATE_LT";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_RT"] = "BROWSER_INPUT_SIMULATE_RT";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_LB"] = "BROWSER_INPUT_SIMULATE_LB";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_RB"] = "BROWSER_INPUT_SIMULATE_RB";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_L3"] = "BROWSER_INPUT_SIMULATE_L3";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_R3"] = "BROWSER_INPUT_SIMULATE_R3";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_LEFT"] = "BROWSER_INPUT_SIMULATE_LEFT";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_RIGHT"] = "BROWSER_INPUT_SIMULATE_RIGHT";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_UP"] = "BROWSER_INPUT_SIMULATE_UP";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_DOWN"] = "BROWSER_INPUT_SIMULATE_DOWN";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_NEXT"] = "BROWSER_INPUT_SIMULATE_NEXT";
  DEBUG_MESSAGE_TYPE["BROWSER_INPUT_SIMULATE_PREV"] = "BROWSER_INPUT_SIMULATE_PREV";
})(DEBUG_MESSAGE_TYPE || (DEBUG_MESSAGE_TYPE = {}));
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/debugExtension/messaging.ts
function messaging_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function messaging_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { messaging_ownKeys(Object(source), true).forEach(function (key) { messaging_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { messaging_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function messaging_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function messaging_extends() { messaging_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return messaging_extends.apply(this, arguments); }







let hasBeenCalled = false;

const messaging_debounce = func => {
  if (hasBeenCalled === false) {
    setTimeout(() => {
      func();
      hasBeenCalled = false;
    });
  }

  hasBeenCalled = true;
};

const useDebugFocusTreeExtension = (focusTreeFacet, focusIdFacet, handleFocusedIdChange) => {
  const focusTreeFacetRef = (0,react_facet_src.useFacetRef)(focusTreeFacet);
  const focusIdFacetRef = (0,react_facet_src.useFacetRef)(focusIdFacet);
  const debugTreeCallback = (0,react.useCallback)(() => {
    const focusTree = focusTreeFacetRef.current;
    const focusId = focusIdFacetRef.current;
    if (focusTree === react_facet_src.NO_VALUE || focusId === react_facet_src.NO_VALUE) return;
    debugTree(focusTree, focusId);
  }, [focusTreeFacetRef, focusIdFacetRef]); // Send tree updates to extension

  (0,react_facet_src.useFacetEffect)(() => {
    // Add a 0 timeout debounce, so that synchronous calls get buffered.
    // We are not interested in the changes to the focus tree that
    // happen synchronously
    messaging_debounce(() => debugTreeCallback());
  }, [debugTreeCallback], [focusTreeFacet, focusIdFacet]);
  (0,react.useEffect)(() => {
    if (window.__REACT_FACET_DEVTOOLS_GLOBAL_HOOK__ != null) {
      window.__REACT_FACET_DEVTOOLS_GLOBAL_HOOK__.listen(unknownEvent => {
        const event = unknownEvent;
        const focusTree = focusTreeFacetRef.current;
        const focusId = focusIdFacetRef.current;
        if (focusTree === react_facet_src.NO_VALUE || focusId === react_facet_src.NO_VALUE) return;

        switch (event.type) {
          case DEBUG_MESSAGE_TYPE.BROWSER_ON_FOCUS:
            {
              handleFocusedIdChange(event.payload.focusableId);
              return;
            }

          case DEBUG_MESSAGE_TYPE.BROWSER_ON_FOCUS_HANDLER:
            {
              var _getElement, _getElement$onFocus;

              (_getElement = getElement(focusTree, event.payload.focusableId)) === null || _getElement === void 0 ? void 0 : (_getElement$onFocus = _getElement.onFocus) === null || _getElement$onFocus === void 0 ? void 0 : _getElement$onFocus.call(_getElement);
              return;
            }

          case DEBUG_MESSAGE_TYPE.BROWSER_ON_BLUR_HANDLER:
            {
              var _getElement2, _getElement2$onBlur;

              (_getElement2 = getElement(focusTree, event.payload.focusableId)) === null || _getElement2 === void 0 ? void 0 : (_getElement2$onBlur = _getElement2.onBlur) === null || _getElement2$onBlur === void 0 ? void 0 : _getElement2$onBlur.call(_getElement2);
              return;
            }

          case DEBUG_MESSAGE_TYPE.BROWSER_ON_NAVIGATE_UP:
            {
              var _getElement3, _getElement3$onUp;

              (_getElement3 = getElement(focusTree, event.payload.focusableId)) === null || _getElement3 === void 0 ? void 0 : (_getElement3$onUp = _getElement3.onUp) === null || _getElement3$onUp === void 0 ? void 0 : _getElement3$onUp.call(_getElement3);
              return;
            }

          case DEBUG_MESSAGE_TYPE.BROWSER_ON_NAVIGATE_DOWN:
            {
              var _getElement4, _getElement4$onDown;

              (_getElement4 = getElement(focusTree, event.payload.focusableId)) === null || _getElement4 === void 0 ? void 0 : (_getElement4$onDown = _getElement4.onDown) === null || _getElement4$onDown === void 0 ? void 0 : _getElement4$onDown.call(_getElement4);
              return;
            }

          case DEBUG_MESSAGE_TYPE.BROWSER_ON_NAVIGATE_RIGHT:
            {
              var _getElement5, _getElement5$onRight;

              (_getElement5 = getElement(focusTree, event.payload.focusableId)) === null || _getElement5 === void 0 ? void 0 : (_getElement5$onRight = _getElement5.onRight) === null || _getElement5$onRight === void 0 ? void 0 : _getElement5$onRight.call(_getElement5);
              return;
            }

          case DEBUG_MESSAGE_TYPE.BROWSER_ON_NAVIGATE_LEFT:
            {
              var _getElement6, _getElement6$onLeft;

              (_getElement6 = getElement(focusTree, event.payload.focusableId)) === null || _getElement6 === void 0 ? void 0 : (_getElement6$onLeft = _getElement6.onLeft) === null || _getElement6$onLeft === void 0 ? void 0 : _getElement6$onLeft.call(_getElement6);
              return;
            }

          case DEBUG_MESSAGE_TYPE.BROWSER_ON_SHORTCUT:
            {
              const elementId = getIdFromAliasOrId(focusTree, event.payload.focusableId);
              if (elementId == null) return;
              const shortcut = treeQueries_getShortcut(focusTree, elementId, event.payload.shortcut);
              shortcut === null || shortcut === void 0 ? void 0 : shortcut.callback();
              return;
            }

          case DEBUG_MESSAGE_TYPE.BROWSER_ON_INSPECT_DOM_REF:
            {
              const element = getElement(focusTree, event.payload.focusableId);
              if ((element === null || element === void 0 ? void 0 : element.ref) == null) return;
              console.log(`[FOCUS TREE DEBUGGER]: inspecting element ${element.id}`, element.ref);
              return;
            }

          case DEBUG_MESSAGE_TYPE.BROWSER_ON_DELEGATE:
            {
              const element = getElement(focusTree, event.payload.focusableId);
              if (!isDelegatingLandmark(element) && !isRoot(element)) return;
              const delegatedFocus = element.getDelegatedFocus();

              if (delegatedFocus != null && delegatedFocus != react_facet_src.NO_VALUE) {
                handleFocusedIdChange(delegatedFocus.id);
              }

              return;
            }
        }
      });
    }
  }, [handleFocusedIdChange, focusTreeFacetRef, focusIdFacetRef]);
};

const getJSONShortcuts = (focusTree, focusedId) => {
  const shortcutsMap = getShortcutsFor(focusTree, focusedId);
  if (shortcutsMap == null) return [];
  const shortcuts = [];

  for (const [key, value] of shortcutsMap) {
    const shortcutJSON = {
      buttonType: String(key),
      inputLegend: value.inputLegend
    };
    shortcuts.push(shortcutJSON);
  }

  return shortcuts;
};

const getIsFocused = (focusTree, focusedId, elementId) => {
  const focusedElementId = getIdFromAliasOrId(focusTree, focusedId);
  return focusedElementId === elementId;
};

function debugTree(focusTree, focusedId) {
  const adaptedFocusTree = {
    elements: Array.from(focusTree.elements.entries()).map(([id, _ref]) => {
      let element = messaging_extends({}, _ref);

      if (element.type === types_FocusableType.ROOT) {
        const childrenMap = focusTree.children.get(element.id);
        const debugRoot = {
          id: element.id,
          type: types_FocusableType.ROOT,
          ref: null,
          onFocus: undefined,
          onBlur: undefined,
          onRight: undefined,
          onLeft: undefined,
          onUp: undefined,
          onDown: undefined,
          alias: undefined,
          disabled: false,
          hidden: false,
          getDelegatedFocus: true,
          disableScrollIntoView: undefined,
          scrollAxis: null,
          isFocused: getIsFocused(focusTree, focusedId, element.id),
          shortcuts: getJSONShortcuts(focusTree, element.id),
          hasChildren: childrenMap != null && childrenMap.size > 0
        };
        return [id, debugRoot];
      }

      if (element.type === types_FocusableType.LANDMARK) {
        var _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;

        const childrenMap = focusTree.children.get(element.id);

        const debugContainer = messaging_objectSpread(messaging_objectSpread({
          id: element.id,
          type: types_FocusableType.LANDMARK,
          scrollAlign: element.scrollAlign,
          scrollOffset: element.scrollOffset,
          scrollSpeedFactor: element.scrollSpeedFactor,
          shouldScrollWithAnalog: element.shouldScrollWithAnalog,
          scrollIntoViewAlign: element.scrollIntoViewAlign,
          scrollIntoViewOffset: element.scrollIntoViewOffset,
          scrollIntoViewSpeedFactor: element.scrollIntoViewSpeedFactor,
          getDelegatedFocus: isDelegatingLandmark(element)
        }, isBindingLandmark(element) ? {
          shouldBindFocus: true
        } : {}), {}, {
          ref: element.ref != null,
          onFocus: (_ref2 = (element === null || element === void 0 ? void 0 : element.onFocus) && true) !== null && _ref2 !== void 0 ? _ref2 : false,
          onBlur: (_ref3 = (element === null || element === void 0 ? void 0 : element.onBlur) && true) !== null && _ref3 !== void 0 ? _ref3 : false,
          onRight: (_ref4 = (element === null || element === void 0 ? void 0 : element.onRight) && true) !== null && _ref4 !== void 0 ? _ref4 : false,
          onLeft: (_ref5 = (element === null || element === void 0 ? void 0 : element.onLeft) && true) !== null && _ref5 !== void 0 ? _ref5 : false,
          onUp: (_ref6 = (element === null || element === void 0 ? void 0 : element.onUp) && true) !== null && _ref6 !== void 0 ? _ref6 : false,
          onDown: (_ref7 = (element === null || element === void 0 ? void 0 : element.onDown) && true) !== null && _ref7 !== void 0 ? _ref7 : false,
          isFocused: getIsFocused(focusTree, focusedId, element.id),
          shortcuts: getJSONShortcuts(focusTree, element.id),
          hasChildren: childrenMap != null && childrenMap.size > 0
        });

        return [id, debugContainer];
      }

      const debugItem = messaging_objectSpread(messaging_objectSpread({}, element), {}, {
        ref: element.ref != null,
        onFocus: (element === null || element === void 0 ? void 0 : element.onFocus) != null,
        onBlur: (element === null || element === void 0 ? void 0 : element.onBlur) != null,
        onRight: (element === null || element === void 0 ? void 0 : element.onRight) != null,
        onLeft: (element === null || element === void 0 ? void 0 : element.onLeft) != null,
        onUp: (element === null || element === void 0 ? void 0 : element.onUp) != null,
        onDown: (element === null || element === void 0 ? void 0 : element.onDown) != null,
        isFocused: getIsFocused(focusTree, focusedId, element.id),
        shortcuts: getJSONShortcuts(focusTree, element.id)
      });

      return [id, debugItem];
    }),
    aliases: Array.from(focusTree.aliases.entries()),
    children: Array.from(focusTree.children.entries()).map(([id, children]) => [id, Array.from(children.values())]),
    parents: Array.from(focusTree.parents.entries()),
    history: focusTree.history,
    lastDirectionChange: focusTree.lastDirectionChange
  };
  const generalTree = focusTreeToGeneralTree(adaptedFocusTree);

  if (window.__REACT_FACET_DEVTOOLS_GLOBAL_HOOK__ != null) {
    window.__REACT_FACET_DEVTOOLS_GLOBAL_HOOK__.send({
      type: DEBUG_MESSAGE_TYPE.TREE_UPDATE,
      payload: {
        focusedId,
        generalTree
      }
    });
  }
}
;// CONCATENATED MODULE: ./packages/react-gamepad-driver-visual/src/setupInput/throttleByName.ts

const throttleByName_FIRST_THROTTLE_DELAY = 400;
const throttleByName_MEDIUM_THROTTLE_RATE = 100;
const throttleByName_FAST_THROTTLE_RATE = 40;
/**
 * How many presses we should have triggered before going to fast speed
 */

const throttleByName_FAST_REPETITION_COUNT_WAIT = 16;
function constructThrottleByName() {
  const timestamps = throttleByName_initMetrics();
  const pressCounts = throttleByName_initMetrics();
  return (buttonType, pressed, gamepadIndex) => {
    if (!pressed) {
      timestamps[gamepadIndex][buttonType] = 0;
      pressCounts[gamepadIndex][buttonType] = 0;
    } else {
      const now = Date.now();
      const timestamp = timestamps[gamepadIndex][buttonType] || 0;
      const pressCount = pressCounts[gamepadIndex][buttonType] || 0;
      const delta = now - timestamp;

      if (pressCount === 0) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = 1;
        return buttonType;
      }

      if (pressCount === 1 && delta > throttleByName_FIRST_THROTTLE_DELAY) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = 2;
        return buttonType;
      }

      if (pressCount > 1 && pressCount < throttleByName_FAST_REPETITION_COUNT_WAIT && delta > throttleByName_MEDIUM_THROTTLE_RATE) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = pressCount + 1;
        return buttonType;
      }

      if (pressCount > throttleByName_FAST_REPETITION_COUNT_WAIT - 1 && delta > throttleByName_FAST_THROTTLE_RATE) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = pressCount + 1;
        return buttonType;
      }
    }
  };
}

const throttleByName_initMetrics = () => {
  const metrics = {
    0: throttleByName_initButtons(),
    1: throttleByName_initButtons(),
    2: throttleByName_initButtons(),
    3: throttleByName_initButtons()
  };
  return metrics;
};

const throttleByName_initButtons = () => {
  return {
    [types_ButtonType.A]: 0,
    [types_ButtonType.B]: 0,
    [types_ButtonType.X]: 0,
    [types_ButtonType.Y]: 0,
    [types_ButtonType.START]: 0,
    [types_ButtonType.SELECT]: 0,
    [types_ButtonType.XBOX]: 0,
    [types_ButtonType.RIGHT_TRIGGER]: 0,
    [types_ButtonType.LEFT_TRIGGER]: 0,
    [types_ButtonType.LEFT_BUMPER]: 0,
    [types_ButtonType.RIGHT_BUMPER]: 0,
    [types_ButtonType.L3]: 0,
    [types_ButtonType.R3]: 0,
    [types_ButtonType.LEFT]: 0,
    [types_ButtonType.RIGHT]: 0,
    [types_ButtonType.UP]: 0,
    [types_ButtonType.DOWN]: 0,
    [types_ButtonType.NEXT]: 0,
    [types_ButtonType.PREV]: 0,
    [types_ButtonType.LEFT_ANALOG_LEFT]: 0,
    [types_ButtonType.LEFT_ANALOG_RIGHT]: 0,
    [types_ButtonType.LEFT_ANALOG_UP]: 0,
    [types_ButtonType.LEFT_ANALOG_DOWN]: 0,
    [types_ButtonType.RIGHT_ANALOG_LEFT]: 0,
    [types_ButtonType.RIGHT_ANALOG_RIGHT]: 0,
    [types_ButtonType.RIGHT_ANALOG_UP]: 0,
    [types_ButtonType.RIGHT_ANALOG_DOWN]: 0,
    [types_ButtonType.LEFT_HORIZONTAL_AXIS]: 0,
    [types_ButtonType.LEFT_VERTICAL_AXIS]: 0,
    [types_ButtonType.RIGHT_HORIZONTAL_AXIS]: 0,
    [types_ButtonType.RIGHT_VERTICAL_AXIS]: 0,
    [types_ButtonType.PSEUDO_BUTTON_1]: 0,
    [types_ButtonType.PSEUDO_BUTTON_2]: 0,
    [types_ButtonType.PSEUDO_BUTTON_3]: 0,
    [types_ButtonType.PSEUDO_BUTTON_4]: 0,
    [types_ButtonType.PSEUDO_BUTTON_5]: 0,
    [types_ButtonType.PSEUDO_BUTTON_6]: 0,
    [types_ButtonType.PSEUDO_BUTTON_7]: 0,
    [types_ButtonType.PSEUDO_BUTTON_8]: 0,
    [types_ButtonType.PSEUDO_BUTTON_9]: 0,
    [types_ButtonType.PSEUDO_BUTTON_10]: 0
  };
};
;// CONCATENATED MODULE: ./packages/react-gamepad-driver-visual/src/setupInput/setupGamepads.ts




const setupGamepads_ACTION_BUTTONS_INDEX = types_ACTION_BUTTONS.map(name => types_BUTTON_MAP.indexOf(name));
const setupGamepads_DIRECTIONAL_BUTTONS_INDEX = types_DIRECTIONAL_BUTTONS.map(name => types_BUTTON_MAP.indexOf(name));
/**
 * Setup pooling for the gamepad button states.
 *
 * This code is extremely performance sensitive, so be mindful of any changes and measure the performance
 * on a performance sensitive device (ex: Xbox One)
 */

function setupGamepads_setupGamepads(onPress, onWiggle, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons) {
  const throttleByName = constructThrottleByName();
  const toggleByName = constructToggleByName();
  const mappedActionButtonsIndex = types_ACTION_BUTTONS.map(name => types_BUTTON_MAP.indexOf(setupGamepads_mapButton(name, swapABButtons, swapXYButtons)));
  const checkGamepad = constructCheckGamepad(toggleByName, throttleByName, mappedActionButtonsIndex, onWiggle, onPress);
  return constructTick(acceptInputFromAllControllers, checkGamepad, controllerId);
}
/**
 * Tick that runs every frame and can either be
 * - Accepting input from all controllers
 * - Accept input from one specific controller
 */

const constructTick = (acceptInputFromAllControllers, checkGamepad, controllerId) => {
  let handler;

  const tick = () => {
    try {
      const gamepads = getGamepads();

      if (acceptInputFromAllControllers) {
        const first = gamepads[0];
        const second = gamepads[1];
        const third = gamepads[2];
        const fourth = gamepads[3];
        if (first != null) checkGamepad(first);
        if (second != null) checkGamepad(second);
        if (third != null) checkGamepad(third);
        if (fourth != null) checkGamepad(fourth);
      } else {
        // We use a regular for loop here instead of a for of loop
        // since it's measurably faster. More context here:
        // https://github.com/Mojang/minecraft-ui/pull/2155
        for (let i = 0; i < gamepads.length; i++) {
          const gamepad = gamepads[i];

          if (gamepad != null && controllerId === gamepad.id) {
            checkGamepad(gamepad);
            break;
          }
        }
      }

      handler = requestAnimationFrame(tick);
    } catch (e) {
      console.log('Error handling gamepad input', e);
    }
  };

  handler = requestAnimationFrame(tick);
  return () => {
    cancelAnimationFrame(handler);
  };
};
/**
 * Check an individual gamepad for its presses states and axes values and fire the
 * throttled or toggles callbacks
 */


const constructCheckGamepad = (toggleByName, throttleByName, mappedActionButtonsIndex, onWiggle, onPress) => gamepad => {
  const buttons = gamepad.buttons;
  const gamepadIndex = gamepad.index;

  for (let index = 0; index < setupGamepads_ACTION_BUTTONS_INDEX.length; index++) {
    const name = toggleByName(types_BUTTON_MAP[mappedActionButtonsIndex[index]], buttons[setupGamepads_ACTION_BUTTONS_INDEX[index]].pressed, gamepadIndex);

    if (name != null) {
      onPress(name, FocusOrigin.FocusInput);
    }
  }

  for (let index = 0; index < setupGamepads_DIRECTIONAL_BUTTONS_INDEX.length; index++) {
    const buttonIndex = setupGamepads_DIRECTIONAL_BUTTONS_INDEX[index];
    const name = throttleByName(types_BUTTON_MAP[buttonIndex], buttons[buttonIndex].pressed, gamepadIndex);

    if (name != null) {
      onPress(name, FocusOrigin.FocusInput);
    }
  }

  const axes = [];
  const length = gamepad.axes.length;

  for (let index = 0; index < length; index++) {
    const value = gamepad.axes[index];

    if (value > -0.16 && value < 0.16) {
      axes.push(0);
      continue;
    }

    const map = types_AXIS_MAP[index];
    const name1 = throttleByName(map[0], value < -setupGamepads_AXIS_TRIGGER_LIMIT, gamepadIndex);

    if (name1 != null) {
      onPress(name1, FocusOrigin.FocusInput);
    }

    const name2 = throttleByName(map[1], value > setupGamepads_AXIS_TRIGGER_LIMIT, gamepadIndex);

    if (name2 != null) {
      onPress(name2, FocusOrigin.FocusInput);
    }

    axes.push(value);
  }

  onWiggle(axes);
};

const setupGamepads_AXIS_TRIGGER_LIMIT = 0.5;

const constructToggleByName = () => {
  const pressStates = {
    0: {},
    1: {},
    2: {},
    3: {}
  };
  return (name, pressed, index) => {
    const wasPressed = pressStates[index][name];

    if (pressed === wasPressed) {
      return;
    }

    if (pressed) {
      pressStates[index][name] = true;

      if (wasPressed != null) {
        return name;
      }
    } else {
      pressStates[index][name] = false;
    }
  };
};

const setupGamepads_mapButton = (button, swapABButtons, swapXYButtons) => {
  if (button === types_ButtonType.Y && swapXYButtons) return types_ButtonType.X;
  if (button === types_ButtonType.X && swapXYButtons) return types_ButtonType.Y;
  if (button === types_ButtonType.A && swapABButtons) return types_ButtonType.B;
  if (button === types_ButtonType.B && swapABButtons) return types_ButtonType.A;
  return button;
};
;// CONCATENATED MODULE: ./packages/react-gamepad-driver-visual/src/driver.ts



const src_driver_driver = (onPress, onWiggle, gameControllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons, keyToGamepad) => {
  const disposeGamepads = setupGamepads_setupGamepads(onPress, onWiggle, gameControllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons);

  const keyboardEventHandler = event => {
    var _keyToGamepad$current;

    // If an element in the DOM is focused, stop navigation from the keyboard input
    if (document.activeElement !== document.body || keyToGamepad == null) return; // Gameface does not support the new standard `key`, so we read the `keyCode` instead

    const buttonType = (_keyToGamepad$current = keyToGamepad.current) === null || _keyToGamepad$current === void 0 ? void 0 : _keyToGamepad$current[event.keyCode];

    if (buttonType != null) {
      event.preventDefault();
      onPress(buttonType, FocusOrigin.FocusInput); // Don't fall through to the explicit handling of tab key below.
      // If the tab key is mapped to a gamepad button it will clash.

      return;
    } // Support for using the "tab" key to navigate the focus.
    // Key is being fired as a string on Jest.


    if (event.keyCode === types_KeyboardKey.TAB) {
      event.preventDefault();
      onPress(event.shiftKey ? types_ButtonType.PREV : types_ButtonType.NEXT, FocusOrigin.FocusInput);
      return;
    }
  }; // NOTE: this one could benefit from calling the requestFocusIdUpdate, since it should reset the navigation direction information


  const mouseEventHandler = event => {
    const button = mapMouseButtonToButtonType[event.button];

    if (button != null) {
      onPress(button, FocusOrigin.PointerInput);
    }
  };

  document.addEventListener('keydown', keyboardEventHandler);
   true && document.addEventListener('mousedown', mouseEventHandler);
  return () => {
    document.removeEventListener('keydown', keyboardEventHandler);
    disposeGamepads();
     true && document.removeEventListener('mousedown', mouseEventHandler);
  };
};
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/components/GamepadProvider/setupScrollIntoView.tsx


/**
 * Setups the scrollIntoView function
 * It keeps a local state of previous running animations so that it cancel between scroll requests
 */

function setupScrollIntoView_setupScrollIntoView() {
  const runningAnimations = new Map();
  /**
   * Implementation that takes a list with a focusable and its ancestors and triggers animations
   * It supports:
   * - multiple levels of nesting (column inside a row, for example)
   * - animations to continue when switching between different sections of the focus tree
   *
   * Returns a cleanup function that can be used to stop all previously running animations
   */

  return (focusable, ancestors, disabledTransition) => {
    ancestors.forEach(containerNode => {
      var _ref, _focusable$scrollSpee, _container$scrollInto, _focusable$scrollOffs;

      const container = containerNode;

      if (container.type === types_FocusableType.ROOT) {
        return;
      }

      if (container.scrollAxis == null || focusable.disableScrollIntoView === true) {
        return;
      }

      if (focusable.ref == null) {
        if (false) {}

        return;
      }

      if (container.ref == null) {
        if (false) {}

        return;
      }

      const existingStop = runningAnimations.get(container.id);

      if (existingStop) {
        existingStop();
        runningAnimations.delete(container.id);
      }

      const {
        scrollIntoView,
        stopScrolling
      } = createScrollingManager({
        disabledTransition,
        speedFactor: (_ref = (_focusable$scrollSpee = focusable.scrollSpeedFactor) !== null && _focusable$scrollSpee !== void 0 ? _focusable$scrollSpee : container.scrollIntoViewSpeedFactor) !== null && _ref !== void 0 ? _ref : 1,
        align: (focusable.scrollAlign ? focusable.scrollAlign : container.scrollIntoViewAlign) || 'center',
        scrollOffset: ((_container$scrollInto = container.scrollIntoViewOffset) !== null && _container$scrollInto !== void 0 ? _container$scrollInto : 0) + ((_focusable$scrollOffs = focusable.scrollOffset) !== null && _focusable$scrollOffs !== void 0 ? _focusable$scrollOffs : 0),
        axis: container.scrollAxis === ScrollAxis.HORIZONTAL ? 'x' : 'y'
      });
      scrollIntoView(container.ref, focusable.ref);
      runningAnimations.set(container.id, stopScrolling);
    });
    /**
     * Cleanup function that stops all running animations
     */

    return () => {
      for (const stopScrolling of runningAnimations.values()) {
        stopScrolling();
      }

      runningAnimations.clear();
    };
  };
}
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/components/GamepadProvider/temporaryHelpers.ts


const temporaryHelpers_scrollIntoView = setupScrollIntoView_setupScrollIntoView();
const scrollIntoFocused = (focusTree, focusedId, disabledTransition) => {
  if (focusedId == null) return;
  const focusedNodeId = getIdFromAliasOrId(focusTree, focusedId);
  if (focusedNodeId == null) return;
  const focusable = focusTree.elements.get(focusedNodeId);
  if (!focusable || focusable.type == types_FocusableType.ROOT) return;
  const ancestors = treeQueries_getAncestorNodes(focusTree, focusedNodeId);
  return temporaryHelpers_scrollIntoView(focusable, ancestors, disabledTransition);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/focusTree/localQueries.ts


function localQueries_findInputLegends(focusTree, focusedId) {
  const result = {};
  const elementId = getIdFromAliasOrId(focusTree, focusedId);

  if (elementId == null) {
    return result;
  }

  for (const actionButton of types_INPUT_LEGEND_BUTTONS) {
    var _getShortcut;

    const inputLegend = (_getShortcut = treeQueries_getShortcut(focusTree, elementId, actionButton)) === null || _getShortcut === void 0 ? void 0 : _getShortcut.inputLegend;

    if (inputLegend != null) {
      result[actionButton] = inputLegend;
    }
  }

  return result;
}
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/isNavigationDisabled.tsx


const isNavigationDisabledContext = (0,react.createContext)([(0,react_facet_src.createStaticFacet)(true), () => {}]);
const useDisableNavigation = () => useContext(isNavigationDisabledContext);
const ToggleNavigationProvider = ({
  isNavigationDisabledFacet,
  setIsNavigationDisabled,
  children
}) => {
  const value = (0,react.useMemo)(() => [isNavigationDisabledFacet, setIsNavigationDisabled], [isNavigationDisabledFacet, setIsNavigationDisabled]);
  return /*#__PURE__*/react.createElement(isNavigationDisabledContext.Provider, {
    value: value
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/components/GamepadProvider/GamepadProvider.tsx


function GamepadProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function GamepadProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GamepadProvider_ownKeys(Object(source), true).forEach(function (key) { GamepadProvider_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GamepadProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function GamepadProvider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










const ANALOG_SCROLL_MAX_SPEED = 20;
const INITIAL_PATH = [ROOT_NODE_ID];

/**
 * Provider that enables the gamepad focus capability around a React component tree.
 */
function GamepadProvider_GamepadProvider({
  children,
  driver = src_driver_driver,
  initialFocusTree,
  initialFocusedId,
  notifyFocusRequest,
  onFocusedIdChange,
  gameControllerId = '0',
  acceptInputFromAllControllers = false,
  swapABButtons = false,
  swapXYButtons = false,
  disabledTransition = false,
  keyboardGamepadMap
}) {
  const [isNavigationDisabledFacet, setIsNavigationDisabled] = (0,react_facet_src.useFacetState)(false);
  const actualInitialFocusedId = {
    id: initialFocusedId != null ? initialFocusedId : ROOT_NODE_ID,
    origin: FocusOrigin.Initial
  };
  const [focusedFacet, setFocusedFacet] = (0,react_facet_src.useFacetState)(actualInitialFocusedId);
  const focusedRef = (0,react.useRef)(actualInitialFocusedId);
  const setFocusedId = (0,react.useCallback)((newFocusedId, origin) => {
    const newValue = {
      id: newFocusedId,
      origin
    };
    focusedRef.current = newValue;
    setFocusedFacet(newValue);
  }, [focusedRef, setFocusedFacet]);
  const lastFocusOriginFacet = (0,react_facet_src.useFacetMap)(focused => focused.origin, [], [focusedFacet]);
  const focusTree = (0,react.useMemo)(() => initialFocusTree == null ? treeInitialization_getFreshTree() : initialFocusTree, [initialFocusTree]);
  const [debugFocusTreeFacet, setDebugFocusTreeFacet] = (0,react_facet_src.useFacetState)(focusTree);
  const [inputLegends, setInputLegends] = (0,react_facet_src.useFacetState)(localQueries_findInputLegends(focusTree, initialFocusedId));
  const [keyboardGamepadMapFacet, setKeyboardGamepadMap] = (0,react_facet_src.useFacetState)(keyboardGamepadMap);
  const keyToGamepadFacet = (0,react_facet_src.useFacetMap)(keyboardGamepadMap => Object.entries(keyboardGamepadMap).reduce((acc, [buttonType, buttonValues]) => {
    const keys = buttonValues.reduce((acc, buttonValue) => GamepadProvider_objectSpread(GamepadProvider_objectSpread({}, acc), {}, {
      [buttonValue]: buttonType
    }), {});
    return GamepadProvider_objectSpread(GamepadProvider_objectSpread({}, acc), keys);
  }, {}), [], [keyboardGamepadMapFacet]);
  const keyToGamepadRef = (0,react.useRef)(undefined);
  (0,react_facet_src.useFacetEffect)(keyToGamepad => {
    keyToGamepadRef.current = keyToGamepad;
  }, [], [keyToGamepadFacet]);
  const isLastInputFocus = useIsLastInputFocus(); // Central place to handle updates of the focus to a new focused id

  const handleFocusedChange = (0,react_facet_src.useFacetCallback)(isLastInputFocus => (newFocusedId, newFocusedOrigin) => {
    if (newFocusedId != null && focusedRef.current.id !== newFocusedId) {
      const previousId = getIdFromAliasOrId(focusTree, focusedRef.current.id); // Update local record of the focused id

      setFocusedId(newFocusedId, newFocusedOrigin); // Notify external listeners of the focused id change, for example
      // for updating the URL

      onFocusedIdChange(newFocusedId); // Notify the ancestors of this element that its child was focused

      notifyAncestorsOfDecedentFocus(focusTree, newFocusedId, newFocusedOrigin); // Notify the nodes of onFocus and onBlur, and
      // store current values as the next previous values

      nofifyNodesOfBlurAndFocus(focusTree, previousId, newFocusedId); // Update the input legends according to the ones calculated for the new
      // focused id

      setInputLegends(localQueries_findInputLegends(focusTree, newFocusedId)); // If necessary, request the scroll to move to center the current focused element.
      // We keep a reference to the canceling operation to be able to cancel if
      // another event starts scrolling before the animated transition is over

      if (isLastInputFocus) {
        cancelScrollRef.current = scrollIntoFocused(focusTree, newFocusedId, disabledTransition);
      }
    }
  }, [setFocusedId, onFocusedIdChange, focusTree, setInputLegends, disabledTransition, focusedRef], [isLastInputFocus]);
  const requestFocusIdUpdate = (0,react_facet_src.useFacetCallback)(oldFocusedId => (newFocusedId, origin, isDefault) => {
    resetNavigationDirection(focusTree);

    if (isDefault) {
      const oldId = getIdFromAliasOrId(focusTree, oldFocusedId.id);

      if (oldId != null) {
        if (treeQueries_isNodeEnabled(focusTree, oldId)) {
          return () => {};
        }

        const oldElement = focusTree.elements.get(oldId);

        if (oldElement != null && oldElement.type === types_FocusableType.ITEM) {
          return () => {};
        }
      }
    }

    handleFocusedChange(newFocusedId, origin);
    return () => {
      resetNavigationDirection(focusTree);

      if (treeQueries_isNodeEnabled(focusTree, oldFocusedId.id)) {
        handleFocusedChange(oldFocusedId.id, oldFocusedId.origin);
      }
    };
  }, [handleFocusedChange, focusTree], [focusedFacet]);
  const imperativeSetFocusedId = (0,react.useCallback)((newFocusedId, isDefault, origin = FocusOrigin.ImperativeSetFocus) => {
    // Focusing something disabled
    // is always a bug. We might avoid some bugs by preventing focused to
    // be (probably manually) moved to a disabled item.
    if (!treeQueries_isNodeEnabled(focusTree, newFocusedId)) {
      if (false) {}

      return () => {};
    }

    return requestFocusIdUpdate(newFocusedId, origin, isDefault);
  }, [requestFocusIdUpdate, focusTree, focusedRef]);
  const focusTreeAPI = (0,react.useMemo)(() => {
    return {
      press(button, origin) {
        const focusedId = getIdFromAliasOrId(focusTree, focusedRef.current.id);

        if (focusedId != null) {
          const didFireShortcut = fireShortcut(focusTree, focusedId, button);
          if (didFireShortcut) return;
        }

        if (button in mapButtonToArrow) {
          const arrow = mapButtonToArrow[button];

          if (arrow != null) {
            var _getAlias;

            if (focusedId != null) {
              const didFireHandler = fireHandler(focusTree, focusedId, arrow);
              if (didFireHandler) return;
            }

            const newFocusedId = navigate_navigateToDirection(focusTree, focusedId, arrow);
            handleFocusedChange((_getAlias = treeQueries_getAlias(focusTree, newFocusedId)) !== null && _getAlias !== void 0 ? _getAlias : newFocusedId, origin);
          }

          return;
        }

        switch (button) {
          case types_ButtonType.A:
            // go deeper
            click(focusTree, focusedId);
            return;

          case types_ButtonType.B:
            // go to parent
            return;

          case types_ButtonType.NEXT:
            {
              const nextId = legacyNavigateToAdjacentElement(focusTree, focusedId, false);

              if (nextId != null) {
                handleFocusedChange(nextId, FocusOrigin.FocusInput);
              }

              return;
            }

          case types_ButtonType.PREV:
            {
              const nextId = legacyNavigateToAdjacentElement(focusTree, focusedId, true);

              if (nextId != null) {
                handleFocusedChange(nextId, FocusOrigin.FocusInput);
              }

              return;
            }
        }
      },

      putNode(element, parentId) {
        const focused = focusedRef.current; // We don't want to change the focus id via tree mutation if 1) the focused
        // id is from a deep link (from URL or set as the initial id)
        // and 2) the id has not been added to the focus tree yet.

        const isFromDeepLink = focused.id != null && focused.id != ROOT_NODE_ID && (focused.origin === FocusOrigin.URL || focused.origin === FocusOrigin.Initial);
        const shouldSuggestNewId = !isFromDeepLink || focused.id != null;
        const newFocusSuggestion = putFocusable(focusTree, element, parentId, focusedRef.current, shouldSuggestNewId);

        if (newFocusSuggestion != null) {
          handleFocusedChange(newFocusSuggestion.id, FocusOrigin.FocusTreeMutation);
        }

        setDebugFocusTreeFacet(focusTree);
      },

      putShortcut(elementId, actionButton, shortcut) {
        putShortcut(focusTree, elementId, actionButton, shortcut);
        setDebugFocusTreeFacet(focusTree);
      },

      removeNode(elementId) {
        const newFocusSuggestion = removeFocusable(focusTree, elementId, focusedRef.current);

        if (newFocusSuggestion != null) {
          handleFocusedChange(newFocusSuggestion.id, FocusOrigin.FocusTreeMutation);
        }

        setDebugFocusTreeFacet(focusTree);
      },

      removeShortcut(elementId, actionButton) {
        removeShortcut(focusTree, elementId, actionButton);
        setDebugFocusTreeFacet(focusTree);
      },

      isFocused(elementId, alias) {
        return elementId === focusedRef.current.id || alias != null && alias === focusedRef.current.id;
      },

      isFocusable: focusableId => {
        // TODO: Need to consolidate the checks from `navigateToDirection()` into here as well. We need to understand which should be shared.
        return treeQueries_isNodeEnabled(focusTree, focusableId);
      },
      getElement: elementId => getElement(focusTree, getIdFromAliasOrId(focusTree, elementId)),
      isAncestorOf: (parentId, elementId) => isAncestorOf(focusTree, parentId, elementId),
      getDynasty: elementId => focusTree.dynasty.get(elementId),
      getEnabledBindingLandmarkDescendant: elementId => {
        return getEnabledBindingLandmarkDescendant(focusTree, elementId);
      }
    };
  }, [focusedRef, focusTree, handleFocusedChange, setDebugFocusTreeFacet]);
  const focusedIdFacet = (0,react_facet_src.useFacetMap)(focused => focused.id, [], [focusedFacet]);
  const setFocusFromDebugTool = (0,react.useCallback)(id => handleFocusedChange(id, FocusOrigin.DebugTool), [handleFocusedChange]);
  useDebugFocusTreeExtension(debugFocusTreeFacet, focusedIdFacet, setFocusFromDebugTool);
  const analogListenersRef = (0,react.useRef)([]);
  const digitalListenersRef = (0,react.useRef)([]);
  const invokeCurrentCallback = (0,react.useCallback)(actionButton => {
    const focused = focusedRef.current;
    const focusedNumberId = getIdFromAliasOrId(focusTree, focused.id);
    if (focusedNumberId == null) return;
    const handler = getShortcutHandler(focusTree, focusedNumberId, actionButton);
    handler === null || handler === void 0 ? void 0 : handler();
  }, [focusTree]);
  const cancelScrollRef = (0,react.useRef)(undefined);
  const onPress = (0,react.useCallback)((button, origin = FocusOrigin.Unknown) => {
    digitalListenersRef.current.forEach(digitalListener => digitalListener(button));
    focusTreeAPI.press(button, origin);
  }, [focusTreeAPI]);
  const onWiggle = (0,react.useCallback)(axes => {
    analogListenersRef.current.forEach(analogListener => analogListener(axes));
    const didWiggleCauseScroll = wiggleScrollables(focusTree, focusedRef.current.id, axes, ANALOG_SCROLL_MAX_SPEED);
    if (didWiggleCauseScroll && cancelScrollRef.current) cancelScrollRef.current();
  }, [focusTree, analogListenersRef, focusedRef]);
  (0,react_facet_src.useFacetLayoutEffect)(isNavigationDisabled => {
    // NOTE: If we in the future would disable / enable navigation based on shared input facet state
    // then we might end up in a race condition between registering the driver and determining initial
    // focus state. In case that happens it can be solved by waiting a frame (using requestAnimationFrame)
    // before initializing the driver below.
    return !isNavigationDisabled ? driver(onPress, onWiggle, gameControllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons, keyToGamepadRef) : undefined;
  }, [gameControllerId, driver, onWiggle, onPress, acceptInputFromAllControllers, swapABButtons, swapXYButtons, keyToGamepadRef], [isNavigationDisabledFacet]);
  const cursorAPI = (0,react.useMemo)(() => {
    const cursorAPI = {
      addAnalogListener: analogListener => {
        analogListenersRef.current = [...analogListenersRef.current, analogListener];
        return () => {
          analogListenersRef.current = without_default()([analogListener], analogListenersRef.current);
        };
      },
      addDigitalListener: digitalListener => {
        digitalListenersRef.current = [...digitalListenersRef.current, digitalListener];
        return () => {
          digitalListenersRef.current = without_default()([digitalListener], digitalListenersRef.current);
        };
      },
      clickAtPoint: (x, y) => {
        clickFocusableAtPoint(focusTree, x, y);
      },
      focusAtPoint: (x, y) => {
        var _focusable$alias;

        const focusable = visualQueries_findClickableFocusableAtPoint(focusTree, x, y);
        const focusableId = (_focusable$alias = focusable === null || focusable === void 0 ? void 0 : focusable.alias) !== null && _focusable$alias !== void 0 ? _focusable$alias : focusable === null || focusable === void 0 ? void 0 : focusable.id;

        if (focusableId != null) {
          requestFocusIdUpdate(focusableId, FocusOrigin.PointerInput);
        }
      }
    };
    return cursorAPI;
  }, [requestFocusIdUpdate, focusTree]); // Prevent buttonMap to be created on every render by using useMemo,
  // which would trigger an update on any consumer of the ButtonMapProvider context provider below

  const buttonMap = (0,react.useMemo)(() => ({
    swapABButtons,
    swapXYButtons
  }), [swapABButtons, swapXYButtons]);
  const keyboardGamepadMapValue = (0,react.useMemo)(() => [keyboardGamepadMapFacet, setKeyboardGamepadMap], [keyboardGamepadMapFacet, setKeyboardGamepadMap]); // Using a layout effect since we want this to run before we render components further down
  // in the tree that will mutate the focus tree. Can't use a useMemo since then requestFocusIdUpdate
  // isn't initialized yet (by useFacetCallback)

  (0,react.useLayoutEffect)(() => {
    if (notifyFocusRequest == null) return () => {}; // Note that we are using requestFocusIdUpdate here instead of imperativeSetFocusedId since we want to
    // be able to be able to deep link to a particular focused id from the URL. However, at that point we don't
    // know if the full tree is constructed yet or not, so we just set the focused id regardless if it is in the
    // tree, disabled etc.

    return notifyFocusRequest(newFocusedId => requestFocusIdUpdate(newFocusedId, FocusOrigin.URL));
  }, [requestFocusIdUpdate, notifyFocusRequest]);
  return /*#__PURE__*/react.createElement(ToggleNavigationProvider, {
    isNavigationDisabledFacet: isNavigationDisabledFacet,
    setIsNavigationDisabled: setIsNavigationDisabled
  }, /*#__PURE__*/react.createElement(PathContext.Provider, {
    value: INITIAL_PATH
  }, /*#__PURE__*/react.createElement(keyboardGamepadMapContext.Provider, {
    value: keyboardGamepadMapValue
  }, /*#__PURE__*/react.createElement(setFocusedId_setFocusedIdContext.Provider, {
    value: imperativeSetFocusedId
  }, /*#__PURE__*/react.createElement(lastFocusOriginContext.Provider, {
    value: lastFocusOriginFacet
  }, /*#__PURE__*/react.createElement(ButtonMapProvider, {
    value: buttonMap
  }, /*#__PURE__*/react.createElement(FocusTreeAPIProvider, {
    value: focusTreeAPI
  }, /*#__PURE__*/react.createElement(CursorAPIProvider, {
    value: cursorAPI
  }, /*#__PURE__*/react.createElement(AvailableInputLegendsProvider, {
    value: inputLegends
  }, /*#__PURE__*/react.createElement(InvokeCurrentCallbackProvider, {
    value: invokeCurrentCallback
  }, children))))))))));
}
;// CONCATENATED MODULE: ./packages/react-gamepad/src/gamepadAdapterContext.tsx

let GamepadAdapterVersion;

(function (GamepadAdapterVersion) {
  GamepadAdapterVersion[GamepadAdapterVersion["LEGACY"] = 0] = "LEGACY";
  GamepadAdapterVersion[GamepadAdapterVersion["VISUAL"] = 1] = "VISUAL";
})(GamepadAdapterVersion || (GamepadAdapterVersion = {}));

const gamepadAdapterContext = (0,react.createContext)({
  version: GamepadAdapterVersion.LEGACY,
  setVersion: () => {}
});
const useGamepadAdapter = () => (0,react.useContext)(gamepadAdapterContext);
const GamepadAdapterProvider = ({
  children,
  version: defaultVersion
}) => {
  const [version, setVersion] = (0,react.useState)(defaultVersion);
  const value = (0,react.useMemo)(() => ({
    version,
    setVersion
  }), [version, setVersion]);
  return /*#__PURE__*/react.createElement(gamepadAdapterContext.Provider, {
    value: value
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad/src/GamepadProvider.tsx
function GamepadProvider_extends() { GamepadProvider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return GamepadProvider_extends.apply(this, arguments); }






// Static facet holding a false value
const falseFacet = (0,react_facet_src.createStaticFacet)(false);
function src_GamepadProvider_GamepadProvider(props) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();
  const [focusedIdFacet, setFocusedId] = (0,react_facet_src.useFacetState)(undefined);
  const {
    disabledNavigation,
    notifyFocusRequest,
    onFocusedIdChange
  } = props;
  const mappedFocusedIdFacet = (0,react_facet_src.useFacetMap)((disabledNavigation, focusedId) => disabledNavigation !== true ? focusedId : undefined, [], [(0,react_facet_src.useFacetWrap)(disabledNavigation !== null && disabledNavigation !== void 0 ? disabledNavigation : falseFacet), focusedIdFacet]);
  (0,react.useEffect)(() => {
    if (notifyFocusRequest == null) return () => {};
    const cleanup = notifyFocusRequest(focusedId => {
      setFocusedId(focusedId);
    });
    return cleanup;
  }, [notifyFocusRequest, setFocusedId]);
  const legacyOnFocusedIdChange = (0,react.useCallback)(newFocusedId => {
    setFocusedId(newFocusedId);
    onFocusedIdChange(newFocusedId);
  }, [setFocusedId, onFocusedIdChange]);

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return /*#__PURE__*/react.createElement(GamepadProvider, GamepadProvider_extends({
      focusedId: mappedFocusedIdFacet
    }, props, {
      onFocusedIdChange: legacyOnFocusedIdChange,
      mostRecentlyFocusedId: focusedIdFacet
    }));
  }

  return /*#__PURE__*/react.createElement(GamepadProvider_GamepadProvider, props);
}
// EXTERNAL MODULE: ./node_modules/rtl-detect/index.js
var rtl_detect = __webpack_require__(23972);
var rtl_detect_default = /*#__PURE__*/__webpack_require__.n(rtl_detect);
;// CONCATENATED MODULE: ./packages/react-localization/src/LocalizationProvider.tsx



const noopTranslate = key => key;

const noopFormatDate = timestamp => `${timestamp}`;

const LocalizationContext = (0,react.createContext)({
  translationPrefix: 'hbui',
  translate: noopTranslate,
  formatDate: noopFormatDate,
  locale: 'en-US',
  isRtl: false
});
function LocalizationProvider({
  translationPrefix,
  translate,
  formatDate,
  children,
  locale
}) {
  const isRtl = (0,react.useMemo)(() =>  true ? rtl_detect_default().getLangDir(locale) === 'rtl' : 0, [locale]);
  const value = (0,react.useMemo)(() => ({
    translationPrefix,
    translate,
    formatDate,
    locale,
    isRtl
  }), [translationPrefix, translate, formatDate, locale, isRtl]);
  return /*#__PURE__*/react.createElement(LocalizationContext.Provider, {
    value: value
  }, children);
}
;// CONCATENATED MODULE: ./packages/react-localization/src/useIsLocaleRtl.tsx


const useIsLocaleRtl = () => {
  return (0,react.useContext)(LocalizationContext).isRtl;
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/inputFacet.ts

const INPUT_FACET = 'core.input';
/**
 * React Hook that requests the facet
 */

const inputFacet = (0,react_facet_src.sharedFacet)(INPUT_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/facets/animationFacet.ts

const ANIMATION_FACET = 'core.animation';
const animationFacet = (0,react_facet_src.sharedFacet)(ANIMATION_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/facets/splitScreenFacet.ts

let SplitScreenDirection;

(function (SplitScreenDirection) {
  SplitScreenDirection[SplitScreenDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
  SplitScreenDirection[SplitScreenDirection["VERTICAL"] = 1] = "VERTICAL";
})(SplitScreenDirection || (SplitScreenDirection = {}));

const SPLIT_SCREEN_FACET = 'core.splitScreen';
/**
 * React Hook that requests the facet
 */

const splitScreenFacet = (0,react_facet_src.sharedFacet)(SPLIT_SCREEN_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/GamepadEngineProvider.tsx









/**
 * Provider that setups the Gamepad to be used by the RouterEngineProvider
 * differently than other "engine provider", this has some required props that are to be used by another provider
 *
 * It should not be moved outside of this folder
 */
function GamepadEngineProvider({
  notifyFocusRequest,
  onFocusedIdChange,
  onFocusedIdChangeFail,
  children,
  keyboardGamepadMap,
  isInputLegendClickable
}) {
  const animation = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(animationFacet));
  const splitScreen = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(splitScreenFacet));
  const isRtl = useIsLocaleRtl();
  const acceptInputFromAllControllers = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(input => input.acceptInputFromAllControllers, [], [(0,react_facet_src.useSharedFacet)(inputFacet)]));
  const gameControllerId = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(input => input.gameControllerId, [], [(0,react_facet_src.useSharedFacet)(inputFacet)]));
  const swapABButtons = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(input => input.swapABButtons, [], [(0,react_facet_src.useSharedFacet)(inputFacet)]));
  const swapXYButtons = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(input => input.swapXYButtons, [], [(0,react_facet_src.useSharedFacet)(inputFacet)]));
  const disabledNavigation = (0,react_facet_src.useFacetMap)(isLastInputFocus => !isLastInputFocus, [], [useIsLastInputFocus()]);

  if (acceptInputFromAllControllers == react_facet_src.NO_VALUE || gameControllerId == react_facet_src.NO_VALUE || swapABButtons == react_facet_src.NO_VALUE || swapXYButtons == react_facet_src.NO_VALUE || animation === react_facet_src.NO_VALUE || isRtl == null || splitScreen === react_facet_src.NO_VALUE) {
    return null;
  } // Performance while running the game in split screen is degraded,
  // so we disable animations to a more snappy UI


  const disabledTransition = !animation.screenAnimationEnabled || splitScreen.numActivePlayers > 1;
  return /*#__PURE__*/react.createElement(src_GamepadProvider_GamepadProvider, {
    notifyFocusRequest: notifyFocusRequest,
    onFocusedIdChange: onFocusedIdChange,
    onFocusedIdChangeFail: onFocusedIdChangeFail,
    disabledNavigation: disabledNavigation,
    acceptInputFromAllControllers: acceptInputFromAllControllers,
    gameControllerId: gameControllerId,
    swapABButtons: swapABButtons,
    swapXYButtons: swapXYButtons,
    disabledTransition: disabledTransition,
    isRtl: isRtl,
    keyboardGamepadMap: keyboardGamepadMap,
    isInputLegendClickable: isInputLegendClickable
  }, children);
}
;// CONCATENATED MODULE: ./packages/react-sound-effect/src/context.ts

const context_context = (0,react.createContext)(() => () => {});
const {
  Provider: context_Provider,
  Consumer: context_Consumer
} = context_context;

const usePlay = () => (0,react.useContext)(context_context);
;// CONCATENATED MODULE: ./packages/react-sound-effect/src/constants.ts
const NO_SOUND = 'react-sound-effect.NoSound';
;// CONCATENATED MODULE: ./packages/react-sound-effect/src/useSoundEffectTrigger.ts



function useSoundEffectTrigger() {
  const play = usePlay();
  const triggerSoundEffect = (0,react.useCallback)((eventName, delay = 0, volume = 1, pitch = 1) => {
    if (eventName === NO_SOUND || !eventName) return;
    play(eventName, delay, volume, pitch);
  }, [play]);
  return triggerSoundEffect;
}
;// CONCATENATED MODULE: ./packages/react-narrator/src/context/narrationEnabled.ts

const narrationEnabledContext = (0,react.createContext)(true);
const NarrationEnabledProvider = narrationEnabledContext.Provider;
;// CONCATENATED MODULE: ./packages/react-narrator/src/hooks/useNarrationEnabled.ts


const useNarrationEnabled = () => (0,react.useContext)(narrationEnabledContext);
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/constants.ts
const DEFAULT_ROLE = 'neutral';
const NEUTRAL_ROLES = [DEFAULT_ROLE, 'neutral20', 'neutral50', 'neutral60', 'neutral80', 'neutral100'];
const SEMANTIC_ROLES = ['primary', 'primaryTint', 'secondary', 'tertiary', 'success', 'successTint', 'destructive', 'destructiveTint', 'informative', 'informativeTint', 'notice', 'noticeTint'];
const PAPER_ROLE = 'paper';
const ROLES = [...NEUTRAL_ROLES, ...SEMANTIC_ROLES, PAPER_ROLE]; // Variant

const DEFAULT_FOREGROUND_VARIANT = 'regular';
const EFFECT_VARIANT = 'reversed';
const FOREGROUND_VARIANTS = ['dimmest', 'dimmer', 'stronger', 'strongest'];
const NONE_DEFAULT_VARIANTS = [...FOREGROUND_VARIANTS, EFFECT_VARIANT];
const VARIANTS = [DEFAULT_FOREGROUND_VARIANT, ...NONE_DEFAULT_VARIANTS]; // Element

const FOREGROUND_ELEMENTS = ['text', 'icon', 'border', 'caret'];
const LIGHTING_EFFECT_ELEMENTS = ['specular', 'bevel', 'highlight'];
const HIGHLIGHT_ELEMENT = 'highlight';
const BASE_ELEMENTS = ['background', 'shadow', 'outline', 'overlay', 'dropShadow'];
const ELEMENTS = [...FOREGROUND_ELEMENTS, ...BASE_ELEMENTS, ...LIGHTING_EFFECT_ELEMENTS]; // Modifier

const DEFAULT_MODIFIER = 'default';
const HOVERED = 'hovered';
const PRESSED = 'pressed';
const DISABLED = 'disabled';
const SELECTED = 'selected';
const FOCUSED = 'focused';
const INTERACTIVE_MODIFIERS = [SELECTED, FOCUSED, HOVERED, PRESSED, DISABLED];
const MODIFIERS = ['default', ...INTERACTIVE_MODIFIERS];
const PSEUDO_SELECTORS = ['hover', 'press', 'disable', 'select', 'focus', 'base', 'interactive']; // Component

const COMPONENTS = ['pressable', 'panel']; // Sound

const SOUND_EVENTS = ['reject', 'click', 'press', 'focus', 'hover', 'hoverExit', 'contract', 'expand', 'toggle', 'lift'];
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/typeGuards.ts
 // Element

const isForegroundElement = element => {
  return FOREGROUND_ELEMENTS.includes(element);
};
const isLightingEffectElement = element => {
  return LIGHTING_EFFECT_ELEMENTS.includes(element);
};
const hasVariant = (element, variant = 'regular') => typeof element !== 'undefined' && variant in element;
const isRegularModifier = element => typeof element !== 'undefined' && 'default' in element;
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/collectionToClassName.ts


const flattenCollection = collection => {
  const flattened = []; // Way too much hassle to get the types correct
  // eslint-disable-next-line @typescript-eslint/no-explicit-any

  const recurse = (value, path) => {
    if (value != null && 'default' in value) {
      MODIFIERS.forEach(modifier => {
        if (value[modifier] != null) {
          flattened.push({
            path: [...path, mapModifierToPseudoSelector[modifier]],
            value: value[modifier]
          });
        }
      });
    } else {
      for (const prop in value) {
        recurse(value[prop], [...path, prop]);
      }
    }
  };

  recurse(collection.color, [collection.id]);
  recurse(collection.component, [collection.id]);
  return flattened;
};

const generateCss = (selector, element, value) => {
  switch (element) {
    case 'background':
    case 'icon':
    case 'shadow':
    case 'highlight':
    case 'overlay':
    case 'dropShadow':
      return `${selector} { background-color: ${value}; }`;

    case 'border':
    case 'outline':
      return `${selector} { border-color: ${value}; }`;

    case 'text':
      return `${selector} { color: ${value}; }`;

    case 'specular':
    case 'bevel':
      const {
        top,
        bottom
      } = value;

      if (selector.includes('reversed')) {
        return `${selector} { border-top-color: ${bottom}; border-left-color: ${bottom}; border-bottom-color: ${top};  border-right-color: ${top} }`;
      }

      return `${selector} { border-top-color: ${top}; border-left-color: ${top}; border-bottom-color: ${bottom};  border-right-color: ${bottom} }`;

    case 'caret':
      return `${selector} { caret-color: ${value}; }`;

    case 'pressable':
    case 'panel':
      const texture = value;
      return `${selector} { border-image-slice: ${texture.slice}; border-image-width: ${texture.width}; border-image-outset: ${texture.outset}; border-image-repeat: ${texture.repeat}; border-image-source: url(${texture.source}); }`;
  }
};

const mapModifierToPseudoSelector = {
  [DEFAULT_MODIFIER]: 'base',
  [HOVERED]: 'hover',
  [PRESSED]: 'press',
  [FOCUSED]: 'focus',
  [SELECTED]: 'select',
  [DISABLED]: 'disable'
};
const mapPseudoSelectorToModifier = {
  base: DEFAULT_MODIFIER,
  hover: HOVERED,
  press: PRESSED,
  focus: FOCUSED,
  select: SELECTED,
  disable: DISABLED
};

const extractSelectorAndElement = path => {
  const element = isTexture(path) ? path[1] : path[2];
  const foregroundElement = isForegroundElement(element);
  const lightingElement = isLightingEffectElement(element);
  const modifier = path[path.length - 1];
  const state = mapPseudoSelectorToModifier[modifier]; // Note that splice will mutate path by removing variant from it

  const variant = foregroundElement ? path.splice(3, 1)[0] : undefined;
  const baseSelector = path.join('-');
  const defaultSelector = path.slice(0, -1).join('-');
  const interactiveSelector = path.slice(0, -1).concat('interactive').join('-');

  if (lightingElement) {
    const selector = modifier === 'base' ? `.${defaultSelector},.${interactiveSelector}` : `.${baseSelector}.${state},.${state} .${baseSelector},.${interactiveSelector}.${state},.${state} .${interactiveSelector}`;
    const reversedSelector = modifier === 'base' ? `.${defaultSelector}.reversed,.${interactiveSelector}.reversed` : `.${baseSelector}.reversed.${state},.${state} .${baseSelector}.reversed,.${interactiveSelector}.reversed.${state},.${state} .${interactiveSelector}.reversed`;
    return {
      element,
      selector: [selector, reversedSelector]
    };
  }

  const variantClassName = variant == null || variant === 'regular' ? '' : `.${variant}`;
  const selector = modifier === 'base' ? `.${defaultSelector}${variantClassName},.${interactiveSelector}${variantClassName}` : `.${baseSelector}${variantClassName}.${state},.${state} .${baseSelector}${variantClassName},.${interactiveSelector}${variantClassName}.${state},.${state} .${interactiveSelector}${variantClassName}`;
  return {
    element,
    selector
  };
};

const isTexture = path => path.includes('texture');

const transformToCss = arr => {
  return arr.map(({
    path,
    value
  }) => {
    const {
      element,
      selector
    } = extractSelectorAndElement(path);
    return Array.isArray(selector) ? selector.map(selector => generateCss(selector, element, value)).join('') : generateCss(selector, element, value);
  }).join('');
};

const collectionToClassName = collection => {
  const collectionFlattened = flattenCollection(collection);
  const css = transformToCss(collectionFlattened);
  return css;
};
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/SemanticRole.tsx

const SemanticRoleScopeContext = (0,react.createContext)('neutral');
const useInheritSemanticRole = () => (0,react.useContext)(SemanticRoleScopeContext);
const SemanticRoleProvider = ({
  role,
  children
}) => {
  if (role === 'inherit') {
    return /*#__PURE__*/react.createElement(react.Fragment, null, children);
  }

  return /*#__PURE__*/react.createElement(SemanticRoleScopeContext.Provider, {
    value: role
  }, children);
};
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/utils.ts
const COLLECTION_STYLE_ID_PREFIX = `semantic-tokens-collection-id-`;
const getCollectionStyleId = collectionId => `${COLLECTION_STYLE_ID_PREFIX}${collectionId}`;
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/semanticColorTokens.ts


const generateClassNames = id => {
  const classNames = {
    color: {},
    component: {},
    variant: VARIANT_CLASS_NAMES,
    modifier: MODIFIER_CLASS_NAMES // eslint-disable-next-line @typescript-eslint/no-explicit-any

  };

  for (const role of ROLES) {
    classNames.color[role] = {};

    for (const element of ELEMENTS) {
      classNames.color[role][element] = {};

      for (const pseudo of PSEUDO_SELECTORS) {
        if (id == null) {
          classNames.color[role][element][pseudo] = undefined;
        } else {
          if (pseudo === 'base') {
            classNames.color[role][element][pseudo] = `${id}-${role}-${element}`;
          } else {
            classNames.color[role][element][pseudo] = `${id}-${role}-${element}-${pseudo}`;
          }
        }
      }
    }
  }

  for (const component of COMPONENTS) {
    classNames.component[component] = {
      texture: {}
    };

    for (const role of ROLES) {
      classNames.component[component].texture[role] = {};

      for (const pseudo of PSEUDO_SELECTORS) {
        if (id == null) {
          classNames.component[component].texture[role][pseudo] = undefined;
        } else {
          if (pseudo === 'base') {
            classNames.component[component].texture[role][pseudo] = `${id}-${component}-${role}-texture`;
          } else {
            classNames.component[component].texture[role][pseudo] = `${id}-${component}-${role}-texture-${pseudo}`;
          }
        }
      }
    }
  }

  return classNames;
};

const semanticColorTokensPerId = {};
const getSemanticColorTokens = id => {
  if (id == null) return EMPTY_SEMANTIC_COLOR_TOKENS;

  if (semanticColorTokensPerId[id] == null) {
    semanticColorTokensPerId[id] = generateClassNames(id);
  }

  return semanticColorTokensPerId[id];
};

const getModifiers = () => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const modifiers = {};

  for (const modifier of INTERACTIVE_MODIFIERS) {
    modifiers[modifier] = modifier;
  }

  return modifiers;
};

const MODIFIER_CLASS_NAMES = getModifiers();

const getVariants = () => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const variants = {};

  for (const variant of NONE_DEFAULT_VARIANTS) {
    variants[variant] = variant;
  }

  return variants;
};

const VARIANT_CLASS_NAMES = getVariants();
const EMPTY_SEMANTIC_COLOR_TOKENS = generateClassNames();
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/semanticSoundTokens.ts


const generateSoundTokens = collection => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const semanticSoundTokens = {};

  for (const role of ROLES) {
    var _collection$sound$rol, _collection$sound;

    semanticSoundTokens[role] = (_collection$sound$rol = collection === null || collection === void 0 ? void 0 : (_collection$sound = collection.sound) === null || _collection$sound === void 0 ? void 0 : _collection$sound[role]) !== null && _collection$sound$rol !== void 0 ? _collection$sound$rol : {};
  }

  return semanticSoundTokens;
};

const semanticSoundTokensPerId = {};
const getSemanticSoundTokens = collection => {
  if (collection == null) return EMPTY_SEMANTIC_SOUND_TOKENS;
  if (collection.id == null) return EMPTY_SEMANTIC_SOUND_TOKENS;

  if (semanticSoundTokensPerId[collection.id] == null) {
    semanticSoundTokensPerId[collection.id] = generateSoundTokens(collection);
  }

  return semanticSoundTokensPerId[collection.id];
};
const EMPTY_SEMANTIC_SOUND_TOKENS = generateSoundTokens();
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/SemanticTokensProvider.tsx
function SemanticTokensProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function SemanticTokensProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SemanticTokensProvider_ownKeys(Object(source), true).forEach(function (key) { SemanticTokensProvider_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SemanticTokensProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function SemanticTokensProvider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








const DEFAULT_MANAGER_CONTEXT = {
  registerCollection: () => undefined
};
const ManagerContext = (0,react.createContext)(DEFAULT_MANAGER_CONTEXT);
const DEFAULT_COLLECTION_CONTEXT = {
  id: undefined,
  tokens: SemanticTokensProvider_objectSpread(SemanticTokensProvider_objectSpread({}, EMPTY_SEMANTIC_COLOR_TOKENS), {}, {
    sound: EMPTY_SEMANTIC_SOUND_TOKENS
  })
};
const CollectionContext = (0,react.createContext)(DEFAULT_COLLECTION_CONTEXT);

const useCollection = () => {
  const ctxValue = (0,react.useContext)(CollectionContext);

  if (ctxValue.id == null) {
    console.error('Trying to use collection context outside of provider.');
  }

  return ctxValue;
};

const useSemanticTokens = () => {
  const tokens = useCollection().tokens;
  const inheritRole = useInheritSemanticRole();
  const semanticClassNamesWithInheritedRole = (0,react.useMemo)(() => {
    var _tokens$rawColors;

    return SemanticTokensProvider_objectSpread(SemanticTokensProvider_objectSpread({}, tokens), {}, {
      color: SemanticTokensProvider_objectSpread(SemanticTokensProvider_objectSpread({}, tokens.color), {}, {
        inherit: tokens.color[inheritRole]
      }),
      rawColors: SemanticTokensProvider_objectSpread(SemanticTokensProvider_objectSpread({}, tokens.rawColors || {}), {}, {
        inherit: (_tokens$rawColors = tokens.rawColors) === null || _tokens$rawColors === void 0 ? void 0 : _tokens$rawColors[inheritRole]
      }),
      sound: SemanticTokensProvider_objectSpread(SemanticTokensProvider_objectSpread({}, tokens.sound), {}, {
        inherit: tokens.sound[inheritRole]
      })
    });
  }, [tokens, inheritRole]);
  return semanticClassNamesWithInheritedRole;
};
// Query for styles added at build time
const initialStyleElementsById = Array.from(document.querySelectorAll(`head style[id^="${COLLECTION_STYLE_ID_PREFIX}"]`)).reduce((stylesMap, element) => SemanticTokensProvider_objectSpread(SemanticTokensProvider_objectSpread({}, stylesMap), {}, {
  [element.id.replace(COLLECTION_STYLE_ID_PREFIX, '')]: element
}), {});
const SemanticTokensCollectionsManager = ({
  children
}) => {
  const styleElementsById = (0,react.useRef)(initialStyleElementsById);
  const registeredCollections = (0,react.useRef)({});
  const ctxValue = (0,react.useMemo)(() => ({
    registerCollection: collection => {
      // In development we want to update styling when a collections changes, eg. for hot module reloading
      if (false) {} // In production we don't have a use case (yet) for updating styling dynamically, so ignore updates of collections


      if (true) {
        if (styleElementsById.current[collection.id] != null) {
          return;
        }
      }

      const styleId = getCollectionStyleId(collection.id); // Remove old styling (needed in Gameface)

      const oldStyleElement = document.querySelector(`head style[id="${styleId}"]`);

      if (oldStyleElement != null) {
        document.head.removeChild(oldStyleElement);
      } // Add new styling


      const style = document.createElement('style');
      style.id = styleId;
      style.innerHTML = collectionToClassName(collection);
      document.head.appendChild(style);
      styleElementsById.current[collection.id] = style;
      registeredCollections.current[collection.id] = collection;
    }
  }), []);
  return /*#__PURE__*/react.createElement(ManagerContext.Provider, {
    value: ctxValue
  }, children);
};
const SemanticTokensProvider_SemanticTokensCollectionProvider = ({
  collection,
  children
}) => {
  const managerCtx = (0,react.useContext)(ManagerContext);
  const registerCollection = managerCtx === null || managerCtx === void 0 ? void 0 : managerCtx.registerCollection;
  const parentCtx = (0,react.useContext)(CollectionContext);
  (0,react.useEffect)(() => {
    if (collection == null || registerCollection == null) {
      return;
    }

    registerCollection(collection);
  }, [collection, registerCollection]);
  const collectionCtxValue = (0,react.useMemo)(() => {
    const semanticClassNames = getSemanticColorTokens(collection === null || collection === void 0 ? void 0 : collection.id); // Fallback on other collection's colors for each role on a per element basis.
    // Note: Not sure if possible to make the below type safe, so used any + cast to correct type.

    const color = {}; // eslint-disable-next-line @typescript-eslint/no-explicit-any

    const rawColors = {};

    for (const role of ROLES) {
      const className = semanticClassNames.color[role];
      const parentClassName = parentCtx.tokens.color[role];
      color[role] = {};
      rawColors[role] = {};

      for (const element of ELEMENTS) {
        var _collection$color$rol, _collection$color$rol2, _collection$color$rol3, _parentCtx$tokens$raw, _parentCtx$tokens$raw2;

        color[role][element] = (collection === null || collection === void 0 ? void 0 : (_collection$color$rol = collection.color[role]) === null || _collection$color$rol === void 0 ? void 0 : _collection$color$rol[element]) != null ? className[element] : parentClassName[element];
        rawColors[role][element] = (collection === null || collection === void 0 ? void 0 : (_collection$color$rol2 = collection.color[role]) === null || _collection$color$rol2 === void 0 ? void 0 : _collection$color$rol2[element]) != null ? collection === null || collection === void 0 ? void 0 : (_collection$color$rol3 = collection.color[role]) === null || _collection$color$rol3 === void 0 ? void 0 : _collection$color$rol3[element] : parentCtx === null || parentCtx === void 0 ? void 0 : (_parentCtx$tokens$raw = parentCtx.tokens.rawColors) === null || _parentCtx$tokens$raw === void 0 ? void 0 : (_parentCtx$tokens$raw2 = _parentCtx$tokens$raw[role]) === null || _parentCtx$tokens$raw2 === void 0 ? void 0 : _parentCtx$tokens$raw2[element];
      }
    } // Set texture class names to undefined if not defined in collection.


    const component = COMPONENTS.reduce((acc, component) => {
      const texture = ROLES.reduce((texturesPerRole, role) => {
        var _collection$component, _collection$component2;

        texturesPerRole[role] = (collection === null || collection === void 0 ? void 0 : (_collection$component = collection.component) === null || _collection$component === void 0 ? void 0 : (_collection$component2 = _collection$component[component]) === null || _collection$component2 === void 0 ? void 0 : _collection$component2[role]) != null ? semanticClassNames.component[component].texture[role] : EMPTY_SEMANTIC_COLOR_TOKENS.component[component].texture[role];
        return texturesPerRole;
      }, {});
      acc[component] = {
        texture
      };
      return acc;
    }, {});
    const semanticSounds = getSemanticSoundTokens(collection);
    const sound = {};

    for (const role of ROLES) {
      sound[role] = {};
      const parentSound = parentCtx.tokens.sound[role];

      for (const soundEvent of SOUND_EVENTS) {
        var _semanticSounds$role$;

        sound[role][soundEvent] = (_semanticSounds$role$ = semanticSounds[role][soundEvent]) !== null && _semanticSounds$role$ !== void 0 ? _semanticSounds$role$ : parentSound[soundEvent];
      }
    }

    return {
      id: collection === null || collection === void 0 ? void 0 : collection.id,
      tokens: {
        variant: VARIANT_CLASS_NAMES,
        modifier: MODIFIER_CLASS_NAMES,
        color,
        component,
        // We expose raw values here since it is in some rare cases necessary to get those values directly,
        // eg. if a text-decoration should have the same color as the text token.
        // However, for performance reasons this should be avoided if not absolutely necessary.
        rawColors: rawColors,
        sound
      }
    };
  }, [collection, parentCtx]);

  if (!collection) {
    return /*#__PURE__*/react.createElement(react.Fragment, null, children);
  }

  return /*#__PURE__*/react.createElement(CollectionContext.Provider, {
    value: collectionCtxValue
  }, children);
};
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/testHelpers.tsx
function testHelpers_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function testHelpers_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { testHelpers_ownKeys(Object(source), true).forEach(function (key) { testHelpers_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { testHelpers_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function testHelpers_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




const emptyColorRole = ELEMENTS.reduce((acc, element) => testHelpers_objectSpread(testHelpers_objectSpread({}, acc), {}, {
  [element]: {}
}), {});

const createSoundsForRoleMock = role => SOUND_EVENTS.reduce((acc, sound) => testHelpers_objectSpread(testHelpers_objectSpread({}, acc), {}, {
  [sound]: `mockTokens.${role}.${sound}`
}), {});

const mockTokens = {
  id: 'mockTokens',
  color: ROLES.reduce((acc, role) => testHelpers_objectSpread(testHelpers_objectSpread({}, acc), {}, {
    [role]: emptyColorRole
  }), {}),
  sound: ROLES.reduce((roles, role) => testHelpers_objectSpread(testHelpers_objectSpread({}, roles), {}, {
    [role]: createSoundsForRoleMock(role)
  }), {})
};
const MockSemanticTokensCollectionProvider = ({
  children
}) => {
  return /*#__PURE__*/React.createElement(SemanticTokensCollectionProvider, {
    collection: mockTokens
  }, children);
};
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/collectionCreator.ts


const collectionCreator = collection => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const collectionWithFallbacks = {
    id: collection.id,
    color: {},
    component: {},
    sound: {}
  };

  for (const role of ROLES) {
    var _collection$sound, _collection$sound2;

    collectionWithFallbacks.sound[role] = ((_collection$sound = collection.sound) === null || _collection$sound === void 0 ? void 0 : _collection$sound[role]) || ((_collection$sound2 = collection.sound) === null || _collection$sound2 === void 0 ? void 0 : _collection$sound2[DEFAULT_ROLE]) || {};

    if (!collection.color[role]) {
      continue;
    }

    collectionWithFallbacks.color[role] = {};

    for (const element of ELEMENTS) {
      var _collection$color;

      const collectionRole = collection.color[role];
      const fallbackRole = (_collection$color = collection.color) === null || _collection$color === void 0 ? void 0 : _collection$color[DEFAULT_ROLE];
      const collectionElement = collectionRole === null || collectionRole === void 0 ? void 0 : collectionRole[element];

      if (isForegroundElement(element)) {
        for (const variant of VARIANTS) {
          if (hasVariant(collectionElement, variant) || collectionElement == null && variant === DEFAULT_FOREGROUND_VARIANT) {
            var _collectionWithFallba, _fallbackRole$element, _fallbackRole$element2, _ref, _ref2, _collectionVariant$DI;

            collectionWithFallbacks.color[role][element] = (_collectionWithFallba = collectionWithFallbacks.color[role][element]) !== null && _collectionWithFallba !== void 0 ? _collectionWithFallba : {};
            const collectionVariant = collectionElement === null || collectionElement === void 0 ? void 0 : collectionElement[variant];
            const fallbackVariant = collectionElement === null || collectionElement === void 0 ? void 0 : collectionElement[DEFAULT_FOREGROUND_VARIANT];
            const fallbackRoleVariant = (fallbackRole === null || fallbackRole === void 0 ? void 0 : (_fallbackRole$element = fallbackRole[element]) === null || _fallbackRole$element === void 0 ? void 0 : _fallbackRole$element[variant]) || (fallbackRole === null || fallbackRole === void 0 ? void 0 : (_fallbackRole$element2 = fallbackRole[element]) === null || _fallbackRole$element2 === void 0 ? void 0 : _fallbackRole$element2[DEFAULT_FOREGROUND_VARIANT]);
            collectionWithFallbacks.color[role][element][variant] = (_ref = collectionVariant !== null && collectionVariant !== void 0 ? collectionVariant : fallbackVariant) !== null && _ref !== void 0 ? _ref : fallbackRoleVariant;
            const disabledValue = (_ref2 = (_collectionVariant$DI = collectionVariant === null || collectionVariant === void 0 ? void 0 : collectionVariant[DISABLED]) !== null && _collectionVariant$DI !== void 0 ? _collectionVariant$DI : fallbackVariant === null || fallbackVariant === void 0 ? void 0 : fallbackVariant[DISABLED]) !== null && _ref2 !== void 0 ? _ref2 : fallbackRoleVariant === null || fallbackRoleVariant === void 0 ? void 0 : fallbackRoleVariant[DISABLED];

            if (disabledValue != null) {
              collectionWithFallbacks.color[role][element][variant].disabled = disabledValue;
            }
          }
        }
      } else {
        if (collectionRole) {
          const collectionElementWithFallback = collectionElement !== null && collectionElement !== void 0 ? collectionElement : fallbackRole === null || fallbackRole === void 0 ? void 0 : fallbackRole[element];

          if (isRegularModifier(collectionElementWithFallback)) {
            var _collectionWithFallba2, _collectionElementWit, _fallbackRole$element3;

            collectionWithFallbacks.color[role][element] = (_collectionWithFallba2 = collectionWithFallbacks.color[role][element]) !== null && _collectionWithFallba2 !== void 0 ? _collectionWithFallba2 : {};
            collectionWithFallbacks.color[role][element] = collectionElementWithFallback;
            const disabledValue = (_collectionElementWit = collectionElementWithFallback === null || collectionElementWithFallback === void 0 ? void 0 : collectionElementWithFallback[DISABLED]) !== null && _collectionElementWit !== void 0 ? _collectionElementWit : fallbackRole === null || fallbackRole === void 0 ? void 0 : (_fallbackRole$element3 = fallbackRole[element]) === null || _fallbackRole$element3 === void 0 ? void 0 : _fallbackRole$element3[DISABLED];

            if (disabledValue != null) {
              collectionWithFallbacks.color[role][element].disabled = disabledValue;
            }
          }
        }
      }
    }
  }

  for (const component of COMPONENTS) {
    var _collection$component;

    const componentStyles = (_collection$component = collection.component) === null || _collection$component === void 0 ? void 0 : _collection$component[component];

    if (componentStyles == null) {
      continue;
    }

    collectionWithFallbacks.component[component] = {};

    for (const role of ROLES) {
      const componentStyle = componentStyles[role];

      if (componentStyle == null) {
        continue;
      }

      collectionWithFallbacks.component[component][role] = {};

      if (componentStyle.texture != null) {
        var _textureStyle$hovered, _textureStyle$pressed, _textureStyle$disable, _textureStyle$focused, _textureStyle$selecte;

        const textureStyle = componentStyle.texture;
        const defaultTexture = textureStyle.default;

        if (defaultTexture.outset == null) {
          defaultTexture.outset = '0';
        }

        if (defaultTexture.repeat == null) {
          defaultTexture.repeat = 'stretch';
        }

        collectionWithFallbacks.component[component][role].texture = {
          default: defaultTexture,
          hovered: applyBaseTexture((_textureStyle$hovered = textureStyle.hovered) !== null && _textureStyle$hovered !== void 0 ? _textureStyle$hovered : {}, defaultTexture),
          pressed: applyBaseTexture((_textureStyle$pressed = textureStyle.pressed) !== null && _textureStyle$pressed !== void 0 ? _textureStyle$pressed : {}, defaultTexture),
          disabled: applyBaseTexture((_textureStyle$disable = textureStyle.disabled) !== null && _textureStyle$disable !== void 0 ? _textureStyle$disable : {}, defaultTexture),
          focused: applyBaseTexture((_textureStyle$focused = textureStyle.focused) !== null && _textureStyle$focused !== void 0 ? _textureStyle$focused : {}, defaultTexture),
          selected: applyBaseTexture((_textureStyle$selecte = textureStyle.selected) !== null && _textureStyle$selecte !== void 0 ? _textureStyle$selecte : {}, defaultTexture)
        };
      }
    }
  }

  return collectionWithFallbacks;
};

const applyBaseTexture = (texture, baseTexture) => {
  if (texture.slice == null) {
    texture.slice = baseTexture.slice;
  }

  if (texture.width == null) {
    texture.width = baseTexture.width;
  }

  if (texture.outset == null) {
    texture.outset = baseTexture.outset;
  }

  if (texture.repeat == null) {
    texture.repeat = baseTexture.repeat;
  }

  if (texture.source == null) {
    texture.source = baseTexture.source;
  }

  return texture;
};
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/index.ts









;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/RouterEngineProvider.tsx










/**
 * Provider that setups our routing and gamepad infrastructure, given the focus is tied to navigating URLs in the application.
 */
function RouterEngineProvider({
  children,
  keyboardGamepadMap,
  isInputLegendClickable
}) {
  var _semanticTokens$sound, _semanticTokens$sound2;

  const sharedFacetDriver = (0,react.useContext)(react_facet_src.sharedFacetDriverContext);
  const [history, setHistory] = (0,react.useState)(null);
  (0,react.useLayoutEffect)(() => {
    createEngineHistory(setHistory, sharedFacetDriver);
  }, [setHistory, sharedFacetDriver]);
  const handleFocusedIdChange = (0,react.useCallback)(newFocusedId => {
    if (!history) return;
    const location = history.location;

    if (location.pathname === '/' || location.pathname === '/__INVALID_ROUTE__') {
      // '/' was the old "fallback location" in Minecraft and is the current one in Legends returned when the current location is not valid.
      // '/__INVALID_ROUTE__' is the new "fallback location" in Minecraft.
      // This location can be returned when for example a screen currently being popped, or when a cached screen is destroyed as part of shutting down the game.
      // See RouterFacet::RouterHistoryAdapter::mFallbackLocation in OreUIRouterHistoryAdapter.cpp (Minecraft) or OreUIRouterFacet.cpp (Legends).
      return;
    }

    history.replace(getURLWithFocusedId(location, newFocusedId));
  }, [history]);
  const triggerSound = useSoundEffectTrigger();
  const isNarrationEnabled = useNarrationEnabled();
  const semanticTokens = useSemanticTokens();
  const semanticRejectSound = semanticTokens === null || semanticTokens === void 0 ? void 0 : (_semanticTokens$sound = semanticTokens.sound) === null || _semanticTokens$sound === void 0 ? void 0 : (_semanticTokens$sound2 = _semanticTokens$sound.neutral) === null || _semanticTokens$sound2 === void 0 ? void 0 : _semanticTokens$sound2.reject; // semanticTokens can be undefined if a collection isn't provided to the application

  const handleFocusedIdChangeFail = (0,react.useCallback)(() => {
    if (isNarrationEnabled && semanticRejectSound != null) {
      triggerSound(semanticRejectSound, 0, 0.5, 0.75);
    }
  }, [isNarrationEnabled, triggerSound, semanticRejectSound]);
  const notifyFocusRequest = (0,react.useCallback)(onHistoryChange => {
    if (history == null) return () => {};
    const idOrAlias = getFocusedIdFromLocation(history.location);

    if (idOrAlias != null) {
      onHistoryChange(idOrAlias);
    }

    const cleanup = history.listen(location => {
      const idOrAlias = getFocusedIdFromLocation(location);

      if (idOrAlias != null) {
        onHistoryChange(idOrAlias);
      }
    });
    return cleanup;
  }, [history]);

  if (!history) {
    return null;
  }

  return /*#__PURE__*/react.createElement(GamepadEngineProvider, {
    notifyFocusRequest: notifyFocusRequest,
    onFocusedIdChange: handleFocusedIdChange,
    onFocusedIdChangeFail: handleFocusedIdChangeFail,
    keyboardGamepadMap: keyboardGamepadMap,
    isInputLegendClickable: isInputLegendClickable
  }, /*#__PURE__*/react.createElement(Router, {
    history: history,
    children: children
  }));
}
;// CONCATENATED MODULE: ./node_modules/path-to-regexp/dist.es2015/index.js
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at " + i);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at " + j);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at " + j);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at " + i);
            if (!pattern)
                throw new TypeError("Missing pattern at " + i);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
    };
    var consumeText = function () {
        var result = "";
        var value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
        }
        return path;
    };
}
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = dist_es2015_pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            // tslint:disable-next-line
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
        for (var i = 0; i < groups.length; i++) {
            keys.push({
                name: i,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
        }
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return dist_es2015_pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
    var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
    var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                    }
                    else {
                        route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                    }
                }
                else {
                    route += "(" + token.pattern + ")" + token.modifier;
                }
            }
            else {
                route += "(?:" + prefix + suffix + ")" + token.modifier;
            }
        }
    }
    if (end) {
        if (!strict)
            route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
            route += "(?=" + delimiter + "|" + endsWith + ")";
        }
    }
    return new RegExp(route, flags(options));
}
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function dist_es2015_pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/Redirect.tsx



function Redirect_Redirect({
  history,
  to,
  from
}) {
  const match = useRouteMatch(from);
  (0,react.useEffect)(() => {
    const destination = match ? compile(to)(match.params) : to;
    history.replace(destination);
  }, [history, to, match]);
  return null;
}
function RedirectWrapper({
  from,
  to
}) {
  return /*#__PURE__*/react.createElement(react_router_Route, {
    exact: true,
    path: from,
    render: ({
      history
    }) => /*#__PURE__*/react.createElement(Redirect_Redirect, {
      history: history,
      to: to,
      from: from
    })
  });
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/RouteHistory.tsx
function RouteHistory_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function RouteHistory_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { RouteHistory_ownKeys(Object(source), true).forEach(function (key) { RouteHistory_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { RouteHistory_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function RouteHistory_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




const dummy = {
  push: () => {},
  replace: () => {},
  replaceKeepingFocus: () => {},
  replaceWithPreviousFocus: () => {},
  goBack: () => {}
};
const RouteHistory_context = (0,react.createContext)(dummy);

/**
 * Cache implementation that takes care of removing any trailing slash to store and retrieve entries
 */
const previousFocusedIdCache = (() => {
  const map = new Map();

  const removeTrailingSlash = route => {
    return route.replace(/\/$/, '');
  };

  return {
    set: (route, focusedId) => {
      map.set(removeTrailingSlash(route), focusedId);
    },
    get: route => {
      return map.get(removeTrailingSlash(route));
    }
  };
})();

const RouteHistory_RouteHistoryProvider = ({
  children,
  disabled
}) => {
  const history = useHistory();
  const disabledRef = (0,react.useRef)(disabled);
  disabledRef.current = disabled;
  const historyAPI = (0,react.useMemo)(() => ({
    goBack: () => {
      if (disabledRef.current) return;
      history.goBack();
    },
    push: route => {
      if (disabledRef.current) return;
      history.push(route);
    },
    replace: route => {
      if (disabledRef.current) return;
      history.replace(route);
    },
    replaceKeepingFocus: route => {
      if (disabledRef.current) return;
      const focusedId = getFocusedIdFromLocation(history.location);
      previousFocusedIdCache.set(history.location.pathname, focusedId);
      history.replace(getURLWithFocusedId(RouteHistory_objectSpread(RouteHistory_objectSpread({}, history.location), {}, {
        pathname: route
      }), focusedId));
    },
    replaceWithPreviousFocus: newRoute => {
      if (disabledRef.current) return;
      const currentFocusedId = getFocusedIdFromLocation(history.location);
      previousFocusedIdCache.set(history.location.pathname, currentFocusedId);
      const previousFocusedId = previousFocusedIdCache.get(newRoute);
      history.replace(getURLWithFocusedId(RouteHistory_objectSpread(RouteHistory_objectSpread({}, history.location), {}, {
        pathname: newRoute
      }), previousFocusedId));
    }
  }), [history]);
  return /*#__PURE__*/react.createElement(RouteHistory_context.Provider, {
    value: historyAPI
  }, children);
};
const RouteHistory_useRouteHistory = () => (0,react.useContext)(RouteHistory_context);
;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/routeParamsContext.tsx

const paramsContext = (0,react.createContext)({});

/**
 * Provider for the params of a route.
 *
 * This implementation differs from the useRouterParams of react-router by keeping the last known
 * value of the params even after the route is no longer matching.
 *
 * This is important for transitions to run while having access to the params of the route.
 */
function routeParamsContext_RouteParamsProvider({
  match,
  children
}) {
  const paramsRef = (0,react.useRef)({});

  if (match) {
    paramsRef.current = match.params;
  }

  return /*#__PURE__*/react.createElement(paramsContext.Provider, {
    value: paramsRef.current
  }, children);
}
/**
 * Hook for the params of a route.
 *
 * This implementation differs from the useRouterParams of react-router by keeping the last known
 * value of the params even after the route is no longer matching.
 *
 * This is important for transitions to run while having access to the params of the route.
 */

const useRouteParams = () => (0,react.useContext)(paramsContext);
;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/TestRoute.tsx





/**
 * Component to be used on testing of Route screens/components.
 *
 * It simulates that there is a route configured and the page is in a given URL.
 */
function TestRoute({
  url,
  route,
  children
}) {
  return /*#__PURE__*/React.createElement(MemoryRouter, {
    initialEntries: [url]
  }, /*#__PURE__*/React.createElement(RouteHistoryProvider, {
    disabled: false
  }, /*#__PURE__*/React.createElement(Route, {
    path: route,
    children: routerProps => {
      return /*#__PURE__*/React.createElement(RouteParamsProvider, {
        match: routerProps.match
      }, children);
    }
  })));
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/pathContext.tsx

const pathContext_PathContext = (0,react.createContext)([]);
const {
  Provider: pathContext_Provider,
  Consumer: pathContext_Consumer
} = pathContext_PathContext;

;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/id.tsx
// starts with 1 given 0 has a falsy value and can lead to incorrect checks
let seed = 1;
const __generateId = () => seed++;
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/boundedFocusContext.ts

const boundedFocusContext_Context = (0,react.createContext)(true);
const useShouldBoundFocus = () => (0,react.useContext)(boundedFocusContext_Context);
const BoundedFocusProvider = boundedFocusContext_Context.Provider;
const BoundedFocusConsumer = boundedFocusContext_Context.Consumer;
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/useContainer.tsx






function useContainer(gamepad, type, ref, nodeIdRef) {
  const shouldBoundFocus = useShouldBoundFocus();
  const id = (0,react.useMemo)(() => __generateId(), []);

  if (nodeIdRef) {
    nodeIdRef.current = id;
  }

  const gamepadFacet = (0,react_facet_src.useFacetWrap)(gamepad);
  const api = (0,react.useContext)(GamepadAPIContext);
  const path = (0,react.useContext)(pathContext_PathContext);
  /**
   * Tries to add the container to the focus tree during the render body to make sure it is available by the time
   * any focusable is rendered.
   *
   * If we rely only on effects, React runs the leaves first (adding the focusables before the containers).
   */

  const gamepadValue = gamepadFacet.get();

  if (gamepadValue != null && gamepadValue != react_facet_src.NO_VALUE) {
    const container = {
      type: type,
      id: id,
      path: path,
      bounded: shouldBoundFocus && gamepadValue.bounded,
      index: gamepadValue.index,
      defaultFocusedChildAlias: gamepadValue.defaultFocusedChildAlias,
      defaultFocusedChildBehavior: gamepadValue.defaultFocusedChildBehavior,
      disabled: gamepadValue.disabled,
      ref: ref,
      scrollWithAnalog: gamepadValue.scrollWithAnalog,
      scrollIntoView: gamepadValue.scrollIntoView,
      scrollIntoViewAlign: gamepadValue.scrollIntoViewAlign,
      scrollIntoViewOffset: gamepadValue.scrollIntoViewOffset,
      scrollIntoViewSpeedFactor: gamepadValue.scrollIntoViewSpeedFactor
    };
    api.addOrUpdateNode(container);
  }

  (0,react_facet_src.useFacetEffect)(gamepad => {
    const container = {
      type: type,
      id: id,
      path: path,
      bounded: shouldBoundFocus && gamepad.bounded,
      index: gamepad.index,
      defaultFocusedChildAlias: gamepad.defaultFocusedChildAlias,
      defaultFocusedChildBehavior: gamepad.defaultFocusedChildBehavior,
      disabled: gamepad.disabled,
      ref: ref,
      scrollWithAnalog: gamepad.scrollWithAnalog,
      scrollIntoView: gamepad.scrollIntoView,
      scrollIntoViewAlign: gamepad.scrollIntoViewAlign,
      scrollIntoViewOffset: gamepad.scrollIntoViewOffset,
      scrollIntoViewSpeedFactor: gamepad.scrollIntoViewSpeedFactor
    };
    api.addOrUpdateNode(container);
  }, [api, id, path, type, ref, shouldBoundFocus], [gamepadFacet]); // does nothing on mount
  // doesn't run on updates
  // remove on unmount

  (0,react.useEffect)(() => () => api.removeNode(id), [api, id]);
  const pathWithId = [...path, id];
  const Wrapper = (0,react.useMemo)(() => ({
    children
  }) => /*#__PURE__*/react.createElement(pathContext_Provider, {
    value: pathWithId
  }, children), // Disable lint check because we actually want each value in the array
  // eslint-disable-next-line react-hooks/exhaustive-deps
  pathWithId);
  return Wrapper;
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/useRow.tsx

function useRow(gamepad, ref, nodeIdRef) {
  return useContainer(gamepad, 'row', ref, nodeIdRef);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/useColumn.tsx

function useColumn(gamepad, ref, nodeIdRef) {
  return useContainer(gamepad, 'column', ref, nodeIdRef);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/deprecated.tsx




/**
 * @deprecated use Row instead
 */
function GamepadRow(props) {
  const gamepad = {
    bounded: props.bounded,
    disabled: props.disabled,
    index: props.gamepadIndex,
    defaultFocusedChildAlias: props.defaultFocusedChildAlias,
    defaultFocusedChildBehavior: props.defaultFocusedChildBehavior,
    scrollWithAnalog: props.scrollWithAnalog,
    scrollIntoView: props.scrollIntoView,
    scrollIntoViewAlign: props.scrollIntoViewAlign,
    scrollIntoViewOffset: props.scrollIntoViewOffset,
    scrollIntoViewSpeedFactor: props.scrollIntoViewSpeedFactor
  };
  const Row = useRow(gamepad, props.scrollRef, props.nodeIdRef);
  return /*#__PURE__*/react.createElement(Row, null, props.children);
}

/**
 * @deprecated use Column instead
 */
function GamepadColumn(props) {
  const gamepad = {
    bounded: props.bounded,
    disabled: props.disabled,
    index: props.gamepadIndex,
    defaultFocusedChildAlias: props.defaultFocusedChildAlias,
    defaultFocusedChildBehavior: props.defaultFocusedChildBehavior,
    scrollWithAnalog: props.scrollWithAnalog,
    scrollIntoView: props.scrollIntoView,
    scrollIntoViewAlign: props.scrollIntoViewAlign,
    scrollIntoViewOffset: props.scrollIntoViewOffset,
    scrollIntoViewSpeedFactor: props.scrollIntoViewSpeedFactor
  };
  const Column = useColumn(gamepad, props.scrollRef, props.nodeIdRef);
  return /*#__PURE__*/react.createElement(Column, null, props.children);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/disabledArea.tsx


const DisabledAreaContext = (0,react_facet_src.createFacetContext)({});
const {
  Provider: disabledArea_Provider,
  Consumer: disabledArea_Consumer
} = DisabledAreaContext;
const DisabledAreaProvider = (/* unused pure expression or super */ null && (disabledArea_Provider));
const DisabledAreaConsumer = (/* unused pure expression or super */ null && (disabledArea_Consumer));
function DisabledArea({
  disabled,
  hidden,
  children
}) {
  const context = (0,react.useContext)(DisabledAreaContext);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const hiddenFacet = (0,react_facet_src.useFacetWrap)(hidden);
  const value = (0,react_facet_src.useFacetMap)((context, disabled, hidden) => {
    return {
      disabled: disabled || context.disabled,
      hidden: hidden || context.hidden
    };
  }, [], [context, disabledFacet, hiddenFacet]);
  return /*#__PURE__*/react.createElement(disabledArea_Provider, {
    value: value
  }, children);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/id.tsx

let id_seed = ROOT_NODE_ID + 1;
const id_generateId = () => id_seed++;
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/disableFocusBinding.ts

const disableFocusBinding_Context = (0,react.createContext)(false);
const useDisableFocusBinding = () => (0,react.useContext)(disableFocusBinding_Context);
const DisableFocusBindingProvider = disableFocusBinding_Context.Provider;
const DisableFocusBindingConsumer = disableFocusBinding_Context.Consumer;
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/refreshFocus.tsx


const refreshFocus_Context = (0,react_facet_src.createFacetContext)(undefined);
const useRefreshFocus = () => (0,react.useContext)(refreshFocus_Context);
const RefreshFocusProvider = refreshFocus_Context.Provider;
const RefreshFocusConsumer = refreshFocus_Context.Consumer;
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/components/Landmark.tsx
function Landmark_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function Landmark_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Landmark_ownKeys(Object(source), true).forEach(function (key) { Landmark_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Landmark_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Landmark_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






const NO_LANDMARK_KEY = 'NO_LANDMARK_KEY';
const Landmark = ({
  children,
  disabled,
  hidden,
  alias,
  scrollAxis,
  scrollOptions,
  shouldBindFocus,
  containerRef,
  delegateFocusFirstFound,
  delegateFocusFromMemory,
  delegateFocusByAlias,
  landmarkKey
}) => {
  if (false) {}

  const id = (0,react.useMemo)(() => id_generateId(), []);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const hiddenFacet = (0,react_facet_src.useFacetWrap)(hidden);
  const delegateFocusFirstFoundFacet = (0,react_facet_src.useFacetWrap)(delegateFocusFirstFound);
  const delegateFocusFromMemoryFacet = (0,react_facet_src.useFacetWrap)(delegateFocusFromMemory);
  const delegateFocusByAliasFacet = (0,react_facet_src.useFacetWrap)(delegateFocusByAlias);
  const scrollAxisFacet = (0,react_facet_src.useFacetWrap)(scrollAxis);
  const aliasFacet = (0,react_facet_src.useFacetWrap)(alias);
  const scrollOptionsFacet = (0,react_facet_src.useFacetWrap)(scrollOptions);
  const shouldBindFocusFacet = (0,react_facet_src.useFacetWrap)(shouldBindFocus);
  const landmarkKeyFacet = (0,react_facet_src.useFacetWrap)(landmarkKey);
  const disabledContextFacet = (0,react.useContext)(DisabledAreaContext);
  const disableFocusBinding = useDisableFocusBinding();
  const focusTreeAPI = (0,react.useContext)(FocusTreeAPIContext);
  const path = (0,react.useContext)(PathContext);
  const refreshFocusFacet = useRefreshFocus();
  const parentId = path[path.length - 1];
  const setFocusedId = setFocusedId_useSetFocusedId();
  const createIsElementAncestorOf = (0,react.useCallback)(id => element => {
    var _element$getAttribute;

    const idAttribute = (_element$getAttribute = element.getAttribute(types_DATA_FOCUSABLE_ID)) !== null && _element$getAttribute !== void 0 ? _element$getAttribute : element.getAttribute(DATA_LANDMARK_ID);
    if (idAttribute == null) return false;
    const elementId = parseInt(idAttribute, 10);
    return id === elementId || focusTreeAPI.isAncestorOf(id, elementId);
  }, [focusTreeAPI]);
  const getDelegatedFocus = (0,react_facet_src.useFacetCallback)((delegateFocusFirstFound, delegateFocusFromMemory) => cachedDecedentElements => {
    const enabledBindingLandmarkDescendant = focusTreeAPI.getEnabledBindingLandmarkDescendant(id); // We start by looking at enabled binding landmark descendants.
    // Binding landmarks take priority over any other behavior

    if (enabledBindingLandmarkDescendant != null) {
      const cachedDecedentElementsOfMemory = cachedDecedentElements === null || cachedDecedentElements === void 0 ? void 0 : cachedDecedentElements.filter(createIsElementAncestorOf(enabledBindingLandmarkDescendant.id));
      const delegatedFocus = enabledBindingLandmarkDescendant.getDelegatedFocus(cachedDecedentElementsOfMemory);

      if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
        return delegatedFocus;
      }
    }

    const element = focusTreeAPI.getElement(id);
    const dynasty = focusTreeAPI.getDynasty(id);
    const delegatingLandmark = isDelegatingLandmark(element) ? element : undefined; // Check memory for focusable decedent

    if (delegatingLandmark != null && delegateFocusFromMemory) {
      var _delegatingLandmark$l, _delegatingLandmark$d;

      const usedLandmarkKey = (_delegatingLandmark$l = delegatingLandmark === null || delegatingLandmark === void 0 ? void 0 : delegatingLandmark.landmarkKey) !== null && _delegatingLandmark$l !== void 0 ? _delegatingLandmark$l : NO_LANDMARK_KEY;
      const delegationMemoryStack = delegatingLandmark === null || delegatingLandmark === void 0 ? void 0 : (_delegatingLandmark$d = delegatingLandmark.delegationMemoryStack) === null || _delegatingLandmark$d === void 0 ? void 0 : _delegatingLandmark$d.get(usedLandmarkKey);

      if (delegationMemoryStack != null) {
        // Loop through the memory stack and find the first available element
        let firstAvailableMemoryElement = undefined;

        for (let i = 0; i < delegationMemoryStack.length; i++) {
          const delegationMemoryId = delegationMemoryStack[i];
          const delegationMemoryElement = focusTreeAPI.getElement(delegationMemoryId);

          if (delegationMemoryElement != null && focusTreeAPI.isFocusable(delegationMemoryElement.id) && dynasty !== null && dynasty !== void 0 && dynasty.has(delegationMemoryElement.id)) {
            firstAvailableMemoryElement = delegationMemoryElement;
            break;
          }
        }

        if (firstAvailableMemoryElement != null) {
          const memoryDelegatingLandmark = isDelegatingLandmark(firstAvailableMemoryElement) ? firstAvailableMemoryElement : undefined;

          if (memoryDelegatingLandmark != null) {
            const cachedDecedentElementsOfMemory = cachedDecedentElements === null || cachedDecedentElements === void 0 ? void 0 : cachedDecedentElements.filter(createIsElementAncestorOf(memoryDelegatingLandmark.id));
            const delegatedFocus = memoryDelegatingLandmark.getDelegatedFocus(cachedDecedentElementsOfMemory);

            if (delegatedFocus != null && delegatedFocus != react_facet_src.NO_VALUE) {
              return delegatedFocus;
            }
          } else {
            return {
              id: firstAvailableMemoryElement.id,
              reason: NewFocusSuggestionReason.MemoryDelegation
            };
          }
        }
      }
    } // Delegate by alias. We are using the element ref here instead of the delegateFocusByAliasFacet
    // since we don't want to have several sources of truths.


    if (isDelegatingLandmark(focusTreeElement.current) && focusTreeElement.current.delegateFocusByAlias != null && focusTreeElement.current.delegateFocusByAlias != '') {
      const elementByAlias = focusTreeAPI.getElement(focusTreeElement.current.delegateFocusByAlias);

      if (elementByAlias != null && dynasty !== null && dynasty !== void 0 && dynasty.has(elementByAlias.id) && focusTreeAPI.isFocusable(elementByAlias.id)) {
        if (isDelegatingLandmark(elementByAlias)) {
          const cachedDecedentElementsOfMemory = cachedDecedentElements === null || cachedDecedentElements === void 0 ? void 0 : cachedDecedentElements.filter(createIsElementAncestorOf(elementByAlias.id));
          const delegatedFocus = elementByAlias.getDelegatedFocus(cachedDecedentElementsOfMemory);

          if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
            return delegatedFocus;
          }
        } else {
          return {
            id: elementByAlias.id,
            reason: NewFocusSuggestionReason.AliasDelegation
          };
        }
      }
    } // Get first focusable decedent


    if (delegateFocusFirstFound) {
      var _containerRef$current, _containerRef$current2;

      const defaultDelegatedId = focusTreeElement.current == null || focusTreeElement.current.hidden === true || focusTreeElement.current.disabled === true ? undefined : id;
      const defaultDelegatedFocus = defaultDelegatedId != null ? {
        id: defaultDelegatedId,
        reason: NewFocusSuggestionReason.DefaultDelegation
      } : undefined;
      const elements = cachedDecedentElements !== null && cachedDecedentElements !== void 0 ? cachedDecedentElements : Array.from((_containerRef$current = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.querySelectorAll(`[${types_DATA_FOCUSABLE_ID}], [${DATA_LANDMARK_ID}]`)) !== null && _containerRef$current !== void 0 ? _containerRef$current : []);

      if (elements.length === 0) {
        return defaultDelegatedFocus;
      }

      for (let i = 0; i < elements.length; i++) {
        const landmarkIdAttribute = elements[i].getAttribute(DATA_LANDMARK_ID);
        const focusableIdAttribute = elements[i].getAttribute(types_DATA_FOCUSABLE_ID);

        if (landmarkIdAttribute != null) {
          const landmarkId = parseInt(landmarkIdAttribute, 10);

          if (!(dynasty !== null && dynasty !== void 0 && dynasty.has(landmarkId))) {
            continue;
          }

          const landmarkElement = focusTreeAPI.getElement(landmarkId);

          if (!isDelegatingLandmark(landmarkElement)) {
            continue;
          }

          if (!focusTreeAPI.isFocusable(landmarkId)) {
            continue;
          }

          const isElementAncestorOfLandmark = createIsElementAncestorOf(landmarkId);
          const landmarkDecedentElements = elements.filter(isElementAncestorOfLandmark);
          const delegatedFocus = landmarkElement.getDelegatedFocus(landmarkDecedentElements);

          if (delegatedFocus != react_facet_src.NO_VALUE && delegatedFocus != null) {
            return delegatedFocus;
          }
        } else if (focusableIdAttribute != null) {
          const focusableId = parseInt(focusableIdAttribute, 10);

          if (dynasty !== null && dynasty !== void 0 && dynasty.has(focusableId) && focusTreeAPI.isFocusable(focusableId)) {
            return {
              id: focusableId,
              reason: NewFocusSuggestionReason.FirstFoundDelegation
            };
          }
        }
      }

      return defaultDelegatedFocus;
    }

    return undefined;
  }, [focusTreeAPI, containerRef, createIsElementAncestorOf, id], [delegateFocusFirstFoundFacet, delegateFocusFromMemoryFacet]);
  const onFocusableOfDynastyFocused = (0,react.useCallback)((decedentId, origin) => {
    // We don't want to store the focused id for delegation memory when the focus
    // originates from a tree mutation, since we rely on the memory being stable
    // between focus tree mutations of a sub tree. Furthermore, it is arguable that
    // delegation after a focus tree mutation much rather should be calculated when
    // needed instead and isn't preferable to store.
    if (origin === FocusOrigin.FocusTreeMutation) return;
    const element = focusTreeAPI.getElement(id);
    const delegatingLandmark = isDelegatingLandmark(element) ? element : undefined;

    if ((delegatingLandmark === null || delegatingLandmark === void 0 ? void 0 : delegatingLandmark.delegationMemoryStack) != null) {
      var _delegatingLandmark$l2;

      const usedLandmarkKey = (_delegatingLandmark$l2 = delegatingLandmark === null || delegatingLandmark === void 0 ? void 0 : delegatingLandmark.landmarkKey) !== null && _delegatingLandmark$l2 !== void 0 ? _delegatingLandmark$l2 : NO_LANDMARK_KEY; // We are intentionally mutating the delegationMemoryStack here without using
      // putNode, since this is considered local state of the node itself
      // and shouldn't cause any side effects / mutations of the rest of the tree or
      // to the currently focused element. The reason why we are doing this is because
      // calling putNode is a lot unnecessary overhead in this case. If we in the future
      // will do any other mutations to the node in this place then we should
      // consider to use putNode instead.

      const delegationMemoryStack = delegatingLandmark.delegationMemoryStack.get(usedLandmarkKey) || [];

      if (delegationMemoryStack != null) {
        // If the id already exists in the stack, remove it
        const itemIndexInStack = delegationMemoryStack.indexOf(decedentId);

        if (itemIndexInStack !== -1) {
          delegationMemoryStack.splice(itemIndexInStack, 1);
        } // Add the id to the top of the stack


        delegationMemoryStack.unshift(decedentId);
        delegatingLandmark.delegationMemoryStack.set(usedLandmarkKey, delegationMemoryStack);
      }
    }
  }, [focusTreeAPI, id]);
  const unObserve = (0,react.useRef)();
  const focusTreeElement = (0,react.useRef)(undefined);
  const refWasMissingOnFirstPutNode = (0,react.useRef)(false);
  /**
   * Tries to add the container to the focus tree during the render body to make sure it is available by the time
   * any focusable is rendered.LandmarkType
   *
   * If we rely only on effects, React runs the leaves first (adding the focusables before the containers).
   */

  (0,react.useMemo)(() => {
    var _unObserve$current;

    (_unObserve$current = unObserve.current) === null || _unObserve$current === void 0 ? void 0 : _unObserve$current.call(unObserve);
    unObserve.current = (0,react_facet_src.multiObserve)((disabled, hidden, scrollAxis, alias, scrollOptions, shouldBindFocus, disabledContext, delegateFocusFirstFound, delegateFocusByAlias, delegateFocusFromMemory, landmarkKey) => {
      const previousFocusable = focusTreeAPI.getElement(id);
      const delegatingProps = delegateFocusFirstFound ? Landmark_objectSpread(Landmark_objectSpread({
        onFocusableOfDynastyFocused,
        getDelegatedFocus
      }, !disableFocusBinding && shouldBindFocus ? {
        shouldBindFocus: true
      } : {}), {}, {
        delegateFocusByAlias,
        landmarkKey,
        delegationMemoryStack: delegateFocusFromMemory === true ? isDelegatingLandmark(previousFocusable) && previousFocusable.delegationMemoryStack != null ? previousFocusable.delegationMemoryStack : new Map() : undefined
      }) : {};

      const container = Landmark_objectSpread({
        scrollAxis: scrollAxis,
        type: types_FocusableType.LANDMARK,
        id: id,
        ref: containerRef.current,
        alias: alias,
        scrollIntoViewAlign: scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.scrollIntoViewAlign,
        scrollIntoViewOffset: scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.scrollIntoViewOffset,
        scrollIntoViewSpeedFactor: scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.scrollIntoViewSpeedFactor,
        disabled: disabled === true || disabledContext.disabled === true,
        hidden: hidden === true || disabledContext.hidden === true
      }, delegatingProps);

      focusTreeElement.current = container;
      refWasMissingOnFirstPutNode.current = containerRef.current == null;
      focusTreeAPI.putNode(container, parentId);
    }, [disabledFacet, hiddenFacet, scrollAxisFacet, aliasFacet, scrollOptionsFacet, shouldBindFocusFacet, disabledContextFacet, delegateFocusFirstFoundFacet, delegateFocusByAliasFacet, delegateFocusFromMemoryFacet, landmarkKeyFacet]);
  }, [id, focusTreeAPI, parentId, onFocusableOfDynastyFocused, containerRef, getDelegatedFocus, disableFocusBinding, disabledFacet, hiddenFacet, scrollAxisFacet, aliasFacet, scrollOptionsFacet, shouldBindFocusFacet, disabledContextFacet, delegateFocusFirstFoundFacet, delegateFocusByAliasFacet, delegateFocusFromMemoryFacet, landmarkKeyFacet]);
  (0,react.useEffect)(() => () => {
    var _unObserve$current2;

    (_unObserve$current2 = unObserve.current) === null || _unObserve$current2 === void 0 ? void 0 : _unObserve$current2.call(unObserve);
  }, []);
  (0,react.useEffect)(() => {
    if (!refWasMissingOnFirstPutNode.current) {
      return;
    }

    if (containerRef.current == null || focusTreeElement.current == null) {
      // The container ref could be missing when for example the Landmark is
      // disabled and the ref is not mounted until the Landmark is enabled.
      return;
    }

    const updatedContainer = Landmark_objectSpread(Landmark_objectSpread({}, focusTreeElement.current), {}, {
      ref: containerRef.current
    }); // We need to call putNode here again since container components can be a decedent of the Landmark component
    // and the useMemo above will run before React creates the native elements of decedent components.


    focusTreeAPI.putNode(updatedContainer, parentId); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  (0,react_facet_src.useFacetEffect)(refreshFocus => {
    if (focusTreeElement.current == null || focusTreeElement.current.hidden || focusTreeElement.current.disabled || refreshFocus == null) {
      return;
    }

    const delegatedFocus = getDelegatedFocus();

    if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
      setFocusedId(delegatedFocus.id, false);
    } // TODO: this didn't manage to save the memory of the child debug this

  }, [getDelegatedFocus, setFocusedId], [refreshFocusFacet]); // does nothing on mount
  // doesn't run on updates
  // remove on unmount

  (0,react.useEffect)(() => () => focusTreeAPI.removeNode(id), [focusTreeAPI, id]);
  const pathWithId = [...path, id];
  const Landmark = (0,react.useMemo)(() => ({
    children
  }) => /*#__PURE__*/react.createElement(PathContext.Provider, {
    value: pathWithId
  }, children), // Disable lint check because we actually want each value in the array
  // eslint-disable-next-line react-hooks/exhaustive-deps
  pathWithId); // This is for debugging the focus tree

  (0,react.useEffect)(() => {
    if (window.__REACT_FACET_DEVTOOLS_GLOBAL_HOOK__ == null) return;
    if (containerRef.current == null) return;
    containerRef.current.setAttribute(DATA_FOCUSABLE_DEBUG_ID, `${id}`);
  }, [id, containerRef]);
  return /*#__PURE__*/react.createElement(Landmark, null, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad/src/GamepadRow.tsx
function GamepadRow_extends() { GamepadRow_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return GamepadRow_extends.apply(this, arguments); }





function GamepadRow_GamepadRow(props) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return /*#__PURE__*/react.createElement(GamepadRow, props);
  }

  if (props.shouldSkipLandmarkInVisual) {
    return /*#__PURE__*/react.createElement(DisabledArea, {
      disabled: props.disabled
    }, props.children);
  }

  if (props.scrollAxis != null) {
    // wery weird typescript problem
    return /*#__PURE__*/react.createElement(Landmark, GamepadRow_extends({}, props, {
      scrollAxis: props.scrollAxis,
      shouldBindFocus: props.bounded,
      containerRef: props.scrollRef,
      delegateFocusFirstFound: props.defaultFocusedChildBehavior === 'first' || props.defaultFocusedChildBehavior === 'remember' || props.bounded,
      delegateFocusFromMemory: props.defaultFocusedChildBehavior === 'remember',
      delegateFocusByAlias: props.defaultFocusedChildAlias
    }));
  }

  return /*#__PURE__*/react.createElement(Landmark, GamepadRow_extends({}, props, {
    scrollAxis: props.scrollAxis,
    shouldBindFocus: props.bounded,
    containerRef: props.scrollRef,
    delegateFocusFirstFound: props.defaultFocusedChildBehavior === 'first' || props.defaultFocusedChildBehavior === 'remember' || props.bounded,
    delegateFocusFromMemory: props.defaultFocusedChildBehavior === 'remember',
    delegateFocusByAlias: props.defaultFocusedChildAlias
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/RouteInstantTransition/RouteInstantTransition.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RouteInstantTransition = ({"base":"qp8dp","exited":"Al8HR"});
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var node_modules_classnames = __webpack_require__(94184);
var classnames_default = /*#__PURE__*/__webpack_require__.n(node_modules_classnames);
;// CONCATENATED MODULE: ./packages/ui/src/RouteInstantTransition/RouteInstantTransition.tsx





function RouteInstantTransition_RouteInstantTransition({
  visible,
  unmountOnExit,
  contentComponent,
  renderTracker,
  defaultFocusedChildAlias,
  defaultFocusedChildBehavior
}) {
  const Content = (0,react.useMemo)(() => react.memo(contentComponent), [contentComponent]);
  const mountedRef = (0,react.useRef)(visible);
  mountedRef.current = unmountOnExit ? visible : mountedRef.current || visible;
  const ref = (0,react.useRef)(null);
  const hiddenFacet = (0,react_facet_src.useFacetWrap)(!visible);
  return mountedRef.current ? /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    scrollRef: ref,
    gamepadIndex: 0,
    disabled: !visible,
    defaultFocusedChildAlias: defaultFocusedChildAlias,
    defaultFocusedChildBehavior: defaultFocusedChildBehavior
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: classnames_default()(RouteInstantTransition.base, {
      [RouteInstantTransition.entered]: visible,
      [RouteInstantTransition.exited]: !visible
    })
  }, renderTracker && renderTracker(visible), /*#__PURE__*/react.createElement(Content, {
    hidden: hiddenFacet
  }))) : null;
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/animationConfiguration.ts


const animationConfiguration_context = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: true
}));
const ScreenAnimationEnabledProvider = animationConfiguration_context.Provider;
const useScreenAnimationEnabled = () => (0,react.useContext)(animationConfiguration_context);
;// CONCATENATED MODULE: ./packages/react-render-tracking/src/RouteActiveProvider.tsx


const RouteActiveProvider_context = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: false
}));
function RouteActiveProvider({
  children,
  active
}) {
  return /*#__PURE__*/react.createElement(RouteActiveProvider_context.Provider, {
    value: active
  }, children);
}
const useRouteActive = () => (0,react.useContext)(RouteActiveProvider_context);
;// CONCATENATED MODULE: ./packages/react-render-tracking/src/apiContext.ts

const RenderTrackingApiContext = (0,react.createContext)({
  block: () => {},
  unblock: () => {},
  contentfulPaint: () => {},
  meaningfulPaint: () => {}
});
;// CONCATENATED MODULE: ./packages/react-render-tracking/src/useRenderTrackingApi.ts


function useRenderTrackingApi() {
  return (0,react.useContext)(RenderTrackingApiContext);
}
;// CONCATENATED MODULE: ./packages/react-render-tracking/src/RenderTrackingDelay.tsx




let renderTrackingDelayId = 0;

/**
 * Used to block a given type of from being fired until ready.
 *
 * Example. Blocking contentful paint event until a transition is done.
 *
 *   const transitionComplete = useRef(false)
 * 	 <Transition onComplete={() => { transitionComplete = true }} />
 * 	 <RenderTrackingDelay type="contentful" renderingCompleted={transitionComplete} />
 */
function RenderTrackingDelay({
  type,
  renderingCompleted
}) {
  const renderTrackingApi = useRenderTrackingApi();
  const isRouteActive = useRouteActive();
  const id = (0,react.useMemo)(() => renderTrackingDelayId++, []);
  (0,react_facet_src.useFacetEffect)(isRouteActive => {
    if (!isRouteActive) {
      /**
       * If the user leaves the route that this blocker was on
       * then we should unblock it.
       */
      return renderTrackingApi.unblock(id, type);
    }

    if (renderingCompleted) {
      renderTrackingApi.unblock(id, type);
    } else {
      renderTrackingApi.block(id, type);
    }
  }, [id, renderingCompleted, renderTrackingApi, type], [isRouteActive]);
  return null;
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/Route.tsx
function Route_extends() { Route_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Route_extends.apply(this, arguments); }









function Route_Route(props) {
  return /*#__PURE__*/react.createElement(react_router_Route, {
    exact: true,
    path: props.route,
    children: routerProps => /*#__PURE__*/react.createElement(RouteChildWrapper, Route_extends({}, props, {
      routerProps: routerProps
    }))
  });
}

const RouteChildWrapper = ({
  component,
  transitionComponent: routeTransition,
  unmountOnPush,
  keepMountedOnPop,
  match,
  routerProps,
  defaultFocusedChildAlias,
  defaultFocusedChildBehavior
}) => {
  // If the Route component is wrapped by a Switch it will pass us a match prop.
  // Otherwise, it will be undefined, and we'll instead take it from the routerProps.
  // eslint-disable-next-line @mojang/no-strict-nullish-comparison/only-soft-nullish-comparison
  const routeMatch = match === undefined ? routerProps.match : match;
  return /*#__PURE__*/react.createElement(routeParamsContext_RouteParamsProvider, {
    match: routeMatch
  }, /*#__PURE__*/react.createElement(RouteActiveProvider, {
    active: (0,react_facet_src.useFacetWrap)(!!routeMatch)
  }, /*#__PURE__*/react.createElement(RouteChild, {
    unmountOnPush: unmountOnPush,
    keepMountedOnPop: keepMountedOnPop,
    component: component,
    routeTransition: routeTransition,
    action: routerProps.history.action,
    currentIn: !!routeMatch,
    defaultFocusedChildAlias: defaultFocusedChildAlias,
    defaultFocusedChildBehavior: defaultFocusedChildBehavior
  })));
};

/**
 * Memoized child component that takes care of preparing an environment for the route component to render
 *
 * The goal is to re-render this only when necessary
 */
const RouteChild = react.memo(({
  component,
  routeTransition,
  action,
  currentIn,
  unmountOnPush,
  keepMountedOnPop,
  defaultFocusedChildAlias,
  defaultFocusedChildBehavior
}) => {
  const mountComponentRef = (0,react.useRef)(null);
  const previouslyInRef = (0,react.useRef)(null);
  const screenAnimationEnabled = (0,react_facet_src.useFacetUnwrap)(useScreenAnimationEnabled()) === true;
  (0,react.useEffect)(() => {
    previouslyInRef.current = currentIn;
  }, [currentIn]); // Handles lazy rendering of a route
  // It works by having its default value as null (so not mounted)
  // Once the route is first mounted, mountComponentRef.current will be true permanently
  // This is used to maintain the state of routes as we navigate in the application

  mountComponentRef.current = mountComponentRef.current || currentIn; // If we POP from this route, we need to unmount it
  // We don't want to keep its state

  if (action === 'POP' && previouslyInRef.current && !keepMountedOnPop) {
    mountComponentRef.current = false;
  }

  const isNavigatingBack = action === 'POP';
  const RouteComponent = component;
  const RouteTransition = screenAnimationEnabled && routeTransition != null ? routeTransition : RouteInstantTransition_RouteInstantTransition;
  const unmountOnExit = !mountComponentRef.current || !!unmountOnPush;
  return /*#__PURE__*/react.createElement(RouteHistory_RouteHistoryProvider, {
    disabled: !currentIn
  }, /*#__PURE__*/react.createElement(RouteTransition, {
    defaultFocusedChildAlias: defaultFocusedChildAlias,
    defaultFocusedChildBehavior: defaultFocusedChildBehavior,
    visible: currentIn,
    unmountOnExit: unmountOnExit,
    contentComponent: RouteComponent,
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingDelay, {
      type: "contentful",
      renderingCompleted: isContentShown
    }),
    inverse: isNavigatingBack
  }));
});
;// CONCATENATED MODULE: ./packages/engine/src/engineWrapper/index.ts
/* eslint-env node */
if (false) {}
/*
 * There is a cohtml file provided by Coherent Labs that needs to loaded by the frontend to allow communication with the game engine.
 * Historically, this cohtml lived in this repository, but we have since moved it to be loaded and updated by the C++ backend.
 * We keep a legacyCohtml in this repository as a backwards compatible solution to older version of the C++ backend.
 *
 * YOU SHOULD NOT UPDATE THIS LOCAL cohtml file.
 */


const engineWrapper_engine =  true ? window.__bedrockProvidedCohtmljs === true ? window.engine : __webpack_require__(35341)() : 0; // eslint-disable-line @typescript-eslint/no-explicit-any
;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/Switch.tsx
function Switch_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function Switch_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Switch_ownKeys(Object(source), true).forEach(function (key) { Switch_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Switch_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Switch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





 // eslint-disable-next-line

const isRoute = x => {
  const props = Boolean(x.props) ? x.props : {};
  return Boolean(props.route) && Boolean(props.component);
};

const isRedirect = x => {
  const props = Boolean(x.props) ? x.props : {};
  return Boolean(props.from) && Boolean(props.component);
};

function Switch_Switch({
  children
}) {
  const location = useLocation();
  let hasPrevMatch = false;
  let shouldRender = false; // This is to calculate if we should render anything at all so OreUI screens dont overlap on JSONUI screens

  react.Children.forEach(children, child => {
    if (shouldRender === true) {
      return;
    }

    if (!(0,react.isValidElement)(child)) {
      return;
    }

    if (child.type === Route_Route) {
      if (matchPath(location.pathname, Switch_objectSpread(Switch_objectSpread({}, child.props), {}, {
        path: child.props.route
      }))) {
        shouldRender = true;
      }

      return;
    }

    if (child.type === RedirectWrapper) {
      if (matchPath(location.pathname, Switch_objectSpread(Switch_objectSpread({}, child.props), {}, {
        path: child.props.from
      }))) {
        shouldRender = true;
      }

      return;
    }
  });
  const childrenWithMatch = react.Children.map(children, child => {
    if (!(0,react.isValidElement)(child)) {
      return shouldRender ? child : null;
    }

    if (isRedirect(child)) {
      return child;
    }

    if (!isRoute(child)) {
      return shouldRender ? child : null;
    }

    const match = hasPrevMatch ? null : matchPath(location.pathname, Switch_objectSpread(Switch_objectSpread({}, child.props), {}, {
      path: child.props.route
    }));
    hasPrevMatch = hasPrevMatch || !!match;
    return react.cloneElement(child, {
      match
    });
  });
  /**
   * Event that notifies the backend engine that the Switch was unable to match any route.
   *
   * This is currently used by backend to consider the frontend to be in an "idle state".
   *
   * When a Gameface screen goes into this "idle state", the backend can safely stop updating it,
   * until a new route is pushed.
   *
   * For more information check the ticket, and pull requests.
   * - https://dev-mc.visualstudio.com/Minecraft/_workitems/edit/930195
   */

  (0,react.useEffect)(() => {
    if (!hasPrevMatch) {
      engineWrapper_engine.trigger('core:routing:not-found');
    }
  }, [hasPrevMatch]); // If there are no matches, return all the routes so that caching and "stay mounted on push" works, but do not render
  // anything else other than Routes and Redirects to not overlap with JSON UI

  return /*#__PURE__*/react.createElement(react.Fragment, null, childrenWithMatch);
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/useRouteQuery.ts


const useRouteQuery = () => {
  const location = useLocation();
  return new url_search_params_esm(location.search);
};
;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/index.tsx










;// CONCATENATED MODULE: ./packages/react-device-information/src/decideScreenType.ts

const screenTypeMap = {
  [Platform.IOS]: ScreenType.HANDHELD_SCREEN_TYPE,
  [Platform.GOOGLE]: ScreenType.HANDHELD_SCREEN_TYPE,
  [Platform.AMAZON_HANDHELD]: ScreenType.HANDHELD_SCREEN_TYPE,
  [Platform.UWP]: ScreenType.DESKTOP_SCREEN_TYPE,
  [Platform.XBOX]: ScreenType.TV_SCREEN_TYPE,
  [Platform.NX_HANDHELD]: ScreenType.HANDHELD_SCREEN_TYPE,
  [Platform.PS4]: ScreenType.TV_SCREEN_TYPE,
  [Platform.GEARVR]: ScreenType.HANDHELD_SCREEN_TYPE,
  [Platform.WIN32]: ScreenType.DESKTOP_SCREEN_TYPE,
  [Platform.MACOS]: ScreenType.DESKTOP_SCREEN_TYPE,
  [Platform.AMAZON_TV]: ScreenType.TV_SCREEN_TYPE,
  [Platform.NX_TV]: ScreenType.TV_SCREEN_TYPE,
  [Platform.PS5]: ScreenType.TV_SCREEN_TYPE
};
function decideScreenType(platform) {
  return screenTypeMap[platform];
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/decideControllerType.ts

const controllerTypeMap = {
  [Platform.IOS]: Controller.XBOX,
  // Asuming XBOX as default because missing information
  [Platform.GOOGLE]: Controller.XBOX,
  // Asuming XBOX as default because missing information
  [Platform.AMAZON_HANDHELD]: Controller.XBOX,
  // Asuming XBOX as default because missing information
  [Platform.UWP]: Controller.XBOX,
  [Platform.XBOX]: Controller.XBOX,
  [Platform.NX_HANDHELD]: Controller.SWITCH,
  [Platform.PS4]: Controller.PS,
  [Platform.GEARVR]: Controller.QUEST,
  [Platform.WIN32]: Controller.XBOX,
  [Platform.MACOS]: Controller.XBOX,
  [Platform.AMAZON_TV]: Controller.XBOX,
  [Platform.NX_TV]: Controller.SWITCH,
  [Platform.PS5]: Controller.PS
};
function decideControllerType(platform) {
  return controllerTypeMap[platform];
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/useUpdateBodyCursor.ts


function useUpdateBodyCursor(lastInputMethodUsed) {
  (0,react_facet_src.useFacetEffect)(lastInputMethodUsed => {
    if (lastInputMethodUsed === types_InputMethod.MOUSE) {
      document.body.style.cursor = 'auto';
    } else {
      document.body.style.cursor = 'none';
    }
  }, [], [lastInputMethodUsed]);
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/inputMethods/typeGuards.ts

const isFocusInputMethod = inputMethod => {
  return inputMethod === types_InputMethod.GAMEPAD || inputMethod === types_InputMethod.KEYBOARD;
};
const isPointerInputMethod = inputMethod => {
  return inputMethod === types_InputMethod.MOUSE || inputMethod === types_InputMethod.TOUCH;
};
;// CONCATENATED MODULE: ./packages/react-device-information/src/inputMethods/usePointerInputMethodState.ts





const getDefaultPointerInput = (lastInputMethodUsed, platform) => {
  if (isPointerInputMethod(lastInputMethodUsed)) {
    return lastInputMethodUsed;
  } // The defaults based on platform are just currently our "best guess" and we might need to tweak these in the future.
  // It is for example not clear if we should default to null, mouse or touch for consoles.


  switch (platform) {
    case Platform.WIN32:
    case Platform.MACOS:
      return types_InputMethod.MOUSE;

    case Platform.NX_HANDHELD:
    case Platform.IOS:
    case Platform.GOOGLE:
    case Platform.AMAZON_HANDHELD:
      return types_InputMethod.TOUCH;

    default:
      return null;
  }
}; // Handles state of the last used pointer input method (mouse or touch)


const usePointerInputMethodState = (lastInputMethodUsed, platform) => {
  const [pointerInputMethod, setPointerInputMethod] = (0,react_facet_src.useFacetState)(null);
  const isInitialized = (0,react.useRef)(false);
  (0,react_facet_src.useFacetEffect)((lastUsed, pointer, platform) => {
    // Initialize state
    if (!isInitialized.current && pointer == null) {
      isInitialized.current = true;
      setPointerInputMethod(getDefaultPointerInput(lastUsed, platform));
    } // Sync state based on last input method used
    else if (isPointerInputMethod(lastUsed) && pointer != lastUsed) {
        setPointerInputMethod(lastUsed);
      }
  }, [setPointerInputMethod], [lastInputMethodUsed, pointerInputMethod, platform]);
  return pointerInputMethod;
};
;// CONCATENATED MODULE: ./packages/react-device-information/src/inputMethods/useFocusInputMethodState.ts





const getDefaultFocusInput = (lastInputMethodUsed, platform) => {
  if (isFocusInputMethod(lastInputMethodUsed)) {
    return lastInputMethodUsed;
  } // The defaults based on platform are just currently our "best guess" and we might need to tweak these in the future.
  // It is for example not clear if we should default to null, keyboard or gamepad on touch devices.


  switch (platform) {
    case Platform.WIN32:
    case Platform.MACOS:
    case Platform.UWP:
      return types_InputMethod.KEYBOARD;

    case Platform.XBOX:
    case Platform.NX_HANDHELD:
    case Platform.PS4:
    case Platform.GEARVR:
    case Platform.AMAZON_TV:
    case Platform.NX_TV:
    case Platform.PS5:
      return types_InputMethod.GAMEPAD;

    default:
      return null;
  }
}; // Handles state of the last used focus input method (gamepad or keyboard)


const useFocusInputMethodState = (lastInputMethodUsed, platform) => {
  const [focusInputMethod, setFocusInputMethod] = (0,react_facet_src.useFacetState)(null);
  const isInitialized = (0,react.useRef)(false);
  (0,react_facet_src.useFacetEffect)((lastUsed, focus, platform) => {
    // Initialize state
    if (!isInitialized.current && focus == null) {
      isInitialized.current = true;
      setFocusInputMethod(getDefaultFocusInput(lastUsed, platform));
    } // Sync state based on last input method used
    else if (isFocusInputMethod(lastUsed) && focus != lastUsed) {
        setFocusInputMethod(lastUsed);
      }
  }, [setFocusInputMethod], [lastInputMethodUsed, focusInputMethod, platform]);
  return focusInputMethod;
};
;// CONCATENATED MODULE: ./packages/react-device-information/src/inputMethods/useInputMethods.ts




 // Hook that takes:
// - Facet for last input method used
// - Facet for supported input methods
// And returns:
// - Facets for current focus input method (gamepad or keyboard)
// - Facets for current pointer input method used (mouse or touch)
// - Facets for last input method used (of any input method)
// - Facets for supported input methods

const useInputMethods = (lastInputMethodUsed, supportedInputMethods, platform) => {
  const pointerInputMethod = usePointerInputMethodState(lastInputMethodUsed, platform);
  const focusInputMethod = useFocusInputMethodState(lastInputMethodUsed, platform);
  const isPointerInputMouse = (0,react_facet_src.useFacetMemo)(pointer => pointer === types_InputMethod.MOUSE, [], [pointerInputMethod]);
  const isPointerInputTouch = (0,react_facet_src.useFacetMemo)(pointer => pointer === types_InputMethod.TOUCH, [], [pointerInputMethod]);
  const isPointerInputAvailable = (0,react_facet_src.useFacetMemo)(pointer => pointer != null, [], [pointerInputMethod]);
  const isFocusInputGamepad = (0,react_facet_src.useFacetMemo)(focus => focus === types_InputMethod.GAMEPAD, [], [focusInputMethod]);
  const isFocusInputKeyboard = (0,react_facet_src.useFacetMemo)(focus => focus === types_InputMethod.KEYBOARD, [], [focusInputMethod]);
  const isFocusInputAvailable = (0,react_facet_src.useFacetMemo)(focus => focus != null, [], [focusInputMethod]);
  const isLastInputMouse = (0,react_facet_src.useFacetMemo)(last => last === types_InputMethod.MOUSE, [], [lastInputMethodUsed]);
  const isLastInputTouch = (0,react_facet_src.useFacetMemo)(last => last === types_InputMethod.TOUCH, [], [lastInputMethodUsed]);
  const isLastInputGamepad = (0,react_facet_src.useFacetMemo)(last => last === types_InputMethod.GAMEPAD, [], [lastInputMethodUsed]);
  const isLastInputKeyboard = (0,react_facet_src.useFacetMemo)(last => last === types_InputMethod.KEYBOARD, [], [lastInputMethodUsed]);
  const isLastInputPointer = (0,react_facet_src.useFacetMemo)(last => last === types_InputMethod.MOUSE || last === types_InputMethod.TOUCH, [], [lastInputMethodUsed]);
  const isLastInputFocus = (0,react_facet_src.useFacetMemo)(last => last === types_InputMethod.KEYBOARD || last === types_InputMethod.GAMEPAD, [], [lastInputMethodUsed]);
  const isGamepadSupported = (0,react_facet_src.useFacetMemo)(supported => supported.includes(types_InputMethod.GAMEPAD), [], [supportedInputMethods]);
  const isKeyboardSupported = (0,react_facet_src.useFacetMemo)(supported => supported.includes(types_InputMethod.KEYBOARD), [], [supportedInputMethods]);
  const isMouseSupported = (0,react_facet_src.useFacetMemo)(supported => supported.includes(types_InputMethod.MOUSE), [], [supportedInputMethods]);
  const isTouchSupported = (0,react_facet_src.useFacetMemo)(supported => supported.includes(types_InputMethod.TOUCH), [], [supportedInputMethods]);
  const isPointerSupported = (0,react_facet_src.useFacetMemo)(supported => {
    for (let i = 0; i < supported.length; i++) {
      if (isPointerInputMethod(supported[i])) return true;
    }

    return false;
  }, [], [supportedInputMethods]);
  const isFocusSupported = (0,react_facet_src.useFacetMemo)(supported => {
    for (let i = 0; i < supported.length; i++) {
      if (isFocusInputMethod(supported[i])) return true;
    }

    return false;
  }, [], [supportedInputMethods]);
  return {
    isPointerInputMouse,
    isPointerInputTouch,
    isPointerInputAvailable,
    isFocusInputGamepad,
    isFocusInputKeyboard,
    isFocusInputAvailable,
    isLastInputMouse,
    isLastInputTouch,
    isLastInputGamepad,
    isLastInputKeyboard,
    isLastInputPointer,
    isLastInputFocus,
    isGamepadSupported,
    isKeyboardSupported,
    isMouseSupported,
    isTouchSupported,
    isPointerSupported,
    isFocusSupported
  };
};
;// CONCATENATED MODULE: ./packages/react-device-information/src/DeviceInformationProvider.tsx







function DeviceInformationProvider({
  lastInputMethodUsed,
  supportedInputMethods,
  platform,
  arvrPlatform: vrPlatform,
  children
}) {
  const inputMethods = useInputMethods(lastInputMethodUsed, supportedInputMethods, platform);
  const screenTypeFacet = (0,react_facet_src.useFacetMemo)(platform => decideScreenType(platform), [], [platform]);
  const controllerTypeFacet = (0,react_facet_src.useFacetMemo)(platform => decideControllerType(platform), [], [platform]);
  useUpdateBodyCursor(lastInputMethodUsed);
  return /*#__PURE__*/react.createElement(InputMethodsContext.Provider, {
    value: inputMethods
  }, /*#__PURE__*/react.createElement(platformContext.Provider, {
    value: platform
  }, /*#__PURE__*/react.createElement(VRPlatformContext.Provider, {
    value: vrPlatform
  }, /*#__PURE__*/react.createElement(screenTypeContext.Provider, {
    value: screenTypeFacet
  }, /*#__PURE__*/react.createElement(controllerContext.Provider, {
    value: controllerTypeFacet
  }, children)))));
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/useMouseDetection.ts



const DISTANCE_THRESHOLD = 10;

const useTimeStampLastTouchEndEvent = isEnabledFacet => {
  const timeStampLastTouchEndEvent = (0,react.useRef)(-1);
  (0,react_facet_src.useFacetEffect)(isEnabled => {
    if (!isEnabled) {
      return;
    }

    const handleTouchEnd = event => {
      timeStampLastTouchEndEvent.current = event.timeStamp;
    };

    window.addEventListener('touchend', handleTouchEnd);
    return () => {
      window.removeEventListener('touchend', handleTouchEnd);
    };
  }, [], [isEnabledFacet]);
  return timeStampLastTouchEndEvent;
};

function useMouseDetection(isEnabledFacet, onMouseDetected, availableInputMethods) {
  // We want to track last touchend event when both mouse and touch input are available. The reason is
  // that the touchend event will also trigger the mousedown and mousemove events and in those cases
  // we don't want to call the mouse detected handler, since the source was touch input.
  const shouldTrackLastTouchEndTimeStamp = (0,react_facet_src.useFacetMap)(available => available.includes(types_InputMethod.MOUSE) && available.includes(types_InputMethod.TOUCH), [], [availableInputMethods]);
  const timeStampLastTouchEndEvent = useTimeStampLastTouchEndEvent(shouldTrackLastTouchEndTimeStamp);
  const mouseStartPositionRef = (0,react.useRef)(null);
  (0,react_facet_src.useFacetEffect)(isEnabled => {
    if (!isEnabled) {
      mouseStartPositionRef.current = null;
      return;
    }

    const shouldIgnoreMouseEvent = event => timeStampLastTouchEndEvent.current === event.timeStamp;

    const handleMouseMove = event => {
      const latestPosition = [event.clientX, event.clientY];

      if (!mouseStartPositionRef.current) {
        mouseStartPositionRef.current = latestPosition;
        return;
      }

      const a = Math.abs(latestPosition[0] - mouseStartPositionRef.current[0]);
      const b = Math.abs(latestPosition[1] - mouseStartPositionRef.current[1]);
      const distance = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));

      if (distance > DISTANCE_THRESHOLD) {
        mouseStartPositionRef.current = null;

        if (shouldIgnoreMouseEvent(event)) {
          return;
        }

        onMouseDetected();
      }
    };

    const handleMouseDown = event => {
      if (shouldIgnoreMouseEvent(event)) {
        return;
      }

      onMouseDetected();
    };

    const handleWheel = () => {
      onMouseDetected();
    };

    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('wheel', handleWheel);
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mousedown', handleMouseDown);
      window.removeEventListener('wheel', handleWheel);
    };
  }, [onMouseDetected, timeStampLastTouchEndEvent], [isEnabledFacet]);
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/useTouchDetection.ts

function useTouchDetection(isEnabledFacet, onTouchDetected) {
  (0,react_facet_src.useFacetEffect)(isEnabled => {
    if (!isEnabled) {
      return;
    } // We need to listen to touchend here since if the current touch input is the first touch input
    // received, making touch available, then the touchstart event won't be fired. In all other cases
    // we want to detect touch on touchstart since we want to adjust the UI as soon as possible for the
    // best user experience.


    window.addEventListener('touchstart', onTouchDetected);
    window.addEventListener('touchend', onTouchDetected);
    return () => {
      window.removeEventListener('touchstart', onTouchDetected);
      window.removeEventListener('touchend', onTouchDetected);
    };
  }, [onTouchDetected], [isEnabledFacet]);
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/useKeyboardDetection.tsx

const useKeyboardDetection = (isEnabledFacet, onKeyboardDetected) => {
  (0,react_facet_src.useFacetEffect)(isEnabled => {
    if (!isEnabled) return;
    window.addEventListener('keyup', onKeyboardDetected);
    return () => {
      window.removeEventListener('keyup', onKeyboardDetected);
    };
  }, [onKeyboardDetected], [isEnabledFacet]);
};
;// CONCATENATED MODULE: ./packages/engine/src/onGamepadInput.ts

const DEAD_ZONE = 0.16;
const onGamepadInput_onGamepadInput = handler => {
  let requestId;

  const detectGamepadInput = () => {
    const gamepads = getGamepads();
    const activeGamepads = gamepads.filter(gamepad => {
      if (gamepad == null) return false;
      const activeAxis = gamepad.axes.find(axis => Math.abs(axis) > DEAD_ZONE);
      if (activeAxis != null) return true;
      const activeButton = gamepad.buttons.find(button => button.pressed);
      if (activeButton) return true;
      return false;
    });

    if (activeGamepads.length > 0) {
      handler(activeGamepads);
    }

    requestId = window.requestAnimationFrame(detectGamepadInput);
  };

  detectGamepadInput();
  return () => window.cancelAnimationFrame(requestId);
};
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/useGamepadDetection.ts


function useGamepadDetection(isEnabledFacet, acceptInputFromAllControllersFacet, gameControllerIdFacet, onGamepadDetected) {
  (0,react_facet_src.useFacetEffect)((isEnabled, acceptInputFromAllControllers, gameControllerId) => {
    if (!isEnabled) {
      return;
    }

    const cleanup = onGamepadInput_onGamepadInput(gamepads => {
      const acceptedGamepads = acceptInputFromAllControllers ? gamepads : gamepads.filter(gamepad => gamepad.id === gameControllerId);

      if (acceptedGamepads.length > 0) {
        onGamepadDetected();
      }
    });
    return cleanup;
  }, [onGamepadDetected], [isEnabledFacet, acceptInputFromAllControllersFacet, gameControllerIdFacet]);
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/useLastUsedAndSupportedInputMethods.ts








const useSupportedInputMethods = supportedBackendInputMethods => {
  const [supportedInputMethods, setSupportedInputMethods] = (0,react_facet_src.useFacetState)([]); // Keyboard input is not sent to use from the backend so we need to keep track of it ourselves.
  // We are currently just saying that keyboard is supported if we have ever detected it,
  // which isn't ideal but the best we can do on the frontend.

  const isKeyboardSupported = (0,react.useRef)(false);
  const setKeyboardIsSupported = (0,react_facet_src.useFacetCallback)(supported => () => {
    if (!isKeyboardSupported.current) {
      isKeyboardSupported.current = true;
      const updatedSupported = Array.from(supported);
      updatedSupported.push(types_InputMethod.KEYBOARD);
      setSupportedInputMethods(updatedSupported);
    }
  }, [setSupportedInputMethods], [supportedInputMethods]);
  (0,react_facet_src.useFacetEffect)((supported, supportedFromBackend) => {
    const supportedLengthWithoutKeyboard = isKeyboardSupported.current ? supported.length - 1 : supported.length;
    const sameCount = supportedLengthWithoutKeyboard === supportedFromBackend.length;
    const shouldSync = !sameCount || !supportedFromBackend.every(method => supported.includes(method));

    if (shouldSync) {
      // Important to keep wrapping supportedFromBackend in Array.from(). The array originates from the backend
      // and those do not support the same operators / methods as native javascript arrays.
      const updatedSupported = Array.from(supportedFromBackend);

      if (isKeyboardSupported.current) {
        updatedSupported.push(types_InputMethod.KEYBOARD);
      }

      setSupportedInputMethods(updatedSupported);
    }
  }, [setSupportedInputMethods], [supportedInputMethods, supportedBackendInputMethods]);
  return {
    supportedInputMethods,
    setKeyboardIsSupported
  };
};

const useLastInputMethodUsed = currentBackendInputMethod => {
  const facetState = (0,react_facet_src.useFacetState)(null);
  const [lastInputMethodUsed, baseSetter] = facetState;
  const previousInputMethodRef = (0,react.useRef)(null); // Decorate the base setter in order to keep track of the previous input method used.

  const setLastInputMethodUsed = (0,react.useCallback)(newValue => {
    baseSetter(currentValue => {
      if (currentValue === newValue) {
        return currentValue;
      }

      if (currentValue !== react_facet_src.NO_VALUE) {
        previousInputMethodRef.current = currentValue;
      }

      return newValue;
    });
  }, [baseSetter]); // Sync last input method used with the backend. Note that we can not only do initialization here
  // and then track the state entirely on the frontend. This is due to how we initialize input methods
  // on the backend before running functional tests (see core:test:setInputMode).

  (0,react_facet_src.useFacetEffect)(currentBackendInputMethod => {
    if (currentBackendInputMethod == null) return;
    setLastInputMethodUsed(currentBackendInputMethod);
  }, [setLastInputMethodUsed], [currentBackendInputMethod]);
  return [lastInputMethodUsed, setLastInputMethodUsed, previousInputMethodRef];
}; // We only need to detect input on the frontend when we are going back and forth between
// keyboard and other input methods. The reason is that the backend tracks all input methods
// for us besides keyboard and we sync state changes received from the backend.
//
// The below illustrates the only place where we need to track state changes on the frontend:
// 1) Using Gamepad | Mouse | Touch -> Synced from backend state
// 2) Using Keyboard -> Tracked on the frontend entirely
// 3) Using same as 1) -> Tracked on the frontend, since from a backend perspective nothing has changed.


const useShouldListenToInput = (inputMethod, lastInputMethodUsed, supportedInputMethods, previousInputMethodRef, override = false) => {
  return (0,react_facet_src.useFacetMap)((last, supported) => override || previousInputMethodRef.current === inputMethod && last === types_InputMethod.KEYBOARD && supported.includes(inputMethod), [inputMethod, previousInputMethodRef, override], [lastInputMethodUsed, supportedInputMethods]);
}; // Hook that keeps track of last used input method and supported input methods.
// Keyboard is always supported after first use (since we don't get that state from the backend and we need to keep track of it ourselves)
// We do this aggregated hook in order to avoid setting up detection hooks for gamepad, mouse, touch and keyboard multiple times.


const useLastUsedAndSupportedInputMethods = (currentBackendInputMethod, acceptInputFromAllControllers, gameControllerId, supportedBackendInputMethods, options) => {
  const {
    supportedInputMethods,
    setKeyboardIsSupported
  } = useSupportedInputMethods(supportedBackendInputMethods);
  const [lastInputMethodUsed, setLastInputMethodUsed, previousInputMethodRef] = useLastInputMethodUsed(currentBackendInputMethod);
  const shouldListenToMouse = useShouldListenToInput(types_InputMethod.MOUSE, lastInputMethodUsed, supportedInputMethods, previousInputMethodRef, options === null || options === void 0 ? void 0 : options.trackAllUserInput);
  const shouldListenToTouch = useShouldListenToInput(types_InputMethod.TOUCH, lastInputMethodUsed, supportedInputMethods, previousInputMethodRef, options === null || options === void 0 ? void 0 : options.trackAllUserInput);
  const shouldListenToGamepad = useShouldListenToInput(types_InputMethod.GAMEPAD, lastInputMethodUsed, supportedInputMethods, previousInputMethodRef, options === null || options === void 0 ? void 0 : options.trackAllUserInput);
  const shouldListenToKeyboard = (0,react_facet_src.useFacetMap)(last => last !== types_InputMethod.KEYBOARD, [], [lastInputMethodUsed]);
  useMouseDetection(shouldListenToMouse, () => {
    setLastInputMethodUsed(types_InputMethod.MOUSE);
  }, supportedBackendInputMethods);
  useTouchDetection(shouldListenToTouch, () => {
    setLastInputMethodUsed(types_InputMethod.TOUCH);
  });
  useKeyboardDetection(shouldListenToKeyboard, () => {
    setKeyboardIsSupported();
    setLastInputMethodUsed(types_InputMethod.KEYBOARD);
  });
  useGamepadDetection(shouldListenToGamepad, acceptInputFromAllControllers, gameControllerId, () => {
    setLastInputMethodUsed(types_InputMethod.GAMEPAD);
  });
  return {
    lastInputMethodUsed,
    supportedInputMethods
  };
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/deviceInformationFacet.ts

const DEVICE_INFORMATION_FACET = 'core.deviceInformation';
/**
 * React Hook that requests the facet
 */

const deviceInformationFacet = (0,react_facet_src.sharedFacet)(DEVICE_INFORMATION_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/DeviceInformationEngineProvider.tsx
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = DeviceInformationEngineProvider_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function DeviceInformationEngineProvider_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







function DeviceInformationEngineProvider(_ref) {
  let {
    children
  } = _ref,
      options = _objectWithoutProperties(_ref, ["children"]);

  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const input = (0,react_facet_src.useSharedFacet)(inputFacet);
  const currentBackendInputMethod = (0,react_facet_src.useFacetMap)(inputFacet => inputFacet.currentInputType, [], [input]);
  const supportedBackendInputMethods = (0,react_facet_src.useFacetMap)(deviceInformation => deviceInformation.inputMethods, [], [deviceInformation]);
  const platform = (0,react_facet_src.useFacetMap)(deviceInformation => deviceInformation.platform, [], [deviceInformation]);
  const vrPlatform = (0,react_facet_src.useFacetMap)(deviceInformation => deviceInformation.arvrPlatform, [], [deviceInformation]);
  const acceptInputFromAllControllers = (0,react_facet_src.useFacetMap)(inputFacet => inputFacet.acceptInputFromAllControllers, [], [input]);
  const gameControllerId = (0,react_facet_src.useFacetMap)(inputFacet => inputFacet.gameControllerId, [], [input]); // This hook is needed since the MinecraftPE backend doesn't include keyboard input in `inputFacet.currentInputType`
  // and in `deviceInformation.inputMethods`. Ideally we would move all detection to the backend in the future.
  // We do the detection here in the engine layer instead of in the device information provider since this is a
  // Bedrock specific quirk.

  const {
    lastInputMethodUsed,
    supportedInputMethods
  } = useLastUsedAndSupportedInputMethods(currentBackendInputMethod, acceptInputFromAllControllers, gameControllerId, supportedBackendInputMethods, options);
  return /*#__PURE__*/react.createElement(DeviceInformationProvider, {
    platform: platform,
    arvrPlatform: vrPlatform,
    lastInputMethodUsed: lastInputMethodUsed,
    supportedInputMethods: supportedInputMethods
  }, children);
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/index.ts


;// CONCATENATED MODULE: ./packages/engine/src/ErrorBoundary.tsx





/**
 * Catches any error in the React sub-tree and renders the provided errorComponent
 */
function ErrorBoundary({
  children,
  errorComponent
}) {
  const [error, setError] = (0,react.useState)(null);
  const handleError = (0,react.useCallback)(error => {
    setError(error);
    engineWrapper_engine.trigger('core:exception');
  }, []);
  const clearError = (0,react.useCallback)(() => {
    setError(null);
  }, []);
  const isDevMode = "production" === 'development';
  const errorMessage = isDevMode && error ? error.message || 'Unknown error' : undefined;
  return /*#__PURE__*/react.createElement(ErrorCatcher, {
    onError: handleError
  }, error ? /*#__PURE__*/react.createElement(ErrorComponentWrapper, {
    dismissTimeout: isDevMode ? undefined : 40000,
    errorMessage: errorMessage,
    errorComponent: errorComponent,
    onDismiss: clearError
  }) : children);
}

class ErrorCatcher extends react.Component {
  static getDerivedStateFromError() {}

  componentDidCatch(error) {
    this.props.onError(error);
  }

  render() {
    return this.props.children;
  }

}

/**
 * Wrapper component to render the user-provided ErrorComponent
 * We use a wrapper to only request the routerFacet when needed (preventing unnecessary renders)
 */
function ErrorComponentWrapper({
  errorComponent: ErrorComponent,
  errorMessage,
  onDismiss,
  dismissTimeout
}) {
  const router = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(routerFacet));
  const handleDismiss = (0,react.useCallback)(() => {
    if (router != null && router !== react_facet_src.NO_VALUE) {
      router.history.goBack();
    } // Allows the history change to propagate so that the component that caused the error
    // will no longer be rendered


    requestAnimationFrame(onDismiss);
  }, [router, onDismiss]);
  (0,react.useEffect)(() => {
    // Automatically dismisses the ErrorModal after 4 seconds
    // TODO: remove this once we fix an issue that allows buttons in the error modal to work with Gamepad
    if (dismissTimeout != null) {
      const id = setTimeout(handleDismiss, dismissTimeout);
      return () => clearTimeout(id);
    }
  }, [router, handleDismiss, dismissTimeout]);
  return /*#__PURE__*/react.createElement(ErrorComponent, {
    errorMessage: errorMessage,
    onDismiss: handleDismiss
  });
}
;// CONCATENATED MODULE: ./packages/react-feature-flag/src/flagsContext.ts

const flagsContext_context = (0,react.createContext)([]);
const useFlags = () => (0,react.useContext)(flagsContext_context);
const FeatureFlagsProvider = flagsContext_context.Provider;
FeatureFlagsProvider.displayName = 'FeatureFlagsProvider';
;// CONCATENATED MODULE: ./packages/engine/src/facets/featureFlagsFacet.ts

const FEATURE_FLAGS_FACET = 'core.featureFlags';
/**
 * React Hook that requests the facet
 */

const featureFlagsFacet = (0,react_facet_src.sharedFacet)(FEATURE_FLAGS_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/FeatureFlagsEngineProvider.tsx




function FeatureFlagsEngineProvider({
  children
}) {
  const facetFlags = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(featureFlagsFacet));
  const flags = facetFlags === react_facet_src.NO_VALUE ? [] : facetFlags.flags;
  return /*#__PURE__*/react.createElement(FeatureFlagsProvider, {
    value: flags
  }, children);
}
;// CONCATENATED MODULE: ./packages/engine/src/facets/localeFacet.ts


const LOCALE_FACET = 'core.locale';
const localeFacet = (0,react_facet_src.sharedFacet)(LOCALE_FACET);
const localeFacetSelector = (0,react_facet_src.sharedSelector)(facet => {
  // We need to bind the functions to the localeFacet because separating
  // the function from the object causes Gameface to loose track of it and
  // crashes instantly when calling the function.
  return {
    set locale(newValue) {
      if (facet != null) {
        facet.locale = newValue;
      }
    },

    get locale() {
      return facet.locale;
    },

    translate: facet.translate != null ? facet.translate.bind(facet) : translateFallback,
    translateWithParameters: facet.translateWithParameters != null ? facet.translateWithParameters.bind(facet) : translateWithParametersFallback,
    formatDate: facet.formatDate != null ? facet.formatDate.bind(facet) : formatDateFallback
  };
}, [localeFacet]);
/**
 * Fallback implementation for old builds of the backend
 */

const translateFallback = key => {
  return engineWrapper_engine.translate(key);
};
/**
 * Fallback implementation for old builds of the backend
 */


const translateWithParametersFallback = key => {
  console.error('Update Bedrock to get support for translations with parameters.');
  return engineWrapper_engine.translate(key);
};
/**
 * Fallback implementation for old builds of the backend
 */


const formatDateFallback = timestampInSeconds => {
  console.error('Update Bedrock to get support for formatDate.');
  return `${timestampInSeconds}`;
};
;// CONCATENATED MODULE: ./packages/engine/src/providers/LocalizationEngineProvider.tsx




function LocalizationEngineProvider({
  children,
  developmentTranslations
}) {
  const locale = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(localeFacetSelector));
  const translate = (0,react.useCallback)((key, params) => {
    if (false) {}

    if (locale === react_facet_src.NO_VALUE) {
      return react_facet_src.NO_VALUE;
    }

    if (params != null) {
      return locale.translateWithParameters(key, params);
    }

    return locale.translate(key);
  }, [developmentTranslations, locale]);
  return locale !== react_facet_src.NO_VALUE ? /*#__PURE__*/react.createElement(LocalizationProvider, {
    translationPrefix: "hbui",
    locale: locale.locale,
    translate: translate,
    formatDate: locale.formatDate
  }, children) : null;
}
;// CONCATENATED MODULE: ./packages/react-narrator/src/context/narrationDriver.ts

const narrationDriverContext = (0,react.createContext)({
  narrationTree: {},
  readById: () => {},
  readText: () => {},
  clear: () => {}
});
const NarrationDriverProvider = narrationDriverContext.Provider;
;// CONCATENATED MODULE: ./packages/react-narrator/src/utils/getAncestry.ts
const getAncestry = (narrationTree, narrationId) => {
  if (narrationId === '') {
    return [];
  }

  const currentNode = narrationTree[narrationId];
  return [narrationId, ...getAncestry(narrationTree, currentNode.parentNarrationId)];
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/utils/getAncestryDifference.ts
const getAncestryDifference = (currentAncestry, previousAncestry) => {
  if (previousAncestry.length === 0) {
    return currentAncestry;
  }

  const lastCurrentItem = currentAncestry[currentAncestry.length - 1];
  const lastPreviousItem = previousAncestry[previousAncestry.length - 1];

  if (lastCurrentItem === lastPreviousItem) {
    return getAncestryDifference(currentAncestry.slice(0, -1), previousAncestry.slice(0, -1));
  }

  return currentAncestry;
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/utils/constructNarration.ts
const constructNarration = (narrationTree, ancestry) => {
  // The values on `shouldSkipParent` are the indexes of the ancestors to skip
  // The value `0` corresponds to the first parent, so the in ancestry array,
  // it corresponds to the element indexed as `1`, because the element `0` in
  // the ancestry array is the current node.
  // We index starting from the leaf instead of starting from the root
  // of the narration node tree because when we are developing we are most
  // aware of the immediate context of the current node, and not
  // necessarily of the root
  const nodesToSkip = narrationTree[ancestry[0]].shouldSkipParent;
  return ancestry.filter((_, index) => nodesToSkip.indexOf(index - 1) === -1).reverse().map(key => {
    var _narrationTree$key$ge, _narrationTree$key$ge2, _narrationTree$key;

    const item = narrationTree[key];

    if (item.text != null) {
      return item.text.trim();
    }

    return (_narrationTree$key$ge = (_narrationTree$key$ge2 = (_narrationTree$key = narrationTree[key]).getText) === null || _narrationTree$key$ge2 === void 0 ? void 0 : _narrationTree$key$ge2.call(_narrationTree$key).trim()) !== null && _narrationTree$key$ge !== void 0 ? _narrationTree$key$ge : '';
  }).filter(text => text !== '').join(' . ');
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/components/NarrationSetup.tsx




const NarrationSetup = ({
  children,
  disabled,
  narrationTree,
  driver,
  isIdle = true,
  shouldUseQueueSystem,
  shouldInterrupt
}) => {
  const isDisabledFacet = (0,react_facet_src.useFacetWrap)(disabled !== null && disabled !== void 0 ? disabled : true);
  const driverFacet = (0,react_facet_src.useFacetWrap)(driver);
  const [narrationQueueFacet, setNarrationQueueFacet] = (0,react_facet_src.useFacetState)([]);
  const isIdleFacet = (0,react_facet_src.useFacetWrap)(isIdle);
  const shouldUseQueueSystemFacet = (0,react_facet_src.useFacetWrap)(shouldUseQueueSystem !== null && shouldUseQueueSystem !== void 0 ? shouldUseQueueSystem : false);
  const shouldInterruptFacet = (0,react_facet_src.useFacetWrap)(shouldInterrupt !== null && shouldInterrupt !== void 0 ? shouldInterrupt : false);
  const narrationTreeDefaultRef = (0,react.useRef)({
    root: {
      text: '',
      parentNarrationId: '',
      shouldSkipParent: []
    }
  });
  const previousNarrationId = (0,react.useRef)('');
  const isDisabled = (0,react_facet_src.useFacetUnwrap)(isDisabledFacet);
  const disabledRef = (0,react.useRef)(isDisabled);
  (0,react_facet_src.useFacetEffect)((driver, isIdle, narrationQueue) => {
    /**
     * We only want to trigger the narration if the narration queue is not empty and the two following conditions are met:
     * 1. TTS driver is idle.
     * 2.TTS driver is not idle but the first item in the queue is can interrupt current narration.
     */
    if (narrationQueue.length > 0 && (Boolean(isIdle) || !Boolean(isIdle) && narrationQueue[0].itemShouldInterrupt)) {
      const [itemToNarrate, ...restOfQueue] = narrationQueue;
      const {
        narrationId,
        textToRead,
        profanityFilterContext,
        interruptible,
        required,
        playInBackground
      } = itemToNarrate;
      driver.read(textToRead, profanityFilterContext, interruptible, required, playInBackground);

      if (false) {}

      setNarrationQueueFacet(restOfQueue);

      if (false) {}

      if (narrationId != null) {
        previousNarrationId.current = narrationId;
      }
    }
  }, [setNarrationQueueFacet], [driverFacet, isIdleFacet, narrationQueueFacet]);
  const clear = (0,react_facet_src.useFacetCallback)(driver => () => {
    driver.clear();
  }, [], [driverFacet]);
  const readText = (0,react_facet_src.useFacetCallback)((driver, shouldUseQueueSystem, shouldInterrupt) => (narration, profanityFilterContext = {
    outOfGame: true,
    inGame: true
  }, interruptible = true, required = false, playInBackground = false, narrationId) => {
    if (!Boolean(shouldUseQueueSystem)) {
      driver.read(narration, profanityFilterContext, interruptible, required, playInBackground);

      if (narrationId != null) {
        previousNarrationId.current = narrationId;
      }
    } else {
      const newQueueItem = {
        narrationId,
        textToRead: narration,
        profanityFilterContext,
        interruptible: interruptible,
        required: required,
        playInBackground: playInBackground,
        itemShouldInterrupt: shouldInterrupt
      };

      if (Boolean(shouldInterrupt)) {
        setNarrationQueueFacet([newQueueItem]);
        return;
      }

      setNarrationQueueFacet(currentQueue => currentQueue !== react_facet_src.NO_VALUE ? [...currentQueue, newQueueItem] : [newQueueItem]);
    }
  }, [setNarrationQueueFacet], [driverFacet, shouldUseQueueSystemFacet, shouldInterruptFacet]); // To make testing easier, we want to have the functionality to manually pass in narrationTree.
  // For other scenarios they are not meaningful to add by the consumer of the API

  const actualNarrationTree = narrationTree ? narrationTree : narrationTreeDefaultRef.current;
  const readById = (0,react.useCallback)((narrationId, profanityFilterContext = {
    outOfGame: true,
    inGame: true
  }, interruptible = true, required = false, playInBackground = false) => {
    var _narrationNode$getSuf, _narrationNode$getSuf2;

    // TODO should we always do this?
    // Is there any scenario at all in which we wouldn’t want to clear the current
    // narration before starting the new one?
    // driver.clear()
    const currentAncestry = getAncestry(actualNarrationTree, narrationId);
    const previousAncestry = getAncestry(actualNarrationTree, previousNarrationId.current);
    const ancestryDifference = getAncestryDifference(currentAncestry, previousAncestry);
    const narration = constructNarration(actualNarrationTree, ancestryDifference.length === 0 ? [narrationId] : ancestryDifference);
    const narrationNode = actualNarrationTree[narrationId];
    const suffixNarration = (_narrationNode$getSuf = (_narrationNode$getSuf2 = narrationNode.getSuffix) === null || _narrationNode$getSuf2 === void 0 ? void 0 : _narrationNode$getSuf2.call(narrationNode)) !== null && _narrationNode$getSuf !== void 0 ? _narrationNode$getSuf : '';
    const finalNarration = suffixNarration !== '' ? narration + ' . ' + suffixNarration : narration;

    if (false) {}

    readText(finalNarration, profanityFilterContext, interruptible, required, playInBackground, narrationId);
  }, [actualNarrationTree, readText]);
  (0,react.useEffect)(() => {
    if (disabled === true) {
      clear();
    }
  }, [clear, disabled]);
  return /*#__PURE__*/react.createElement(NarrationDriverProvider, {
    value: {
      narrationTree: actualNarrationTree,
      readById,
      readText,
      clear
    }
  }, /*#__PURE__*/react.createElement(NarrationEnabledProvider, {
    value: isDisabled !== react_facet_src.NO_VALUE ? !isDisabled : true
  }, children));
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/screenReaderFacet.ts

let ProfanityFilterContext; // refer to https://coherent-labs.com/Documentation/cpp-gameface/df/d01/javascript_virtual_machine.html
// __Type is needed by Gameface when passing javascript object to C++

(function (ProfanityFilterContext) {
  ProfanityFilterContext[ProfanityFilterContext["NONE"] = 0] = "NONE";
  ProfanityFilterContext[ProfanityFilterContext["UI_FRONT_END"] = 1] = "UI_FRONT_END";
  ProfanityFilterContext[ProfanityFilterContext["UI_IN_GAME"] = 2] = "UI_IN_GAME";
  ProfanityFilterContext[ProfanityFilterContext["ALL_UI"] = ProfanityFilterContext.UI_FRONT_END | ProfanityFilterContext.UI_IN_GAME] = "ALL_UI";
  ProfanityFilterContext[ProfanityFilterContext["IN_GAME_CHAT"] = 4] = "IN_GAME_CHAT";
  ProfanityFilterContext[ProfanityFilterContext["IN_GAME_ITEMS"] = 8] = "IN_GAME_ITEMS";
  ProfanityFilterContext[ProfanityFilterContext["IN_GAME_NAME"] = 16] = "IN_GAME_NAME";
  ProfanityFilterContext[ProfanityFilterContext["ALL"] = ProfanityFilterContext.UI_FRONT_END | ProfanityFilterContext.UI_IN_GAME | ProfanityFilterContext.IN_GAME_CHAT | ProfanityFilterContext.IN_GAME_ITEMS | ProfanityFilterContext.IN_GAME_NAME] = "ALL";
})(ProfanityFilterContext || (ProfanityFilterContext = {}));

const SCREEN_READER_FACET = 'core.screenReader';
/**
 * React Hook that requests the facet
 */

const screenReaderSharedFacet = (0,react_facet_src.sharedFacet)(SCREEN_READER_FACET);
const screenReaderReadFactory = screenReader => (textToRead, profanityFilterContext, interruptible, required, playInBackground, playWhenPlatformTTSEnabled) => {
  screenReader.read(textToRead, profanityFilterContext, {
    __Type: 'core.screenReaderOptions',
    canBeInterrupted: interruptible,
    isRequired: required,
    shouldPlayInBackground: playInBackground,
    shouldPlayWhenPlatformTTSEnabled: playWhenPlatformTTSEnabled
  });
};
;// CONCATENATED MODULE: ./packages/engine/src/providers/useClearNarrationOnRouteChange.ts



/**
 * Whenever a user performs a navigation action, any narration that is currently on-going needs to stop.
 */

const useClearNarrationOnRouteChange = () => {
  const clearScreenReader = (0,react_facet_src.useFacetCallback)(screenReader => () => screenReader.clear(), [], [(0,react_facet_src.useSharedFacet)(screenReaderSharedFacet)]);
  (0,react_facet_src.useFacetEffect)(pathname => {
    /**
     * Since Ore UI screens can be pre-loaded for caching reasons, this code can execute
     * even without the screen being on a scene stack.
     *
     * Calling clear would wrongly cancel a narration on whatever screen is active in the game.
     */
    if (pathname !== ROUTER_INVALID_ROUTE) {
      clearScreenReader();
    }
  }, [clearScreenReader], [(0,react_facet_src.useFacetMap)(routerFacet => routerFacet.history.location.pathname, [], [(0,react_facet_src.useSharedFacet)(routerFacet)])]);
};
;// CONCATENATED MODULE: ./packages/engine/src/providers/NarratorEngineProvider.tsx







function NarratorEngineProvider({
  children,
  shouldUseQueueSystem
}) {
  useClearNarrationOnRouteChange(); // Warning note: This might cause excesive re-renders if isIdle is introduced to the screenReaderFacet

  const screenReaderFacet = (0,react_facet_src.useSharedFacet)(screenReaderSharedFacet);
  const isUITextToSpeechEnabledFacet = (0,react_facet_src.useFacetMap)(screenReader => screenReader.isUITextToSpeechEnabled, [], [screenReaderFacet]);
  const screenReaderIsIdleFacet = (0,react_facet_src.useFacetMap)(screenReader => screenReader.isIdle, [], [screenReaderFacet]);
  const read = (0,react_facet_src.useFacetCallback)(screenReaderReadFactory, [], [screenReaderFacet]);
  const clear = (0,react_facet_src.useFacetCallback)(screenReader => () => screenReader.clear(), [], [screenReaderFacet]);
  const lastFocusOriginFacet = useLastFocusOrigin();
  const shouldInterrupt = (0,react_facet_src.useFacetMap)(currentFocusChangeSource => currentFocusChangeSource === FocusOrigin.FocusInput || currentFocusChangeSource === FocusOrigin.PointerInput || currentFocusChangeSource === FocusOrigin.URL, [], [lastFocusOriginFacet]);
  const driverRead = (0,react_facet_src.useFacetCallback)(isUITextToSpeechEnabled => (text, profanityContext, interruptible, required, playInBackground) => {
    if (Boolean(isUITextToSpeechEnabled)) {
      read(text, mapProfanityContext(profanityContext), interruptible, required, playInBackground, true);
    }
  }, [read], [isUITextToSpeechEnabledFacet]);
  const driverFacet = (0,react.useMemo)(() => ({
    read: driverRead,
    clear: () => clear()
  }), [driverRead, clear]);
  const isDisabledFacet = (0,react_facet_src.useFacetMap)(isUITextToSpeechEnabled => !Boolean(isUITextToSpeechEnabled), [], [isUITextToSpeechEnabledFacet]);
  return /*#__PURE__*/react.createElement(NarrationSetup, {
    driver: driverFacet,
    disabled: isDisabledFacet,
    isIdle: screenReaderIsIdleFacet,
    shouldUseQueueSystem: shouldUseQueueSystem === true,
    shouldInterrupt: shouldInterrupt
  }, children);
}
function mapProfanityContext(profanityContext) {
  let x = 0;

  if (profanityContext.outOfGame) {
    x = x + ProfanityFilterContext.UI_FRONT_END;
  }

  if (profanityContext.inGame) {
    x = x + ProfanityFilterContext.UI_IN_GAME;
  }

  if (profanityContext.inGameChat) {
    x = x + ProfanityFilterContext.IN_GAME_CHAT;
  }

  if (profanityContext.inGameItem) {
    x = x + ProfanityFilterContext.IN_GAME_ITEMS;
  }

  if (profanityContext.inGameName) {
    x = x + ProfanityFilterContext.IN_GAME_NAME;
  }

  return x;
}
;// CONCATENATED MODULE: ./packages/react-sound-effect/src/SoundProvider.tsx


function SoundProvider({
  children,
  driver
}) {
  return /*#__PURE__*/react.createElement(context_Provider, {
    value: driver.play
  }, children);
}
;// CONCATENATED MODULE: ./packages/engine/src/facets/soundFacet.ts

const SOUND_FACET = 'core.sound';
const soundFacet = (0,react_facet_src.sharedFacet)(SOUND_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/SoundEngineProvider.tsx




function SoundEngineProvider({
  children
}) {
  const soundApi = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(soundFacet));
  const soundDriver = (0,react.useMemo)(() => ({
    play(eventName, extraDelay, volume = 1, pitch = 1) {
      const delay = extraDelay;
      let soundId;
      let timeout;

      const play = () => {
        if (soundApi == null || soundApi === react_facet_src.NO_VALUE) {
          console.log('Bedrock Sound driver not yet initialized while playing', eventName);
          return;
        }

        soundId = soundApi.play(eventName, volume, pitch);
      };

      if (delay > 0) {
        timeout = setTimeout(play, delay);
      } else {
        play();
      }

      return () => {
        if (timeout != null) clearTimeout(timeout);

        if (soundApi == null || soundApi === react_facet_src.NO_VALUE) {
          console.log('Bedrock Sound driver not yet initialized while stopping', eventName);
          return;
        } else if (soundApi.isPlaying(soundId)) {
          soundApi.fadeOut(soundId, 0);
        }
      };
    }

  }), [soundApi]);
  return /*#__PURE__*/react.createElement(SoundProvider, {
    driver: soundDriver
  }, children);
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/SafeZone/SafeZoneContext.ts

const safeZoneContext = (0,react.createContext)({
  top: 0,
  bottom: 0,
  left: 0,
  right: 0
});
const useSafeZone = () => (0,react.useContext)(safeZoneContext);
;// CONCATENATED MODULE: ./packages/react-device-information/src/SplitScreen.tsx

let SplitScreen_SplitScreenDirection;

(function (SplitScreenDirection) {
  SplitScreenDirection[SplitScreenDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
  SplitScreenDirection[SplitScreenDirection["VERTICAL"] = 1] = "VERTICAL";
})(SplitScreen_SplitScreenDirection || (SplitScreen_SplitScreenDirection = {}));

const splitScreenContext = (0,react.createContext)({
  numActivePlayers: 1,
  direction: SplitScreen_SplitScreenDirection.HORIZONTAL,
  position: 0
});
const useSplitScreen = () => (0,react.useContext)(splitScreenContext);
function SplitScreenProvider({
  children,
  numActivePlayers,
  direction = SplitScreen_SplitScreenDirection.HORIZONTAL,
  position
}) {
  const value = (0,react.useMemo)(() => ({
    numActivePlayers,
    direction,
    position
  }), [numActivePlayers, direction, position]);
  return /*#__PURE__*/react.createElement(splitScreenContext.Provider, {
    value: value
  }, children);
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/SafeZone/useSafeZoneCalculation/calculateSafeZone.ts
function calculateSafeZone(safeAreaX, safeAreaY, screenPositionX, screenPositionY) {
  const clampedSafeAreaX = calculateSafeZone_clamp(safeAreaX, 0.9, 1);
  const clampedSafeAreaY = calculateSafeZone_clamp(safeAreaY, 0.9, 1);
  const clampedScreenPositionX = calculateSafeZone_clamp(screenPositionX, -0.1, 0.1);
  const clampedScreenPositionY = calculateSafeZone_clamp(screenPositionY, -0.1, 0.1);
  const windowWidth = window.innerWidth;
  const windowHeight = window.innerHeight;
  return {
    top: Math.round((1 - clampedSafeAreaY + clampedScreenPositionY) / 2 * windowHeight),
    bottom: Math.round((1 - clampedSafeAreaY - clampedScreenPositionY) / 2 * windowHeight),
    left: Math.round((1 - clampedSafeAreaX + clampedScreenPositionX) / 2 * windowWidth),
    right: Math.round((1 - clampedSafeAreaX - clampedScreenPositionX) / 2 * windowWidth)
  };
}

function calculateSafeZone_clamp(input, min, max) {
  return Math.min(Math.max(input, min), max);
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/SafeZone/useSafeZoneCalculation/applySplitScreen.ts
var applySplitScreen_SplitScreenDirection;

(function (SplitScreenDirection) {
  SplitScreenDirection[SplitScreenDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
  SplitScreenDirection[SplitScreenDirection["VERTICAL"] = 1] = "VERTICAL";
})(applySplitScreen_SplitScreenDirection || (applySplitScreen_SplitScreenDirection = {}));

function applySplitScreen({
  top,
  bottom,
  left,
  right
}, {
  numActivePlayers,
  direction,
  position
}) {
  return {
    top: isOnTop(numActivePlayers, position, direction) ? top : 0,
    bottom: isOnBottom(numActivePlayers, position, direction) ? bottom : 0,
    left: isOnLeft(numActivePlayers, position, direction) ? left : 0,
    right: isOnRight(numActivePlayers, position, direction) ? right : 0
  };
}

function isOnTop(numActivePlayers, position, direction) {
  switch (numActivePlayers) {
    case 2:
      return position === 0 || position === 1 && direction === applySplitScreen_SplitScreenDirection.VERTICAL;

    case 3:
      return position === 0 || position === 1;

    case 4:
      return position === 0 || position === 1;

    default:
      return true;
  }
}

function isOnBottom(numActivePlayers, position, direction) {
  switch (numActivePlayers) {
    case 2:
      return position === 1 || position === 0 && direction === applySplitScreen_SplitScreenDirection.VERTICAL;

    case 3:
      return position === 2;

    case 4:
      return position === 2 || position === 3;

    default:
      return true;
  }
}

function isOnLeft(numActivePlayers, position, direction) {
  switch (numActivePlayers) {
    case 2:
      return position === 0 || position === 1 && direction === applySplitScreen_SplitScreenDirection.HORIZONTAL;

    case 3:
      return position === 0 || position === 2;

    case 4:
      return position === 0 || position === 2;

    default:
      return true;
  }
}

function isOnRight(numActivePlayers, position, direction) {
  switch (numActivePlayers) {
    case 2:
      return position === 1 || position === 0 && direction === applySplitScreen_SplitScreenDirection.HORIZONTAL;

    case 3:
      return position === 1;

    case 4:
      return position === 1 || position === 3;

    default:
      return true;
  }
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/SafeZone/useSafeZoneCalculation/useSafeZoneCalculation.ts




function useSafeZoneCalculation(safeAreaX, safeAreaY, screenPositionX, screenPositionY) {
  const splitScreen = useSplitScreen();
  const calculateSafeZoneWithLatestValues = (0,react.useCallback)(() => calculateSafeZone(safeAreaX, safeAreaY, screenPositionX, screenPositionY), [safeAreaX, safeAreaY, screenPositionX, screenPositionY]);
  const calculateSafeZoneWithSplitScreen = (0,react.useCallback)(() => applySplitScreen(calculateSafeZoneWithLatestValues(), splitScreen), [calculateSafeZoneWithLatestValues, splitScreen]);
  const [safeZone, setSafeZone] = (0,react.useState)(calculateSafeZoneWithSplitScreen);
  (0,react.useEffect)(() => {
    setSafeZone(calculateSafeZoneWithSplitScreen);

    const onResize = () => setSafeZone(calculateSafeZoneWithSplitScreen);

    window.addEventListener('resize', onResize);
    return () => {
      window.removeEventListener('resize', onResize);
    };
  }, [calculateSafeZoneWithSplitScreen]);
  return safeZone;
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/SafeZone/SafeZoneProvider.tsx



function SafeZoneProvider({
  children,
  safeAreaX,
  safeAreaY,
  screenPositionX,
  screenPositionY
}) {
  const safeZone = useSafeZoneCalculation(safeAreaX, safeAreaY, screenPositionX, screenPositionY);
  return /*#__PURE__*/react.createElement(safeZoneContext.Provider, {
    value: safeZone
  }, children);
}
;// CONCATENATED MODULE: ./packages/engine/src/facets/safeZoneFacet.ts

const SAFE_ZONE_FACET = 'core.safeZone';
/**
 * React Hook that requests the facet
 */

const safeZoneFacet = (0,react_facet_src.sharedFacet)(SAFE_ZONE_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/SafeZoneEngineProvider.tsx




function SafeZoneEngineProvider({
  children
}) {
  const safeZone = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(safeZoneFacet));
  return safeZone != null && safeZone !== react_facet_src.NO_VALUE ? /*#__PURE__*/react.createElement(SafeZoneProvider, {
    safeAreaX: safeZone.safeAreaX,
    safeAreaY: safeZone.safeAreaY,
    screenPositionX: safeZone.screenPositionX,
    screenPositionY: safeZone.screenPositionY
  }, children) : null;
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/SplitScreenEngineProvider.tsx




function SplitScreenEngineProvider({
  children
}) {
  const splitScreen = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(splitScreenFacet));
  return splitScreen != null && splitScreen !== react_facet_src.NO_VALUE ? /*#__PURE__*/react.createElement(SplitScreenProvider, {
    numActivePlayers: splitScreen.numActivePlayers,
    direction: splitScreen.splitScreenDirection,
    position: splitScreen.splitScreenPosition
  }, children) : null;
}
;// CONCATENATED MODULE: ./packages/ui/src/UIProvider/UIProvider.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const UIProvider = ({});
;// CONCATENATED MODULE: ./packages/themes/src/context.ts

const interactiveThemeContext = (0,react.createContext)({
  theme: "vanilla" || 0,
  onSetTheme: () => {}
});
const context_InteractiveThemeProvider = interactiveThemeContext.Provider;
const useInteractiveTheme = () => useContext(interactiveThemeContext).theme;
;// CONCATENATED MODULE: ./packages/themes/src/Provider/ThemeProvider.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ThemeProvider = ({"themeProvider":"N1Tqo"});
;// CONCATENATED MODULE: ./packages/ui/src/Button/Button.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Button_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/NintendoImages/NintendoIcons.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NintendoIcons_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PCImages/PCImages.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PCImages_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PS4Images/PS4Icons.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PS4Icons_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PS5Images/PS5Icons.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PS5Icons_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/XboxImages/XboxIcons.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const XboxIcons_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Divider/Divider.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Divider_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/InputLegend.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InputLegend_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Link/Link.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Link_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItem.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ListItem_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/BackButton/BackButton.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BackButton_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/MenuButton/MenuButton.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MenuButton_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/NavigationBar/NavigationBar.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NavigationBar_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationButton/NavigationButton.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NavigationButton_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/ProgressBar/ProgressBar.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ProgressBar_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/RadioGroup/RadioBox.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RadioBox_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/SideMenu/SideMenu.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SideMenu_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Slider/Slider.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Slider_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Switch/Switch.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Switch_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/TabBar/TabBar.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const TabBar_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Toggles/Toggle.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Toggle_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/UIProvider/UIProvider.tokens.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const UIProvider_tokens_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Window/Window.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Window_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Divider/Divider.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Divider_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Link/Link.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Link_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/BackButton/BackButton.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BackButton_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/MenuButton/MenuButton.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MenuButton_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/NavigationBar/NavigationBar.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NavigationBar_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationButton/NavigationButton.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NavigationButton_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/UIProvider/UIProvider.tokens.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const UIProvider_tokens_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/themeVariables.ts
// Vanilla tokens






















 // Docs tokens









const toClassNamesFlatList = (...styles) => {
  return styles.reduce((flatStyles, currentStyles) => {
    flatStyles = flatStyles.concat(Object.values(currentStyles));
    return flatStyles;
  }, []);
};

const themeVariables = {
  docs: toClassNamesFlatList(Divider_theme_docs_variables, Link_theme_docs_variables, BackButton_theme_docs_variables, MenuButton_theme_docs_variables, NavigationBar_theme_docs_variables, NavigationButton_theme_docs_variables, UIProvider_tokens_theme_docs_variables),
  vanilla: toClassNamesFlatList(Button_theme_vanilla_variables, NintendoIcons_theme_vanilla_variables, PCImages_theme_vanilla_variables, PS4Icons_theme_vanilla_variables, PS5Icons_theme_vanilla_variables, XboxIcons_theme_vanilla_variables, Divider_theme_vanilla_variables, InputLegend_theme_vanilla_variables, Link_theme_vanilla_variables, ListItem_theme_vanilla_variables, BackButton_theme_vanilla_variables, MenuButton_theme_vanilla_variables, NavigationBar_theme_vanilla_variables, NavigationButton_theme_vanilla_variables, ProgressBar_theme_vanilla_variables, RadioBox_theme_vanilla_variables, SideMenu_theme_vanilla_variables, Slider_theme_vanilla_variables, Switch_theme_vanilla_variables, TabBar_theme_vanilla_variables, Toggle_theme_vanilla_variables, UIProvider_tokens_theme_vanilla_variables, Window_theme_vanilla_variables)
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseDropdown/BaseDropdown.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseDropdown_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseSlider/BaseSlider.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseSlider_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseTextField/component/BaseTextField.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseTextField_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Pressable/Pressable.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Pressable_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/MouseScrollbar.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MouseScrollbar_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/ScrollView.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ScrollView_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseDropdown/BaseDropdown.theme.badger.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseDropdown_theme_badger_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseSlider/BaseSlider.theme.badger.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseSlider_theme_badger_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseTextField/component/BaseTextField.theme.badger.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseTextField_theme_badger_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Pressable/Pressable.theme.badger.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Pressable_theme_badger_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/MouseScrollbar.theme.badger.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MouseScrollbar_theme_badger_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/MouseScrollbar.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MouseScrollbar_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/themeVariables.ts
// Vanilla tokens





 // Badger tokens





 // Docs tokens



const themeVariables_toClassNamesFlatList = (...styles) => {
  return styles.reduce((flatStyles, currentStyles) => {
    flatStyles = flatStyles.concat(Object.values(currentStyles));
    return flatStyles;
  }, []);
};

const themeVariables_themeVariables = {
  vanilla: themeVariables_toClassNamesFlatList(BaseDropdown_theme_vanilla_variables, BaseSlider_theme_vanilla_variables, BaseTextField_theme_vanilla_variables, Pressable_theme_vanilla_variables, MouseScrollbar_theme_vanilla_variables, ScrollView_theme_vanilla_variables),
  badger: themeVariables_toClassNamesFlatList(BaseDropdown_theme_badger_variables, BaseSlider_theme_badger_variables, BaseTextField_theme_badger_variables, Pressable_theme_badger_variables, MouseScrollbar_theme_badger_variables),
  docs: themeVariables_toClassNamesFlatList(MouseScrollbar_theme_docs_variables)
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBack/IconArrowBack.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowBack_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForward/IconArrowForward.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowForward_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBack/IconArrowBack.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowBack_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForward/IconArrowForward.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowForward_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-icons/src/themeVariables.ts
// Vanilla

 // Docs




const src_themeVariables_toClassNamesFlatList = (...styles) => {
  return styles.reduce((flatStyles, currentStyles) => {
    flatStyles = flatStyles.concat(Object.values(currentStyles));
    return flatStyles;
  }, []);
};

const src_themeVariables_themeVariables = {
  vanilla: src_themeVariables_toClassNamesFlatList(IconArrowBack_theme_vanilla_variables, IconArrowForward_theme_vanilla_variables),
  docs: src_themeVariables_toClassNamesFlatList(IconArrowBack_theme_docs_variables, IconArrowForward_theme_docs_variables)
};
;// CONCATENATED MODULE: ./packages/react-component-playground/src/AlgoliaSearch/AlgoliaSearch.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AlgoliaSearch_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/react-component-playground/src/AlgoliaSearch/AlgoliaSearch.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AlgoliaSearch_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/react-component-playground/src/themeVariables.ts



const react_component_playground_src_themeVariables_toClassNamesFlatList = (...styles) => {
  return styles.reduce((flatStyles, currentStyles) => {
    flatStyles = flatStyles.concat(Object.values(currentStyles));
    return flatStyles;
  }, []);
};

const react_component_playground_src_themeVariables_themeVariables = {
  docs: react_component_playground_src_themeVariables_toClassNamesFlatList(AlgoliaSearch_theme_docs_variables),
  vanilla: react_component_playground_src_themeVariables_toClassNamesFlatList(AlgoliaSearch_theme_vanilla_variables)
};
;// CONCATENATED MODULE: ./packages/themes/src/Provider/docs.theme.ts




const docs = [...themeVariables.docs, ...themeVariables_themeVariables.docs, ...src_themeVariables_themeVariables.docs, ...react_component_playground_src_themeVariables_themeVariables.docs];
;// CONCATENATED MODULE: ./packages/themes/src/Provider/vanilla.theme.ts




const vanilla = [...themeVariables.vanilla, ...themeVariables_themeVariables.vanilla, ...src_themeVariables_themeVariables.vanilla, ...react_component_playground_src_themeVariables_themeVariables.vanilla];
;// CONCATENATED MODULE: ./games/vanilla/theme/src/palette.ts
const palette = {
  green10: '#a0e081',
  green20: '#86d562',
  green30: '#6cc349',
  green40: '#52a535',
  green50: '#3c8527',
  green60: '#2a641c',
  green70: '#1d4d13',
  green80: '#153a0e',
  green90: '#112f0b',
  green100: '#0f2b0a',
  white: '#ffffff',
  black: '#000000',
  gray10: '#f4f6f9',
  gray20: '#e6e8eb',
  gray30: '#d0d1d4',
  gray40: '#b1b2b5',
  gray50: '#8c8d90',
  gray60: '#58585a',
  gray70: '#48494a',
  gray80: '#313233',
  gray90: '#242425',
  gray100: '#1e1e1f',
  red10: '#ff8080',
  red20: '#d93636',
  red30: '#b31b1b',
  red40: '#d54242',
  red50: '#ca3636',
  red60: '#c02d2d',
  red70: '#b62525',
  red80: '#ad1d1d',
  red90: '#a31616',
  red100: '#990f0f',
  orange10: '#ffb366',
  orange20: '#d3791f',
  orange30: '#a65b11',
  yellow10: '#ffe866',
  yellow20: '#e5c317',
  yellow30: '#8a7500',
  gold10: '#fff0c5',
  gold20: '#ffd783',
  gold30: '#f8af2b',
  gold40: '#ce8706',
  gold50: '#ae7100',
  blue10: '#8cb3ff',
  blue20: '#2e6be5',
  blue30: '#1452cc',
  blackOpacity10: 'rgba(0, 0, 0, 0.1)',
  blackOpacity20: 'rgba(0, 0, 0, 0.2)',
  blackOpacity25: 'rgba(0, 0, 0, 0.25)',
  blackOpacity30: 'rgba(0, 0, 0, 0.3)',
  blackOpacity40: 'rgba(0, 0, 0, 0.4)',
  blackOpacity50: 'rgba(0, 0, 0, 0.5)',
  blackOpacity60: 'rgba(0, 0, 0, 0.6)',
  blackOpacity70: 'rgba(0, 0, 0, 0.7)',
  blackOpacity80: 'rgba(0, 0, 0, 0.8)',
  blackOpacity90: 'rgba(0, 0, 0, 0.9)',
  blackOpacity100: 'rgba(0, 0, 0, 1)',
  whiteOpacity10: 'rgba(255, 255, 255, 0.1)',
  whiteOpacity20: 'rgba(255, 255, 255, 0.2)',
  whiteOpacity30: 'rgba(255, 255, 255, 0.3)',
  whiteOpacity40: 'rgba(255, 255, 255, 0.4)',
  whiteOpacity50: 'rgba(255, 255, 255, 0.5)',
  whiteOpacity60: 'rgba(255, 255, 255, 0.6)',
  whiteOpacity70: 'rgba(255, 255, 255, 0.7)',
  whiteOpacity80: 'rgba(255, 255, 255, 0.8)',
  whiteOpacity90: 'rgba(255, 255, 255, 0.9)',
  pink10: '#FB95E2',
  pink20: '#FFB1EC',
  pink30: '#E159C2',
  pink40: '#F877DC',
  purple40: '#643ACB',
  deepBlue10: '#AC90F3',
  deepBlue20: '#9471E0',
  deepBlue40: '#8557F8',
  deepBlue50: '#7345E5',
  deepBlue60: '#5D2CC6',
  deepBlue70: '#4A1CAC',
  deepBlue100: '#050029',
  deepBlueOpacity50: 'rgba(5, 0, 41, 0.5)'
};
;// CONCATENATED MODULE: ./games/vanilla/theme/src/index.ts

;// CONCATENATED MODULE: ./support/docs/theme/src/palette.ts

;// CONCATENATED MODULE: ./support/docs/theme/src/index.ts

;// CONCATENATED MODULE: ./games/edu/theme/src/palette.ts

;// CONCATENATED MODULE: ./games/edu/theme/src/index.ts

;// CONCATENATED MODULE: ./games/example/theme/src/palette.ts

;// CONCATENATED MODULE: ./games/example/theme/src/index.ts

;// CONCATENATED MODULE: ./support/test-screens/theme/src/palette.ts

;// CONCATENATED MODULE: ./support/test-screens/theme/src/index.ts

;// CONCATENATED MODULE: ./palettes.ts





const palettes_docs = (/* unused pure expression or super */ null && (docsPalette));
const edu = (/* unused pure expression or super */ null && (eduPalette));
const example = (/* unused pure expression or super */ null && (examplePalette));
const testScreens = (/* unused pure expression or super */ null && (testScreensPalette));
const palettes_vanilla = (/* unused pure expression or super */ null && (vanillaPalette));
;// CONCATENATED MODULE: ./packages/themes/src/Provider/ThemeProvider.dynamic.tsx







const themes = {
  docs: docs,
  legacy: [],
  vanilla: vanilla
};
const defaultTheme = (/* unused pure expression or super */ null && ("vanilla" || 0));
/**
 * Theme provider that loads all the available themes and let them be selected dynamically at runtime.
 * This component should not be used by the "production build" of game screens.
 *
 * This is toggled by a configuration flag within `loom` (webpack config)
 */

function ThemeProvider_dynamic_ThemeProvider({
  children,
  theme = defaultTheme
}) {
  const ref = useRef(null);
  const [currentTheme, setCurrentTheme] = useState(theme);
  const themeClasses = themes[currentTheme];
  const vanillaThemeClasses = themes['vanilla'];
  useEffect(() => {
    if (ref.current == null) return;
    const palette = palettes[theme];
    const style = ref.current.style;

    for (const key in palette) {
      style.setProperty(`--${key}`, palette[key]);
    }
  }, [ref, theme]); // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions

  if (!themeClasses && "production" === 'development') {}

  useEffect(() => {
    setCurrentTheme(theme);
  }, [theme]);
  return /*#__PURE__*/React.createElement(InteractiveThemeProvider, {
    value: {
      theme: currentTheme,
      onSetTheme: setCurrentTheme
    }
  }, /*#__PURE__*/React.createElement("div", {
    ref: ref,
    className: classnames(styles.themeProvider, vanillaThemeClasses)
  }, /*#__PURE__*/React.createElement("div", {
    className: classnames(styles.themeProvider, themeClasses)
  }, children)));
}
;// CONCATENATED MODULE: ./packages/themes/src/Provider/ThemeProvider.static.tsx


const ThemeProvider_static_defaultTheme = "vanilla" || 0;
/**
 * Dummy component that is used to not have any dynamic theme being applied (has a static theme)
 * This is toggled by a configuration flag within `loom` (webpack config)
 */

function ThemeProvider_static_ThemeProvider({
  children
}) {
  return /*#__PURE__*/react.createElement(context_InteractiveThemeProvider, {
    value: {
      theme: ThemeProvider_static_defaultTheme,
      onSetTheme: () => {}
    }
  }, children);
}
;// CONCATENATED MODULE: ./packages/themes/src/Provider/index.ts



;// CONCATENATED MODULE: ./packages/themes/src/index.ts




;// CONCATENATED MODULE: ./packages/ui-hooks/src/useAnimationState.ts
 // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars

const useAnimationState_noop = (...args) => undefined;
/**
 * @deprecated use InteractivePrimitive instead
 */


function useAnimationState({
  onClick = useAnimationState_noop,
  resetDelay = 200,
  animationLength = 0,
  touchUpDelay = 200
} = {}) {
  const [clicked, setClicked] = useState(false);
  const [touchedUp, setTouchedUp] = useState(false);
  const [touchedDown, setTouchedDown] = useState(false);
  const setTimeoutRef = useRef(); // eslint-disable-next-line @typescript-eslint/no-explicit-any

  const wrappedOnClick = (...args) => {
    setTouchedDown(true);
    setTimeoutRef.current = setTimeout(() => {
      setTouchedUp(true);
      setTimeoutRef.current = setTimeout(() => {
        setClicked(true);
        onClick(...args);
        setTimeoutRef.current = setTimeout(() => {
          setTouchedDown(false);
          setTouchedUp(false);
          setClicked(false);
          setTimeoutRef.current = undefined;
        }, Math.max(0, resetDelay - animationLength));
      }, animationLength);
    }, touchUpDelay);
  };

  useEffect(() => () => setTimeoutRef.current && clearTimeout(setTimeoutRef.current), [setTimeoutRef]);
  return {
    clicked,
    touchedUp,
    touchedDown,
    wrappedOnClick
  };
}
;// CONCATENATED MODULE: ./packages/ui-hooks/src/useLangDirection.ts

function useLangDirection(isRtl) {
  (0,react.useEffect)(() => {
    if (false) {}
    const html = document.getElementsByTagName('html')[0];
    const cssLink = document.querySelector('link[rel="stylesheet"]');

    if (cssLink == null) {
      console.error('No stylesheet link tag found, RTL is not applied');
      return;
    }

    const cssHref = cssLink.getAttribute('href');

    if (cssHref == null) {
      console.error('Something wrong with style attribute, RTL is not applied');
      return;
    }

    const cssFileName = cssHref.substring(0, cssHref.length - 4).replace('.rtl', '');
    const suffix = isRtl ? '.rtl' : '';
    const transformedLink = cssFileName + suffix + '.css';

    if (isRtl) {
      html.setAttribute('dir', 'rtl');
    } else {
      html.removeAttribute('dir');
    }

    cssLink.setAttribute('href', transformedLink);
  }, [isRtl]);
}
;// CONCATENATED MODULE: ./packages/ui-hooks/src/useOnChange.ts

function useOnChange(value, onChange) {
  const previousValueRef = useRef(value);
  useEffect(() => {
    if (previousValueRef.current !== value) {
      previousValueRef.current = value;
      onChange();
    }
  }, [value, onChange]);
}
;// CONCATENATED MODULE: ./packages/ui-hooks/src/useOnClickOutside.ts

function useOnClickOutside(ref, callback, isOpen = true) {
  const isOpenFacet = (0,react_facet_src.useFacetWrap)(isOpen);
  (0,react_facet_src.useFacetEffect)(isOpen => {
    if (!isOpen) return;

    const listener = event => {
      if (!(ref.current && ref.current.contains(event.target))) {
        callback();
      }
    };

    document.addEventListener('click', listener, true);
    return () => {
      document.removeEventListener('click', listener, true);
    };
  }, [ref, callback], [isOpenFacet]);
}
;// CONCATENATED MODULE: ./packages/ui-hooks/src/useUniqueIdentifier.ts

let counter = 0;
const useUniqueIdentifier = () => {
  return (0,react.useMemo)(() => `unique-identifier${counter++}`, []);
};
;// CONCATENATED MODULE: ./packages/ui-hooks/src/useRestoreFocus.ts



const useRestoreFocus = (captureFocus, targetGamepadAlias) => {
  const setFocusedId = useSetFocusedId();
  const restoreFocusedId = useRef(useRestoreFocus_noop);
  useFacetEffect(captureFocus => {
    if (captureFocus) {
      const restoreFocusedIdValue = setFocusedId(targetGamepadAlias);

      if (restoreFocusedIdValue !== NO_VALUE) {
        restoreFocusedId.current = restoreFocusedIdValue;
      }
    } else {
      restoreFocusedId.current();
    }
  }, [setFocusedId, targetGamepadAlias], [captureFocus]);
};

function useRestoreFocus_noop() {}
;// CONCATENATED MODULE: ./packages/ui-hooks/src/index.ts






;// CONCATENATED MODULE: ./packages/ui/src/UIProvider/useLocaleSpecificFonts.ts

/**
 * Defines custom CSS properties with font fallbacks custom tailored based
 * on the current locale.
 *
 * These properties are injected by @mojang/postcss-minecraft-fallback-font-family
 *
 * We need to do this because there are unicode clashes between some of the fonts that we use.
 * For example, Japanese and Chinese characters end up using the wrong period ('.') if we don't
 * order the font families in a specific order.
 *
 * For more information on why this is needed, check the ticket:
 * - https://dev-mc.visualstudio.com/Minecraft/_workitems/edit/504080
 */

const DEFAULT = 'Noto Sans';
const JP = 'Noto Sans JP';
const TC = 'Noto Sans TC';
const SC = 'Noto Sans SC';
const KR = 'Noto Sans KR';
const AR = 'Noto Sans AR';
const FALLBACKS = ['Noto Sans Mongolian', 'Noto Sans Syriac', 'Noto Sans TamilSupplement'];
function getLocaleSpecificFonts(locale) {
  if (locale.startsWith('ja')) {
    return [JP, TC, SC, KR, DEFAULT, ...FALLBACKS];
  } else if (locale === 'zh_TW') {
    return [TC, SC, JP, KR, DEFAULT, ...FALLBACKS];
  } else if (locale === 'zh_CN') {
    return [SC, TC, JP, KR, DEFAULT, ...FALLBACKS];
  } else if (locale.startsWith('ko')) {
    return [KR, TC, SC, JP, DEFAULT, ...FALLBACKS];
  } else if (locale.startsWith('ar_')) {
    return [AR, DEFAULT, KR, TC, SC, JP, ...FALLBACKS];
  } else {
    return [DEFAULT, SC, TC, JP, KR, AR, ...FALLBACKS];
  }
}
function useLocaleSpecificFonts(locale) {
  (0,react.useEffect)(() => {
    const localeSpecificFonts = getLocaleSpecificFonts(locale);
    document.body.style.setProperty('--localeSpecificNotoSansFonts', localeSpecificFonts.join(','));
  }, [locale]);
}
// EXTERNAL MODULE: ./node_modules/events/events.js
var events = __webpack_require__(17187);
;// CONCATENATED MODULE: ./packages/react-scaling/src/useOnComponentResize.ts



/**
 * Hook that allows listening on changes of the size of a component
 *
 * @param ref ref to the DOM element being listened
 * @param onResize callback that will be called with the new sizes
 */
const useOnComponentResize_useOnComponentResize = (ref, onResize) => {
  const eventEmitter = (0,react.useContext)(resizesRecalculationContext);
  (0,react.useEffect)(() => {
    const element = ref.current;
    if (element == null) return;
    return observeResize(element, onResize, eventEmitter);
  }, [ref, onResize, eventEmitter]);
};
/**
 * Implementation based on https://github.com/batata-frita/element-rect-observer
 */

const observeResize = (element, onResize, eventEmitter) => {
  let recordedSize;
  let frameId;

  const handler = () => {
    const boundingClientRect = element.getBoundingClientRect(); // If the new bounding client rect is completely zero, that means
    // that the component got hidden. We don't want to act on that, since
    // it is not a resize: when the component gets displayed again, it will
    // have the same size as it had before it being hidden.

    if ( true && boundingClientRect.width === 0 && boundingClientRect.height === 0 && boundingClientRect.top === 0 && boundingClientRect.left === 0 && boundingClientRect.right === 0 && boundingClientRect.bottom === 0 && boundingClientRect.x === 0 && boundingClientRect.y === 0) {
      return;
    }

    if (recordedSize != null && boundingClientRect.width === recordedSize.width && boundingClientRect.height === recordedSize.height && boundingClientRect.top === recordedSize.top && boundingClientRect.left === recordedSize.left && boundingClientRect.right === recordedSize.right && boundingClientRect.bottom === recordedSize.bottom && boundingClientRect.x === recordedSize.x && boundingClientRect.y === recordedSize.y) {
      return;
    }

    recordedSize = boundingClientRect;
    onResize(recordedSize);
  };
  /**
   * Wait three frames to get the initial value, as Gameface doesn't calculate bounding rect on request.
   * On testing we don't wait so we can have snapshots.
   */


  const handlerWrapper =  false ? 0 : () => {
    frameId = requestAnimationFrame(() => {
      frameId = requestAnimationFrame(handler);
    });
  };
  const observer = new window.MutationObserver(handlerWrapper);
  window.addEventListener('resize', handlerWrapper);
  observer.observe(element, {
    attributes: true,
    childList: true,
    characterData: true,
    subtree: true
  });
  eventEmitter.addListener('recalculate', handlerWrapper);
  handlerWrapper();
  return () => {
    observer.disconnect();
    window.removeEventListener('resize', handlerWrapper);
    eventEmitter.removeListener('recalculate', handlerWrapper);
    cancelAnimationFrame(frameId);
  };
};

const resizesRecalculationContext = (0,react.createContext)(new events.EventEmitter());
/**
 * Hook that returns a function that once called will force recalculating the sizes of all
 * components we are listening on resizing.
 *
 * Can be useful on situations such as transitions or animations that causes the UI to change size unexpectedly.
 */

const useOnComponentResizeForceRecalculate = () => {
  const eventEmitter = (0,react.useContext)(resizesRecalculationContext);
  return (0,react.useCallback)(() => {
    eventEmitter.emit('recalculate');
  }, [eventEmitter]);
};
;// CONCATENATED MODULE: ./packages/react-scaling/src/ScalingProvider.tsx




let GUIScales;

(function (GUIScales) {
  GUIScales[GUIScales["SCALING_25"] = 1] = "SCALING_25";
  GUIScales[GUIScales["SCALING_50"] = 2] = "SCALING_50";
  GUIScales[GUIScales["SCALING_75"] = 3] = "SCALING_75";
  GUIScales[GUIScales["SCALING_100"] = 4] = "SCALING_100";
  GUIScales[GUIScales["SCALING_125"] = 5] = "SCALING_125";
  GUIScales[GUIScales["SCALING_150"] = 6] = "SCALING_150";
  GUIScales[GUIScales["SCALING_175"] = 7] = "SCALING_175";
  GUIScales[GUIScales["SCALING_200"] = 8] = "SCALING_200";
})(GUIScales || (GUIScales = {}));

/**
 * Private API Provider that setups scaling in the UI
 */
function ScalingProvider({
  guiScale,
  onGuiScaleApplied,
  children
}) {
  const [baseFontSize, setBaseFontSize] = (0,react_facet_src.useFacetState)(10);
  (0,react_facet_src.useFacetEffect)(guiScale => {
    setBaseFontSize(guiScale * 2.5);
  }, [setBaseFontSize], [guiScale]);
  (0,react_facet_src.useFacetEffect)((guiScale, baseFontSize) => {
    const html = document.getElementsByTagName('html')[0];
    const body = document.body;
    html.style.fontSize = `${baseFontSize}px`;
    body.style.setProperty('--baseFontSize', `${baseFontSize}px`);
    const base2Scale = Math.max(Math.round(guiScale / 4 * 2), 1);
    body.style.setProperty('--base2Scale', `${base2Scale}px`);
    body.style.setProperty('--base2ScaleNeg', `-${base2Scale}px`);
    const base1Scale = Math.max(Math.round(guiScale / 4), 1);
    body.style.setProperty('--base1Scale', `${base1Scale}px`);
    body.style.setProperty('--base1ScaleNeg', `-${base1Scale}px`);
    onGuiScaleApplied();
  }, [onGuiScaleApplied], [guiScale, baseFontSize]);
  return /*#__PURE__*/react.createElement(resizesRecalculationContext.Provider, {
    value: (0,react.useMemo)(() => new events.EventEmitter(), [])
  }, /*#__PURE__*/react.createElement(scaleContext.Provider, {
    value: guiScale
  }, /*#__PURE__*/react.createElement(baseFontSizeContext.Provider, {
    value: baseFontSize
  }, children)));
}
const baseFontSizeContext = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: 10
}));
const scaleContext = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: 4
}));
;// CONCATENATED MODULE: ./packages/react-scaling/src/useSizeInPixels.ts



/**
 * Converts a size in rems to pixels using the scaling information
 */

const useSizeInPixels = sizeInRems => {
  const baseFontSize = (0,react_facet_src.useFacetUnwrap)((0,react.useContext)(baseFontSizeContext));
  const fontSize = baseFontSize === react_facet_src.NO_VALUE ? 10 : baseFontSize;
  return sizeInRems * fontSize;
};
;// CONCATENATED MODULE: ./packages/react-scaling/src/useWindowBreakpoint.ts



/**
 * Hook that takes scaling and window size into consideration to calculate styling breakpoints
 */
const useWindowBreakpoint = (narrowBreakpointWidth = 70) => {
  const narrowBreakpoint = useSizeInPixels(narrowBreakpointWidth);
  const tabletBreakpoint = useSizeInPixels(128);
  const [breakpoint, setBreakpoint] = (0,react.useState)('desktop');
  (0,react.useEffect)(() => {
    const checkBreakpoint = () => {
      const screenWidth = window.innerWidth;

      if (screenWidth < narrowBreakpoint) {
        return 'narrow';
      }

      if (screenWidth < tabletBreakpoint) {
        return 'tablet';
      }

      return 'desktop';
    };

    const update = () => setBreakpoint(checkBreakpoint());

    update();
    window.addEventListener('resize', update);
    return () => window.removeEventListener('resize', update);
  }, [narrowBreakpoint, tabletBreakpoint]);
  return breakpoint;
};
;// CONCATENATED MODULE: ./packages/react-scaling/src/useIsWindowNarrow.ts


/**
 * Given a size in rems, taking scaling in consideration it checks if the window is smaller in width
 * than the provided size.
 *
 * @param size in rems
 * @returns if the window is narrower then the provided size
 */

const useIsWindowNarrow = (size = 100) => {
  const sizeInPixels = useSizeInPixels(size);
  const checkNarrow = (0,react.useCallback)(() => {
    return window.innerWidth < sizeInPixels;
  }, [sizeInPixels]);
  const [isNarrow, setIsNarrow] = (0,react.useState)(checkNarrow());
  (0,react.useEffect)(() => {
    const update = () => setIsNarrow(checkNarrow());

    update();
    window.addEventListener('resize', update);
    return () => window.removeEventListener('resize', update);
  }, [checkNarrow]);
  return isNarrow;
};
;// CONCATENATED MODULE: ./packages/react-scaling/src/useIsComponentSmallerThan.ts




/**
 * If "unknown', the size of the component is not yet known and the recommendation is to render a skeleton
 */

/**
 * Hook that returns a facet with the information about this component being smaller than a given size
 *
 * @param ref ref to the DOM element being listened
 * @param sizeInRem size in rems
 * @returns Facet<SmallerThanResult>
 */
const useIsComponentSmallerThan = (ref, sizeInRem) => {
  const [isSmallerFacet, setIsSmaller] = (0,react_facet_src.useFacetState)('unknown');
  const sizeInPixels = useSizeInPixels(sizeInRem);
  const onResize = (0,react.useCallback)(newSize => {
    setIsSmaller(newSize.width < sizeInPixels ? 'smaller' : 'bigger');
  }, [setIsSmaller, sizeInPixels]);
  useOnComponentResize_useOnComponentResize(ref, onResize);
  return isSmallerFacet;
};
;// CONCATENATED MODULE: ./packages/react-scaling/src/Scaling.ts





;// CONCATENATED MODULE: ./packages/react-scaling/src/index.ts


;// CONCATENATED MODULE: ./packages/ui/src/UIProvider/UIProvider.tsx








if (false) {}

function UIProvider_UIProvider({
  children,
  guiScale,
  onGuiScaleApplied = UIProvider_noop,
  screenAnimationEnabled,
  isRtl = false,
  locale
}) {
  useLangDirection(isRtl);
  useLocaleSpecificFonts(locale);
  return /*#__PURE__*/react.createElement(ScreenAnimationEnabledProvider, {
    value: screenAnimationEnabled
  }, /*#__PURE__*/react.createElement(ThemeProvider_static_ThemeProvider, null, /*#__PURE__*/react.createElement(ScalingProvider, {
    guiScale: guiScale,
    onGuiScaleApplied: onGuiScaleApplied
  }, children)));
}

const UIProvider_noop = () => {};
;// CONCATENATED MODULE: ./packages/react-localization/src/useLocale.tsx


const useLocale = () => {
  return (0,react.useContext)(LocalizationContext).locale;
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/customScalingFacet.ts

const CUSTOM_SCALING_FACET = 'core.customScaling';
/**
 * React Hook that requests the facet
 */

const customScalingFacet = (0,react_facet_src.sharedFacet)(CUSTOM_SCALING_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/UIEngineProvider/calculateScale.ts

/**
 * How the UI should scale across different screens
 *
 * - default: the way we want to move in the future (should be used by most teams)
 * - compat: some teams have the relative sizes of their components not being mobile-first
 * - legacy: scale the UI so that relative sises compared to legacy screens feels the same
 * - fixed: will only scale when a user actively chooses to scale through an option
 */

function isHandheld(a, b) {
  return b === ScreenType.HANDHELD_SCREEN_TYPE;
}

function calculateScale(mode, screenType, guiScaleModifier, width, height, pixelsPerMillimeter, accessibleGuiScale) {
  if (false) {}
  /**
   * For now, scaling mode 'fixed' will do the same thing as if
   * the user was running in a browser, but that might change.
   */


  if (mode === 'fixed') {
    /**
     * It's possible that guiScaleModifier is also set from the
     * engine when the window is resized. In that case, we probably
     * want to use a different variable here, such as fixedGuiScaleModifier.
     * This potential new value would need to be added to the UIEngineProvider.
     * Basically, we only want fixed scaling to be set by a menu option, the way
     * that scaling can be set in the browser through handleScaleChange (which
     * in turn triggers useScale)
     */
    return calculateFixedGuiScale(guiScaleModifier, accessibleGuiScale);
    /**
     * If this turns out to be an issue, we could temporarily just always return
     * 100% scaling like so:
     *
     * return Scale.SCALE_100_PERCENT
     *
     * This should force the scaling to be fixed, but it won't let the user manually
     * change the scaling, so we will definitely want to have a variable for that.
     */
  }

  const screenTypeBaseScale = SCREEN_TYPE_BASE_SCALE[mode][screenType];

  if (isHandheld(screenTypeBaseScale, screenType)) {
    return calculatePPIGuiScale(mode, screenTypeBaseScale, guiScaleModifier, pixelsPerMillimeter, width, height, accessibleGuiScale);
  }

  return calculateResolutionGuiScale(mode, screenTypeBaseScale, guiScaleModifier, width, height, accessibleGuiScale);
}
/**
 * Calculates the final scaling of UI elements based on the pixel density (PPI) of the current device.
 * It uses the PPI of the original iPhone as a base, and calculates a scaling factor to be applied on the UI.
 *
 * For example:
 * 	- running the game on the original iPhone (163ppi), would result in a guiScale of 4 (the base scale)
 *  - running the game on an iPhone 7 (326ppi, 14.330709 ppm), would return a guiScale of 8
 */

function calculatePPIGuiScale(mode, screenTypeBaseScale, guiScaleModifier, pixelsPerMillimeter, width, height, accessibleGuiScale) {
  const dpiScaleFactor = pixelsPerMillimeter / SCREEN_TYPE_BASE_PPM;
  const widthPoints = width / dpiScaleFactor;
  const heightPoints = height / dpiScaleFactor;
  const currentHandheldDeviceType = widthPoints > 1000 && heightPoints > 700 ? HandheldDeviceType.TABLET : HandheldDeviceType.PHONE;
  const handheldDeviceTypeBaseScale = screenTypeBaseScale[currentHandheldDeviceType];
  const guiScaleBase = Math.round(dpiScaleFactor * handheldDeviceTypeBaseScale);
  const scaledGuiScaleModifier = Math.round(dpiScaleFactor * guiScaleModifier);
  const PPIGuiScale = guiScaleBase + scaledGuiScaleModifier;

  if (accessibleGuiScale === true) {
    return calculateAccessibleGuiScale(PPIGuiScale);
  }

  return PPIGuiScale;
}
/**
 * For TVs and Desktops, the PPI information is not reliable
 * so instead we use a base resolution (1920x1080) and calculate a scaling factor from it
 *
 * For example:
 * - running the game in a console in 1080p will result in the scale of 7 (the base for that screen type)
 * - running the game in a console in 4k will result in the scale of 14 (twice the base for that screen type)
 */


function calculateResolutionGuiScale(mode, screenTypeBaseScale, guiScaleModifier, width, height, accessibleGuiScale) {
  const widthNeeded = 1920;
  const heightNeeded = 1080;
  const widthScale = width / widthNeeded;
  const heightScale = height / heightNeeded;
  const resolutionScaleFactor = Math.min(heightScale, widthScale);
  const guiScaleBase = Math.round(resolutionScaleFactor * screenTypeBaseScale);
  const scaledGuiScaleModifier = Math.round(resolutionScaleFactor * guiScaleModifier);
  const resolutionGuiScale = guiScaleBase + scaledGuiScaleModifier;

  if (accessibleGuiScale === true) {
    return calculateAccessibleGuiScale(resolutionGuiScale);
  }

  return resolutionGuiScale;
}
/**
 * Fixed scaling is to be used on development environments where we don't want the ui to scale (ex: browser)
 */


function calculateFixedGuiScale(guiScaleModifier, accessibleGuiScale) {
  const fixedGuiScale = Scale.SCALE_100_PERCENT + guiScaleModifier;

  if (accessibleGuiScale === true) {
    return calculateAccessibleGuiScale(fixedGuiScale);
  }

  return fixedGuiScale;
}
/**
 * This function returns an increased scale by 25% for accessibility purposes
 */


function calculateAccessibleGuiScale(guiScale) {
  return Math.ceil(guiScale * 1.25);
}
/**
 * For different platforms, what is the "starting scale"
 *
 * In this context, 4 means 100% scaling.
 */


const SCREEN_TYPE_BASE_SCALE = {
  /**
   * There are currently some inconsistencies in how different teams within the monorepo
   * work with scaling, so we provide this mode to keep the "starting scale" consistent
   * across different screen types.
   */
  compat: {
    [ScreenType.DESKTOP_SCREEN_TYPE]: Scale.SCALE_100_PERCENT,
    [ScreenType.TV_SCREEN_TYPE]: Scale.SCALE_100_PERCENT,
    [ScreenType.HANDHELD_SCREEN_TYPE]: {
      [HandheldDeviceType.PHONE]: Scale.SCALE_100_PERCENT,
      [HandheldDeviceType.TABLET]: Scale.SCALE_100_PERCENT
    },
    [ScreenType.VR_SCREEN_TYPE]: Scale.SCALE_100_PERCENT
  },

  /**
   * Legacy mode allows better relative sizes between new UI elements and legacy UI elements
   * and can be used in a game that is transitioning to Ore UI (Gameface)
   */
  legacy: {
    /**
     * On desktop, font size should equal or exceed:
     * - 18px at 1080p
     * - 29px at 4k
     *
     * Our base size (for handheld) is 16px, so we should do 125% (5)
     * However, this makes the UI too small in comparison with the legacy UI
     * To keep things more consistently, we are keeping the UI bigger overall, thus having base size as 175% (7) (for the time being)
     *
     * TODO: once more screens are converted to Gameface, we can update this to a more correct number
     */
    [ScreenType.DESKTOP_SCREEN_TYPE]: Scale.SCALE_175_PERCENT,

    /**
     * On tv, font size should equal or exceed:
     * - 26px at 1080p
     * - 44px at 4k
     *
     * Our base size (for handheld) is 16px, so we do 175% (7)
     */
    [ScreenType.TV_SCREEN_TYPE]: Scale.SCALE_175_PERCENT,

    /**
     * We use PPI information for handheld, so the base is 100% (4),
     * except for tablets that we bump up to 6 in order to match
     * the size of the UI in the legacy screens.
     */
    [ScreenType.HANDHELD_SCREEN_TYPE]: {
      [HandheldDeviceType.PHONE]: Scale.SCALE_100_PERCENT,
      [HandheldDeviceType.TABLET]: Scale.SCALE_150_PERCENT
    },

    /**
     * TODO: still needs to be defined
     */
    [ScreenType.VR_SCREEN_TYPE]: Scale.SCALE_100_PERCENT
  },
  default: {
    /**
     * On desktop, font size should equal or exceed:
     * - 18px at 1080p
     * - 29px at 4k
     *
     * Our base size (for handheld) is 16px, so we should do 125% (5)
     */
    [ScreenType.DESKTOP_SCREEN_TYPE]: Scale.SCALE_125_PERCENT,

    /**
     * On tv, font size should equal or exceed:
     * - 26px at 1080p
     * - 44px at 4k
     *
     * Our base size (for handheld) is 16px, so we do 175% (7)
     */
    [ScreenType.TV_SCREEN_TYPE]: Scale.SCALE_175_PERCENT,

    /**
     * We use PPI information for handheld, so the base is 100% (4)
     */
    [ScreenType.HANDHELD_SCREEN_TYPE]: {
      [HandheldDeviceType.PHONE]: Scale.SCALE_100_PERCENT,
      [HandheldDeviceType.TABLET]: Scale.SCALE_100_PERCENT
    },

    /**
     * TODO: still needs to be defined
     */
    [ScreenType.VR_SCREEN_TYPE]: Scale.SCALE_100_PERCENT
  },

  /**
   * This is an experimental ScalingMode that will never scale based on resolution
   * or screen size. It can, however, be scaled manually by a user through settings.
   */
  fixed: {
    [ScreenType.DESKTOP_SCREEN_TYPE]: Scale.SCALE_100_PERCENT,
    [ScreenType.TV_SCREEN_TYPE]: Scale.SCALE_100_PERCENT,
    [ScreenType.HANDHELD_SCREEN_TYPE]: {
      [HandheldDeviceType.PHONE]: Scale.SCALE_100_PERCENT,
      [HandheldDeviceType.TABLET]: Scale.SCALE_100_PERCENT
    },
    [ScreenType.VR_SCREEN_TYPE]: Scale.SCALE_100_PERCENT
  }
};
/**
 * 163ppi which is the original iPhone
 */

const SCREEN_TYPE_BASE_PPM = 6.417322835;
;// CONCATENATED MODULE: ./packages/engine/src/providers/UIEngineProvider/UIEngineProvider.tsx











function UIEngineProvider({
  children,
  scalingMode
}) {
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const customScaling = (0,react_facet_src.useSharedFacet)(customScalingFacet);
  const splitScreen = (0,react_facet_src.useSharedFacet)(splitScreenFacet);
  const animation = (0,react_facet_src.useSharedFacet)(animationFacet);
  const scalingModeToUse = (0,react_facet_src.useFacetMap)(customScaling => customScaling.scalingModeOverride != null && customScaling.scalingModeOverride && customScaling.scalingModeOverride.length > 0 ? customScaling.scalingModeOverride : scalingMode, [scalingMode], [customScaling]);
  const fixedGuiScaleModifier = (0,react_facet_src.useFacetMap)(customScaling => customScaling.fixedGuiScaleModifier, [], [customScaling]);
  const accessibleGuiScale = (0,react_facet_src.useFacetMap)(customScaling => {
    var _customScaling$guiAcc;

    return (_customScaling$guiAcc = customScaling.guiAccessibilityScaling) !== null && _customScaling$guiAcc !== void 0 ? _customScaling$guiAcc : false;
  }, [], [customScaling]); // Wait for all facets to emit values

  const shouldRender = (0,react_facet_src.useFacetMap)(() => true, [], [deviceInformation, splitScreen, animation, fixedGuiScaleModifier, scalingModeToUse, accessibleGuiScale]); // Performance while running the game in split screen is degraded,
  // so we disable animations to a more snappy UI

  const screenAnimationEnabled = (0,react_facet_src.useFacetMap)((animation, splitScreen) => animation.screenAnimationEnabled && splitScreen.numActivePlayers === 1, [], [animation, splitScreen]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldRender
  }, /*#__PURE__*/react.createElement(ScaleProvider, {
    deviceInformationFacet: deviceInformation,
    scalingMode: scalingModeToUse,
    screenAnimationEnabled: screenAnimationEnabled,
    fixedGuiScaleModifier: fixedGuiScaleModifier,
    accessibleGuiScale: accessibleGuiScale
  }, children));
}

function ScaleProvider({
  scalingMode,
  children,
  deviceInformationFacet,
  screenAnimationEnabled,
  fixedGuiScaleModifier,
  accessibleGuiScale
}) {
  const screenType = useDeviceScreenType();
  const guiScale = useScale(scalingMode, screenType, deviceInformationFacet, fixedGuiScaleModifier, accessibleGuiScale);
  const locale = useLocale();
  const isRtl = useIsLocaleRtl();
  const handleGuiScaleApplied = (0,react.useCallback)(() => {
    // Gameface currently has a bug where it will apply incorrect proportions to elements
    // when a new base font-size is applied.
    // This events lets the backend knows we just changed the font size so that they can
    // do a workaround
    // More information at https://coherentlabs.zendesk.com/hc/requests/16845
    engineWrapper_engine.trigger('core:gui:resize-hack');
  }, []);
  return /*#__PURE__*/react.createElement(UIProvider_UIProvider, {
    guiScale: guiScale,
    onGuiScaleApplied: handleGuiScaleApplied,
    screenAnimationEnabled: screenAnimationEnabled,
    isRtl: isRtl,
    locale: locale
  }, children);
}

function useScale(scalingMode, screenType, deviceInformation, fixedGuiScaleModifier, accessibleGuiScale) {
  const guiScaleModifier = (0,react_facet_src.useFacetMap)((deviceInformation, fixedGuiScaleModifier, scalingMode) => scalingMode == 'fixed' ? fixedGuiScaleModifier : deviceInformation.guiScaleModifier, [], [deviceInformation, fixedGuiScaleModifier, scalingMode]);
  const calculateCurrentScale = (0,react_facet_src.useFacetCallback)((scalingMode, screenType, deviceInformation, guiScaleModifier, accessibleGuiScale) => () => calculateScale(scalingMode, screenType, guiScaleModifier, window.innerWidth, window.innerHeight, deviceInformation.pixelsPerMillimeter, accessibleGuiScale), [], [scalingMode, screenType, deviceInformation, guiScaleModifier, accessibleGuiScale]); // Initialize the state by calling the calculateCurrentScale function

  const [scale, setScale] = (0,react_facet_src.useFacetState)(calculateCurrentScale());
  (0,react.useEffect)(() => {
    const resize = () => setScale(calculateCurrentScale);

    resize();
    window.addEventListener('resize', resize);
    return () => window.removeEventListener('resize', resize);
  }, [calculateCurrentScale, setScale]);
  (0,react_facet_src.useFacetEffect)(() => {
    setScale(calculateCurrentScale);
  }, [setScale, calculateCurrentScale], [deviceInformation, fixedGuiScaleModifier]);
  return scale;
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/UIEngineProvider/index.ts

;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseTextField/context/onGlobalChange.ts

function createEmptyTextInputChange() {
  return {
    addedChars: '',
    removedChars: '',
    invalidChars: '',
    index: -1
  };
}
const textFieldOnChangeContext = (0,react.createContext)(null);
const useKeyboardEventCallbacks = () => (0,react.useContext)(textFieldOnChangeContext);
const OnChangeProvider = textFieldOnChangeContext.Provider;
;// CONCATENATED MODULE: ./packages/engine/src/onEvent.ts

function onEvent(eventName, cb) {
  const callback = cb; // eslint-disable-line @typescript-eslint/no-explicit-any

  engineWrapper_engine.on(eventName, callback);
  return () => engineWrapper_engine.off(eventName, callback);
}
// Gameface doesn't support returning values from JavaScript so we use
// OutParameter<T> as a workaround and return a value by modifying its
// value property
function onReturnValueEvent(eventName, getValue) {
  return onEvent(eventName, (out, ...args) => {
    out.value = getValue(...args);
  }); // eslint-disable-next-line react-hooks/exhaustive-deps
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/TextFieldEngineProvider.tsx



function TextFieldEngineProvider({
  children
}) {
  const onGlobalChange = (0,react.useCallback)(cb => {
    // inputChange object will be destroyed after this callback, this is to make sure it can be accessed after the callback
    // TextInputChange only has immutable parameters, so shallow copy applied. Otherwise, it shall be deep copied.
    const copyInputChangeCB = inputChange => {
      cb({
        addedChars: inputChange.addedChars + '',
        removedChars: inputChange.removedChars + '',
        invalidChars: inputChange.invalidChars + '',
        index: inputChange.index + 0
      });
    };

    return onEvent('core:keyboard:changed', copyInputChangeCB);
  }, []);
  const onKeyboardSubmitted = (0,react.useCallback)(cb => onEvent('core:keyboard:submitted', cb), []);
  const onKeyboadrDismissed = (0,react.useCallback)(cb => onEvent('core:keyboard:dismissed', cb), []);
  const onKeyboardTabbed = (0,react.useCallback)(cb => onEvent('core:keyboard:tabbed', cb), []);
  const KeyboardCallbacks = {
    changedCB: onGlobalChange,
    submittedCB: onKeyboardSubmitted,
    dismissedCB: onKeyboadrDismissed,
    tabbedCB: onKeyboardTabbed
  };
  return /*#__PURE__*/react.createElement(OnChangeProvider, {
    value: KeyboardCallbacks
  }, children);
}
;// CONCATENATED MODULE: ./packages/react-render-tracking/src/RenderTrackingProvider.tsx


let TelemetryEvent;

(function (TelemetryEvent) {
  TelemetryEvent["FIRST_MEANINGFUL_PAINT"] = "core:telemetry:firstMeaningfulPaint";
  TelemetryEvent["FIRST_CONTENTFUL_PAINT"] = "core:telemetry:firstContentfulPaint";
})(TelemetryEvent || (TelemetryEvent = {}));

const renderQueueMap = () => new Map();

function RenderTrackingProvider({
  children,
  triggerEvent
}) {
  const contentfulRenderQueue = (0,react.useMemo)(renderQueueMap, []);
  const meaningfulRenderQueue = (0,react.useMemo)(renderQueueMap, []);
  const shouldFireMeaningfulPaint = (0,react.useRef)(false);
  const shouldFireContentfulPaint = (0,react.useRef)(false);
  const api = (0,react.useMemo)(() => {
    const meaningfulPaint = () => {
      shouldFireMeaningfulPaint.current = true;
      tryMeaningfulPaint();
    };

    const contentfulPaint = () => {
      shouldFireContentfulPaint.current = true;
      tryContentfulPaint();
    };

    const tryMeaningfulPaint = () => {
      if (contentfulRenderQueue.size === 0 && meaningfulRenderQueue.size === 0 && // Don't fire a meaningful paint if the contentful paints aren't finished
      shouldFireMeaningfulPaint.current) {
        // 👇 Log intentionally left in for debugging
        // console.log(`%c ${TelemetryEvent.FIRST_MEANINGFUL_PAINT}`, 'background: #c6c4f5; color: #222')
        triggerEvent(TelemetryEvent.FIRST_MEANINGFUL_PAINT);
        shouldFireMeaningfulPaint.current = false; // Reset the flag for future use
      }
    };

    const tryContentfulPaint = () => {
      if (contentfulRenderQueue.size === 0 && shouldFireContentfulPaint.current) {
        // 👇 Log intentionally left in for debugging
        // console.log(`%c ${TelemetryEvent.FIRST_CONTENTFUL_PAINT}`, 'background: #c4f5d1; color: #222')
        triggerEvent(TelemetryEvent.FIRST_CONTENTFUL_PAINT);
        shouldFireContentfulPaint.current = false;
      } // We should try a meaningful paint, because all of the meaningful events
      // may have fired before the contentful events were ready (note: this cannot
      // be the other way around, because you cannot have meaningful without contentful)


      tryMeaningfulPaint();
    };

    const block = (id, type) => {
      const renderStates = type === 'contentful' ? contentfulRenderQueue : meaningfulRenderQueue;
      renderStates.set(id, true);
    };

    const unblock = (id, type) => {
      const renderStates = type === 'contentful' ? contentfulRenderQueue : meaningfulRenderQueue;
      renderStates.delete(id); // Try and fire the event if it's ready

      type === 'contentful' ? tryContentfulPaint() : tryMeaningfulPaint();
    };

    return {
      block,
      unblock,
      meaningfulPaint,
      contentfulPaint
    };
  }, [triggerEvent, contentfulRenderQueue, meaningfulRenderQueue]);
  return /*#__PURE__*/react.createElement(RenderTrackingApiContext.Provider, {
    value: api
  }, children);
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/RenderTrackingEngineProvider.tsx



function RenderTrackingEngineProvider({
  children
}) {
  const trigger = (0,react.useMemo)(() => engineWrapper_engine.trigger.bind(engineWrapper_engine), []);
  return /*#__PURE__*/react.createElement(RenderTrackingProvider, {
    triggerEvent: trigger
  }, children);
}
;// CONCATENATED MODULE: ./packages/engine/src/GamepadPolyfillInitializer.tsx


const GamepadPolyfillInitializer = ({
  children
}) => {
  (0,react.useEffect)(() => {
    if (isInitialized()) return;
    const cleanup = initialize();
    return cleanup;
  }, []);
  return /*#__PURE__*/react.createElement(react.Fragment, null, children);
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/requestFacet.ts

const referenceCount = new Map();
const instancePool = new Map(); // eslint-disable-line @typescript-eslint/no-explicit-any

const notFoundPool = new Map(); // eslint-disable-line @typescript-eslint/no-explicit-any

const ERROR_ACTIVATE_NOT_FOUND = 'activate-facet-not-found';
function requestFacet(facetName, update, fallBack, customErrorHandler) {
  var _referenceCount$get;

  const notFound = notFoundPool.get(facetName);

  if (notFound != null) {
    // if not found, we just use the fallback implementation already stored
    // and don't try to request it ever again
    update(notFound);
    return () => {// given it's a facet that was not found, there is no cleanup that needs to be performed
    };
  }

  const defaultErrorHandler = errorCode => {
    console.warn(`Error "${errorCode}" while using facet ${facetName}`);
  };

  const handleError = errorCode => {
    if (errorCode === ERROR_ACTIVATE_NOT_FOUND && fallBack != null) {
      notFoundPool.set(facetName, fallBack);
      update(fallBack);
    } else if (customErrorHandler) {
      customErrorHandler(errorCode);
    } else {
      defaultErrorHandler(errorCode);
    }
  };

  const handleUpdated = newValue => {
    instancePool.set(facetName, newValue);
    update(newValue);
  };

  const facetReferenceCount = (_referenceCount$get = referenceCount.get(facetName)) !== null && _referenceCount$get !== void 0 ? _referenceCount$get : 0;
  const facetInstance = instancePool.get(facetName);
  engineWrapper_engine.on(`facet:updated:${facetName}`, handleUpdated);
  engineWrapper_engine.on(`facet:error:${facetName}`, handleError);

  if (facetReferenceCount === 0) {
    // request the facet if it is the first time
    engineWrapper_engine.trigger('facet:request', [facetName]);
  } else if (facetInstance != null) {
    // since we are not requesting, we send an instance if it is available
    update(facetInstance);
  } // increment the reference count


  referenceCount.set(facetName, facetReferenceCount + 1); // returns a function that performs a cleanup

  return () => {
    var _referenceCount$get2;

    const currentFacetReferenceCount = (_referenceCount$get2 = referenceCount.get(facetName)) !== null && _referenceCount$get2 !== void 0 ? _referenceCount$get2 : 0;
    engineWrapper_engine.off(`facet:updated:${facetName}`, handleUpdated);
    engineWrapper_engine.off(`facet:error:${facetName}`, handleError);

    if (currentFacetReferenceCount === 1) {
      // if it is the last reference, inform the backend it can
      // stop updating this facet
      engineWrapper_engine.trigger('facet:discard', [facetName]); // and remove it from the instance pool

      instancePool.delete(facetName);
    }

    if (currentFacetReferenceCount > 0) {
      referenceCount.set(facetName, currentFacetReferenceCount - 1);
    }
  };
}
function resetInstancePool() {
  instancePool.clear();
  referenceCount.clear();
  notFoundPool.clear();
}
;// CONCATENATED MODULE: ./packages/ui-primitive/src/controllerSpecificButtonTranslation/controllerSpecificButtonTranslation.ts


// TODO: Should this context be part of GamepadProvider? Is it related to Navigation?
// It seems as if it could be part of the device information package instead, or something else unrelated
const controllerSpecificButtonTranslationsContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)({
  keyboard: {},
  gamepad: {}
}));
const useControllerSpecificButtonTranslations = () => (0,react.useContext)(controllerSpecificButtonTranslationsContext);
;// CONCATENATED MODULE: ./packages/react-localization/src/useLocalization.tsx


function useLocalization(namespace) {
  const {
    translationPrefix,
    translate,
    formatDate
  } = (0,react.useContext)(LocalizationContext);
  const localization = (0,react.useMemo)(() => {
    const t = (key, params) => {
      const completeKey = `${translationPrefix}${translationPrefix !== '' ? '.' : ''}${namespace}${key}`;
      const translation = translate(completeKey, params);

      if (!translation && "real" == 'fake') {}

      return translation !== null && translation !== void 0 ? translation : completeKey;
    };

    return {
      f: {
        formatDate
      },
      t
    };
  }, [translationPrefix, namespace, translate, formatDate]);
  return localization;
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/ControllerSpecificButtonTranslationsProvider.tsx







const ControllerSpecificButtonTranslationsProvider = ({
  children
}) => {
  const {
    t
  } = useLocalization('ControllerSpecificButtonNarration'); // We don't want to use useFacetMemo because of the assumption that it might not run when there's no facet,
  // we're not sure if that bug has been fixed. In either case, we only wanna memoize an object and then wrap it to a facet.
  // When the object changes facet update should take care of propagating the update.

  const translations = (0,react.useMemo)(() => ({
    gamepad: {
      [types_ButtonType.A]: {
        [Controller.XBOX]: t('.Gamepad.A.XBOX'),
        [Controller.PS]: t('.Gamepad.A.PS'),
        [Controller.STEAM]: t('.Gamepad.A.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.A.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.A.QUEST')
      },
      [types_ButtonType.B]: {
        [Controller.XBOX]: t('.Gamepad.B.XBOX'),
        [Controller.PS]: t('.Gamepad.B.PS'),
        [Controller.STEAM]: t('.Gamepad.B.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.B.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.B.QUEST')
      },
      [types_ButtonType.X]: {
        [Controller.XBOX]: t('.Gamepad.X.XBOX'),
        [Controller.PS]: t('.Gamepad.X.PS'),
        [Controller.STEAM]: t('.Gamepad.X.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.X.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.X.QUEST')
      },
      [types_ButtonType.Y]: {
        [Controller.XBOX]: t('.Gamepad.Y.XBOX'),
        [Controller.PS]: t('.Gamepad.Y.PS'),
        [Controller.STEAM]: t('.Gamepad.Y.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.Y.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.Y.QUEST')
      },
      [types_ButtonType.START]: {
        [Controller.XBOX]: t('.Gamepad.START.XBOX'),
        [Controller.PS]: t('.Gamepad.START.PS'),
        [Controller.STEAM]: t('.Gamepad.START.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.START.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.START.QUEST')
      },
      [types_ButtonType.SELECT]: {
        [Controller.XBOX]: t('.Gamepad.SELECT.XBOX'),
        [Controller.PS]: t('.Gamepad.SELECT.PS'),
        [Controller.STEAM]: t('.Gamepad.SELECT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.SELECT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.SELECT.QUEST')
      },
      [types_ButtonType.XBOX]: {
        [Controller.XBOX]: t('.Gamepad.XBOX.XBOX'),
        [Controller.PS]: t('.Gamepad.XBOX.PS'),
        [Controller.STEAM]: t('.Gamepad.XBOX.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.XBOX.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.XBOX.QUEST')
      },
      [types_ButtonType.RIGHT_TRIGGER]: {
        [Controller.XBOX]: t('.Gamepad.RT.XBOX'),
        [Controller.PS]: t('.Gamepad.RT.PS'),
        [Controller.STEAM]: t('.Gamepad.RT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.RT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.RT.QUEST')
      },
      [types_ButtonType.LEFT_TRIGGER]: {
        [Controller.XBOX]: t('.Gamepad.LT.XBOX'),
        [Controller.PS]: t('.Gamepad.LT.PS'),
        [Controller.STEAM]: t('.Gamepad.LT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.LT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.LT.QUEST')
      },
      [types_ButtonType.LEFT_BUMPER]: {
        [Controller.XBOX]: t('.Gamepad.LB.XBOX'),
        [Controller.PS]: t('.Gamepad.LB.PS'),
        [Controller.STEAM]: t('.Gamepad.LB.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.LB.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.LB.QUEST')
      },
      [types_ButtonType.RIGHT_BUMPER]: {
        [Controller.XBOX]: t('.Gamepad.RB.XBOX'),
        [Controller.PS]: t('.Gamepad.RB.PS'),
        [Controller.STEAM]: t('.Gamepad.RB.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.RB.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.RB.QUEST')
      },
      [types_ButtonType.L3]: {
        [Controller.XBOX]: t('.Gamepad.L3.XBOX'),
        [Controller.PS]: t('.Gamepad.L3.PS'),
        [Controller.STEAM]: t('.Gamepad.L3.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.L3.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.L3.QUEST')
      },
      [types_ButtonType.R3]: {
        [Controller.XBOX]: t('.Gamepad.R3.XBOX'),
        [Controller.PS]: t('.Gamepad.R3.PS'),
        [Controller.STEAM]: t('.Gamepad.R3.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.R3.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.R3.QUEST')
      },
      [types_ButtonType.LEFT]: {
        [Controller.XBOX]: t('.Gamepad.LEFT.XBOX'),
        [Controller.PS]: t('.Gamepad.LEFT.PS'),
        [Controller.STEAM]: t('.Gamepad.LEFT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.LEFT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.LEFT.QUEST')
      },
      [types_ButtonType.RIGHT]: {
        [Controller.XBOX]: t('.Gamepad.RIGHT.XBOX'),
        [Controller.PS]: t('.Gamepad.RIGHT.PS'),
        [Controller.STEAM]: t('.Gamepad.RIGHT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.RIGHT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.RIGHT.QUEST')
      },
      [types_ButtonType.UP]: {
        [Controller.XBOX]: t('.Gamepad.UP.XBOX'),
        [Controller.PS]: t('.Gamepad.UP.PS'),
        [Controller.STEAM]: t('.Gamepad.UP.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.UP.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.UP.QUEST')
      },
      [types_ButtonType.DOWN]: {
        [Controller.XBOX]: t('.Gamepad.DOWN.XBOX'),
        [Controller.PS]: t('.Gamepad.DOWN.PS'),
        [Controller.STEAM]: t('.Gamepad.DOWN.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.DOWN.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.DOWN.QUEST')
      },
      [types_ButtonType.NEXT]: {
        [Controller.XBOX]: t('.Gamepad.NEXT.XBOX'),
        [Controller.PS]: t('.Gamepad.NEXT.PS'),
        [Controller.STEAM]: t('.Gamepad.NEXT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.NEXT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.NEXT.QUEST')
      },
      [types_ButtonType.PREV]: {
        [Controller.XBOX]: t('.Gamepad.PREV.XBOX'),
        [Controller.PS]: t('.Gamepad.PREV.PS'),
        [Controller.STEAM]: t('.Gamepad.PREV.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PREV.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PREV.QUEST')
      },
      [types_ButtonType.LEFT_ANALOG_LEFT]: {
        [Controller.XBOX]: t('.Gamepad.L_LEFT.XBOX'),
        [Controller.PS]: t('.Gamepad.L_LEFT.PS'),
        [Controller.STEAM]: t('.Gamepad.L_LEFT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.L_LEFT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.L_LEFT.QUEST')
      },
      [types_ButtonType.LEFT_ANALOG_RIGHT]: {
        [Controller.XBOX]: t('.Gamepad.L_RIGHT.XBOX'),
        [Controller.PS]: t('.Gamepad.L_RIGHT.PS'),
        [Controller.STEAM]: t('.Gamepad.L_RIGHT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.L_RIGHT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.L_RIGHT.QUEST')
      },
      [types_ButtonType.LEFT_ANALOG_UP]: {
        [Controller.XBOX]: t('.Gamepad.L_UP.XBOX'),
        [Controller.PS]: t('.Gamepad.L_UP.PS'),
        [Controller.STEAM]: t('.Gamepad.L_UP.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.L_UP.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.L_UP.QUEST')
      },
      [types_ButtonType.LEFT_ANALOG_DOWN]: {
        [Controller.XBOX]: t('.Gamepad.L_DOWN.XBOX'),
        [Controller.PS]: t('.Gamepad.L_DOWN.PS'),
        [Controller.STEAM]: t('.Gamepad.L_DOWN.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.L_DOWN.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.L_DOWN.QUEST')
      },
      [types_ButtonType.RIGHT_ANALOG_LEFT]: {
        [Controller.XBOX]: t('.Gamepad.R_LEFT.XBOX'),
        [Controller.PS]: t('.Gamepad.R_LEFT.PS'),
        [Controller.STEAM]: t('.Gamepad.R_LEFT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.R_LEFT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.R_LEFT.QUEST')
      },
      [types_ButtonType.RIGHT_ANALOG_RIGHT]: {
        [Controller.XBOX]: t('.Gamepad.R_RIGHT.XBOX'),
        [Controller.PS]: t('.Gamepad.R_RIGHT.PS'),
        [Controller.STEAM]: t('.Gamepad.R_RIGHT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.R_RIGHT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.R_RIGHT.QUEST')
      },
      [types_ButtonType.RIGHT_ANALOG_UP]: {
        [Controller.XBOX]: t('.Gamepad.R_UP.XBOX'),
        [Controller.PS]: t('.Gamepad.R_UP.PS'),
        [Controller.STEAM]: t('.Gamepad.R_UP.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.R_UP.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.R_UP.QUEST')
      },
      [types_ButtonType.RIGHT_ANALOG_DOWN]: {
        [Controller.XBOX]: t('.Gamepad.R_DOWN.XBOX'),
        [Controller.PS]: t('.Gamepad.R_DOWN.PS'),
        [Controller.STEAM]: t('.Gamepad.R_DOWN.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.R_DOWN.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.R_DOWN.QUEST')
      },
      [types_ButtonType.LEFT_HORIZONTAL_AXIS]: {
        [Controller.XBOX]: t('.Gamepad.LEFT_HORIZONTAL_AXIS.XBOX'),
        [Controller.PS]: t('.Gamepad.LEFT_HORIZONTAL_AXIS.PS'),
        [Controller.STEAM]: t('.Gamepad.LEFT_HORIZONTAL_AXIS.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.LEFT_HORIZONTAL_AXIS.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.LEFT_HORIZONTAL_AXIS.QUEST')
      },
      [types_ButtonType.LEFT_VERTICAL_AXIS]: {
        [Controller.XBOX]: t('.Gamepad.LEFT_VERTICAL_AXIS.XBOX'),
        [Controller.PS]: t('.Gamepad.LEFT_VERTICAL_AXIS.PS'),
        [Controller.STEAM]: t('.Gamepad.LEFT_VERTICAL_AXIS.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.LEFT_VERTICAL_AXIS.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.LEFT_VERTICAL_AXIS.QUEST')
      },
      [types_ButtonType.RIGHT_HORIZONTAL_AXIS]: {
        [Controller.XBOX]: t('.Gamepad.RIGHT_HORIZONTAL_AXIS.XBOX'),
        [Controller.PS]: t('.Gamepad.RIGHT_HORIZONTAL_AXIS.PS'),
        [Controller.STEAM]: t('.Gamepad.RIGHT_HORIZONTAL_AXIS.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.RIGHT_HORIZONTAL_AXIS.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.RIGHT_HORIZONTAL_AXIS.QUEST')
      },
      [types_ButtonType.RIGHT_VERTICAL_AXIS]: {
        [Controller.XBOX]: t('.Gamepad.RIGHT_VERTICAL_AXIS.XBOX'),
        [Controller.PS]: t('.Gamepad.RIGHT_VERTICAL_AXIS.PS'),
        [Controller.STEAM]: t('.Gamepad.RIGHT_VERTICAL_AXIS.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.RIGHT_VERTICAL_AXIS.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.RIGHT_VERTICAL_AXIS.QUEST')
      },
      // these are "pseudo buttons" defined to allow us to use additional keyboard-only inputs that remain unmapped on gamepad
      [types_ButtonType.PSEUDO_BUTTON_1]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_1.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_1.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_1.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_1.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_1.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_2]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_2.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_2.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_2.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_2.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_2.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_3]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_3.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_3.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_3.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_3.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_3.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_4]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_4.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_4.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_4.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_4.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_4.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_5]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_5.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_5.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_5.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_5.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_5.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_6]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_6.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_6.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_6.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_6.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_6.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_7]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_7.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_7.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_7.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_7.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_7.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_8]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_8.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_8.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_8.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_8.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_8.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_9]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_9.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_9.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_9.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_9.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_9.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_10]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_10.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_10.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_10.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_10.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_10.QUEST')
      }
    },
    keyboard: {
      [types_KeyboardKey.BACKSPACE]: t('.Keyboard.BACKSPACE'),
      [types_KeyboardKey.TAB]: t('.Keyboard.TAB'),
      [types_KeyboardKey.ENTER]: t('.Keyboard.ENTER'),
      [types_KeyboardKey.SHIFT]: t('.Keyboard.SHIFT'),
      [types_KeyboardKey.CTRL]: t('.Keyboard.CTRL'),
      [types_KeyboardKey.ALT]: t('.Keyboard.ALT'),
      [types_KeyboardKey.ESCAPE]: t('.Keyboard.ESCAPE'),
      [types_KeyboardKey.SPACE]: t('.Keyboard.SPACE'),
      [types_KeyboardKey.LEFT]: t('.Keyboard.LEFT'),
      [types_KeyboardKey.UP]: t('.Keyboard.UP'),
      [types_KeyboardKey.RIGHT]: t('.Keyboard.RIGHT'),
      [types_KeyboardKey.DOWN]: t('.Keyboard.DOWN'),
      [types_KeyboardKey.INSERT]: t('.Keyboard.INSERT'),
      [types_KeyboardKey.DELETE]: t('.Keyboard.DELETE'),
      [types_KeyboardKey.KEY_0]: t('.Keyboard.KEY_0'),
      [types_KeyboardKey.KEY_1]: t('.Keyboard.KEY_1'),
      [types_KeyboardKey.KEY_2]: t('.Keyboard.KEY_2'),
      [types_KeyboardKey.KEY_3]: t('.Keyboard.KEY_3'),
      [types_KeyboardKey.KEY_4]: t('.Keyboard.KEY_4'),
      [types_KeyboardKey.KEY_5]: t('.Keyboard.KEY_5'),
      [types_KeyboardKey.KEY_6]: t('.Keyboard.KEY_6'),
      [types_KeyboardKey.KEY_7]: t('.Keyboard.KEY_7'),
      [types_KeyboardKey.KEY_8]: t('.Keyboard.KEY_8'),
      [types_KeyboardKey.KEY_9]: t('.Keyboard.KEY_9'),
      [types_KeyboardKey.KEY_A]: t('.Keyboard.KEY_A'),
      [types_KeyboardKey.KEY_B]: t('.Keyboard.KEY_B'),
      [types_KeyboardKey.KEY_C]: t('.Keyboard.KEY_C'),
      [types_KeyboardKey.KEY_D]: t('.Keyboard.KEY_D'),
      [types_KeyboardKey.KEY_E]: t('.Keyboard.KEY_E'),
      [types_KeyboardKey.KEY_F]: t('.Keyboard.KEY_F'),
      [types_KeyboardKey.KEY_G]: t('.Keyboard.KEY_G'),
      [types_KeyboardKey.KEY_H]: t('.Keyboard.KEY_H'),
      [types_KeyboardKey.KEY_I]: t('.Keyboard.KEY_I'),
      [types_KeyboardKey.KEY_J]: t('.Keyboard.KEY_J'),
      [types_KeyboardKey.KEY_K]: t('.Keyboard.KEY_K'),
      [types_KeyboardKey.KEY_L]: t('.Keyboard.KEY_L'),
      [types_KeyboardKey.KEY_M]: t('.Keyboard.KEY_M'),
      [types_KeyboardKey.KEY_N]: t('.Keyboard.KEY_N'),
      [types_KeyboardKey.KEY_O]: t('.Keyboard.KEY_O'),
      [types_KeyboardKey.KEY_P]: t('.Keyboard.KEY_P'),
      [types_KeyboardKey.KEY_Q]: t('.Keyboard.KEY_Q'),
      [types_KeyboardKey.KEY_R]: t('.Keyboard.KEY_R'),
      [types_KeyboardKey.KEY_S]: t('.Keyboard.KEY_S'),
      [types_KeyboardKey.KEY_T]: t('.Keyboard.KEY_T'),
      [types_KeyboardKey.KEY_U]: t('.Keyboard.KEY_U'),
      [types_KeyboardKey.KEY_V]: t('.Keyboard.KEY_V'),
      [types_KeyboardKey.KEY_W]: t('.Keyboard.KEY_W'),
      [types_KeyboardKey.KEY_X]: t('.Keyboard.KEY_X'),
      [types_KeyboardKey.KEY_Y]: t('.Keyboard.KEY_Y'),
      [types_KeyboardKey.KEY_Z]: t('.Keyboard.KEY_Z'),
      [types_KeyboardKey.F1]: t('.Keyboard.F1'),
      [types_KeyboardKey.F2]: t('.Keyboard.F2'),
      [types_KeyboardKey.F3]: t('.Keyboard.F3'),
      [types_KeyboardKey.F4]: t('.Keyboard.F4'),
      [types_KeyboardKey.F5]: t('.Keyboard.F5'),
      [types_KeyboardKey.F6]: t('.Keyboard.F6'),
      [types_KeyboardKey.F7]: t('.Keyboard.F7'),
      [types_KeyboardKey.F8]: t('.Keyboard.F8'),
      [types_KeyboardKey.F9]: t('.Keyboard.F9'),
      [types_KeyboardKey.F10]: t('.Keyboard.F10'),
      [types_KeyboardKey.F11]: t('.Keyboard.F11'),
      [types_KeyboardKey.F12]: t('.Keyboard.F12'),
      [types_KeyboardKey.MOUSE_MOVEMENT]: t('.Keyboard.MOUSE_MOVEMENT'),
      [types_KeyboardKey.MOUSE_BUTTON_LEFT]: t('.Keyboard.MOUSE_BUTTON_LEFT'),
      [types_KeyboardKey.MOUSE_BUTTON_MIDDLE]: t('.Keyboard.MOUSE_BUTTON_MIDDLE'),
      [types_KeyboardKey.MOUSE_BUTTON_RIGHT]: t('.Keyboard.MOUSE_BUTTON_RIGHT'),
      [types_KeyboardKey.MOUSE_WHEEL]: t('.Keyboard.MOUSE_WHEEL'),
      [types_KeyboardKey.BRACKET_OPEN]: t('.Keyboard.BRACKET_OPEN'),
      [types_KeyboardKey.BRACKET_CLOSE]: t('.Keyboard.BRACKET_CLOSE'),
      [types_KeyboardKey.PSEUDO_KEY_1]: t('.Keyboard.PSEUDO_KEY_1'),
      [types_KeyboardKey.PSEUDO_KEY_2]: t('.Keyboard.PSEUDO_KEY_2'),
      [types_KeyboardKey.PSEUDO_KEY_3]: t('.Keyboard.PSEUDO_KEY_3'),
      [types_KeyboardKey.PSEUDO_KEY_4]: t('.Keyboard.PSEUDO_KEY_4')
    }
  }), [t]);
  const translationsFacet = (0,react_facet_src.useFacetWrap)(translations);
  return /*#__PURE__*/react.createElement(controllerSpecificButtonTranslationsContext.Provider, {
    value: translationsFacet
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-modal-manager/src/ModalManager.tsx


const ModalContext = (0,react.createContext)({
  showModal: () => {},
  hideModal: () => {}
});
const NO_MODAL_NO_PAYLOAD = {
  component: null,
  payload: null
};
function ModalManager({
  children,
  ModalContainerWrapper
}) {
  const modalQueue = (0,react.useRef)([]);
  const [currentModalAndPayload, setCurrentModalAndPayload] = (0,react_facet_src.useFacetState)(NO_MODAL_NO_PAYLOAD); // If the modalQueue changes, we call this function to ensure the correct modal is shown.

  const refreshMountedModal = (0,react.useCallback)(() => {
    // No modals on the queue
    if (modalQueue.current.length <= 0) {
      setCurrentModalAndPayload(NO_MODAL_NO_PAYLOAD);
    } // Modals on the queue
    else {
        const head = modalQueue.current[modalQueue.current.length - 1];
        setCurrentModalAndPayload({
          component: head.component,
          payload: head.payload
        });
      }
  }, [setCurrentModalAndPayload]);
  /**
   * API for showing/hiding modals, provided to consumers via context
   */

  const api = (0,react.useMemo)(() => ({
    showModal: (component, payload) => {
      modalQueue.current.push({
        component: component,
        payload: payload
      });
      refreshMountedModal();
    },
    hideModal: (targetComponent, targetPayload) => {
      if (modalQueue.current.length <= 0) return; // If trying to hide a specific modal (usually triggered declaratively on unmount)
      // then we need to find that target modal because it could be anywhere in the queue.

      if (targetComponent != null) {
        const index = modalQueue.current.findIndex(({
          component,
          payload
        }) => component === targetComponent && payload === targetPayload);
        if (index === -1) return;
        modalQueue.current.splice(index, 1);
      } // Otherwise being called imperatively, so just pop the latest on the queue
      // because we know this must be triggered by a user within the current modal.
      else {
          modalQueue.current.splice(modalQueue.current.length - 1, 1);
        }

      refreshMountedModal();
    }
  }), [refreshMountedModal]);
  const ModalContainer = ModalContainerWrapper !== null && ModalContainerWrapper !== void 0 ? ModalContainerWrapper : react.Fragment;
  return /*#__PURE__*/react.createElement(ModalContext.Provider, {
    value: api
  }, children, /*#__PURE__*/react.createElement(ModalContainer, null, /*#__PURE__*/react.createElement(ModalRenderer, {
    modalAndPayload: currentModalAndPayload
  })));
}

function ModalRenderer({
  modalAndPayload
}) {
  const unwrapped = (0,react_facet_src.useFacetUnwrap)(modalAndPayload);

  if (unwrapped === react_facet_src.NO_VALUE) {
    return null;
  }

  const {
    component: Component,
    payload
  } = unwrapped;

  if (Component == null) {
    return null;
  }

  return /*#__PURE__*/react.createElement(Component, payload !== null && payload !== void 0 ? payload : {});
}

const useModalAPI = () => (0,react.useContext)(ModalContext);

const useHideModal = () => useModalAPI().hideModal;
const registerModal = component => {
  return {
    // Imperative API
    useShowModal: () => {
      const api = (0,react.useContext)(ModalContext);
      return (0,react.useCallback)((...payload) => {
        api.showModal(component, payload[0]);
      }, [api]);
    },
    // Declarative API
    Component: (...payload) => {
      const api = (0,react.useContext)(ModalContext); // We store the payload in a ref and use that so that if anything
      // causes this component to re-render, it won't trigger another `showModal` call.
      // People shouldn't be updating the Modals with live content via the props anyway.

      const payloadRef = (0,react.useRef)(payload[0]); // Changing the props of an already mounted component isn't yet
      // supported so warn the user in dev environments.

      if (false) {}

      (0,react.useEffect)(() => {
        const payloadRefCurrent = payloadRef.current;
        api.showModal(component, payloadRefCurrent);
        return () => {
          api.hideModal(component, payloadRefCurrent);
        };
      }, [api]);
      return null;
    }
  };
};
/**
 * Type testing bed can be uncommented below for sanity check during development
 */

/*
const Foo = registerModal(({ label }: { label: string }) => <div>{label}</div>)
const Bar = registerModal(() => <div />)

;() => {
	const showFoo = Foo.useShowModal()
	const showBar = Bar.useShowModal()

	// Should NOT error
	showBar()
	showFoo({ label: 'hello' })

	// Should error
	showFoo()
	showFoo({ label: 213 })
	showBar({ x: 123 })
	showBar({ y: '123' })

	return (
		<>
			<p>Should NOT error</p>
			<foo.Component label="foo" />
			<bar.Component />

			<p>Should error</p>
			<foo.Component />
			<foo.Component label={123} />
			<foo.Component x={123} />
		</>
	)
}
*/
;// CONCATENATED MODULE: ./packages/ui-primitive/src/Image/Image.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Image_Image = ({"cover":"N00gN"});
;// CONCATENATED MODULE: ./packages/ui-primitive/src/Image/Image.tsx




function Image_Image_Image({
  className,
  src,
  imageRendering,
  height,
  width,
  cover = false
}) {
  const imageRenderingFacet = (0,react_facet_src.useFacetWrap)(imageRendering);
  const srcFacet = (0,react_facet_src.useFacetWrap)(src);
  return cover === true ? /*#__PURE__*/react.createElement(BackgroundImage, {
    src: srcFacet,
    className: className,
    imageRendering: imageRenderingFacet,
    height: height,
    width: width
  }) : /*#__PURE__*/react.createElement("fast-img", {
    className: className,
    src: srcFacet,
    style: {
      height,
      width,
      imageRendering: imageRenderingFacet
    }
  });
}

function BackgroundImage({
  className,
  src,
  imageRendering,
  width,
  height
}) {
  const backgroundImage = (0,react_facet_src.useFacetMap)(src => `url(${src})`, [], [src]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(className => `${Image_Image.cover} ${className}`, [], [(0,react_facet_src.useFacetWrap)(className)]),
    style: {
      width,
      height,
      backgroundImage,
      imageRendering: imageRendering
    }
  });
}

const ImageResponsive = ({
  images,
  cover,
  className,
  height
}) => {
  const ref = useRef(null);
  const imagesFacet = useFacetWrap(images);
  const [containerWidth, setContainerWidth] = useFacetState(0);
  useOnComponentResize(ref, ({
    width
  }) => setContainerWidth(Math.round(width)));
  const imagesSorted = useFacetMemo(images => images.sort((a, b) => b.maxWidth - a.maxWidth), [], [imagesFacet]);
  const image = useFacetMap((images, containerWidth) => images.find(image => image.maxWidth <= containerWidth), [], [imagesSorted, containerWidth]);
  const src = useFacetMap(image => image === null || image === void 0 ? void 0 : image.src, [], [image]);
  const width = useFacetMap(image => `${image === null || image === void 0 ? void 0 : image.maxWidth}px`, [], [image]);
  return /*#__PURE__*/React.createElement("div", {
    ref: ref
  }, /*#__PURE__*/React.createElement(With, {
    data: src
  }, src => /*#__PURE__*/React.createElement(Image_Image_Image, {
    cover: cover,
    src: src,
    className: className,
    width: width,
    height: height,
    imageRendering: 'pixelated'
  })));
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBackWhite/images/arrowBackWhite.png
const arrowBackWhite_namespaceObject = __webpack_require__.p + "assets/arrowBackWhite-2eb91.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBackWhite/IconArrowBackWhite.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowBackWhite = ({"iconArrowBackWhite":"QY9oU"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBackWhite/IconArrowBackWhite.tsx




const IconArrowBackWhite_IconArrowBackWhite = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconArrowBackWhite.iconArrowBackWhite,
  src: arrowBackWhite_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCrossWhite/images/crossWhite.png
const crossWhite_namespaceObject = __webpack_require__.p + "assets/crossWhite-0f6ce.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCrossWhite/IconCrossWhite.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconCrossWhite = ({"iconCrossWhite":"pOfo3"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCrossWhite/IconCrossWhite.tsx




const IconCrossWhite_IconCrossWhite = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconCrossWhite.iconCrossWhite,
  src: crossWhite_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Reflection/Reflection.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Reflection = ({"base":"VhM7i","top":"IJLgK","thin":"TlrkS","bottom":"vgsJS","left":"TayiM","right":"NnaWJ"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Reflection/Reflection.tsx
function Reflection_extends() { Reflection_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Reflection_extends.apply(this, arguments); }

function Reflection_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Reflection_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Reflection_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







const ReflectionEffect = ({
  thin,
  top = true,
  bottom = true,
  left = true,
  right = true,
  className,
  semanticStyles
}) => {
  const classList = classnames_default()(Reflection.base, semanticStyles, className, {
    [Reflection.thin]: thin
  });
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(classList, {
      [Reflection.top]: top,
      [Reflection.left]: left
    })
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(classList, {
      [Reflection.bottom]: bottom,
      [Reflection.right]: right
    })
  }));
};

const StaticReflection = (_ref) => {
  let {
    children
  } = _ref,
      props = Reflection_objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(ReflectionEffect, props), children);
};

const DynamicReflection = (_ref2) => {
  let {
    disabled,
    children
  } = _ref2,
      props = Reflection_objectWithoutProperties(_ref2, ["disabled", "children"]);

  const enabled = (0,react_facet_src.useFacetMap)(disabled => (disabled !== null && disabled !== void 0 ? disabled : false) === false, [], [(0,react_facet_src.useFacetWrap)(disabled !== null && disabled !== void 0 ? disabled : false)]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: enabled
  }, /*#__PURE__*/react.createElement(ReflectionEffect, props)), children);
};

const Reflection_Reflection = (_ref3) => {
  let {
    effect = 'specular',
    reversed,
    role = 'inherit',
    interactive = true
  } = _ref3,
      props = Reflection_objectWithoutProperties(_ref3, ["effect", "reversed", "role", "interactive"]);

  const {
    color: {
      [role]: {
        [effect]: element
      }
    },
    variant
  } = useSemanticTokens();
  const semanticStyles = classnames_default()(interactive ? element.interactive : element.base, {
    [variant.reversed]: reversed
  });
  return props.disabled != null ? /*#__PURE__*/react.createElement(DynamicReflection, Reflection_extends({
    semanticStyles: semanticStyles
  }, props)) : /*#__PURE__*/react.createElement(StaticReflection, Reflection_extends({
    semanticStyles: semanticStyles
  }, props));
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/InteractiveSiblingState/InteractiveSiblingState.tsx


const InteractiveSiblingState = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: false
}));
const useHasInteractiveSiblings = () => (0,react.useContext)(InteractiveSiblingState);
;// CONCATENATED MODULE: ./packages/ui-internal/src/Focus/Focus.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Focus = ({"focus":"Yp0em","focused":"wI0IL","inset":"L0e76","withoutBorders":"n2X5o"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Focus/Focus.tsx
function Focus_extends() { Focus_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Focus_extends.apply(this, arguments); }

function Focus_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Focus_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Focus_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







const FocusEffect = ({
  semanticStyles,
  className,
  withoutBorders,
  inset
}) => {
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Focus.focus, semanticStyles, className, {
      [Focus.withoutBorders]: withoutBorders,
      [Focus.inset]: inset
    })
  });
};

const DynamicFocus = (_ref) => {
  let {
    disabled
  } = _ref,
      props = Focus_objectWithoutProperties(_ref, ["disabled"]);

  const unwrappedDisabled = (0,react_facet_src.useFacetUnwrap)(disabled);
  const disabledValue = unwrappedDisabled === react_facet_src.NO_VALUE ? false : !!unwrappedDisabled;
  return disabledValue ? null : /*#__PURE__*/react.createElement(FocusEffect, props);
};

const Focus_Focus = (_ref2) => {
  let {
    role = 'inherit',
    interactive = true
  } = _ref2,
      props = Focus_objectWithoutProperties(_ref2, ["role", "interactive"]);

  const {
    color: {
      [role]: {
        outline
      }
    }
  } = useSemanticTokens();
  const semanticStyles = interactive ? outline.interactive : outline.base;
  return props.disabled != null ? /*#__PURE__*/react.createElement(DynamicFocus, Focus_extends({
    semanticStyles: semanticStyles
  }, props)) : /*#__PURE__*/react.createElement(FocusEffect, Focus_extends({
    semanticStyles: semanticStyles
  }, props));
};
const focusClass = Focus.focused;
;// CONCATENATED MODULE: ./packages/ui-internal/src/Spacing/Spacing.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Spacing = ({"size1":"dKnsZ","size2":"jlzzq","size3":"kImvy","size4":"wuFIX","size5":"N0bYN","size6":"IhAF5","size7":"hzGpu","size8":"pqqwM"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Spacing/Spacing.tsx


function Spacing_Spacing({
  size
}) {
  return /*#__PURE__*/react.createElement("div", {
    className: Spacing[`size${size}`]
  });
}
Spacing_Spacing.displayName = 'Spacing';
;// CONCATENATED MODULE: ./packages/react-gamepad/src/useFocus.ts






function useFocus(gamepad, onClick, ref, nodeIdRef) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();
  const id = (0,react.useMemo)(() => {
    if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
      return __generateId();
    } else {
      return id_generateId();
    }
  }, [gamepadVersion]); // One use case for this is that the facet effect that calls the onFocusChanged function might not be called in time
  // if something is focused on mount. This allows the consumer to obtain the nodeIdRef as soon as we have assigned it.

  if (nodeIdRef != null) {
    nodeIdRef.current = id;
  }

  const disabledContext = (0,react.useContext)(DisabledAreaContext);
  const gamepadFacet = (0,react_facet_src.useFacetWrap)(gamepad);
  const visualApi = (0,react.useContext)(FocusTreeAPIContext);
  const visualRequestFocusIdUpdate = setFocusedId_useSetFocusedId();
  const legacyApi = (0,react.useContext)(GamepadAPIContext);
  const legacyPath = (0,react.useContext)(pathContext_PathContext);
  const visualPath = (0,react.useContext)(PathContext);
  const [isFocusedFacet, setIsFocusedFacet] = (0,react_facet_src.useFacetState)(false);
  /** This is only part of Visual API */

  const onFocus = (0,react_facet_src.useFacetCallback)(disabledContext => (origin = FocusOrigin.Unknown) => {
    if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
      legacyApi.requestFocus(id, true);
    } else if (disabledContext.disabled !== true && disabledContext.hidden !== true) {
      visualRequestFocusIdUpdate(id, false, origin);
    }
  }, [visualRequestFocusIdUpdate, id, legacyApi, gamepadVersion], [disabledContext]);
  (0,react_facet_src.useFacetEffect)((gamepad, disabledContext) => {
    const handleFocusChanged = focused => {
      if (gamepad.onFocusChanged) {
        gamepad.onFocusChanged(focused);
      }

      setIsFocusedFacet(focused);
    };

    if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
      const focusable = {
        type: 'focusable',
        id: id,
        path: legacyPath,
        alias: gamepad.alias,
        ref: ref,
        disabled: gamepad.disabled,
        autofocus: gamepad.autofocus,
        disableScrollIntoView: gamepad.disableScrollIntoView,
        scrollSpeedFactor: gamepad.scrollIntoViewSpeedFactor,
        scrollAlign: gamepad.scrollIntoViewAlign,
        scrollOffset: gamepad.scrollIntoViewOffset,
        onClick: onClick,
        onFocusedChange: handleFocusChanged,
        index: gamepad.index,
        inputLegend: gamepad.inputLegend,
        onRight: gamepad.onRight,
        onLeft: gamepad.onLeft,
        onUp: gamepad.onUp,
        onDown: gamepad.onDown
      };
      legacyApi.addOrUpdateNode(focusable);
      const isFocused = legacyApi.isFocusableFocused(id, gamepad.alias);
      setIsFocusedFacet(isFocused);
    } else {
      const focusable = {
        type: types_FocusableType.ITEM,
        id: id,
        alias: gamepad.alias,
        ref: ref.current,
        disabled: gamepad.disabled || disabledContext.disabled || false,
        hidden: gamepad.hidden || disabledContext.hidden || false,
        scrollSpeedFactor: gamepad.scrollIntoViewSpeedFactor,
        scrollAlign: gamepad.scrollIntoViewAlign,
        scrollOffset: gamepad.scrollIntoViewOffset,
        onFocus: () => {
          handleFocusChanged(true);
        },
        onBlur: () => {
          handleFocusChanged(false);
        },
        onRight: gamepad.onRight,
        onLeft: gamepad.onLeft,
        onUp: gamepad.onUp,
        onDown: gamepad.onDown
      };
      visualApi.putNode(focusable, visualPath[visualPath.length - 1]);
      visualApi.putShortcut(id, types_ButtonType.A, {
        callback: onClick,
        inputLegend: gamepad.inputLegend
      });
      setIsFocusedFacet(visualApi.isFocused(id, gamepad.alias));
    }
  }, [gamepadVersion, setIsFocusedFacet, legacyApi, visualApi, legacyPath, visualPath, id, onClick, ref], [gamepadFacet, disabledContext]);
  /**
   * Tries to request autofocus if disabled or autofocus options changes
   *
   * This effect must come after the effect that addOrUpdateNode
   */

  (0,react_facet_src.useFacetEffect)(autofocus => {
    if (autofocus) {
      if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
        legacyApi.requestAutofocus(id);
      } else {
        visualRequestFocusIdUpdate(id, true);
      }
    }
  }, [legacyApi, visualRequestFocusIdUpdate, id, gamepadVersion], [(0,react_facet_src.useFacetMap)(gamepad => gamepad.autofocus && !gamepad.disabled, [], [gamepadFacet])]);
  (0,react.useEffect)(() => {
    if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
      legacyApi.runAddNodeEffect();
      return () => legacyApi.removeNode(id);
    } else {
      return () => visualApi.removeNode(id);
    }
  }, [visualApi, legacyApi, gamepadVersion, id]);
  (0,react.useLayoutEffect)(() => {
    const node = ref.current;
    if (node == null) return;

    const handleFocused = () => {
      if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
        legacyApi.requestFocus(id);
      } else {
        visualRequestFocusIdUpdate(id);
      }
    };

    node.addEventListener('focusin', handleFocused);
    return () => {
      node.removeEventListener('focusin', handleFocused);
    };
  }, [ref, id, visualApi, legacyApi, gamepadVersion, visualRequestFocusIdUpdate]);
  return {
    isFocused: isFocusedFacet,
    onFocus
  };
}
;// CONCATENATED MODULE: ./packages/ui-primitive/src/InteractivePrimitive/useScheduledFunctions.ts

const useScheduledFunctions = () => {
  const timerRef = (0,react.useRef)([]);
  const cancelSchedule = (0,react.useCallback)(() => {
    timerRef.current.forEach(clearTimeout);
    timerRef.current = [];
  }, [timerRef]);
  const scheduleFunctions = (0,react.useCallback)(schedule => {
    cancelSchedule();
    let accumulatedDelay = 0;
    schedule.forEach(unit => {
      if (typeof unit === 'number') {
        accumulatedDelay += unit;
      } else {
        timerRef.current.push(setTimeout(() => unit(), accumulatedDelay));
      }
    });
  }, [cancelSchedule]);
  (0,react.useEffect)(() => {
    // Cleanup function that is triggered on component unmount to clear all the timers
    const timers = timerRef.current;
    return () => {
      timers.forEach(timeoutId => clearTimeout(timeoutId));
    };
  }, []);
  return scheduleFunctions;
};
;// CONCATENATED MODULE: ./packages/ui-primitive/src/InputStateOverride/InputStateOverride.tsx

const InputStateOverride_context = (0,react.createContext)(null);
const useInputStateOverride = () => (0,react.useContext)(InputStateOverride_context);
const InputStateOverride = InputStateOverride_context.Provider;
;// CONCATENATED MODULE: ./packages/react-narrator/src/context/narrationContext.ts


const narrationContextContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)('root'));
const NarrationContextProvider = narrationContextContext.Provider;
const useNarrationContext = () => (0,react.useContext)(narrationContextContext);
;// CONCATENATED MODULE: ./packages/react-narrator/src/hooks/useNarrationPutNode.ts
/**
 * NOTE: This hook is meant to be used only by Core components.
 * It shouldn't be considered a public API.
 *
 * In order to use it, it is exposed through the main package, but
 * the documentation for it is not in the README to avoid confusion.
 */



const useNarrationPutNode = () => {
  const {
    narrationTree
  } = (0,react.useContext)(narrationDriverContext);
  const parentNarrationIdRef = (0,react_facet_src.useFacetRef)((0,react.useContext)(narrationContextContext));
  const narrationPutNode = (0,react.useCallback)((text, shouldSkipParent = [], getSuffix) => {
    const parentNarrationId = parentNarrationIdRef.current !== react_facet_src.NO_VALUE ? parentNarrationIdRef.current : '';
    const fullNarrationId = `${parentNarrationId}-${text}`;
    narrationTree[fullNarrationId] = {
      parentNarrationId,
      text,
      shouldSkipParent,
      getSuffix
    };
    return fullNarrationId;
  }, [narrationTree, parentNarrationIdRef]); // Providing a callback to retrieve the text allows us to delay potentially
  // expensive computations used to compute the text to narrate to the moment
  // where the text will actually be read (if read)
  //
  // This is particularly useful because text is read after a delay of about
  // 300ms after the focus / hover is triggered, so that it can be canceled if
  // many focus events happen one after the other.
  //
  // This will also help keeping the frame associated with the focus event
  // small in computation time, since the computation that computes the text
  // is done asynchronously, which means the focus-related style changes
  // will be finished before it triggers.

  const narrationPutNodeWithIdAndCallback = (0,react.useCallback)((id, getText, shouldSkipParent = [], getSuffix) => {
    const parentNarrationId = parentNarrationIdRef.current !== react_facet_src.NO_VALUE ? parentNarrationIdRef.current : '';
    const fullNarrationId = `${parentNarrationId}-${id}`;
    narrationTree[fullNarrationId] = {
      parentNarrationId,
      getText,
      shouldSkipParent,
      getSuffix
    };
    return fullNarrationId;
  }, [narrationTree, parentNarrationIdRef]);
  return {
    narrationPutNode,
    narrationPutNodeWithIdAndCallback
  };
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/constants.ts
const NARRATION_DEBOUNCE_DELAY = 200;
;// CONCATENATED MODULE: ./packages/react-narrator/src/hooks/useNarrateCurrentContext.ts
/**
 * NOTE: This hook is meant to be used only by Core components.
 * It shouldn't be considered a public API.
 *
 * In order to use it, it is exposed through the main package, but
 * the documentation for it is not in the README to avoid confusion.
 */




// `useNarrateCurrentContext` will narrate the content of the current narration node
// and, if necessary, all the ancestors of the current narration node.
// The goal of `useNarrateCurrentContext` is to allow the user to understand what and where the
// currently highlighted content is, for example with a focus event or with
// a mouse over event.
const useNarrateCurrentContext = () => {
  const narrateTimeoutRef = (0,react.useRef)();
  const narrationId = (0,react.useContext)(narrationContextContext);
  const {
    readById,
    narrationTree
  } = (0,react.useContext)(narrationDriverContext);
  const narrateCurrentContext = (0,react_facet_src.useFacetCallback)(narrationId => (profanityFilterContext, interruptible = true, required, playInBackground) => {
    if (Object.keys(narrationTree).length > 0) {
      narrateTimeoutRef.current = setTimeout(() => {
        readById(narrationId, profanityFilterContext ? profanityFilterContext : undefined, interruptible, required, playInBackground);
      }, NARRATION_DEBOUNCE_DELAY);
    }
  }, [readById, narrationTree], [narrationId]);
  const preventNarrateCurrentContext = (0,react.useCallback)(() => {
    if (narrateTimeoutRef.current) {
      clearTimeout(narrateTimeoutRef.current);
    }
  }, []);
  return {
    narrateCurrentContext,
    preventNarrateCurrentContext
  };
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/hooks/useNarrateById.ts
/**
 * NOTE: This hook is meant to be used only by Core components.
 * It shouldn't be considered a public API.
 *
 * In order to use it, it is exposed through the main package, but
 * the documentation for it is not in the README to avoid confusion.
 */



const useNarrateById = () => {
  const narrateTimeoutRef = (0,react.useRef)();
  const {
    readById
  } = (0,react.useContext)(narrationDriverContext);
  const narrateById = (0,react.useCallback)((narrationId, interruptible = true, profanityFilterContext, required, playInBackground) => {
    narrateTimeoutRef.current = setTimeout(() => {
      readById(narrationId, profanityFilterContext, interruptible, required, playInBackground);
    }, NARRATION_DEBOUNCE_DELAY);
  }, [readById]);
  const preventNarrateById = (0,react.useCallback)(() => {
    if (narrateTimeoutRef.current) {
      clearTimeout(narrateTimeoutRef.current);
    }
  }, []);
  return {
    narrateById,
    preventNarrateById
  };
};
;// CONCATENATED MODULE: ./packages/ui-primitive/src/InteractivePrimitive/InteractivePrimitive.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InteractivePrimitive = ({"interactivePrimitive":"BlHLJ","disabled":"OO8Fh"});
;// CONCATENATED MODULE: ./packages/ui-primitive/src/InteractivePrimitive/InteractivePrimitive.tsx
function InteractivePrimitive_extends() { InteractivePrimitive_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return InteractivePrimitive_extends.apply(this, arguments); }

function InteractivePrimitive_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = InteractivePrimitive_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function InteractivePrimitive_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }















/**
 * If any parent containers want to be informed when an InteractivePrimitive
 * is mounted, they can use this context to receive a callback on mount.
 */

const InteractivePrimitiveMountCallback = (0,react.createContext)(InteractivePrimitive_noop);

function useMountNotification() {
  const notify = (0,react.useContext)(InteractivePrimitiveMountCallback);
  (0,react.useEffect)(notify, [notify]);
}

const DEFAULT_PRESS_DURATION = 150;
const DEFAULT_TOUCH_DETECTION_DELAY = 150;
const DEFAULT_MOUSE_OVER_HANDLER_DELAY = 50;
const TOUCH_DISTANCE_THRESHOLD = 3;
const SOUND_WAIT_DURATION = 10;
const NARRATION_SUFFIX_BUTTONS_TO_SKIP = DEFAULT_ACTIONS.map(key => `${key}`);
/**
 * The recommended abstraction to create interactive targets.
 *
 * It supports:
 * - all input methods (mouse, touch, gamepad)
 * - text-to-speech narration via an ariaLabel prop
 * - sound effect support
 *
 * All done in a better performing way for Gameface.
 */

function InteractivePrimitive_InteractivePrimitive(props) {
  const {
    onHoverChanged,
    onFocusChanged,
    onPressChanged,
    onClick,
    onGamepadClick,
    onKeyDown,
    onMouseDown,
    onUp,
    onDown,
    onLeft,
    onRight,
    touchDetectionDelay = DEFAULT_TOUCH_DETECTION_DELAY,
    focusRefOverride,
    nodeIdRef
  } = props;
  const autofocusFacet = (0,react_facet_src.useFacetWrap)(props.autofocus);
  const classNameFacet = (0,react_facet_src.useFacetWrap)(props.className);
  const dataTestIdFacet = (0,react_facet_src.useFacetWrap)(props['data-testid']);
  const classNameFocusedFacet = (0,react_facet_src.useFacetWrap)(props.classNameFocused);
  const classNameHoveredFacet = (0,react_facet_src.useFacetWrap)(props.classNameHovered);
  const classNamePressedFacet = (0,react_facet_src.useFacetWrap)(props.classNamePressed);
  const classNameDisabledFacet = (0,react_facet_src.useFacetWrap)(props.classNameDisabled);
  const delayedClickFacet = (0,react_facet_src.useFacetWrap)(props.delayedClick);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(props.disabled);
  const nonFocusableFacet = (0,react_facet_src.useFacetWrap)(props.nonFocusable);
  const hiddenFacet = (0,react_facet_src.useFacetWrap)(props.hidden);
  const disableScrollIntoViewFacet = (0,react_facet_src.useFacetWrap)(props.disableScrollIntoView);
  const gamepadAliasFacet = (0,react_facet_src.useFacetWrap)(props.gamepadAlias);
  const gamepadIndexFacet = (0,react_facet_src.useFacetWrap)(props.gamepadIndex);
  const inputLegendFacet = (0,react_facet_src.useFacetWrap)(props.inputLegend);
  const narrationTextFacet = (0,react_facet_src.useFacetWrap)('narrationText' in props ? props.narrationText : false);
  const narrationIdFacet = (0,react_facet_src.useFacetWrap)('narrationId' in props ? props.narrationId : undefined);
  const pressDurationFacet = (0,react_facet_src.useFacetWrap)(props.pressDuration);
  const soundEffectFocusedFacet = (0,react_facet_src.useFacetWrap)(props.soundEffectFocused);
  const soundEffectHoveredFacet = (0,react_facet_src.useFacetWrap)(props.soundEffectHovered);
  const soundEffectPressedFacet = (0,react_facet_src.useFacetWrap)(props.soundEffectPressed);
  const isLastInputMouse = useIsLastInputMouse();
  const isLastInputTouch = useIsLastInputTouch();
  const isLastInputGamepad = useIsLastInputGamepad();
  const isLastInputKeyboard = useIsLastInputKeyboard();
  const isLastInputKeyboardRef = (0,react_facet_src.useFacetRef)(isLastInputKeyboard);
  const localRef = (0,react.useRef)(null);
  const ref = props.innerRef || localRef;
  const lastTouchPositionRef = (0,react.useRef)({
    x: 0,
    y: 0
  });
  const stateOverride = useInputStateOverride();
  const isNarrationEnabled = useNarrationEnabled();
  const scheduleFunctions = useScheduledFunctions();
  const triggerSoundEffect = useSoundEffectTrigger();
  const availableInputLegendsFacet = useAvailableInputLegends();
  const availableInputLegendsFacetRef = (0,react_facet_src.useFacetRef)(availableInputLegendsFacet);
  const controllerSpecificButtonTranslationsFacet = useControllerSpecificButtonTranslations();
  const controllerSpecificButtonTranslationsFacetRef = (0,react_facet_src.useFacetRef)(controllerSpecificButtonTranslationsFacet);
  const currentControllerFacet = useControllerSelected();
  const currentControllerFacetRef = (0,react_facet_src.useFacetRef)(currentControllerFacet);
  const {
    narrationPutNode,
    narrationPutNodeWithIdAndCallback
  } = useNarrationPutNode();
  const {
    narrateCurrentContext,
    preventNarrateCurrentContext
  } = useNarrateCurrentContext();
  const narrationContextFacet = useNarrationContext();
  const {
    narrateById,
    preventNarrateById
  } = useNarrateById();
  const [keyboardGamepadMapFacet] = useKeyboardGamepadMap();
  const keyboardGamepadMapFacetRef = (0,react_facet_src.useFacetRef)(keyboardGamepadMapFacet);
  const hasNarrationId = ('narrationId' in props);
  const getNarrationText = 'getNarrationText' in props ? props.getNarrationText : noopString;
  const getNarrationSuffix = (0,react.useCallback)(() => {
    const currentValue = availableInputLegendsFacetRef.current;
    const currentControllerSpecificButtonTranslations = controllerSpecificButtonTranslationsFacetRef.current;
    const currentController = currentControllerFacetRef.current;
    const currentKeyboardGamepadMap = keyboardGamepadMapFacetRef.current;

    if (currentValue === react_facet_src.NO_VALUE || currentControllerSpecificButtonTranslations === react_facet_src.NO_VALUE || currentController === react_facet_src.NO_VALUE || currentKeyboardGamepadMap === react_facet_src.NO_VALUE) {
      return '';
    }

    let result = '';
    recordEntries(currentValue, (gamepadButton, narrationString) => {
      var _currentControllerSpe;

      if (NARRATION_SUFFIX_BUTTONS_TO_SKIP.indexOf(gamepadButton) !== -1) return;
      if (narrationString == null) return;
      const keyboardKey = currentKeyboardGamepadMap[gamepadButton];
      const buttonActionNarration = isLastInputKeyboardRef.current === true ? currentControllerSpecificButtonTranslations.keyboard[keyboardKey[0]] : (_currentControllerSpe = currentControllerSpecificButtonTranslations.gamepad[gamepadButton]) === null || _currentControllerSpe === void 0 ? void 0 : _currentControllerSpe[currentController];
      if (buttonActionNarration == null) return;
      result += `${buttonActionNarration}: ${narrationString} . `;
    });
    return result;
  }, [availableInputLegendsFacetRef, controllerSpecificButtonTranslationsFacetRef, currentControllerFacetRef, keyboardGamepadMapFacetRef, isLastInputKeyboardRef]);
  const getNewFullPathNarrationId = (0,react_facet_src.useFacetCallback)((narrationText, narrationId) => () => {
    if (hasNarrationId && narrationId != null) {
      return narrationPutNodeWithIdAndCallback(narrationId, getNarrationText, undefined, getNarrationSuffix);
    }

    return narrationText !== false && narrationText != null ? narrationPutNode(narrationText, undefined, getNarrationSuffix) : undefined;
  }, [narrationPutNode, hasNarrationId, narrationPutNodeWithIdAndCallback, getNarrationText, getNarrationSuffix], [narrationTextFacet, narrationIdFacet]);
  const [fullPathNarrationIdFacet, setFullPathNarrationIdFacet] = (0,react_facet_src.useFacetState)(getNewFullPathNarrationId());
  (0,react_facet_src.useFacetEffect)(() => {
    const newNarrationId = getNewFullPathNarrationId();
    setFullPathNarrationIdFacet(newNarrationId !== react_facet_src.NO_VALUE ? newNarrationId : undefined);
  }, [setFullPathNarrationIdFacet, getNewFullPathNarrationId], [narrationTextFacet, narrationContextFacet]);
  const getCurrentNarrationId = (0,react_facet_src.useFacetCallback)(narrationId => () => narrationId, [], [fullPathNarrationIdFacet]);
  const [isHoveredFacet, setIsHoveredFacet] = (0,react_facet_src.useFacetState)(false);
  const [isPressedFacet, setIsPressedFacet] = (0,react_facet_src.useFacetState)(false);
  (0,react_facet_src.useFacetEffect)(isLastInputMouse => {
    if (!isLastInputMouse) {
      setIsHoveredFacet(false);
    }
  }, [setIsHoveredFacet], [isLastInputMouse]);
  const handleMouseLeave = (0,react_facet_src.useFacetCallback)(disabled => () => {
    setIsHoveredFacet(false);
    setIsPressedFacet(false);

    if (disabled) {
      return;
    }

    onHoverChanged === null || onHoverChanged === void 0 ? void 0 : onHoverChanged(false);
    preventNarrateCurrentContext();
    preventNarrateById();
  }, [preventNarrateById, preventNarrateCurrentContext, setIsHoveredFacet, setIsPressedFacet, onHoverChanged], [disabledFacet]);
  const handleDown = (0,react_facet_src.useFacetCallback)((soundEffectPressed, disabled) => (event, ignoreHandlers) => {
    if (disabled) {
      return;
    } // Only handle primary clicks


    if (event && event.button != null && event.button > 0) {
      return;
    } // Used for if you need access to the react mouse event


    if (!ignoreHandlers && onMouseDown) {
      onMouseDown(event);
    }

    setIsPressedFacet(true);

    if (soundEffectPressed != null) {
      triggerSoundEffect(soundEffectPressed);
    }

    onPressChanged === null || onPressChanged === void 0 ? void 0 : onPressChanged(true);
  }, [triggerSoundEffect, setIsPressedFacet, onPressChanged, onMouseDown], [soundEffectPressedFacet, disabledFacet]);
  const handleMouseDown = (0,react_facet_src.useFacetCallback)(isLastInputMouse => (event, ignoreHandlers) => {
    if (!isLastInputMouse) {
      return;
    }

    handleDown(event, ignoreHandlers);
  }, [handleDown], [isLastInputMouse]);
  const handleUp = (0,react_facet_src.useFacetCallback)(disabled => event => {
    setIsPressedFacet(false);

    if (disabled) {
      return;
    } // Only handle primary clicks


    if (event && event.button > 0) {
      return;
    }

    onPressChanged === null || onPressChanged === void 0 ? void 0 : onPressChanged(false);
  }, [setIsPressedFacet, onPressChanged], [disabledFacet]);
  const handleMouseUp = (0,react_facet_src.useFacetCallback)(isLastInputMouse => event => {
    if (!isLastInputMouse) {
      return;
    }

    handleUp(event);
  }, [handleUp], [isLastInputMouse, disabledFacet]);
  const handleMouseClick = (0,react_facet_src.useFacetCallback)(disabled => event => {
    if (disabled || onClick == null) {
      return;
    }

    event.stopPropagation(); // Only handle primary clicks

    if (event.button > 0) {
      return;
    }

    return onClick();
  }, [onClick], [disabledFacet]);
  /**
   * Touch Event Handlers
   */

  const handleTouchStart = (0,react_facet_src.useFacetCallback)((isLastInputTouch, disabled) => e => {
    if (!isLastInputTouch || disabled) {
      return;
    }

    lastTouchPositionRef.current.x = e.touches[0].clientX;
    lastTouchPositionRef.current.y = e.touches[0].clientY;
    scheduleFunctions([touchDetectionDelay, () => handleDown({
      clientX: e.touches[0].clientX,
      clientY: e.touches[0].clientY
    })]);
    onPressChanged === null || onPressChanged === void 0 ? void 0 : onPressChanged(true);
  }, [touchDetectionDelay, scheduleFunctions, handleDown, onPressChanged], [isLastInputTouch, disabledFacet]);
  const handleTouchMove = (0,react_facet_src.useFacetCallback)((isLastInputTouch, disabled) => e => {
    if (!isLastInputTouch || disabled) {
      return;
    }

    if (Math.abs(lastTouchPositionRef.current.x - e.touches[0].clientX) > TOUCH_DISTANCE_THRESHOLD || Math.abs(lastTouchPositionRef.current.y - e.touches[0].clientY) > TOUCH_DISTANCE_THRESHOLD) {
      // We need to call schedule so that it cancels the handleTouchStart schedule
      scheduleFunctions([handleUp]);
    }
  }, [scheduleFunctions, handleUp], [isLastInputTouch, disabledFacet]);
  const handleTouchEnd = (0,react_facet_src.useFacetCallback)((isLastInputTouch, disabled) => () => {
    if (!isLastInputTouch || disabled) {
      return;
    } // We need to call schedule so that it cancels the handleTouchStart schedule


    scheduleFunctions([handleUp]);
    onPressChanged === null || onPressChanged === void 0 ? void 0 : onPressChanged(false);
  }, [scheduleFunctions, handleUp, onPressChanged], [isLastInputTouch, disabledFacet]);
  const handleTouchClick = (0,react_facet_src.useFacetCallback)((pressDuration, delayedClick, disabled) => event => {
    if (disabled || onClick == null) {
      return;
    }

    event.stopPropagation();
    const schedule = delayedClick ? [handleDown, SOUND_WAIT_DURATION, pressDuration !== null && pressDuration !== void 0 ? pressDuration : DEFAULT_PRESS_DURATION, handleUp, onClick] : [handleDown, SOUND_WAIT_DURATION, onClick, pressDuration !== null && pressDuration !== void 0 ? pressDuration : DEFAULT_PRESS_DURATION, handleUp];
    scheduleFunctions(schedule);
  }, [handleDown, handleUp, scheduleFunctions, onClick], [pressDurationFacet, delayedClickFacet, disabledFacet]);
  const handleGamepadOrKeyboardClick = (0,react_facet_src.useFacetCallback)((pressDuration, delayedClick, disabled) => () => {
    if (disabled || onClick == null) {
      return;
    } // If the user provided an onGamepadClick we should only call that and not the
    // onClick; this allows for specific functionality when using gamepad/keyboard.
    // Fallback to the usual onClick if no handler is provided.


    const handleClick = onGamepadClick || onClick; // We suppress the onMouseDown handler as we are calling handleMouseDown synthetically

    const handleMouseDownWithoutHandlers = () => handleDown(undefined, true);

    const schedule = delayedClick ? [handleMouseDownWithoutHandlers, SOUND_WAIT_DURATION, pressDuration !== null && pressDuration !== void 0 ? pressDuration : DEFAULT_PRESS_DURATION, handleUp, handleClick] : [handleMouseDownWithoutHandlers, SOUND_WAIT_DURATION, handleClick, pressDuration !== null && pressDuration !== void 0 ? pressDuration : DEFAULT_PRESS_DURATION, handleUp];
    scheduleFunctions(schedule);
  }, [handleDown, handleUp, scheduleFunctions, onGamepadClick, onClick], [pressDurationFacet, delayedClickFacet, disabledFacet]);
  const localIdRef = (0,react.useRef)();
  const idRef = nodeIdRef !== null && nodeIdRef !== void 0 ? nodeIdRef : localIdRef;
  const {
    isFocused: isFocusedFacet,
    onFocus
  } = useFocus((0,react_facet_src.useFacetMap)((gamepadIndex, gamepadAlias, inputLegend, disabled, hidden, nonFocusable, autofocus, disableScrollIntoView) => ({
    index: gamepadIndex !== null && gamepadIndex !== void 0 ? gamepadIndex : 0,
    alias: gamepadAlias,
    inputLegend: inputLegend === false ? undefined : inputLegend,
    disabled: disabled,
    hidden: hidden || nonFocusable,
    autofocus: autofocus,
    disableScrollIntoView: disableScrollIntoView,
    onFocusChanged,
    onUp,
    onDown,
    onLeft,
    onRight
  }), [onFocusChanged, onUp, onDown, onLeft, onRight], [gamepadIndexFacet, gamepadAliasFacet, inputLegendFacet, disabledFacet, hiddenFacet, nonFocusableFacet, autofocusFacet, disableScrollIntoViewFacet]), handleGamepadOrKeyboardClick, (focusRefOverride === null || focusRefOverride === void 0 ? void 0 : focusRefOverride.current) != null ? focusRefOverride : ref, idRef);
  /**
   * Mouse Event Handlers
   */

  const handleMouseMove = (0,react_facet_src.useFacetCallback)((isLastInputMouse, isLastInputTouch, isLastInputKeyboard, isLastInputGamepad, soundEffectHovered, disabled, isFocused, isHovered, hidden) => () => {
    if (!(isLastInputMouse || isLastInputTouch && isNarrationEnabled)) {
      return;
    }

    if (disabled || hidden || isFocused && isHovered) {
      return;
    }
    /**
     * Handle hover scenario
     */


    if (!isHovered) {
      setIsHoveredFacet(true);

      if (soundEffectHovered != null && !isFocused) {
        triggerSoundEffect(soundEffectHovered);
      } // Pointer need to narrate on every hover


      if (isLastInputMouse || isLastInputTouch) {
        const narrationId = getCurrentNarrationId();

        if (narrationId === react_facet_src.NO_VALUE || narrationId == null) {
          narrateCurrentContext();
        } else {
          narrateById(narrationId);
        }
      }

      onHoverChanged === null || onHoverChanged === void 0 ? void 0 : onHoverChanged(true);
    }
    /**
     * Handle focus scenario
     */


    if (isFocused) {
      return;
    }

    if (!(isLastInputKeyboard || isLastInputGamepad)) {
      onFocus(FocusOrigin.PointerInput);
    }
  }, [triggerSoundEffect, setIsHoveredFacet, onHoverChanged, onFocus, getCurrentNarrationId, narrateById, narrateCurrentContext, isNarrationEnabled], [isLastInputMouse, isLastInputTouch, isLastInputKeyboard, isLastInputGamepad, soundEffectHoveredFacet, disabledFacet, isFocusedFacet, isHoveredFacet, hiddenFacet]);
  const handleClick = (0,react_facet_src.useFacetCallback)((isMouse, isTouch) => event => {
    if (isMouse === true) return handleMouseClick(event);
    if (isTouch === true) return handleTouchClick(event);
  }, [handleMouseClick, handleTouchClick], [isLastInputMouse, isLastInputTouch]);
  const isFocusedAndSoundEffectFocusedFacets = (0,react_facet_src.useFacetMap)((isFocused, soundEffect) => {
    if (isFocused === true) return soundEffect;
  }, [], [isFocusedFacet, soundEffectFocusedFacet]);
  (0,react_facet_src.useFacetEffect)(soundEffectFocused => {
    // Trigger sounds
    if (soundEffectFocused != null) {
      triggerSoundEffect(soundEffectFocused);
    }
  }, [triggerSoundEffect], [isFocusedAndSoundEffectFocusedFacets]);
  (0,react_facet_src.useFacetEffect)((focused, isLastInputGamepad, isLastInputKeyboard) => {
    // Trigger narration for gamepad/keyboard (mouse/touch narration is handled in handleMouseMove)
    if (isLastInputGamepad || isLastInputKeyboard) {
      if (focused === true) {
        const narrationId = getCurrentNarrationId();

        if (narrationId == null || narrationId == react_facet_src.NO_VALUE) {
          narrateCurrentContext();
        } else {
          narrateById(narrationId);
        }
      } else {
        preventNarrateCurrentContext();
        preventNarrateById();
      }
    }
  }, [getCurrentNarrationId, narrateById, narrateCurrentContext, preventNarrateById, preventNarrateCurrentContext, onFocusChanged], [isFocusedFacet, isLastInputGamepad, isLastInputKeyboard]);
  const composedClassNameFacet = (0,react_facet_src.useFacetMap)((className, classNameHovered, classNamePressed, classNameFocused, classNameDisabled, disabledValue, isHoveredValue, isPressedValue, isFocusedValue, isLastInputKeyboard, isLastInputGamepad) => {
    const isHovered = stateOverride ? stateOverride.hovered : isHoveredValue;
    const isPressed = onClick != null && (stateOverride ? stateOverride.pressState === 'pressed' : isPressedValue);
    const isFocused = isFocusedValue && (isLastInputKeyboard || isLastInputGamepad);
    const base = className == null || className === '' ? '' : ` ${className}`;
    const hovered = isHovered ? ` ${MODIFIER_CLASS_NAMES.hovered}${classNameHovered != null ? ` ${classNameHovered}` : ''}` : '';
    const pressed = isPressed ? ` ${MODIFIER_CLASS_NAMES.pressed}${classNamePressed != null ? ` ${classNamePressed}` : ''}` : '';
    const focused = (isFocused || stateOverride !== null && stateOverride !== void 0 && stateOverride.focused) && classNameFocused != null ? ` ${MODIFIER_CLASS_NAMES.focused}${classNameFocused != null ? ` ${classNameFocused}` : ''}` : '';
    const disabled = disabledValue === true ? ` ${InteractivePrimitive.disabled}${MODIFIER_CLASS_NAMES.disabled !== InteractivePrimitive.disabled ? ' ' + MODIFIER_CLASS_NAMES.disabled : ''}` : '';
    const disabledClass = disabledValue === true && classNameDisabled != null && classNameDisabled != InteractivePrimitive.disabled ? ` ${classNameDisabled}` : '';
    return `${InteractivePrimitive.interactivePrimitive}${base}${hovered}${pressed}${focused}${disabled}${disabledClass}`;
  }, [stateOverride, onClick], [classNameFacet, classNameHoveredFacet, classNamePressedFacet, classNameFocusedFacet, classNameDisabledFacet, disabledFacet, isHoveredFacet, isPressedFacet, isFocusedFacet, isLastInputKeyboard, isLastInputGamepad]);

  if (false) {}

  useMountNotification();

  if (props.tag === 'span') {
    return /*#__PURE__*/react.createElement("fast-span", {
      ref: ref,
      className: composedClassNameFacet,
      style: props.style,
      "data-testid": dataTestIdFacet,
      onClick: handleClick,
      onTouchStart: handleTouchStart,
      onTouchMove: handleTouchMove,
      onTouchEnd: handleTouchEnd,
      onMouseDown: handleMouseDown,
      onMouseUp: handleMouseUp,
      onMouseMove: handleMouseMove,
      onMouseLeave: handleMouseLeave,
      onKeyDown: onKeyDown
    }, props.children);
  }

  return /*#__PURE__*/react.createElement("fast-div", {
    ref: ref,
    className: composedClassNameFacet,
    style: props.style,
    "data-testid": dataTestIdFacet,
    onClick: handleClick,
    onTouchStart: handleTouchStart,
    onTouchMove: handleTouchMove,
    onTouchEnd: handleTouchEnd,
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    onMouseMove: handleMouseMove,
    onMouseLeave: handleMouseLeave,
    onKeyDown: onKeyDown
  }, props.children);
}
/**
 * InteractivePrimitive.Maybe can be used to conditionally wrap content
 * in an InteractivePrimitive. Commonly used for narration. The
 * InteractivePrimitive will only be enabled when narration is also enabled.
 */

const InteractivePrimitiveMaybe = (_ref) => {
  let {
    isInteractive,
    children,
    onClick,
    inputLegend,
    innerRef,
    className,
    classNameDisabled,
    disabled,
    style
  } = _ref,
      props = InteractivePrimitive_objectWithoutProperties(_ref, ["isInteractive", "children", "onClick", "inputLegend", "innerRef", "className", "classNameDisabled", "disabled", "style"]);

  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const classNameFacet = (0,react_facet_src.useFacetWrap)(className);
  const classNameDisabledFacet = (0,react_facet_src.useFacetWrap)(classNameDisabled);
  const childrenWrapped = (0,react_facet_src.isFacet)(children) ? /*#__PURE__*/react.createElement("fast-text", {
    text: children
  }) : /*#__PURE__*/react.createElement(react.Fragment, null, children);
  const notInteractiveClassName = (0,react_facet_src.useFacetMap)((className, disabled, classNameDisabled) => classnames_default()(className, disabled === true && MODIFIER_CLASS_NAMES.disabled !== InteractivePrimitive.disabled ? MODIFIER_CLASS_NAMES.disabled : null, disabled === true && classNameDisabled !== InteractivePrimitive.disabled ? classNameDisabled : null, disabled === true ? InteractivePrimitive.disabled : null), [], [classNameFacet, disabledFacet, classNameDisabledFacet]);
  return (0,react_facet_src.useFacetUnwrap)(isInteractive) === true ? /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, InteractivePrimitive_extends({
    onClick: onClick,
    inputLegend: inputLegend !== null && inputLegend !== void 0 ? inputLegend : false,
    innerRef: innerRef,
    className: classNameFacet,
    classNameDisabled: classNameDisabledFacet,
    disabled: disabledFacet
  }, props), childrenWrapped) : /*#__PURE__*/react.createElement("fast-div", {
    ref: innerRef,
    className: notInteractiveClassName,
    style: style
  }, childrenWrapped);
};
InteractivePrimitive_InteractivePrimitive.displayName = 'InteractivePrimitive';
InteractivePrimitive_InteractivePrimitive.Maybe = InteractivePrimitiveMaybe;

function InteractivePrimitive_noop() {}

function noopString() {
  return '';
}

const recordEntries = (record, callback) => {
  for (const key in record) {
    callback(key, record[key]);
  }
};
;// CONCATENATED MODULE: ./packages/ui-primitive/src/TransitionPrimitive/TransitionPrimitive.tsx


const UNMOUNTED = 'unmounted';
const EXITED = 'exited';
const ENTERING = 'entering';
const ENTERED = 'entered';
const EXITING = 'exiting';

/**
 * Some extra timing after a transition is completed to allow it some "breathing room" before we do any JavaScript operation
 * Without this extra time, we can see a small "hitch" at the end of a transition.
 */
const EXTRA_SMOOTHNESS_TIMEOUT = 100;

/**
 * Transition component based on react-transition-group, but with a much slimmer implementation
 * and without a dependency to react-dom.
 */
function TransitionPrimitive({
  visible,
  inverse = false,
  appear,
  unmountOnExit,
  timeout,
  children
}) {
  const timerIdRef = (0,react.useRef)(null); // Ref to keep track of what is the direction of a transition to be used on effects
  // See more information on its usage below

  const inverseRef = (0,react.useRef)(inverse);
  inverseRef.current = inverse; // Ref to update effects on the current value of unmountOnExit
  // without needing to re-creating them

  const unmountOnExitRef = (0,react.useRef)(unmountOnExit);
  unmountOnExitRef.current = unmountOnExit;
  const [status, setStatus] = (0,react.useState)(() => {
    if (visible && appear) return [EXITED, inverse];
    if (visible) return [ENTERED, inverse];
    return [UNMOUNTED, inverse];
  });
  const isEntering = status[0] === ENTERING;
  const isExiting = status[0] === EXITING;
  const isExited = status[0] === EXITED;
  (0,react.useEffect)(() => {
    if (isExited && unmountOnExit) {
      setStatus(status => [UNMOUNTED, status[1]]);
    }
  }, [isExited, unmountOnExit]);
  (0,react.useEffect)(() => {
    // Before we do any effect, we need to make sure to stop any scheduled state update.
    clearTimerId(timerIdRef); // Read the inverse configuration from a ref since we don't want to trigger an animation
    // just by changing its direction
    // More info: ADO 413018

    const inverse = inverseRef.current; // Only start any animation after the default press duration of a button.
    // This is to allow the user to see the press animation and to also allow React to perform any
    // rendering before we start the animation.

    const id = setTimeout(() => {
      setStatus(([currentStatus]) => {
        if (visible) {
          if (currentStatus === ENTERED) return [ENTERED, inverse];
          return [ENTERING, inverse];
        } else {
          if (currentStatus === EXITED) return [EXITED, inverse];
          if (currentStatus === UNMOUNTED) return [UNMOUNTED, inverse];
          return [EXITING, inverse];
        }
      });
    }, DEFAULT_PRESS_DURATION);
    return () => clearTimeout(id);
  }, [visible]);
  (0,react.useEffect)(() => {
    // Before we do any effect, we need to make sure to stop any scheduled state update.
    clearTimerId(timerIdRef);

    if (isEntering) {
      timerIdRef.current = setTimeout(() => setStatus(status => [ENTERED, status[1]]), timeout + EXTRA_SMOOTHNESS_TIMEOUT);
    }
  }, [isEntering, timeout]);
  (0,react.useEffect)(() => {
    // Before we do any effect, we need to make sure to stop any scheduled state update.
    clearTimerId(timerIdRef);

    if (isExiting) {
      timerIdRef.current = setTimeout(() => setStatus(status => [unmountOnExitRef.current ? UNMOUNTED : EXITED, status[1]]), timeout + EXTRA_SMOOTHNESS_TIMEOUT);
    }
  }, [isExiting, timeout]);
  (0,react.useEffect)(() => {
    // Make sure to clear any timer on unmounting this component.
    return () => clearTimerId(timerIdRef);
  }, []);
  return status[0] === UNMOUNTED ? null : children(status[0], status[1]);
}

const clearTimerId = ref => {
  if (ref.current) {
    clearTimeout(ref.current);
    ref.current = null;
  }
};
;// CONCATENATED MODULE: ./packages/react-gamepad/src/GamepadColumn.tsx
function GamepadColumn_extends() { GamepadColumn_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return GamepadColumn_extends.apply(this, arguments); }





function GamepadColumn_GamepadColumn(props) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return /*#__PURE__*/react.createElement(GamepadColumn, props);
  }

  if (props.shouldSkipLandmarkInVisual) {
    return /*#__PURE__*/react.createElement(DisabledArea, {
      disabled: props.disabled
    }, props.children);
  }

  if (props.scrollAxis != null) {
    // wery weird typescript problem
    return /*#__PURE__*/react.createElement(Landmark, GamepadColumn_extends({}, props, {
      scrollAxis: props.scrollAxis,
      shouldBindFocus: props.bounded,
      containerRef: props.scrollRef,
      delegateFocusFirstFound: props.defaultFocusedChildBehavior === 'first' || props.defaultFocusedChildBehavior === 'remember' || props.bounded,
      delegateFocusFromMemory: props.defaultFocusedChildBehavior === 'remember',
      delegateFocusByAlias: props.defaultFocusedChildAlias
    }));
  }

  return /*#__PURE__*/react.createElement(Landmark, GamepadColumn_extends({}, props, {
    scrollAxis: props.scrollAxis,
    shouldBindFocus: props.bounded,
    containerRef: props.scrollRef,
    delegateFocusFirstFound: props.defaultFocusedChildBehavior === 'first' || props.defaultFocusedChildBehavior === 'remember' || props.bounded,
    delegateFocusFromMemory: props.defaultFocusedChildBehavior === 'remember',
    delegateFocusByAlias: props.defaultFocusedChildAlias
  }));
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/MouseScrollbar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MouseScrollbar = ({"vertical":"X5AON","disabled":"HTEVa","mouseScrollbarBackground":"I0uqP","minimal":"WfHBb","mouseScrollbarRail":"p04xH","mouseScrollbarHandler":"VOQuh","reflectionContainer":"dDEKV","mouseScrollbarHandlerBottomBevel":"ZT0PP","horizontal":"IXDlR","floating":"jHZDI","mouseScrollbarTopDetail":"FqQCr","dark":"KRqUY","horizontalIcon":"UmdPV","mouseScrollbarBottomDetail":"aEsRX"});
// EXTERNAL MODULE: ./node_modules/lodash.debounce/index.js
var lodash_debounce = __webpack_require__(91296);
var lodash_debounce_default = /*#__PURE__*/__webpack_require__.n(lodash_debounce);
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/useUpdateScrollbar.ts




 // How long to wait before notifying any listeners that scrolling has stopped

const SCROLL_STATE_CHANGE_TIMEOUT = 500;
const INPUT_LEGEND_BASE_HEIGHT = 4;
const MAX_HORIZONTAL_HANDLER_WIDTH_PERCENTAGE = 0.4;
/**
 * Hook that reads the scroll value of the container and updates the handler position
 * It does so by directly mutating the DOM element (for performance reasons)
 */

function useUpdateScrollbar(scrollingContainerRef, handlerRef, railRef, shouldListenForScrolls, scrollWrapperElement, horizontalScrolling = false, safeZonePadding = 0) {
  const [isScrolling, setIsScrolling] = (0,react_facet_src.useFacetState)(false);
  const [isBehindInputLegendFacet, setIsBehindInputLegend] = (0,react_facet_src.useFacetState)(false);
  const listenForScrolls = (0,react_facet_src.useFacetWrap)(shouldListenForScrolls !== null && shouldListenForScrolls !== void 0 ? shouldListenForScrolls : true);
  const isInitialRenderRef = (0,react.useRef)(true);
  const isFocusInputGamepad = useIsFocusInputGamepad(); // Convert rem units to pixels

  const inputLegendHeight = useSizeInPixels(INPUT_LEGEND_BASE_HEIGHT) + safeZonePadding;
  const handlerPadding = useSizeInPixels(8);
  const onScrollStart = (0,react.useMemo)(() => lodash_debounce_default()(() => setIsScrolling(true), SCROLL_STATE_CHANGE_TIMEOUT, {
    leading: true,
    trailing: false
  }), [setIsScrolling]);
  const onScrollStop = (0,react.useMemo)(() => lodash_debounce_default()(() => setIsScrolling(false), SCROLL_STATE_CHANGE_TIMEOUT, {
    leading: false,
    trailing: true
  }), [setIsScrolling]);
  /**
   * Effect that fixes the position of the scrollbar handle so that it doesn't become hidden or partially hidden behind the input legend.
   *
   * It needs to run its logic after a setTimeout to compensate for a quirk in Gameface on how getBoundingClientRect works.
   *
   * In Gameface, getBoundingClientRect should return the information from the previous frame, but unfortunately for this particular code we actually
   * need to wait a little longer before we can safely read its bounding rect.
   */

  (0,react.useEffect)(() => {
    let timeoutId = null;
    timeoutId = setTimeout(() => {
      if (!scrollWrapperElement || !scrollWrapperElement.current || horizontalScrolling) {
        return;
      }

      if (isFocusInputGamepad.get() !== true) {
        return setIsBehindInputLegend(false);
      }

      const isBehindInputLegendCurrent = window.innerHeight - scrollWrapperElement.current.getBoundingClientRect().bottom - handlerPadding < inputLegendHeight;
      setIsBehindInputLegend(isBehindInputLegendCurrent);
    }, 250);
    return () => {
      timeoutId && window.clearTimeout(timeoutId);
    };
  }, [setIsBehindInputLegend, handlerPadding, inputLegendHeight, isFocusInputGamepad, scrollWrapperElement, scrollingContainerRef, horizontalScrolling]);
  const animationFrameRef = (0,react.useRef)(null);
  const checkScroll = (0,react.useMemo)(() => {
    let previousBehindInputLegend = null;
    let previousWindowSize = null;
    let previousScroll = null;
    let shouldRerender = true;
    return () => {
      var _window$requestAnimat, _window;

      const isBehindInputLegend = isBehindInputLegendFacet.get() === true;
      const scrollingContainer = scrollingContainerRef.current;
      const handlerElement = handlerRef.current;
      const railElement = railRef.current;

      if (!scrollingContainer || !handlerElement || !railElement) {
        return;
      }

      const currentScroll = horizontalScrolling ? scrollingContainer.scrollLeft : scrollingContainer.scrollTop;
      const currentWindowSize = horizontalScrolling ? window.innerWidth : window.innerHeight; // If we detected that the scroll has changed on a previous check
      // we can update the position of affected DOM elements

      if (shouldRerender) {
        const scrollingElementRect = scrollingContainer.getBoundingClientRect(); // If we are mounting and still don't have a size for the element, we wait until the next frame

        if (!(scrollingElementRect.width === 0 || scrollingElementRect.height === 0)) {
          const inputLegendOffset = isBehindInputLegend ? inputLegendHeight : 0;
          const scrollableAreaSize = (horizontalScrolling ? scrollingElementRect.width : scrollingElementRect.height) - inputLegendOffset;
          const scrollingElementSize = horizontalScrolling ? scrollingContainer.scrollWidth : scrollingContainer.scrollHeight;
          const maxScroll = scrollingElementSize - (horizontalScrolling ? scrollingElementRect.width : scrollingElementRect.height);
          const newValue = currentScroll / maxScroll;
          const scrollViewPaddingOffset = horizontalScrolling ? scrollingContainer.getBoundingClientRect().left - scrollingElementRect.left : railElement.getBoundingClientRect().top - scrollingElementRect.top;
          const handlerFluidSize = scrollableAreaSize / scrollingElementSize * scrollableAreaSize - scrollViewPaddingOffset * 2;
          const handlerSize = Math.max(40, horizontalScrolling ? Math.min(MAX_HORIZONTAL_HANDLER_WIDTH_PERCENTAGE * scrollableAreaSize - scrollViewPaddingOffset * 2, handlerFluidSize) : handlerFluidSize);

          if (horizontalScrolling) {
            handlerElement.style.left = `${newValue * 100}%`;
            handlerElement.style.widthPX = handlerSize;
            handlerElement.style.marginLeft = `${-handlerSize / 2}px`;
            railElement.style.leftPX = handlerSize / 2;
            railElement.style.rightPX = handlerSize / 2;
          } else {
            const handlerStartPosition = newValue * (scrollableAreaSize - handlerSize - scrollViewPaddingOffset * 2);
            handlerElement.style.topPX = handlerStartPosition;
            handlerElement.style.heightPX = handlerSize;
            railElement.style.bottomPX = inputLegendOffset;
          }

          shouldRerender = false;
        }
      }

      if (isBehindInputLegend !== previousBehindInputLegend) {
        previousBehindInputLegend = isBehindInputLegend;
        shouldRerender = true;
      }

      if (currentScroll !== previousScroll) {
        if (isInitialRenderRef.current) {
          isInitialRenderRef.current = false;
        } else {
          onScrollStart();
          onScrollStop();
        }

        previousScroll = currentScroll;
        shouldRerender = true;
      }

      if (currentWindowSize !== previousWindowSize) {
        previousWindowSize = currentWindowSize;
        shouldRerender = true;
      } // Needed to be able to run visual regression testing


      animationFrameRef.current = (_window$requestAnimat = (_window = window).requestAnimationFrame) === null || _window$requestAnimat === void 0 ? void 0 : _window$requestAnimat.call(_window, checkScroll);
    };
  }, [onScrollStart, onScrollStop, horizontalScrolling, inputLegendHeight, isBehindInputLegendFacet, scrollingContainerRef, handlerRef, railRef]); // We give the user of this hook the option of providing us with a Facet<boolean>. We can use
  // that facet to determine if we should enqueue scroll checks on subsequent animation frames. If
  // the scroll view isn't visible, or we don't have a scrollbar, there is no point in putting
  // functions on every animation frame. It also scales very poorly. Unfortunately, we have to do
  // it this way because Gameface dosen't provide us with any scroll listeners - but we can at least
  // try to keep it to a minimum.

  (0,react_facet_src.useFacetEffect)(shouldListenForScrolls => {
    if (shouldListenForScrolls) {
      checkScroll();
    }

    return () => {
      var _window$cancelAnimati, _window2;

      animationFrameRef.current != null && ((_window$cancelAnimati = (_window2 = window).cancelAnimationFrame) === null || _window$cancelAnimati === void 0 ? void 0 : _window$cancelAnimati.call(_window2, animationFrameRef.current));
      onScrollStop.cancel();
      onScrollStart.cancel();
    };
  }, [checkScroll, onScrollStop, onScrollStart], [listenForScrolls]);
  return isScrolling;
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/useHasScrollbar.ts


/**
 * Hook that checks if there is enough content vertically to render the scrollbar
 */

function useHasScrollbar(scrollingContainerRef, horizontal = false, floating) {
  const [hasScrollbar, setHasScrollbar] = (0,react_facet_src.useFacetState)(false);
  const previousDimension = (0,react.useRef)(0);
  (0,react.useEffect)(() => {
    const check = () => {
      const scrollingElement = scrollingContainerRef.current;
      if (!scrollingElement) return;
      const {
        scrollHeight,
        scrollWidth
      } = scrollingElement; // If the container has no height then it means it is hidden
      // No need to update any state

      if (scrollHeight === 0) return;
      const {
        width,
        top,
        left,
        height
      } = scrollingElement.getBoundingClientRect();

      if (floating) {
        if (horizontal) {
          return setHasScrollbar(scrollWidth > Math.ceil(width));
        } else {
          return setHasScrollbar(scrollHeight > Math.ceil(height));
        }
      }
      /*
      If a non-floating scrollbar is used, we need to need to keep track of the dimensions of the ScrollView in order
      to not end up in a state where the scrollbar appears and re-appears.
      See https://dev.azure.com/dev-mc/Minecraft/_workitems/edit/961077 for more information.
      */


      setHasScrollbar(hasScrollbarCurrently => {
        if (hasScrollbarCurrently === true && previousDimension.current > 0) {
          if (horizontal) {
            const delta = previousDimension.current - scrollWidth;
            const position = window.innerWidth - (left + scrollWidth);

            if (position <= delta) {
              return scrollWidth > Math.ceil(width - delta);
            }
          } else {
            const delta = previousDimension.current - scrollHeight;
            const position = window.innerHeight - (top + scrollHeight);

            if (position > 0 && position <= delta) {
              return scrollHeight > Math.ceil(height - delta);
            }
          }
        }

        if (horizontal) {
          previousDimension.current = scrollWidth;
          return scrollWidth > Math.ceil(width);
        } else {
          previousDimension.current = scrollHeight;
          return scrollHeight > Math.ceil(height);
        }
      });
    };

    check();
    const intervalId = setInterval(check, 1000);
    return () => clearInterval(intervalId);
  }, [floating, horizontal, scrollingContainerRef, setHasScrollbar]);
  return hasScrollbar;
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/MouseScrollbar.tsx







function MouseScrollbar_MouseScrollbar({
  scrollingContainerRef,
  horizontal,
  stopCheckingForScroll,
  floating,
  darkTheme,
  minimalTheme,
  safeZonePadding
}) {
  const {
    handlerRef,
    railRef
  } = useHandlerDrag(scrollingContainerRef, horizontal);
  const handleClick = useClickToScroll(scrollingContainerRef, railRef, horizontal);
  const hasScrollbarFacet = useHasScrollbar(scrollingContainerRef, horizontal, floating);
  const stopChecking = (0,react_facet_src.useFacetWrap)(stopCheckingForScroll !== null && stopCheckingForScroll !== void 0 ? stopCheckingForScroll : false);
  const shouldListenForScrolls = (0,react_facet_src.useFacetMap)((hasScrollbar, stopChecking) => hasScrollbar && !stopChecking, [], [hasScrollbarFacet, stopChecking]);
  useUpdateScrollbar(scrollingContainerRef, handlerRef, railRef, shouldListenForScrolls, undefined, horizontal, safeZonePadding);
  const rootClassName = (0,react_facet_src.useFacetMap)(hasScrollbar => classnames_default()({
    [MouseScrollbar.vertical]: !horizontal,
    [MouseScrollbar.horizontal]: horizontal,
    [MouseScrollbar.disabled]: !hasScrollbar,
    [MouseScrollbar.floating]: floating
  }), [horizontal, floating], [hasScrollbarFacet]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: rootClassName,
    onClick: handleClick
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(MouseScrollbar.mouseScrollbarTopDetail, {
      [MouseScrollbar.horizontalIcon]: horizontal,
      [MouseScrollbar.minimal]: minimalTheme,
      [MouseScrollbar.dark]: darkTheme
    })
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(MouseScrollbar.mouseScrollbarBackground, {
      [MouseScrollbar.minimal]: minimalTheme
    })
  }), /*#__PURE__*/react.createElement("div", {
    className: MouseScrollbar.mouseScrollbarRail,
    ref: railRef
  }, /*#__PURE__*/react.createElement("div", {
    className: MouseScrollbar.mouseScrollbarHandler,
    ref: handlerRef
  }, /*#__PURE__*/react.createElement("div", {
    className: MouseScrollbar.reflectionContainer
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    role: "secondary"
  })), /*#__PURE__*/react.createElement("div", {
    className: MouseScrollbar.mouseScrollbarHandlerBottomBevel
  }))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(MouseScrollbar.mouseScrollbarBottomDetail, {
      [MouseScrollbar.horizontalIcon]: horizontal,
      [MouseScrollbar.minimal]: minimalTheme,
      [MouseScrollbar.dark]: darkTheme
    })
  }));
}
/**
 * Hook that allows clicking anywhere in the Scrollbar to update the scroll position of the container
 */

const useClickToScroll = (scrollingContainerRef, railRef, horizontalScrollBar) => {
  return (0,react.useCallback)(event => {
    const scrollingElement = scrollingContainerRef.current;
    const railElement = railRef.current;
    if (!scrollingElement || !railElement) return;
    const railRect = railElement.getBoundingClientRect();
    const scrollingElementRect = scrollingElement.getBoundingClientRect();
    /* If it's a horizontal scrollbar the width, x and left properties of the elements should be considered, instead of height, y and top */

    if (horizontalScrollBar) {
      const scrollPercentage = (event.clientX - railRect.left) / railRect.width;
      scrollingElement.scrollLeft = scrollPercentage * (scrollingElement.scrollWidth - scrollingElementRect.width);
    } else {
      const scrollPercentage = (event.clientY - railRect.top) / railRect.height;
      scrollingElement.scrollTop = scrollPercentage * (scrollingElement.scrollHeight - scrollingElementRect.height);
    }
  }, [scrollingContainerRef, railRef, horizontalScrollBar]);
};
/**
 * Hook that allows dragging the handler to update the scroll position of the container vertically and horizontally
 * The flag horizontalScrolling is used to determine the direction of the scroll
 */


const useHandlerDrag = (scrollingContainerRef, horizontalScrolling = false) => {
  const handlerRef = (0,react.useRef)(null);
  const railRef = (0,react.useRef)(null);
  (0,react.useEffect)(() => {
    const handlerElement = handlerRef.current;
    const scrollingContainerElement = scrollingContainerRef.current;
    const railElement = railRef.current;
    if (!handlerElement || !scrollingContainerElement || !railElement) return;
    let isDragging = false;
    let delta = 0;

    const handleMouseDown = event => {
      isDragging = true;
      const rect = handlerElement.getBoundingClientRect();
      delta = horizontalScrolling ? event.clientX - rect.left : event.clientY - rect.top;
    };

    const handleMouseUp = () => {
      isDragging = false;
      delta = 0;
    };

    const handleMouseMove = event => {
      if (!isDragging) return;
      const railElementRect = railElement.getBoundingClientRect();
      const handlerElementRect = handlerElement.getBoundingClientRect();
      const scrollingContainerElementRect = scrollingContainerElement.getBoundingClientRect();
      /* If it's a horizontally scrolling scrollbar, use width, if vertical use height */

      const scrollPercentage = horizontalScrolling ? (event.clientX - delta - railElementRect.left) / (railElementRect.width - handlerElementRect.width) : (event.clientY - delta - railElementRect.top) / (railElementRect.height - handlerElementRect.height);
      /* If it's a horizontally scrolling scrollbar, use width, if vertical use height */

      if (horizontalScrolling) {
        scrollingContainerElement.scrollLeft = scrollPercentage * (scrollingContainerElement.scrollWidth - scrollingContainerElementRect.width);
      } else {
        scrollingContainerElement.scrollTop = scrollPercentage * (scrollingContainerElement.scrollHeight - scrollingContainerElementRect.height);
      }
    };

    const handleClick = event => {
      event.preventDefault();
      event.stopPropagation();
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    handlerElement.addEventListener('mousedown', handleMouseDown);
    handlerElement.addEventListener('click', handleClick);
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      handlerElement.removeEventListener('mousedown', handleMouseDown);
      handlerElement.removeEventListener('click', handleClick);
    };
  }, [handlerRef, scrollingContainerRef, railRef, horizontalScrolling]);
  return {
    handlerRef,
    railRef
  };
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/AutoHidingScrollbar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AutoHidingScrollbar = ({"vertical":"pKafk","scrollbarNonInteractiveRail":"hhUBB","scrollbarHandlerNonInteractive":"VLAZG","horizontal":"qBOw1","scrollbarHandlerNonInteractiveActive":"VEGv3","scrollbarHandlerNonInteractiveIdle":"eC0Tu"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/AutoHidingScrollbar.tsx






function AutoHidingScrollbar_AutoHidingScrollbar({
  scrollingContainerRef,
  horizontal,
  stopCheckingForScroll,
  alwaysVisible,
  safeZonePadding
}) {
  const handlerRef = (0,react.useRef)(null);
  const railRef = (0,react.useRef)(null);
  const scrollWrapperRef = (0,react.useRef)(null);
  const isTouchingFacet = useTouchCheck(scrollingContainerRef);
  const stopChecking = (0,react_facet_src.useFacetWrap)(stopCheckingForScroll !== null && stopCheckingForScroll !== void 0 ? stopCheckingForScroll : false);
  const hasScrollbarFacet = useHasScrollbar(scrollingContainerRef, horizontal);
  const shouldListenForScrolls = (0,react_facet_src.useFacetMap)((hasScrollbar, stopChecking) => hasScrollbar && !stopChecking, [], [hasScrollbarFacet, stopChecking]);
  const isScrollingFacet = useUpdateScrollbar(scrollingContainerRef, handlerRef, railRef, shouldListenForScrolls, scrollWrapperRef, horizontal, safeZonePadding);
  const rootClassName = classnames_default()({
    [AutoHidingScrollbar.vertical]: !horizontal,
    [AutoHidingScrollbar.horizontal]: horizontal
  });
  const handlerClassName = (0,react_facet_src.useFacetMap)((isTouching, isScrolling, hasScrollbar) => {
    const isIdle = !isScrolling && !isTouching && !alwaysVisible;
    return `${AutoHidingScrollbar.scrollbarHandlerNonInteractive} ${hasScrollbar && !isIdle ? AutoHidingScrollbar.scrollbarHandlerNonInteractiveActive : AutoHidingScrollbar.scrollbarHandlerNonInteractiveIdle}`;
  }, [alwaysVisible], [isTouchingFacet, isScrollingFacet, hasScrollbarFacet]);
  return /*#__PURE__*/react.createElement("div", {
    className: rootClassName,
    ref: scrollWrapperRef
  }, /*#__PURE__*/react.createElement("div", {
    className: AutoHidingScrollbar.scrollbarNonInteractiveRail,
    ref: railRef
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: handlerClassName,
    ref: handlerRef
  })));
}
const useTouchCheck = ref => {
  const [isTouching, setIsTouching] = (0,react_facet_src.useFacetState)(false);
  (0,react.useEffect)(() => {
    var _ref$current;

    const handleStart = () => setIsTouching(true);

    const handleEnd = () => setIsTouching(false);

    const element = (_ref$current = ref === null || ref === void 0 ? void 0 : ref.current) !== null && _ref$current !== void 0 ? _ref$current : window;
    element.addEventListener('touchstart', handleStart);
    element.addEventListener('touchend', handleEnd);
    return () => {
      element.removeEventListener('touchstart', handleStart);
      element.removeEventListener('touchend', handleEnd);
    };
  }, [ref, setIsTouching]);
  return isTouching;
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/Scrollbar.tsx






/**
 * Scrollbar component, should be used via a layout components like the FlatList
 */
function Scrollbar({
  scrollingContainerRef,
  stopCheckingForScroll,
  alwaysVisible,
  horizontal = false,
  floating,
  darkTheme,
  minimalTheme
}) {
  const isPointerMouse = useIsPointerInputMouse();
  const isPointerNotMouse = (0,react_facet_src.useFacetMap)(isMouse => !isMouse, [], [isPointerMouse]);
  const safeZone = useSafeZone();
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isPointerMouse
  }, /*#__PURE__*/react.createElement(MouseScrollbar_MouseScrollbar, {
    horizontal: horizontal,
    scrollingContainerRef: scrollingContainerRef,
    stopCheckingForScroll: stopCheckingForScroll,
    safeZonePadding: safeZone.bottom,
    floating: floating,
    darkTheme: darkTheme,
    minimalTheme: minimalTheme
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isPointerNotMouse
  }, /*#__PURE__*/react.createElement(AutoHidingScrollbar_AutoHidingScrollbar, {
    horizontal: horizontal,
    scrollingContainerRef: scrollingContainerRef,
    stopCheckingForScroll: stopCheckingForScroll,
    safeZonePadding: safeZone.bottom,
    alwaysVisible: alwaysVisible
  })));
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/ScrollView.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ScrollView = ({"wrapper":"UedOa","ScrollView":"bXCZP","focusBorder":"cQvwc","emptyFocusable":"YEgzg","ScrollViewHorizontal":"NsGay","safetyPaddings":"ekhCp","safetyPaddingsHorizontal":"n60Ng","content":"OnsGF","scrollBlocker":"WFE9a","contentPaddings":"SIgu2","horizontalContent":"ze6YH","spinnerPlaceholder":"Cp7QN","animateOpacity":"Il2HF","borderedSpinner":"rxEL1","paddedSpinner":"s31Ag","hidden":"t0Ytw","hiddenContent":"AV6LH"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Spinner/Spinner.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Spinner = ({"spinner":"Dpj6m"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Spinner/Spinner.tsx



/**
 * For screenshot tests animations need to be disabled. We also want to make sure that the fixture image
 * not imported into production builds.
 */

const animation =  false ? 0 : __webpack_require__(84984);
function Spinner_Spinner() {
  return /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: animation,
    className: Spinner.spinner,
    imageRendering: "pixelated"
  });
}
;// CONCATENATED MODULE: ./packages/react-narrator/src/hooks/useNarrateText.ts



// `useNarrateText` is a way of reading to the user events that are global
// and happen just once. The goal of `useNarrateText` is to be able to
// narrate something imperatively outside of the current narration node
// context. It could evolve in the future into a system for handling notifications.
// An example is dragging an item from the inventory to a crafting section, or switching a
// switch on and off.
const useNarrateText = ({
  interruptible = true,
  playInBackground = false,
  profanityFilterContext = {
    outOfGame: true,
    inGame: true
  },
  required = false
} = {}) => {
  const narrateTimeoutRef = (0,react.useRef)();
  const {
    readText
  } = (0,react.useContext)(narrationDriverContext);
  const narrateText = (0,react.useCallback)(narration => {
    narrateTimeoutRef.current = setTimeout(() => {
      readText(narration, profanityFilterContext, interruptible, required, playInBackground);
    }, NARRATION_DEBOUNCE_DELAY);
  }, [readText, profanityFilterContext, interruptible, required, playInBackground]);
  const preventNarrateText = (0,react.useCallback)(() => {
    if (narrateTimeoutRef.current) {
      clearTimeout(narrateTimeoutRef.current);
    }
  }, []);
  return {
    narrateText,
    preventNarrateText
  };
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/ScrollView.tsx

















const Wrapper = ({
  children,
  loading,
  scrollingContainerRef,
  stopCheckingForScroll,
  renderTracker,
  alwaysVisible,
  horizontal = false,
  floating,
  darkTheme,
  minimalTheme,
  padSpinnerVertically,
  spinnerBackgroundColor,
  autofocus,
  gamepadIndex,
  showSpinnerBorder,
  showFocusOutline,
  spinnerIdRef
}) => {
  const focusContainerClassNames = (0,react_facet_src.useFacetMap)(isLastInputFocus => classnames_default()({
    [ScrollView.focusBorder]: isLastInputFocus && showFocusOutline,
    [focusClass]: isLastInputFocus && showFocusOutline
  }), [showFocusOutline], [useIsLastInputFocus()]);
  return /*#__PURE__*/react.createElement("div", {
    className: ScrollView.wrapper
  }, /*#__PURE__*/react.createElement(SpinnerPlaceholder, {
    gamepadIndex: gamepadIndex,
    autofocus: autofocus,
    hidden: (0,react_facet_src.useFacetMap)(loading => loading == null ? true : !loading, [], [loading]),
    renderTracker: renderTracker,
    padSpinnerVertically: padSpinnerVertically,
    spinnerBackgroundColor: spinnerBackgroundColor,
    showBorder: showSpinnerBorder,
    nodeIdRef: spinnerIdRef
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)((loading, animationEnabled) => classnames_default()(horizontal ? ScrollView.ScrollViewHorizontal : ScrollView.ScrollView, horizontal ? ScrollView.safetyPaddingsHorizontal : ScrollView.safetyPaddings, {
      [ScrollView.hiddenContent]: loading,
      [ScrollView.animateOpacity]: animationEnabled
    }), [horizontal], [loading, useScreenAnimationEnabled()])
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: focusContainerClassNames
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    inset: true
  })), children, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(loading => loading == null ? true : !loading, [], [loading])
  }, /*#__PURE__*/react.createElement(Scrollbar, {
    floating: floating,
    horizontal: horizontal,
    scrollingContainerRef: scrollingContainerRef,
    stopCheckingForScroll: stopCheckingForScroll,
    alwaysVisible: alwaysVisible,
    darkTheme: darkTheme,
    minimalTheme: minimalTheme
  }))));
};

const fallbackGamepadAPI = {
  navigate: () => {},
  focusedId: (0,react_facet_src.createFacet)({
    initialValue: ''
  })
};

function useFocusFirstFocusableAfterLoading(loadingFacet, // Reference to a wrapping container for the child content
nodeIdRef, spinnerIdRef, autofocus) {
  const isNarrationEnabled = useNarrationEnabled(); // This context is only available with the legacy gamepad navigation.

  const maybeGamepadAPI = useGamepadAPI();
  const gamepadAPI = maybeGamepadAPI !== null && maybeGamepadAPI !== void 0 ? maybeGamepadAPI : fallbackGamepadAPI;
  const listenForLoadingFinished = (0,react.useRef)(true);
  (0,react_facet_src.useFacetEffect)((loading, currentFocusId) => {
    // If we are not yet listening for loading changes and loading is true
    // we set the listenForLoadingChanges ref to true to indicate that we
    // want to know when loading becomes false.
    if (listenForLoadingFinished.current == false && loading) {
      listenForLoadingFinished.current = true;
    } // We just want to run this  block the first time loading goes from true to false.


    if (!loading && listenForLoadingFinished.current) {
      listenForLoadingFinished.current = false;

      if ( // If the user wasn't focusing anything at all and this should be autofocused
      currentFocusId == null && nodeIdRef.current != null && autofocus || // Or if user was focused on the spinner for this ScrollView
      currentFocusId != null && currentFocusId === spinnerIdRef.current && nodeIdRef.current != null) {
        return gamepadAPI.navigate(nodeIdRef.current);
      }
    }
  }, [isNarrationEnabled, gamepadAPI, spinnerIdRef, nodeIdRef, autofocus], [loadingFacet, gamepadAPI.focusedId]);
}

const ScrollView_ScrollView = ({
  children,
  loading,
  renderTracker,
  gamepadIndex,
  scrollIntoViewAlign = 'center',
  scrollIntoView = true,
  scrollIntoViewSpeedFactor,
  defaultFocusedChildBehavior,
  autofocusFocusable,
  horizontal = false,
  innerRef,
  floating,
  darkTheme,
  minimalTheme,
  padSpinnerVertically,
  spinnerBackgroundColor,
  disableScrolling,
  showSpinnerBorder,
  stopCheckingForScroll,
  emptyFocusableGamepadAlias,
  emptyFocusableNarrationText,
  nodeIdRef,
  autofocus = false
}) => {
  const localRef = (0,react.useRef)(null);
  const ref = innerRef || localRef;
  const [alwaysVisibleAutoHidingScrollbar, setAlwaysVisibleAutoHidingScrollbar] = (0,react.useState)(false);
  const loadingFacet = (0,react_facet_src.useFacetWrap)(loading);
  const scrollable = useHasScrollbar(ref, horizontal, floating);
  const isNarrationEnabled = useNarrationEnabled();
  const GamepadContainer = horizontal ? GamepadRow_GamepadRow : GamepadColumn_GamepadColumn; // Used to focus the first thing within the GamePadContainer after the loading is completed

  const localIdRef = (0,react.useRef)();
  const idRef = nodeIdRef !== null && nodeIdRef !== void 0 ? nodeIdRef : localIdRef;
  const spinnerIdRef = (0,react.useRef)();
  useFocusFirstFocusableAfterLoading(loadingFacet, idRef, spinnerIdRef, autofocus);
  const isScrollingDisabledFacet = (0,react_facet_src.useFacetWrap)(disableScrolling !== null && disableScrolling !== void 0 ? disableScrolling : false);
  const contentClassNames = (0,react_facet_src.useFacetMap)(isScrollingDisabled => classnames_default()(horizontal ? ScrollView.horizontalContent : ScrollView.content, isScrollingDisabled ? ScrollView.scrollBlocker : null, ScrollView.contentPaddings, horizontal ? ScrollView.safetyPaddingsHorizontal : ScrollView.safetyPaddings), [horizontal], [isScrollingDisabledFacet]);
  const [hasChildFocusable, setHasChildFocusable] = (0,react_facet_src.useFacetState)(false);
  const mountEmptyFocusable = (0,react_facet_src.useFacetMap)((hasChildFocusable, scrollable) => isNarrationEnabled && !hasChildFocusable || !hasChildFocusable && scrollable, [isNarrationEnabled], [hasChildFocusable, scrollable]);
  return (
    /*#__PURE__*/
    // Set a flag if we contain any focusable children
    react.createElement(InteractivePrimitiveMountCallback.Provider, {
      value: (0,react.useCallback)(() => setHasChildFocusable(true), [setHasChildFocusable])
    }, /*#__PURE__*/react.createElement(InteractiveSiblingState.Provider, {
      value: hasChildFocusable
    }, /*#__PURE__*/react.createElement(Wrapper, {
      floating: floating,
      horizontal: horizontal,
      scrollingContainerRef: ref,
      stopCheckingForScroll: stopCheckingForScroll,
      loading: loadingFacet,
      renderTracker: renderTracker,
      alwaysVisible: alwaysVisibleAutoHidingScrollbar,
      darkTheme: darkTheme,
      minimalTheme: minimalTheme,
      padSpinnerVertically: padSpinnerVertically,
      spinnerBackgroundColor: spinnerBackgroundColor,
      showSpinnerBorder: showSpinnerBorder,
      showFocusOutline: alwaysVisibleAutoHidingScrollbar && floating === true,
      autofocus: autofocus,
      gamepadIndex: gamepadIndex,
      spinnerIdRef: spinnerIdRef
    }, /*#__PURE__*/react.createElement("fast-div", {
      className: contentClassNames,
      ref: ref,
      "data-testid": "scroll-view"
    }, /*#__PURE__*/react.createElement(GamepadContainer, {
      disabled: (0,react_facet_src.useFacetUnwrap)(loading) === true,
      scrollIntoView: scrollIntoView,
      scrollIntoViewAlign: scrollIntoViewAlign,
      scrollWithAnalog: true,
      scrollIntoViewSpeedFactor: scrollIntoViewSpeedFactor,
      gamepadIndex: gamepadIndex,
      defaultFocusedChildBehavior: defaultFocusedChildBehavior,
      scrollRef: ref,
      scrollAxis: horizontal ? ScrollAxis.HORIZONTAL : ScrollAxis.VERTICAL,
      nodeIdRef: idRef
    }, children, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
      when: mountEmptyFocusable
    }, /*#__PURE__*/react.createElement(EmptyFocusable, {
      autofocus: !!autofocusFocusable,
      onFocusChanged: setAlwaysVisibleAutoHidingScrollbar,
      gamepadAlias: emptyFocusableGamepadAlias,
      narrationText: emptyFocusableNarrationText
    })))))))
  );
};
const DEFAULT_SPINNER_BG_COLOR = 'rgba(0, 0, 0, 0.4)';

function SpinnerPlaceholder({
  gamepadIndex,
  autofocus,
  hidden,
  renderTracker,
  spinnerBackgroundColor,
  padSpinnerVertically,
  showBorder = true,
  nodeIdRef
}) {
  const {
    t
  } = useLocalization('ScrollView');
  const {
    narrateText
  } = useNarrateText();
  const [hasFocus, setHasFocus] = (0,react_facet_src.useFacetState)(false);
  const hiddenValue = (0,react_facet_src.useFacetUnwrap)(hidden);
  const animationEnabled = (0,react_facet_src.useFacetUnwrap)(useScreenAnimationEnabled());
  const visible = hiddenValue === react_facet_src.NO_VALUE ? true : !hiddenValue; // We need to know if the spinner has focus so we can narrate 'Loading' again after X seconds.

  const repeatLoadingAfterMs = 10000;
  (0,react_facet_src.useFacetEffect)((isHidden, hasFocus) => {
    let intervalId;

    if (!isHidden && hasFocus) {
      intervalId = setInterval(narrateText.bind(null, t('.loadingState')), repeatLoadingAfterMs);
    } else if (intervalId != null) {
      clearInterval(intervalId);
    }

    return () => intervalId != null && clearInterval(intervalId);
  }, [narrateText, t, repeatLoadingAfterMs], [hidden, hasFocus]);
  return /*#__PURE__*/react.createElement(TransitionPrimitive, {
    visible: visible,
    timeout: 500
  }, status => /*#__PURE__*/react.createElement(react.Fragment, null, status !== 'exited' && /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    autofocus: autofocus,
    gamepadIndex: gamepadIndex,
    narrationText: [t('.narrationScrollViewComponentType'), t('.loadingState')].join(' . '),
    className: classnames_default()(ScrollView.spinnerPlaceholder, {
      [ScrollView.paddedSpinner]: padSpinnerVertically,
      [ScrollView.hidden]: status === 'exiting',
      [ScrollView.borderedSpinner]: showBorder,
      [ScrollView.animateOpacity]: animationEnabled === true
    }),
    classNameFocused: focusClass,
    onFocusChanged: setHasFocus,
    onHoverChanged: setHasFocus,
    style: {
      backgroundColor: spinnerBackgroundColor !== null && spinnerBackgroundColor !== void 0 ? spinnerBackgroundColor : DEFAULT_SPINNER_BG_COLOR
    },
    inputLegend: false,
    onClick: () => {},
    nodeIdRef: nodeIdRef
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    inset: true
  }), /*#__PURE__*/react.createElement(Spinner_Spinner, null)), renderTracker && renderTracker(status === 'exited')));
}

const ScrollView_noop = () => {};

const EmptyFocusable = ({
  autofocus,
  onFocusChanged,
  gamepadAlias,
  narrationText = false
}) => {
  return (
    /*#__PURE__*/

    /**
     * We wrap this empty focusable in a InteractivePrimitiveMountCallback to catch the
     * callback. The ScrollView wraps itself in a InteractivePrimitiveMountCallback so it
     * can detect if any children are focusable and adjust the narration/focusability
     * accordingly. We do not want this focusable to have any affect on that behavior.
     */
    react.createElement(InteractivePrimitiveMountCallback.Provider, {
      value: ScrollView_noop
    }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
      className: ScrollView.emptyFocusable,
      gamepadIndex: 0,
      onClick: ScrollView_noop,
      autofocus: autofocus,
      onFocusChanged: onFocusChanged,
      inputLegend: false,
      gamepadAlias: gamepadAlias,
      narrationText: narrationText
    }))
  );
};
/**
 * Can be used to receive a callback if InteractivePrimitives are nested within a ScrollView.
 * Doesn't have many use cases, but can be useful when setting up narration with composable content.
 */


const SiblingState = ({
  callback
}) => {
  const hasSiblings = useHasInteractiveSiblings();
  (0,react_facet_src.useFacetEffect)(hasSiblings => {
    callback(hasSiblings);
  }, [callback], [hasSiblings]);
  return null;
};

ScrollView_ScrollView.SiblingState = SiblingState;
ScrollView_ScrollView.useHasScrollbar = useHasScrollbar;
;// CONCATENATED MODULE: ./packages/react-gamepad/src/useSetFocusedId.tsx



const src_useSetFocusedId_useSetFocusedId = () => {
  const setFocusedIdLegacy = useSetFocusedId_useSetFocusedId();
  const setFocusedIdVisual = setFocusedId_useSetFocusedId();
  const {
    version: gamepadVersion
  } = useGamepadAdapter();

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return setFocusedIdLegacy;
  }

  return setFocusedIdVisual;
};
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/useShortcut.tsx





function useGlobalShortcut(gamepad, onClick) {
  useShortcut(gamepad, onClick, 'global');
}
function useParentShortcut(gamepad, onClick) {
  useShortcut(gamepad, onClick, 'parent');
}

function useShortcut(gamepad, onClick, scope) {
  const gamepadFacet = (0,react_facet_src.useFacetWrap)(gamepad);
  const id = (0,react.useMemo)(() => __generateId(), []);
  const api = (0,react.useContext)(GamepadAPIContext);
  const path = (0,react.useContext)(pathContext_PathContext);
  (0,react_facet_src.useFacetEffect)(gamepad => {
    const shortcut = {
      type: 'shortcut',
      scope,
      id,
      path,
      onClick,
      shortcut: gamepad.button,
      inputLegend: gamepad.inputLegend,
      disabled: gamepad.disabled || false
    };
    api.addOrUpdateNode(shortcut);
  }, [id, onClick, scope, api, path], [gamepadFacet]);
  (0,react.useEffect)(() => {
    api.runAddNodeEffect();
    return () => api.removeNode(id);
  }, [api, id]);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GlobalShortcut.tsx

function GlobalShortcut({
  options,
  onClick
}) {
  useGlobalShortcut(options, onClick);
  return null;
}
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/hooks/useShortcut.tsx



function useShortcut_useShortcut(gamepad, callback) {
  const gamepadFacet = (0,react_facet_src.useFacetWrap)(gamepad);
  const focusTreeAPI = (0,react.useContext)(FocusTreeAPIContext);
  const path = (0,react.useContext)(PathContext);

  if (path.length === 0) {
    console.error('Parent shortcut cannot be used without a parent');
  }

  const parentId = path[path.length - 1];
  const gamepadValue = gamepadFacet.get();

  if (gamepadValue !== react_facet_src.NO_VALUE && !gamepadValue.disabled) {
    focusTreeAPI.putShortcut(parentId, gamepadValue.button, {
      callback,
      inputLegend: gamepadValue.inputLegend
    });
  } // @TODO global


  (0,react_facet_src.useFacetEffect)(gamepad => {
    const parentId = path[path.length - 1];

    if (!gamepad.disabled) {
      focusTreeAPI.putShortcut(parentId, gamepad.button, {
        callback,
        inputLegend: gamepad.inputLegend
      });
      return () => {
        focusTreeAPI.removeShortcut(parentId, gamepad.button);
      };
    }
  }, [callback, focusTreeAPI, path], [gamepadFacet]);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/components/LandmarkShortcut.tsx

function LandmarkShortcut({
  options,
  onClick
}) {
  useShortcut_useShortcut(options, onClick);
  return null;
}
;// CONCATENATED MODULE: ./packages/react-gamepad/src/GlobalShortcut.tsx




function GlobalShortcut_GlobalShortcut(props) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return /*#__PURE__*/react.createElement(GlobalShortcut, props);
  }

  return /*#__PURE__*/react.createElement(LandmarkShortcut, props);
}
;// CONCATENATED MODULE: ./packages/react-gamepad/src/DisabledAreaWrapper.tsx



function DisabledAreaWrapper({
  options,
  children
}) {
  const optionsFacet = (0,react_facet_src.useFacetWrap)(options);
  const disabled = (0,react_facet_src.useFacetMap)(options => options.disabled, [], [optionsFacet]);
  return /*#__PURE__*/react.createElement(DisabledArea, {
    disabled: disabled
  }, children);
}
;// CONCATENATED MODULE: ./packages/react-gamepad/src/LandmarkWrapper.tsx



function LandmarkWrapper(props) {
  const optionsFacet = (0,react_facet_src.useFacetWrap)(props.options);
  const bounded = (0,react_facet_src.useFacetMap)(options => options.bounded, [], [optionsFacet]);
  const delegateFocusFirstFound = (0,react_facet_src.useFacetMap)(options => options.defaultFocusedChildBehavior === 'first' || options.defaultFocusedChildBehavior === 'remember', [], [optionsFacet]);
  const delegateFocusFromMemory = (0,react_facet_src.useFacetMap)(options => options.defaultFocusedChildBehavior === 'remember', [], [optionsFacet]);
  const disabled = (0,react_facet_src.useFacetMap)(options => options.disabled, [], [optionsFacet]);

  if (props.scrollAxis != null) {
    return /*#__PURE__*/react.createElement(Landmark, {
      scrollAxis: props.scrollAxis,
      disabled: disabled,
      shouldBindFocus: bounded,
      delegateFocusFirstFound: delegateFocusFirstFound,
      delegateFocusFromMemory: delegateFocusFromMemory,
      containerRef: props.scrollRef
    }, props.children);
  }

  return /*#__PURE__*/react.createElement(Landmark, {
    disabled: disabled,
    shouldBindFocus: bounded,
    delegateFocusFirstFound: delegateFocusFirstFound,
    delegateFocusFromMemory: delegateFocusFromMemory,
    containerRef: props.scrollRef
  }, props.children);
}
;// CONCATENATED MODULE: ./packages/react-gamepad/src/Column.tsx





function Column(props) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return /*#__PURE__*/react.createElement(ColumnLegacy, props);
  }

  if (props.shouldSkipLandmarkInVisual) {
    return /*#__PURE__*/react.createElement(DisabledAreaWrapper, {
      options: props.options
    }, props.children);
  }

  return /*#__PURE__*/react.createElement(LandmarkWrapper, props);
}

function ColumnLegacy({
  options,
  children,
  scrollRef
}) {
  const Column = useColumn(options, scrollRef);
  return /*#__PURE__*/react.createElement(Column, null, children);
}
;// CONCATENATED MODULE: ./packages/react-narrator/src/components/NarrationContext.tsx
function NarrationContext_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = NarrationContext_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function NarrationContext_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const NarrationContext_noopString = () => '';

const NarrationContext = (_ref) => {
  let {
    children,
    shouldSkipParent = []
  } = _ref,
      props = NarrationContext_objectWithoutProperties(_ref, ["children", "shouldSkipParent"]);

  const textFacet = (0,react_facet_src.useFacetWrap)('text' in props ? props.text : '');
  const idFacet = (0,react_facet_src.useFacetWrap)('id' in props ? props.id : '');
  const getText = 'getText' in props ? props.getText : NarrationContext_noopString;
  const {
    narrationPutNode,
    narrationPutNodeWithIdAndCallback
  } = useNarrationPutNode();
  const [fullPathNarrationId, setFullPathNarrationId] = (0,react_facet_src.useFacetState)('');
  const unObserve = (0,react.useRef)();
  (0,react.useMemo)(() => {
    var _unObserve$current;

    (_unObserve$current = unObserve.current) === null || _unObserve$current === void 0 ? void 0 : _unObserve$current.call(unObserve);
    unObserve.current = (0,react_facet_src.multiObserve)((text, id) => {
      if (id != null && id !== '') {
        setFullPathNarrationId(narrationPutNodeWithIdAndCallback(id, getText, shouldSkipParent));
      } else {
        setFullPathNarrationId(narrationPutNode(text, shouldSkipParent));
      }
    }, [textFacet, idFacet]);
  }, [textFacet, idFacet, getText, narrationPutNode, narrationPutNodeWithIdAndCallback, shouldSkipParent, setFullPathNarrationId]);
  (0,react.useEffect)(() => () => {
    var _unObserve$current2;

    (_unObserve$current2 = unObserve.current) === null || _unObserve$current2 === void 0 ? void 0 : _unObserve$current2.call(unObserve);
  }, []);
  return /*#__PURE__*/react.createElement(NarrationContextProvider, {
    value: fullPathNarrationId
  }, children);
};
;// CONCATENATED MODULE: ./packages/ui/src/Modal/Modal.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Modal_Modal = ({"container":"icsZi","header":"azoiR","headerShadow":"HJx2A","headerButton":"hiz9d","hide":"yLSeP","spacer":"S2J9J","textContent":"qXm9P","paragraphsWrapper":"MHiRD","paragraphPadding":"Q3Zed","wordWrap":"BPMWS","centerOneLineText":"Rm818","listTextContent":"kxZXz","contentScrollable":"GHU0b","buttons":"kc2Fb","buttonsHorizontal":"IVSIi","wrapper":"UvzEX","overlay":"VT1Tw","progress":"OGKKM","spinner":"YkW5u"});
;// CONCATENATED MODULE: ./packages/ui/src/Typography/Typography.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Typography = ({"white":"t32e0","grey":"NZdRD","darkGrey":"TJqyJ","black":"RoJvv","red":"TTui1","green":"bCnYF","yellow":"tsXc6","center":"IaGhJ","right":"XEoek","left":"W1NXQ","verticalCenter":"JEzgR","Typography":"OIwR8","header1":"jtuPO","header2":"ZSfsQ","header3":"jxr27","header4A":"B6E4l","header4B":"Iu9d0","header5A":"u3V3F","header5B":"Z9bmJ","sectionHeader":"kjlCa","subtitle1":"PyPJl","subtitle2":"gVtt_","body":"vNlW4","paragraphs":"NQiUU","captionTiny":"UNxMi","captionShort":"_He_E","captionLong":"yhCRL","editorCaption":"UwZQy","editorHeader":"X2EMQ","primaryButton":"l6rf0","secondaryButton":"vWcLh","destructiveButton":"P1L1T","shadow":"MIuXl","fontWeightNormal":"RcOKE","fontWeightBold":"j4N5u","fontWeightBolder":"g8JjQ","fontWeightLighter":"uN1hk","fontWeightInitial":"qKtfZ","fontWeightInherit":"EDaTS","whiteSpaceNormal":"JbbH7","whiteSpaceNoWrap":"dI4g4","whiteSpacePre":"wbZka","whiteSpacePreWrap":"_FWvz"});
;// CONCATENATED MODULE: ./packages/ui/src/Typography/Typography.tsx
function Typography_extends() { Typography_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Typography_extends.apply(this, arguments); }





const ALL_VARIANTS = (/* unused pure expression or super */ null && (['header1', 'header2', 'header3', 'header4A', 'header4B', 'header5A', 'header5B', 'paragraphs', 'primaryButton', 'secondaryButton', 'captionTiny', 'captionShort', 'captionLong', 'subtitle1', 'subtitle2', 'body', 'destructiveButton', 'editorCaption', 'editorHeader']));
const variantStyles = {
  header1: [Typography.header1],
  header2: [Typography.header2],
  header3: [Typography.header3],
  header4A: [Typography.header4A],
  header4B: [Typography.header4B],
  header5A: [Typography.header5A],
  header5B: [Typography.header5B],
  sectionHeader: [Typography.sectionHeader],
  subtitle1: [Typography.subtitle1],
  subtitle2: [Typography.subtitle2],
  body: [Typography.body],
  paragraphs: [Typography.paragraphs],
  captionTiny: [Typography.captionTiny],
  captionShort: [Typography.captionShort],
  captionLong: [Typography.captionLong],
  primaryButton: [Typography.primaryButton],
  secondaryButton: [Typography.secondaryButton],
  destructiveButton: [Typography.destructiveButton],
  editorCaption: [Typography.editorCaption],
  editorHeader: [Typography.editorHeader]
};
const colorStyles = {
  white: [Typography.white],
  grey: [Typography.grey],
  black: [Typography.black],
  red: [Typography.red],
  green: [Typography.green],
  yellow: [Typography.yellow],
  darkGrey: [Typography.darkGrey],
  inherit: undefined
};
let FontWeight;

(function (FontWeight) {
  FontWeight[FontWeight["Normal"] = 0] = "Normal";
  FontWeight[FontWeight["Bold"] = 1] = "Bold";
  FontWeight[FontWeight["Bolder"] = 2] = "Bolder";
  FontWeight[FontWeight["Lighter"] = 3] = "Lighter";
  FontWeight[FontWeight["Initial"] = 4] = "Initial";
  FontWeight[FontWeight["Inherit"] = 5] = "Inherit";
})(FontWeight || (FontWeight = {}));

const fontWeightStyles = {
  [FontWeight.Normal]: [Typography.fontWeightNormal],
  [FontWeight.Bold]: [Typography.fontWeightBold],
  [FontWeight.Bolder]: [Typography.fontWeightBolder],
  [FontWeight.Lighter]: [Typography.fontWeightLighter],
  [FontWeight.Initial]: [Typography.fontWeightInitial],
  [FontWeight.Inherit]: [Typography.fontWeightInherit]
};
const whiteSpaceStyles = {
  normal: [Typography.whiteSpaceNormal],
  nowrap: [Typography.whiteSpaceNoWrap],
  pre: [Typography.whiteSpacePre],
  preWrap: [Typography.whiteSpacePreWrap]
};
function Typography_Typography({
  children,
  color = 'white',
  align,
  verticalAlign = 'top',
  variant,
  shadow,
  tag,
  fontWeight,
  shouldNarrate,
  whiteSpace
}) {
  const alignFacet = (0,react_facet_src.useFacetWrap)(align);
  const colorFacet = (0,react_facet_src.useFacetWrap)(color);
  const shadowFacet = (0,react_facet_src.useFacetWrap)(shadow);
  const variantFacet = (0,react_facet_src.useFacetWrap)(variant);
  const verticalAlignFacet = (0,react_facet_src.useFacetWrap)(verticalAlign);
  const fontWeightFacet = (0,react_facet_src.useFacetWrap)(fontWeight);
  const whiteSpaceFacet = (0,react_facet_src.useFacetWrap)(whiteSpace);
  const Element = tag ? tag : variant === 'paragraphs' ? 'p' : 'div';
  const classNameFacet = (0,react_facet_src.useFacetMap)((shadow, align, color, variant, verticalAlign, fontWeight, whiteSpace) => {
    // These classnames are used explicitly
    // for stylelint plugin/no-unused-selectors static check
    const variantStyle = variant ? variantStyles[variant] : undefined;
    const alignStyle = {
      [Typography.center]: align === 'center',
      [Typography.right]: align === 'right',
      [Typography.left]: align === 'left',
      [Typography.verticalCenter]: verticalAlign === 'center'
    };
    const colorStyle = color ? colorStyles[color] : undefined;
    const fontWeightStyle = fontWeight ? fontWeightStyles[fontWeight] : undefined;
    const whiteSpaceStyle = whiteSpace ? whiteSpaceStyles[whiteSpace] : undefined;
    const shadowStyle = {
      [Typography.shadow]: shadow
    };
    return classnames_default()(Typography.Typography, variantStyle, alignStyle, colorStyle, shadowStyle, fontWeightStyle, whiteSpaceStyle);
  }, [], [shadowFacet, alignFacet, colorFacet, variantFacet, verticalAlignFacet, fontWeightFacet, whiteSpaceFacet]);
  const narrateProps = shouldNarrate === true ? {
    ['data-narrate']: true
  } : {};

  if ((0,react_facet_src.isFacet)(children)) {
    if (Element === 'div') {
      return /*#__PURE__*/react.createElement("fast-div", Typography_extends({
        className: classNameFacet
      }, narrateProps), /*#__PURE__*/react.createElement("fast-text", {
        text: children
      }));
    }

    if (Element === 'p') {
      return /*#__PURE__*/react.createElement("fast-p", Typography_extends({
        className: classNameFacet
      }, narrateProps), /*#__PURE__*/react.createElement("fast-text", {
        text: children
      }));
    }

    return /*#__PURE__*/react.createElement("fast-span", Typography_extends({
      className: classNameFacet
    }, narrateProps), /*#__PURE__*/react.createElement("fast-text", {
      text: children
    }));
  }

  if (Element === 'div') {
    return /*#__PURE__*/react.createElement("fast-div", Typography_extends({
      className: classNameFacet
    }, narrateProps), children);
  }

  if (Element === 'p') {
    return /*#__PURE__*/react.createElement("fast-p", Typography_extends({
      className: classNameFacet
    }, narrateProps), children);
  }

  return /*#__PURE__*/react.createElement("fast-span", Typography_extends({
    className: classNameFacet
  }, narrateProps), children);
}
Typography_Typography.FontWeight = FontWeight;
;// CONCATENATED MODULE: ./packages/ui/src/Checkbox/Checkbox.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Checkbox = ({"Checkbox":"tIO8N","main":"jw1g3","textWrapper":"GSYTw","small":"sSJaW","description":"vEsZy"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCheckGrey/images/checkGrey.png
const checkGrey_namespaceObject = __webpack_require__.p + "assets/checkGrey-a9d8c.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCheckGrey/IconCheckGrey.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconCheckGrey = ({"iconCheckGrey":"SBc3u"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCheckGrey/IconCheckGrey.tsx




const IconCheckGrey_IconCheckGrey = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconCheckGrey.iconCheckGrey,
  src: checkGrey_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCheckWhite/images/checkWhite.png
const checkWhite_namespaceObject = __webpack_require__.p + "assets/checkWhite-bcfbf.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCheckWhite/IconCheckWhite.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconCheckWhite = ({"iconCheckWhite":"ycpq0"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCheckWhite/IconCheckWhite.tsx




const IconCheckWhite_IconCheckWhite = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconCheckWhite.iconCheckWhite,
  src: checkWhite_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseCheckbox/BaseCheckbox.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseCheckbox = ({"box":"r3OGg","boxCheck":"em21X","boxDisabled":"h2XVN"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseCheckbox/BaseCheckbox.tsx









function BaseCheckbox_BaseCheckbox({
  value,
  disabled,
  gamepad,
  narrationText,
  onClick,
  soundEffectPressed,
  checkedRole = 'primary',
  uncheckedRole = 'neutral50'
}) {
  const {
    color: {
      [checkedRole]: semanticClassNamesChecked,
      [uncheckedRole]: semanticClassNamesUnchecked
    },
    sound: {
      inherit: semanticSound
    }
  } = useSemanticTokens();
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const onClickHandler = (0,react_facet_src.useFacetCallback)(value => () => onClick === null || onClick === void 0 ? void 0 : onClick(!value), [onClick], [valueFacet]);
  const boxClassName = (0,react_facet_src.useFacetMap)(value => {
    return classnames_default()(BaseCheckbox.box, value ? [semanticClassNamesChecked.background.interactive, semanticClassNamesChecked.border.interactive] : [semanticClassNamesUnchecked.background.interactive, semanticClassNamesUnchecked.border.interactive]);
  }, [semanticClassNamesChecked, semanticClassNamesUnchecked], [valueFacet]);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    narrationText: narrationText,
    isInteractive: typeof onClick === 'function',
    gamepadIndex: gamepad.index,
    classNameFocused: focusClass,
    classNameDisabled: BaseCheckbox.boxDisabled,
    disabled: disabled,
    onClick: onClickHandler,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.toggle
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: boxClassName
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    disabled: disabled
  }), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    disabled: disabled
  }), /*#__PURE__*/react.createElement("fast-div", {
    style: {
      display: (0,react_facet_src.useFacetMap)(value => value ? 'flex' : 'none', [], [valueFacet])
    },
    className: BaseCheckbox.boxCheck
  }, /*#__PURE__*/react.createElement("fast-div", {
    style: {
      display: (0,react_facet_src.useFacetMap)(disabled => disabled ? 'flex' : 'none', [], [disabledFacet])
    }
  }, /*#__PURE__*/react.createElement(IconCheckGrey_IconCheckGrey, null)), /*#__PURE__*/react.createElement("fast-div", {
    style: {
      display: (0,react_facet_src.useFacetMap)(disabled => !disabled ? 'flex' : 'none', [], [disabledFacet])
    }
  }, /*#__PURE__*/react.createElement(IconCheckWhite_IconCheckWhite, null)))));
}
;// CONCATENATED MODULE: ./packages/ui/src/Checkbox/Checkbox.tsx











const Checkbox_noop = () => {};

function Checkbox_Checkbox({
  gamepad,
  onChange = Checkbox_noop,
  value,
  title,
  description,
  disabled,
  small = false,
  soundEffectPressed,
  wrapperRole = 'neutral'
}) {
  const {
    color: {
      [wrapperRole]: semanticClassNames
    },
    variant,
    sound: {
      [wrapperRole]: semanticSound
    }
  } = useSemanticTokens();
  const titleFacet = (0,react_facet_src.useFacetWrap)(title);
  const descriptionFacet = (0,react_facet_src.useFacetWrap)(description !== null && description !== void 0 ? description : '');
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const onClick = (0,react_facet_src.useFacetCallback)(value => () => onChange(!value), [onChange], [valueFacet]);
  const {
    t
  } = useLocalization('Checkbox');
  const narrationText = (0,react_facet_src.useFacetMap)((value, title, description) => [t('.elementType'), title, description, value ? t('.labelChecked') : t('.labelUnChecked')].join(' . '), [t], [valueFacet, titleFacet, descriptionFacet]);
  const className = (0,react_facet_src.useFacetWrap)(classnames_default()(Checkbox.Checkbox, semanticClassNames.background.base, {
    [Checkbox.small]: small
  }));
  return /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: wrapperRole
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    className: className,
    inputLegend: t('.toggle'),
    gamepadIndex: gamepad.index,
    onClick: onClick,
    disabled: disabledFacet,
    narrationText: narrationText,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.toggle,
    classNameFocused: focusClass
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    role: wrapperRole,
    effect: "bevel",
    left: false,
    right: false
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    className: Checkbox.main
  }, /*#__PURE__*/react.createElement(BaseCheckbox_BaseCheckbox, {
    value: valueFacet,
    narrationText: false,
    disabled: disabledFacet,
    gamepad: gamepad
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Checkbox.textWrapper, semanticClassNames.text.base)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: 'inherit'
  }, titleFacet), Boolean(description) && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Checkbox.description, semanticClassNames.text.base, variant.dimmer)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: 'inherit'
  }, descriptionFacet)))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  })));
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/ParentShortcut.tsx

function ParentShortcut({
  options,
  onClick
}) {
  useParentShortcut(options, onClick);
  return null;
}
;// CONCATENATED MODULE: ./packages/react-gamepad/src/ParentShortcut.tsx




function ParentShortcut_ParentShortcut(props) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return /*#__PURE__*/react.createElement(ParentShortcut, props);
  }

  return /*#__PURE__*/react.createElement(LandmarkShortcut, props);
}
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconMagnifyingGlass/images/magnifyingGlass.png
const magnifyingGlass_namespaceObject = __webpack_require__.p + "assets/magnifyingGlass-52f96.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconMagnifyingGlass/IconMagnifyingGlass.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconMagnifyingGlass = ({"iconMagnifyingGlass":"TmKO0"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconMagnifyingGlass/IconMagnifyingGlass.tsx




const IconMagnifyingGlass_IconMagnifyingGlass = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconMagnifyingGlass.iconMagnifyingGlass,
  src: magnifyingGlass_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./packages/ui-primitive/src/EllipsisPrimitive/EllipsisPrimitive.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const EllipsisPrimitive = ({"ellipsis":"nTLvV","browser":"tkVAm"});
;// CONCATENATED MODULE: ./packages/ui-primitive/src/EllipsisPrimitive/EllipsisPrimitive.tsx




const EllipsisPrimitive_EllipsisPrimitive = ({
  children,
  innerRef,
  className
}) => {
  if ((0,react_facet_src.isFacet)(children)) {
    return /*#__PURE__*/react.createElement("fast-div", {
      ref: innerRef,
      className: classnames_default()(EllipsisPrimitive.ellipsis,  false ? 0 : '', className)
    }, /*#__PURE__*/react.createElement("fast-text", {
      text: children
    }));
  }

  return /*#__PURE__*/react.createElement("div", {
    ref: innerRef,
    className: classnames_default()(EllipsisPrimitive.ellipsis,  false ? 0 : '', className)
  }, children);
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/InputChangesOverride/InputChangesOverride.ts

const InputChangesOverride_context = (0,react.createContext)(null);
const useInputChangesOverride = () => (0,react.useContext)(InputChangesOverride_context);
const InputChangesOverrideProvider = InputChangesOverride_context.Provider;
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseTextField/component/BaseTextField.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseTextField = ({"textFieldWrapper":"ZyW_9","textField":"d9dd2","textFieldWrapperShadow":"oC3bl","textFieldBrowserOnly":"PZ6ir","textFieldType":"uHy0P","textFieldPlaceholder":"YuTSL","textFieldTextArea":"DYvK2","disabled":"ezdmG","placeholderAdjustedWithIcon":"_08EUe","textFieldContentWrapper":"v2fnz","textFieldIcon":"b4wn_","textFieldClearInteractive":"mHHfZ"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseTextField/component/BaseTextField.tsx














let PlaceholderIcon;

(function (PlaceholderIcon) {
  PlaceholderIcon[PlaceholderIcon["MagnifyingGlass"] = 0] = "MagnifyingGlass";
})(PlaceholderIcon || (PlaceholderIcon = {}));

const getPlaceholderIcon = placeholderIcon => {
  switch (placeholderIcon) {
    case PlaceholderIcon.MagnifyingGlass:
      return /*#__PURE__*/react.createElement(IconMagnifyingGlass_IconMagnifyingGlass, null);

    default:
      return /*#__PURE__*/react.createElement(IconMagnifyingGlass_IconMagnifyingGlass, null);
  }
};

function BaseTextField_BaseTextField(props) {
  const {
    autofocus,
    gamepadAlias,
    gamepadIndex,
    value,
    disabled = false,
    label,
    className,
    // We set the default maxLength value to 50000 as this is the default value in Bedrock
    // and we must set a max length. This is just to make sure that the Gameface and Bedrock
    // input matches and does not go out of sync
    maxLength = 50000,
    narrationText,
    onBlur,
    onFocus,
    onHover,
    onKeyDown,
    onKeyUp,
    onChange,
    onSelectedChange,
    placeholder = '',
    rows = 1,
    shouldBlurOnEnter,
    shouldBlurOnEscape,
    onTab,
    isNumber,
    placeholderIcon,
    showClearOptionWhenValueExists,
    onClear,
    hasShadow = true,
    role = 'neutral80'
  } = props;
  const {
    t
  } = useLocalization('BaseTextField');
  const [isFocusedFacet, setIsFocusedFacet] = (0,react_facet_src.useFacetState)(false);
  const [isSelectedFacet, setIsSelectedFacet] = (0,react_facet_src.useFacetState)(false);
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledValue = (0,react_facet_src.useFacetUnwrap)(disabled);
  const {
    narrateText,
    preventNarrateText
  } = useNarrateText();
  const stateOverrideFacet = (0,react_facet_src.useFacetWrap)(useInputStateOverride());
  const inputChangesOverride = useInputChangesOverride();
  const classNameFacet = (0,react_facet_src.useFacetWrap)(className);
  const inputTypeFacet = (0,react_facet_src.useFacetMap)(isNumber => isNumber ? 'number' : 'text', [], [(0,react_facet_src.useFacetWrap)(isNumber)]);
  const autofocusRef = (0,react.useRef)(autofocus);
  const {
    color: {
      [role]: semanticColor
    },
    variant
  } = useSemanticTokens();
  const ref = (0,react.useRef)(null);
  const previousFocusState = (0,react.useRef)(false); // When the TextField becomes focused the role and text field label should be read as a hint

  (0,react_facet_src.useFacetEffect)((focused, label) => {
    // The ref is used to prevent the narrateText to fire on every char entry on touch
    // The software keyboard loses and regains focus for each char, triggering this effect again and again
    if (focused && !previousFocusState.current) {
      previousFocusState.current = true;
      narrateText(`${t('.selected')} . ${t('.hint', [`${label}`])}`);
    } else if (!focused) {
      previousFocusState.current = false;
    }
  }, [narrateText, t], [isFocusedFacet, (0,react_facet_src.useFacetWrap)(label !== null && label !== void 0 ? label : '')]);
  (0,react.useEffect)(() => {
    if (!ref.current) return;

    if (autofocusRef.current) {
      ref.current.focus();
    }
  }, []);
  const onKeyboardEvent = useKeyboardEventCallbacks();
  const handleGlobalChange = (0,react.useCallback)(inputChanges => {
    if (ref.current && document.activeElement === ref.current) {
      const narration = inputChangesToNarration(ref.current.value, inputChanges !== null && inputChanges !== void 0 ? inputChanges : inputChangesOverride, t);
      preventNarrateText();

      if (narration != null) {
        narrateText(narration);
      }

      onChange && onChange(ref.current.value, inputChanges !== null && inputChanges !== void 0 ? inputChanges : inputChangesOverride);
    }
  }, [onChange, inputChangesOverride, narrateText, t, preventNarrateText]);
  const handleTab = (0,react.useCallback)(() => {
    if (ref.current && document.activeElement === ref.current) {
      onTab && onTab();
    }
  }, [onTab]);
  const handleSelected = (0,react.useCallback)(selected => {
    setIsSelectedFacet(selected);
    onSelectedChange && onSelectedChange(selected);
  }, [setIsSelectedFacet, onSelectedChange]);
  const handleBlur = (0,react.useCallback)(reselect => {
    if (ref.current) {
      setIsFocusedFacet(false);

      if (onBlur != null) {
        // This handler sets the value of the text field, both by manipulating the dom and by calling the onChange handler.
        // This is unfortunately currently needed since the virtual keyboard integration sets the value of the dom element
        // directly when submitting a value. If we would in a validation in the onBlur handler have used a setter of the facet
        // holding the current value instead, then setting it back to the current facet value would not trigger a change and
        // the input would keep the invalid value, even though the facet will have the correct value.
        const setValue = (newValue = '') => {
          if (ref.current) {
            ref.current.value = newValue;

            if (onChange != null) {
              onChange(newValue, inputChangesOverride !== null && inputChangesOverride !== void 0 ? inputChangesOverride : createEmptyTextInputChange());
            }
          }
        };

        onBlur(ref.current.value, setValue);
      }

      if (Boolean(reselect)) {
        handleSelected(true);
      } else {
        handleSelected(false);
      }
    }
  }, [onBlur, setIsFocusedFacet, handleSelected, onChange, inputChangesOverride]);
  const handleDismissed = (0,react.useCallback)(() => {
    if (ref.current && document.activeElement === ref.current) {
      ref.current.blur();
      handleBlur(true);
    }
  }, [handleBlur]);
  const handleSubmit = (0,react.useCallback)(() => {
    if (ref.current && document.activeElement === ref.current) {
      handleDismissed();
    }
  }, [handleDismissed]);
  (0,react.useEffect)(() => {
    if (!onKeyboardEvent) return;
    const cleanupCallbacks = [onKeyboardEvent.changedCB(handleGlobalChange), onKeyboardEvent.tabbedCB(handleTab), onKeyboardEvent.submittedCB(handleSubmit), onKeyboardEvent.dismissedCB(handleDismissed)];
    return () => {
      cleanupCallbacks.forEach(cb => cb());
    };
  }, [onKeyboardEvent, handleGlobalChange, handleDismissed, handleTab, handleSubmit]);
  const handleClick = (0,react.useCallback)(() => {
    if (!ref.current) return;
    ref.current.focus();
  }, []);
  const handleKeyUp = (0,react.useCallback)(event => {
    onKeyUp && onKeyUp(event); // Don't prevent narration if the user is initially focusing the field

    if (!previousFocusState.current) {
      if ('target' in event) {
        const narration = inputChangesToNarration(event.target.value, inputChangesOverride !== null && inputChangesOverride !== void 0 ? inputChangesOverride : createEmptyTextInputChange(), t);
        preventNarrateText();

        if (narration != null) {
          narrateText(narration);
        }
      }
    }

    onChange && onChange(event.target.value, inputChangesOverride !== null && inputChangesOverride !== void 0 ? inputChangesOverride : createEmptyTextInputChange());
  }, [onChange, onKeyUp, inputChangesOverride, t, narrateText, preventNarrateText]);
  const inputClassName = (0,react_facet_src.useFacetMap)((isFocused, isSelected, stateOverride, classNameValue) => {
    return classnames_default()(BaseTextField.textField, BaseTextField.textFieldType, semanticColor.border.interactive, semanticColor.text.interactive, semanticColor.caret.base, classNameValue, {
      [BaseTextField.textFieldBrowserOnly]: "gameface" === 'browser',
      [BaseTextField.textFieldFocused]: stateOverride && stateOverride.focused || isFocused,
      [BaseTextField.disabled]: disabledValue,
      [BaseTextField.textFieldTextArea]: rows > 1
    });
  }, [disabledValue, rows, semanticColor], [isFocusedFacet, isSelectedFacet, stateOverrideFacet, classNameFacet]);
  const focusedClass = (0,react_facet_src.useFacetMap)((isFocused, isSelected, stateOverride) => {
    return classnames_default()({
      [focusClass]: stateOverride && stateOverride.focused || isSelected && !isFocused
    });
  }, [], [isFocusedFacet, isSelectedFacet, stateOverrideFacet]);
  const handleKeyDown = (0,react.useCallback)(event => {
    if (!ref.current) return;

    if (event.keyCode === KeyboardKey.ESCAPE && document.activeElement === ref.current) {
      if (shouldBlurOnEscape) {
        // Deselect on ESCAPE key down as in legacy Bedrock fields
        ref.current.blur();
        handleBlur(true);
        event.stopPropagation();
      }
    } else if (event.keyCode === KeyboardKey.ENTER && document.activeElement === ref.current && rows === 1) {
      if (shouldBlurOnEnter) {
        // Deselect on ENTER key down if not multiline as in legacy Bedrock fields
        // setTimeout is here to not let the gamepad click handler to refocus the field immediately
        setTimeout(() => {
          ref.current && ref.current.blur();
          handleBlur(true);
        }, 0);
        event.preventDefault();
      }
    }
  }, [rows, shouldBlurOnEnter, shouldBlurOnEscape, handleBlur]);
  const handleFocus = (0,react.useCallback)(() => {
    setIsFocusedFacet(true);
    onFocus && onFocus();
    handleSelected(true);
  }, [onFocus, setIsFocusedFacet, handleSelected]);
  const gamepadFacet = (0,react_facet_src.useFacetMap)(isFocused => ({
    button: types_ButtonType.B,
    inputLegend: t('.deselect'),
    disabled: !isFocused
  }), [t], [isFocusedFacet]);
  const isValueNotNullOrEmptyFacet = (0,react_facet_src.useFacetMap)(value => {
    return value != null && value !== '';
  }, [], [valueFacet]);
  const placeholderDisplay = (0,react_facet_src.useFacetMap)((value, isFocused) => {
    return (value == null || value === '') && !isFocused ? 'flex' : 'none';
  }, [], [valueFacet, isFocusedFacet]);
  const placeholderElement = /*#__PURE__*/react.createElement("fast-div", {
    className: classnames_default()(BaseTextField.textFieldType, BaseTextField.textFieldPlaceholder, semanticColor.text.interactive, variant.dimmest, {
      [BaseTextField.placeholderAdjustedWithIcon]: placeholderIcon != null
    }),
    style: {
      display: placeholderDisplay
    }
  }, placeholderIcon != null ? /*#__PURE__*/react.createElement("div", {
    className: BaseTextField.textFieldContentWrapper
  }, /*#__PURE__*/react.createElement("div", {
    className: BaseTextField.textFieldIcon
  }, getPlaceholderIcon(placeholderIcon)), /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, placeholder)) : /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, placeholder));
  const inputElement = rows > 1 ? /*#__PURE__*/react.createElement("fast-textarea", {
    ref: ref,
    rows: rows,
    className: inputClassName,
    maxLength: maxLength,
    value: valueFacet,
    onFocus: handleFocus,
    onKeyDown: onKeyDown,
    onKeyUp: handleKeyUp,
    onBlur: () => {
      handleBlur(false);
    }
  }) : /*#__PURE__*/react.createElement("fast-input", {
    ref: ref,
    type: inputTypeFacet,
    className: inputClassName,
    maxLength: maxLength,
    value: valueFacet,
    onFocus: handleFocus,
    onKeyDown: onKeyDown,
    onKeyUp: handleKeyUp,
    onBlur: () => {
      handleBlur(false);
    }
  });

  const content = () => {
    if (disabledValue !== react_facet_src.NO_VALUE && disabledValue) {
      return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
        className: classnames_default()(BaseTextField.textFieldWrapper, semanticColor.background.interactive, {
          [BaseTextField.disabled]: disabledValue
        }),
        "data-testid": props['data-testid'],
        key: "disabled",
        narrationText: narrationText,
        inputLegend: false,
        disabled: true,
        gamepadIndex: gamepadIndex !== null && gamepadIndex !== void 0 ? gamepadIndex : 0,
        onFocusChanged: handleSelected,
        onKeyDown: handleKeyDown,
        onClick: handleClick,
        gamepadAlias: gamepadAlias
      }, /*#__PURE__*/react.createElement("div", {
        className: classnames_default()(hasShadow ? semanticColor.shadow.interactive : undefined, {
          [BaseTextField.textFieldWrapperShadow]: hasShadow
        })
      }), placeholderElement, /*#__PURE__*/react.createElement("fast-div", {
        className: inputClassName
      }, /*#__PURE__*/react.createElement("span", null, /*#__PURE__*/react.createElement("span", null, /*#__PURE__*/react.createElement("fast-text", {
        text: valueFacet
      })), ' ')));
    }

    return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
      key: "enabled",
      className: classnames_default()(BaseTextField.textFieldWrapper, semanticColor.background.base, semanticColor.background.disable),
      "data-testid": props['data-testid'],
      narrationText: narrationText,
      gamepadIndex: gamepadIndex !== null && gamepadIndex !== void 0 ? gamepadIndex : 0,
      inputLegend: t('.select'),
      onFocusChanged: handleSelected,
      classNameFocused: focusedClass,
      onKeyDown: handleKeyDown,
      onClick: handleClick,
      gamepadAlias: gamepadAlias,
      onHoverChanged: onHover
    }, /*#__PURE__*/react.createElement("div", {
      className: classnames_default()(hasShadow ? semanticColor.shadow.interactive : undefined, {
        [BaseTextField.textFieldWrapperShadow]: hasShadow
      })
    }), placeholderElement, inputElement, /*#__PURE__*/react.createElement(Focus_Focus, {
      role: role
    }), showClearOptionWhenValueExists && /*#__PURE__*/react.createElement(react_facet_src.Mount, {
      when: isValueNotNullOrEmptyFacet
    }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
      className: BaseTextField.textFieldClearInteractive,
      gamepadIndex: 0,
      narrationText: false,
      inputLegend: '',
      onClick: () => onClear != null && onClear()
    }, /*#__PURE__*/react.createElement(IconCrossWhite_IconCrossWhite, null))));
  };

  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(ParentShortcut_ParentShortcut, {
    options: gamepadFacet,
    onClick: () => {
      if (ref.current && document.activeElement === ref.current) {
        ref.current.blur();
        handleBlur(true);
      }
    }
  }), content());
}

const inputChangesToNarration = (value, inputChanges, t) => {
  const added = inputChanges.addedChars.split('').join(' ');
  const removed = inputChanges.removedChars.split('').join(' ');
  const invalid = inputChanges.invalidChars.split('').join(' ');
  const invalidText = invalid !== '' ? ` ${invalid} ${t('.invalidNarration')}` : '';
  const valueWithPause = value.length !== 0 ? ` . . ${value}` : '';

  if (added !== '') {
    if (removed !== '') {
      return `${removed} ${t('.replacedNarration')} ${added}${invalidText}${valueWithPause}`;
    }

    return `${added} ${t('.addedNarration')}${invalidText}${valueWithPause}`;
  }

  if (removed !== '') {
    return `${removed} ${t('.removedNarration')}${valueWithPause}`;
  }

  return null;
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/Panel/Panel.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Panel = ({"Panel":"eUpFO","compactPanel":"lMcuz","transparent":"oTQSA","panelFocus":"H7Hc9"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Panel/Panel.tsx
function Panel_extends() { Panel_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Panel_extends.apply(this, arguments); }

function Panel_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Panel_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Panel_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }










function Panel_Panel(_ref) {
  let {
    children,
    isTransparent,
    compact = false,
    focusable = false,
    narrationText = false,
    inputLegend = false,
    shouldDisplayFocus = true,
    onClick,
    gamepadIndex,
    role = 'neutral',
    disabled
  } = _ref,
      rest = Panel_objectWithoutProperties(_ref, ["children", "isTransparent", "compact", "focusable", "narrationText", "inputLegend", "shouldDisplayFocus", "onClick", "gamepadIndex", "role", "disabled"]);

  const focusableFacet = (0,react_facet_src.useFacetWrap)(focusable);
  const gamepadIndexFacet = (0,react_facet_src.useFacetWrap)(gamepadIndex);
  const narrationTextFacet = (0,react_facet_src.useFacetWrap)(narrationText);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const {
    color: {
      [role]: {
        background
      }
    },
    component: {
      panel: {
        texture
      }
    }
  } = useSemanticTokens();
  const inheritedRole = useInheritSemanticRole();
  const textureForRole = texture[role === 'inherit' ? inheritedRole : role].base;
  const isTransparentFacet = (0,react_facet_src.useFacetWrap)(isTransparent);
  const className = (0,react_facet_src.useFacetMap)(transparent => {
    return classnames_default()(Panel.Panel, {
      [Panel.transparent]: transparent,
      [Panel.compactPanel]: compact
    }, textureForRole != null ? textureForRole : background.base);
  }, [compact, background.base, textureForRole], [isTransparentFacet]);
  const classNameFocused = (0,react_facet_src.useFacetMap)(className => classnames_default()(className, focusClass), [], [className]);
  const content = /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: role
  }, !compact && textureForRole == null && /*#__PURE__*/react.createElement(Reflection_Reflection, {
    interactive: false,
    effect: "bevel",
    left: false,
    right: false
  }), !compact && /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }), children, !compact && /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }));
  const isMountedFacet = (0,react_facet_src.useFacetMap)((focusable, gamepadIndex, narrationText, disabled) => onClick != null && disabled !== true || focusable === true && gamepadIndex != null && narrationText != null, [onClick], [focusableFacet, gamepadIndexFacet, narrationTextFacet, disabledFacet]);
  const shouldNotDisplayFocusFacet = (0,react_facet_src.useFacetMap)(shouldDisplayFocus => !shouldDisplayFocus, [], [(0,react_facet_src.useFacetWrap)(shouldDisplayFocus)]);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, Panel_extends({
    isInteractive: isMountedFacet,
    gamepadIndex: gamepadIndex,
    className: className,
    classNameFocused: classNameFocused,
    narrationText: narrationText,
    inputLegend: inputLegend,
    onClick: onClick !== null && onClick !== void 0 ? onClick : Panel_noop
  }, rest), content, /*#__PURE__*/react.createElement(Focus_Focus, {
    className: Panel.panelFocus,
    interactive: false,
    disabled: shouldNotDisplayFocusFacet,
    role: role
  }));
}

function Panel_noop() {}
;// CONCATENATED MODULE: ./packages/ui-internal/src/Panel/PanelLabel.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PanelLabel = ({"panelLabel":"i_2FG"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Panel/PanelLabel.tsx





function PanelLabel_PanelLabel({
  children,
  disabled,
  role = 'inherit',
  className
}) {
  const {
    color: {
      [role]: {
        text
      }
    },
    modifier,
    variant
  } = useSemanticTokens();
  const childrenFacet = (0,react_facet_src.useFacetWrap)(children);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const classNameFacet = (0,react_facet_src.useFacetWrap)(className);
  const labelClassName = (0,react_facet_src.useFacetMap)((isDisabled, className) => // Setting text to sub role dimmer when disabled is not ideal, but is needed in order to retrofit the semantic tokens
  classnames_default()(PanelLabel.panelLabel, text.base, {
    [modifier.disabled]: isDisabled,
    [variant.dimmer]: isDisabled
  }, className), [modifier, text, variant], [disabledFacet, classNameFacet]);
  return /*#__PURE__*/react.createElement("fast-span", {
    className: labelClassName
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: childrenFacet
  }));
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/Panel/PanelDescription.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PanelDescription = ({"panelDescription":"rycle"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Panel/PanelDescription.tsx





const PanelDescription_PanelDescription = ({
  children,
  disabled,
  role = 'inherit'
}) => {
  const {
    color: {
      [role]: {
        text
      }
    },
    variant,
    modifier
  } = useSemanticTokens();
  const childrenFacet = (0,react_facet_src.useFacetWrap)(children);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const className = (0,react_facet_src.useFacetMap)(isDisabled => classnames_default()(PanelDescription.panelDescription, text.base, variant.dimmer, {
    [modifier.disabled]: isDisabled
  }), [modifier, text, variant], [disabledFacet]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: className
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: childrenFacet
  }));
};
;// CONCATENATED MODULE: ./packages/ui/src/TextField/TextFieldWrapper.tsx




function TextFieldWrapper({
  disabled,
  label: labelFacet,
  description,
  children,
  gamepadIndex,
  transparent,
  disabledNarrationText
}) {
  const isNarrationEnabled = useNarrationEnabled();
  const panelIsFocusable = (0,react_facet_src.useFacetMap)(disabled => disabled && isNarrationEnabled, [isNarrationEnabled], [disabled]);
  return /*#__PURE__*/react.createElement(Panel_Panel, {
    focusable: panelIsFocusable,
    gamepadIndex: gamepadIndex !== null && gamepadIndex !== void 0 ? gamepadIndex : 0,
    isTransparent: transparent,
    narrationText: disabledNarrationText
  }, /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, {
    disabled: disabled
  }, labelFacet), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), children, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, {
    disabled: disabled
  }, description));
}
;// CONCATENATED MODULE: ./packages/react-gamepad/src/Row.tsx





function Row(props) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return /*#__PURE__*/react.createElement(RowLegacy, props);
  }

  if (props.shouldSkipLandmarkInVisual) {
    return /*#__PURE__*/react.createElement(DisabledAreaWrapper, {
      options: props.options
    }, props.children);
  }

  return /*#__PURE__*/react.createElement(LandmarkWrapper, props);
}

function RowLegacy({
  options,
  children,
  scrollRef
}) {
  const Row = useRow(options, scrollRef);
  return /*#__PURE__*/react.createElement(Row, null, children);
}
;// CONCATENATED MODULE: ./packages/ui/src/Button/Button.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Button_Button = ({"labelContainer":"dGKbF","container":"Mc7_w","focused":"f98RG","elevated":"LtoW3","elevatedAndPressed":"fYLl1","image":"f84oF"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Pressable/Pressable.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Pressable = ({"box":"ZFCMh","elevated":"gm_hk","elevatedAndPressed":"_63rL","horizontal":"z1z73","raised":"jUUof","boxBorder":"S54bt","shine":"NMcbo","shineText":"OdSfJ","bottomOffset":"h4_9h"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Pressable/Pressable.tsx
function Pressable_extends() { Pressable_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Pressable_extends.apply(this, arguments); }








function BoxBorder(props) {
  const propsRef = (0,react.useRef)(props);
  propsRef.current = props;
  const className = classnames_default()(Pressable.box, Pressable.boxBorder, propsRef.current.className != null ? propsRef.current.className : undefined);
  const classNameFocused = classnames_default()(focusClass, propsRef.current.classNameFocused != null ? propsRef.current.classNameFocused : undefined);
  const classNameHovered = classnames_default()(propsRef.current.classNameHovered != null ? propsRef.current.classNameHovered : undefined);
  const classNamePressed = classnames_default()(propsRef.current.classNamePressed != null ? propsRef.current.classNamePressed : undefined);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, Pressable_extends({
    autofocus: propsRef.current.autofocus,
    disabled: propsRef.current.disabled,
    disableScrollIntoView: propsRef.current.disableScrollIntoView,
    className: className,
    "data-testid": propsRef.current['data-testid'],
    classNameFocused: classNameFocused,
    classNameHovered: classNameHovered,
    classNamePressed: classNamePressed,
    classNameDisabled: propsRef.current.classNameDisabled,
    delayedClick: propsRef.current.delayedClick,
    gamepadAlias: propsRef.current.gamepadAlias,
    gamepadIndex: propsRef.current.gamepadIndex,
    inputLegend: propsRef.current.inputLegend,
    innerRef: propsRef.current.innerRef,
    onClick: propsRef.current.onClick,
    onFocusChanged: propsRef.current.onFocusChanged,
    onHoverChanged: propsRef.current.onHoverChanged,
    onPressChanged: propsRef.current.onPressChanged,
    soundEffectHovered: propsRef.current.soundEffectHovered,
    soundEffectFocused: propsRef.current.soundEffectFocused,
    soundEffectPressed: propsRef.current.soundEffectPressed,
    pressDuration: propsRef.current.pressDuration
  }, 'narrationText' in propsRef.current ? {
    narrationText: propsRef.current.narrationText
  } : {
    getNarrationText: propsRef.current.getNarrationText,
    narrationId: propsRef.current.narrationId
  }), props.children);
}
function Pressable_Pressable(props) {
  var _propsRef$current$cla, _propsRef$current$cla2, _propsRef$current$sou, _propsRef$current$sou2, _propsRef$current$sou3, _propsRef$current$ref;

  const propsRef = (0,react.useRef)(props);
  propsRef.current = props;
  const interactivePrimitiveRef = (0,react.useRef)(null);
  const classNameElevated = (_propsRef$current$cla = propsRef.current.classNameElevated) !== null && _propsRef$current$cla !== void 0 ? _propsRef$current$cla : Pressable.elevated;
  const {
    color: {
      [propsRef.current.variant]: {
        shadow,
        background,
        text,
        border
      }
    },
    sound: {
      [propsRef.current.variant]: semanticSound
    },
    component: {
      pressable: {
        texture
      }
    }
  } = useSemanticTokens();
  const inheritedRole = useInheritSemanticRole();
  const textureForRole = texture[propsRef.current.variant !== 'inherit' ? propsRef.current.variant : inheritedRole].interactive;
  const classNameElevatedAndPressed = classnames_default()({
    [(_propsRef$current$cla2 = propsRef.current.classNameElevatedAndPressed) !== null && _propsRef$current$cla2 !== void 0 ? _propsRef$current$cla2 : Pressable.elevatedAndPressed]: propsRef.current.shouldNotDepressWhenPressed !== true
  });
  const className = classnames_default()(...(textureForRole != null ? [textureForRole] : [shadow.interactive, border.interactive]), {
    [classNameElevated]: propsRef.current.isElevated,
    [Pressable.horizontal]: propsRef.current.horizontal
  });
  const classNameShine = classnames_default()(Pressable.shine, Pressable.shineBackground, Pressable.shineText, propsRef.current.className != null ? propsRef.current.className : undefined, textureForRole != null ? undefined : background.interactive, text.interactive);
  const classNameFocused = classnames_default()(focusClass, propsRef.current.classNameFocused);
  return /*#__PURE__*/react.createElement(BoxBorder, Pressable_extends({
    autofocus: propsRef.current.autofocus,
    disabled: propsRef.current.disabled,
    disableScrollIntoView: propsRef.current.disableScrollIntoView,
    className: className,
    classNameFocused: classNameFocused,
    classNameHovered: propsRef.current.classNameHovered,
    "data-testid": propsRef.current['data-testid'],
    classNamePressed: propsRef.current.isElevated ? classNameElevatedAndPressed : undefined,
    delayedClick: propsRef.current.delayedClick,
    gamepadAlias: propsRef.current.gamepadAlias,
    gamepadIndex: propsRef.current.gamepadIndex,
    innerRef: interactivePrimitiveRef,
    inputLegend: propsRef.current.inputLegend,
    onClick: propsRef.current.onClick,
    onFocusChanged: propsRef.current.onFocusChanged,
    onHoverChanged: propsRef.current.onHoverChanged,
    soundEffectHovered: (_propsRef$current$sou = propsRef.current.soundEffectHovered) !== null && _propsRef$current$sou !== void 0 ? _propsRef$current$sou : semanticSound.hover,
    soundEffectFocused: (_propsRef$current$sou2 = propsRef.current.soundEffectFocused) !== null && _propsRef$current$sou2 !== void 0 ? _propsRef$current$sou2 : semanticSound.focus,
    soundEffectPressed: (_propsRef$current$sou3 = propsRef.current.soundEffectPressed) !== null && _propsRef$current$sou3 !== void 0 ? _propsRef$current$sou3 : semanticSound.press,
    pressDuration: propsRef.current.pressDuration
  }, 'narrationText' in propsRef.current ? {
    narrationText: propsRef.current.narrationText
  } : {
    getNarrationText: propsRef.current.getNarrationText,
    narrationId: propsRef.current.narrationId
  }), textureForRole == null && (propsRef.current.focusStateOnElevatedFace ? /*#__PURE__*/react.createElement("div", {
    className: Pressable.bottomOffset
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    role: propsRef.current.variant,
    disabled: propsRef.current.disabled
  })) : /*#__PURE__*/react.createElement(Focus_Focus, {
    role: propsRef.current.variant,
    disabled: propsRef.current.disabled
  })), /*#__PURE__*/react.createElement("div", {
    className: classNameShine,
    style: propsRef.current.height != null ? {
      height: `${propsRef.current.height}rem`
    } : undefined
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, Pressable_extends({
    effect: propsRef.current.reflection,
    disabled: textureForRole != null || propsRef.current.disabled,
    role: propsRef.current.variant
  }, (_propsRef$current$ref = propsRef.current.reflectionConfig) !== null && _propsRef$current$ref !== void 0 ? _propsRef$current$ref : {})), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Pressable.raised, Pressable.shine)
  }, props.children)));
}
;// CONCATENATED MODULE: ./packages/ui/src/Button/Button.tsx








const Button_noop = () => {};

const getVariant = variant => {
  switch (variant) {
    case 'primary':
    case 'secondary':
      return 'secondaryButton';

    case 'destructive':
      return 'destructiveButton';

    default:
      return 'primaryButton';
  }
};

const Button_Button_Button = props => {
  const {
    children,
    variant = 'secondary',
    imgSrc,
    onClick = Button_noop,
    narrationPrefix: accessibilityPrefix = children,
    narrationSuffix: accessibilitySuffix = '',
    disabled,
    soundEffectPressed,
    soundEffectHovered,
    soundEffectFocused,
    delayedClick,
    horizontal,
    linebreak = false,
    isElevated = true,
    autofocus,
    gamepadIndex = 0,
    gamepadAlias,
    disableScrollIntoView,
    inputLegend,
    onFocusChanged,
    disabledTextOverride
  } = props;
  const {
    t
  } = useLocalization('Button');
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const hasShadowFacet = (0,react_facet_src.useFacetMap)(disabled => variant === 'hero' && !disabled, [variant], [disabledFacet]);
  const narrationText = (0,react_facet_src.useFacetMap)((prefix, suffix) => `${prefix} . ${t('.button')} . ${suffix}`, [t], [(0,react_facet_src.useFacetWrap)(accessibilityPrefix), (0,react_facet_src.useFacetWrap)(accessibilitySuffix)]);
  const hasImg = (0,react_facet_src.useFacetMap)(imgSrc => imgSrc != null, [], [(0,react_facet_src.useFacetWrap)(imgSrc)]);
  return /*#__PURE__*/react.createElement(Pressable_Pressable, {
    isElevated: isElevated,
    delayedClick: delayedClick,
    narrationText: narrationText,
    className: Button_Button.container,
    "data-testid": props['data-testid'],
    classNameHovered: Button_Button.hovered,
    classNameFocused: Button_Button.focused,
    classNamePressed: Button_Button.pressed,
    classNameElevated: Button_Button.elevated,
    classNameElevatedAndPressed: Button_Button.elevatedAndPressed,
    disabled: disabled,
    gamepadIndex: gamepadIndex,
    inputLegend: inputLegend,
    autofocus: autofocus,
    gamepadAlias: gamepadAlias,
    disableScrollIntoView: disableScrollIntoView,
    onClick: onClick,
    soundEffectPressed: soundEffectPressed,
    soundEffectHovered: soundEffectHovered,
    soundEffectFocused: soundEffectFocused,
    horizontal: horizontal,
    variant: variant !== 'hero' ? variant : 'primary',
    onFocusChanged: onFocusChanged
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: Button_Button.labelContainer
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasImg
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    imageRendering: "pixelated",
    className: Button_Button.image,
    src: imgSrc
  })), /*#__PURE__*/react.createElement(Typography_Typography, {
    align: linebreak ? 'center' : undefined,
    variant: getVariant(variant),
    color: "inherit",
    shadow: hasShadowFacet,
    children: linebreak ? // Don't wrap this in a fragment or it breaks when rendering facet children
    disabledTextOverride !== null && disabledTextOverride !== void 0 ? disabledTextOverride : children : /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, disabledTextOverride !== null && disabledTextOverride !== void 0 ? disabledTextOverride : children)
  })));
};
;// CONCATENATED MODULE: ./packages/ui/src/TextField/TextFieldWithButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const TextFieldWithButton = ({"textFieldWithButtonWrapper":"L6uh_","textFieldWithButtonInput":"XpDm4","textFieldWithButtonButtonWrapper":"JA_ZQ"});
;// CONCATENATED MODULE: ./packages/ui/src/useAnimation/animations.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const animations = ({"shake":"NFMf6","shakeAnimation":"o50Eb"});
;// CONCATENATED MODULE: ./packages/ui/src/useAnimation/useAnimation.ts



let AnimationType;

(function (AnimationType) {
  AnimationType[AnimationType["HORIZONTAL_SHAKE"] = 0] = "HORIZONTAL_SHAKE";
})(AnimationType || (AnimationType = {}));

const useAnimation_animations = {
  [AnimationType.HORIZONTAL_SHAKE]: {
    className: animations.shake,
    duration: 200
  }
};
const NO_ANIMATION_CLASSNAME = '';
function useAnimation(type = AnimationType.HORIZONTAL_SHAKE) {
  const [classNameFacet, setClassNameFacet] = (0,react_facet_src.useFacetState)(NO_ANIMATION_CLASSNAME);
  const timeoutRef = (0,react.useRef)();
  const trigger = (0,react.useCallback)(() => {
    const animation = useAnimation_animations[type];
    setClassNameFacet(animation.className);
    timeoutRef.current = setTimeout(() => {
      setClassNameFacet(NO_ANIMATION_CLASSNAME);
    }, animation.duration);
  }, [type, setClassNameFacet]);
  (0,react.useEffect)(() => () => clearTimeout(timeoutRef.current), []);
  return [trigger, classNameFacet];
}
;// CONCATENATED MODULE: ./packages/ui/src/TextField/TextFieldValidation.ts
let TextFieldValidationResult;

(function (TextFieldValidationResult) {
  TextFieldValidationResult[TextFieldValidationResult["VALID"] = 0] = "VALID";
  TextFieldValidationResult[TextFieldValidationResult["INVALID"] = 1] = "INVALID";
})(TextFieldValidationResult || (TextFieldValidationResult = {}));
;// CONCATENATED MODULE: ./packages/ui/src/TextField/narration.ts

// Helper function for ordering the narration of disabled text input
function useDisabledNarration(t, label, value, description, placeholder, // Used to narrate more context on how to enable the text field
disabledNarrationSuffix) {
  return (0,react_facet_src.useFacetMap)((label, value, description, disabledNarrationSuffix) => [label, t('.narrationComponentType'), t('.disabled'), value || placeholder != null && placeholder || t('.empty'), description, disabledNarrationSuffix].filter(token => token != null).join(' - '), [t, placeholder], [label, value, description, (0,react_facet_src.useFacetWrap)(disabledNarrationSuffix !== null && disabledNarrationSuffix !== void 0 ? disabledNarrationSuffix : '')]);
} // Helper function for ordering the narration of text input

function useNarration(t, label, value, description, placeholder) {
  return (0,react_facet_src.useFacetMap)((label, value, description) => [label, t('.narrationComponentType'), value || placeholder != null && placeholder || t('.empty'), description].filter(token => token != null).join(' - '), [t, placeholder], [label, value, description]);
}
;// CONCATENATED MODULE: ./packages/ui/src/TextField/TextFieldWithButton.tsx
function TextFieldWithButton_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TextFieldWithButton_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function TextFieldWithButton_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }














const TextFieldWithButton_noop = () => {};
/**
 * TextFieldWithButton
 * -
 * This component shares similarities with the default TextField, with the addition
 * of a secondary Button after the input. We could abstract out the facets/narration
 * to avoid code duplication, but I think that will be over-engineering the problem
 * given that the behaviour of the component may need to differ from the default
 * TextField in the future.
 */


function TextFieldWithButton_TextFieldWithButton({
  autofocus,
  gamepadAlias,
  value,
  disabled = false,
  label,
  maxLength = 50000,
  onChange = TextFieldWithButton_noop,
  onBlur,
  placeholder,
  description = '',
  rows = 1,
  gamepadIndex,
  // Button narration hint that is more descriptive than the field label
  buttonNarrationHint,
  // Used to narrate more context on why this component is disabled
  disabledNarrationSuffix,
  isNumber,
  textDisabled = false,
  buttonText,
  buttonInputLegend = '',
  buttonDisabled = false,
  buttonOnClick = TextFieldWithButton_noop,
  soundEffectButtonPressed
}) {
  const {
    t
  } = useLocalization('TextField');
  const {
    t: t2
  } = useLocalization('TextFieldWithButton');
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledNarrationSuffixFacet = (0,react_facet_src.useFacetWrap)(disabledNarrationSuffix !== null && disabledNarrationSuffix !== void 0 ? disabledNarrationSuffix : '');
  const narrationEnabled = useNarrationEnabled();
  const labelFacet = (0,react_facet_src.useFacetWrap)(label);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const descriptionFacet = (0,react_facet_src.useFacetWrap)(description);
  const descriptionWithNavigationHint = (0,react_facet_src.useFacetMap)(description => `${description} . ${t2('.navigationHint')}`, [t2], [descriptionFacet]);
  const textDisabledFacet = (0,react_facet_src.useFacetWrap)(textDisabled);
  const buttonDisabledFacet = (0,react_facet_src.useFacetWrap)(buttonDisabled);
  const [triggerShakeAnimation, animationClassName] = useAnimation(AnimationType.HORIZONTAL_SHAKE);
  const ref = (0,react.useRef)(null);
  const narrationTextFacet = useNarration(t, labelFacet, valueFacet, descriptionWithNavigationHint, placeholder);
  const disabledNarration = useDisabledNarration(t, labelFacet, valueFacet, descriptionWithNavigationHint, placeholder, disabledNarrationSuffixFacet);
  const rowOptions = (0,react_facet_src.useFacetMap)(disabled => ({
    index: gamepadIndex,
    disabled: narrationEnabled && disabled,
    defaultFocusedChildBehavior: 'first'
  }), [narrationEnabled, gamepadIndex], [disabledFacet]);
  const onBlurHandler = (0,react.useCallback)((value, setValue) => {
    if (onBlur != null) {
      const validationResult = onBlur(value, setValue);

      switch (validationResult) {
        case TextFieldValidationResult.INVALID:
          triggerShakeAnimation();
      }
    }
  }, [onBlur, triggerShakeAnimation]);
  return /*#__PURE__*/react.createElement(TextFieldWrapper, {
    disabled: disabledFacet,
    label: labelFacet,
    gamepadIndex: gamepadIndex,
    description: descriptionFacet,
    disabledNarrationText: disabledNarration
  }, /*#__PURE__*/react.createElement(MaybeRow, {
    shouldSkipLandmarkInVisual: true,
    scrollRef: ref,
    options: rowOptions,
    disabled: disabledFacet
  }, /*#__PURE__*/react.createElement("div", {
    className: TextFieldWithButton.textFieldWithButtonWrapper
  }, /*#__PURE__*/react.createElement("div", {
    className: TextFieldWithButton.textFieldWithButtonInput
  }, /*#__PURE__*/react.createElement(BaseTextField_BaseTextField, {
    className: animationClassName,
    autofocus: autofocus,
    placeholder: placeholder,
    disabled: (0,react_facet_src.useFacetMap)((textDisabled, disabled) => textDisabled || disabled, [], [textDisabledFacet, disabledFacet]),
    label: labelFacet,
    gamepadAlias: gamepadAlias,
    gamepadIndex: 0,
    maxLength: maxLength,
    narrationText: narrationTextFacet,
    value: value,
    onChange: onChange,
    onBlur: onBlurHandler,
    isNumber: isNumber,
    rows: rows,
    shouldBlurOnEnter: true,
    shouldBlurOnEscape: true
  })), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    className: TextFieldWithButton.textFieldWithButtonButtonWrapper
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: buttonInputLegend,
    disabled: (0,react_facet_src.useFacetMap)((buttonDisabled, disabled) => buttonDisabled || disabled, [], [buttonDisabledFacet, disabledFacet]),
    onClick: buttonOnClick,
    soundEffectPressed: soundEffectButtonPressed,
    narrationSuffix: buttonNarrationHint
  }, buttonText)))));
}

const MaybeRow = (_ref) => {
  let {
    children,
    disabled
  } = _ref,
      props = TextFieldWithButton_objectWithoutProperties(_ref, ["children", "disabled"]);

  const isNarrationEnabled = useNarrationEnabled();
  const disabledValue = (0,react_facet_src.useFacetUnwrap)(disabled) === true;
  return isNarrationEnabled || disabledValue === false ? /*#__PURE__*/react.createElement(Row, props, children) : /*#__PURE__*/react.createElement(react.Fragment, null, children);
};
;// CONCATENATED MODULE: ./packages/ui/src/TextField/TextField.tsx










const TextField_noop = () => {};

function TextField({
  autofocus,
  gamepadAlias,
  value,
  disabled = false,
  // We set the default maxLength value to 50000 as this is the default value in Bedrock
  // and we must set a max length. This is just to make sure that the Gameface and Bedrock
  // input matches and does not go out of sync
  maxLength = 50000,
  onChange = TextField_noop,
  onBlur,
  placeholder,
  description = '',
  label,
  rows = 1,
  gamepadIndex,
  disabledNarrationSuffix,
  isNumber,
  transparent
}) {
  const {
    t
  } = useLocalization('TextField');
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledNarrationSuffixFacet = (0,react_facet_src.useFacetWrap)(disabledNarrationSuffix !== null && disabledNarrationSuffix !== void 0 ? disabledNarrationSuffix : '');
  const descriptionFacet = (0,react_facet_src.useFacetWrap)(description);
  const labelFacet = (0,react_facet_src.useFacetWrap)(label);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const transparentFacet = (0,react_facet_src.useFacetWrap)(transparent);
  const [triggerShakeAnimation, animationClassName] = useAnimation(AnimationType.HORIZONTAL_SHAKE);
  const narrationTextFacet = useNarration(t, labelFacet, valueFacet, descriptionFacet, placeholder);
  const disabledNarration = useDisabledNarration(t, labelFacet, valueFacet, descriptionFacet, placeholder, disabledNarrationSuffixFacet);
  const onBlurHandler = (0,react.useCallback)((value, setValue) => {
    if (onBlur != null) {
      const validationResult = onBlur(value, setValue);

      switch (validationResult) {
        case TextFieldValidationResult.INVALID:
          triggerShakeAnimation();
      }
    }
  }, [onBlur, triggerShakeAnimation]);
  return /*#__PURE__*/react.createElement(TextFieldWrapper, {
    disabled: disabledFacet,
    label: labelFacet,
    gamepadIndex: gamepadIndex,
    description: descriptionFacet,
    transparent: transparentFacet // The disabled narration in the TextFieldWrapper allows the user to listen to all relevant
    // field information even though the inner TextField is not interactive
    ,
    disabledNarrationText: disabledNarration
  }, /*#__PURE__*/react.createElement(BaseTextField_BaseTextField, {
    className: animationClassName,
    autofocus: autofocus,
    placeholder: placeholder,
    disabled: disabled,
    label: labelFacet,
    gamepadAlias: gamepadAlias,
    gamepadIndex: gamepadIndex,
    maxLength: maxLength,
    narrationText: narrationTextFacet,
    value: value,
    onChange: onChange,
    rows: rows,
    onBlur: onBlurHandler,
    isNumber: isNumber,
    shouldBlurOnEnter: true,
    shouldBlurOnEscape: true
  }));
}
TextField.WithButton = TextFieldWithButton_TextFieldWithButton;
TextField.ValidationResult = TextFieldValidationResult;
;// CONCATENATED MODULE: ./packages/ui/src/ProgressBar/ProgressBar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ProgressBar = ({"progressBarWrapper":"q6zFV","progressBar":"oOBki","tall":"f6wZX"});
;// CONCATENATED MODULE: ./packages/ui/src/ProgressBar/ProgressBar.tsx





/**
 * Base types
 */

function ProgressBar_ProgressBar({
  percentage,
  tall = false,
  // Hardcoding the hex value below, because vars don't work with inline styles in Gameface
  fillColor = '#2e6be5',
  fillColorThresholds
}) {
  const percentageFacet = (0,react_facet_src.useFacetWrap)(percentage);
  const tallFacet = (0,react_facet_src.useFacetWrap)(tall);

  if ((percentage < 0 || percentage > 1) && "production" !== 'test') {
    console.warn('Percentage needs to be a valid number from 0 to 1');
  }

  const thresholdsSorted = (0,react.useMemo)(() => fillColorThresholds != null ? Object.keys(fillColorThresholds).map(x => x).sort((a, b) => a > b ? 1 : -1) : undefined, [fillColorThresholds]);
  const barBackgroundColor = (0,react_facet_src.useFacetMap)((fillColor, percentage) => {
    // If there are no thresholds, use the given fillColor
    if (thresholdsSorted == null || fillColorThresholds == null) {
      return fillColor;
    } // If there are no thresholds, return the default color.


    if (thresholdsSorted.length === 0) {
      console.warn('Empty thresholds object passed to ProgressBar.');
      return fillColor;
    } // Loop down all the thresholds until we find one we're
    // higher than, then use that color.


    for (let i = thresholdsSorted.length; i >= 0; i--) {
      if (percentage >= thresholdsSorted[i]) {
        return fillColorThresholds[thresholdsSorted[i]];
      }
    } // If the percentage was never greater than any of the thresholds, return the default fillColor.


    return fillColor;
  }, [fillColorThresholds, thresholdsSorted], [(0,react_facet_src.useFacetWrap)(fillColor), percentageFacet]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(tall => classnames_default()(ProgressBar.progressBarWrapper, {
      [ProgressBar.tall]: tall
    }), [], [tallFacet])
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel",
    thin: true,
    reversed: true
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(tall => classnames_default()(ProgressBar.progressBar, {
      [ProgressBar.tall]: tall
    }), [], [tallFacet]),
    style: {
      width: (0,react_facet_src.useFacetMap)(percentage => `${Math.max(Math.min(Math.round(percentage * 100), 100), 0)}%`, [], [percentageFacet]),
      backgroundColor: barBackgroundColor
    }
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel",
    thin: true,
    right: false
  })));
}
;// CONCATENATED MODULE: ./packages/ui/src/NavigationButton/NavigationButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NavigationButton = ({"button":"GbrtL","disabled":"Jw526"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationButton/NavigationButton.tsx







const NavigationButton_NavigationButton = ({
  narrationText,
  inputLegend,
  disabled,
  onClick,
  children,
  gamepadIndex,
  gamepadAlias,
  role = 'inherit',
  soundEffectPressed,
  className
}) => {
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const {
    color: {
      [role]: semanticClassNames
    },
    sound: {
      [role]: semanticSound
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    narrationText: narrationText,
    className: classnames_default()(NavigationButton.button, semanticClassNames.background.interactive, semanticClassNames.text.interactive, className),
    classNameFocused: focusClass,
    classNameDisabled: NavigationButton.disabled,
    gamepadIndex: gamepadIndex,
    gamepadAlias: gamepadAlias,
    inputLegend: inputLegend,
    onClick: onClick,
    disabled: disabledFacet,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.press
  }, children, /*#__PURE__*/react.createElement(Focus_Focus, {
    inset: true,
    role: role
  }));
};
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/InputLegend.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InputLegend = ({"InputLegend":"FGHxt","hidden":"mdtlU"});
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/Wrapper.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InputLegend_Wrapper = ({"Custom":"_iCp3","wrapper":"HvYsi","leftContainer":"gB3x9","rightContainer":"Gehqy"});
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/constants.ts
const constants_INPUT_LEGEND_BASE_HEIGHT = 4;
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/Wrapper.tsx





function InputLegendWrapper({
  safeZone: safeZoneOverride,
  left,
  right
}) {
  const originalSafeZone = useSafeZone();
  const safeZone = safeZoneOverride || originalSafeZone;
  return /*#__PURE__*/react.createElement("div", {
    className: InputLegend_Wrapper.Custom,
    style: {
      height: `calc(${constants_INPUT_LEGEND_BASE_HEIGHT}rem + ${safeZone.bottom}px)`
    }
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular",
    thin: true,
    left: false,
    right: false,
    bottom: false
  }), /*#__PURE__*/react.createElement("div", {
    className: InputLegend_Wrapper.wrapper,
    style: {
      height: `${constants_INPUT_LEGEND_BASE_HEIGHT}rem`,
      paddingRight: safeZone.right + 'px',
      paddingLeft: safeZone.left + 'px'
    }
  }, left != null ? /*#__PURE__*/react.createElement("div", {
    className: InputLegend_Wrapper.leftContainer
  }, left) : null, right != null ? /*#__PURE__*/react.createElement("div", {
    className: InputLegend_Wrapper.rightContainer
  }, right) : null));
}
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/Space.tsx





function InputLegendSpace({
  extraSpace,
  children
}) {
  const wrapperClassName = (0,react_facet_src.useFacetMap)(isGamepad => {
    return isGamepad ? '' : InputLegend.hidden;
  }, [], [useIsFocusInputGamepad()]);
  const safeZone = useSafeZone();
  return /*#__PURE__*/react.createElement("fast-div", {
    className: wrapperClassName
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      height: `calc(${constants_INPUT_LEGEND_BASE_HEIGHT}rem + ${safeZone.bottom}px)`
    }
  }, children), extraSpace);
}
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/XboxImages/XboxIcons.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const XboxIcons = ({"XboxButtonA":"OHrZ8","small":"vMjA2","XboxButtonB":"fg2E4","XboxButtonX":"iQyId","XboxButtonY":"pxPk9","XboxButtonStart":"oDCN0","XboxButtonLT":"WyyoK","XboxButtonRT":"aOFj8","XboxButtonLB":"GS50F","XboxButtonRB":"mKs6r","XboxButtonLeft":"pDhLW","XboxButtonRight":"wK3Xd","XboxButtonUp":"nlvNB","XboxButtonDown":"J9MtE","XboxButtonSelect":"QvCIw","XboxButtonL3":"Fqdok","XboxButtonR3":"yqVFC","XboxButtonLS":"v0Ce5","XboxButtonRS":"i4uVO","large":"aItg1","iconSize":"liriy","ABXY":"VLERn","triggers":"UoTWb","bumpers":"l5n3u","flatTriggers":"_U_vn","dButton":"xN6WQ","startXbox":"eVmaS","toggleViewXbox":"RjcUU","stick":"eMLrL"});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/XboxImages/index.ts



const XboxImages = {
  [types_ButtonType.A]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonA, XboxIcons.ABXY),
  [types_ButtonType.B]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonB, XboxIcons.ABXY),
  [types_ButtonType.X]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonX, XboxIcons.ABXY),
  [types_ButtonType.Y]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonY, XboxIcons.ABXY),
  [types_ButtonType.START]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonStart, XboxIcons.startXbox),
  [types_ButtonType.LEFT_TRIGGER]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonLT, XboxIcons.triggers),
  [types_ButtonType.RIGHT_TRIGGER]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonRT, XboxIcons.triggers),
  [types_ButtonType.LEFT_BUMPER]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonLB, XboxIcons.bumpers),
  [types_ButtonType.RIGHT_BUMPER]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonRB, XboxIcons.bumpers),
  [types_ButtonType.LEFT]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonLeft, XboxIcons.dButton),
  [types_ButtonType.RIGHT]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonRight, XboxIcons.dButton),
  [types_ButtonType.UP]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonUp, XboxIcons.dButton),
  [types_ButtonType.DOWN]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonDown, XboxIcons.dButton),
  [types_ButtonType.SELECT]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonSelect, XboxIcons.toggleViewXbox),
  [types_ButtonType.L3]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonL3, XboxIcons.stick),
  [types_ButtonType.R3]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonR3, XboxIcons.stick),
  [types_ButtonType.LEFT_ANALOG_LEFT]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonLS, XboxIcons.stick),
  [types_ButtonType.RIGHT_ANALOG_LEFT]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonRS, XboxIcons.stick),
  ['large']: XboxIcons.large,
  ['small']: XboxIcons.small
};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PS4Images/PS4Icons.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PS4Icons = ({"PS4ButtonA":"saRDS","small":"VqfCS","PS4ButtonB":"fq1Wt","PS4ButtonX":"KeNau","PS4ButtonY":"e7md4","PS4ButtonStart":"kqt1L","PS4ButtonLT":"DckFK","PS4ButtonRT":"RYAZU","PS4ButtonLB":"U6swu","PS4ButtonRB":"G58dQ","PS4ButtonLeft":"huNm8","PS4ButtonRight":"JHI_T","PS4ButtonUp":"dkG8m","PS4ButtonDown":"xESXG","PS4ButtonTouchpad":"Ep0S5","PS4ButtonL3":"Khy_Q","PS4ButtonR3":"W_0vF","PS4ButtonLS":"JoHy1","PS4ButtonRS":"xI7dX","large":"OQ6xf","iconSize":"YQeSi","ABXY":"at3wP","triggers":"z4huI","bumpers":"hjYMG","flatTriggers":"bSrtd","dButton":"pdEm6","optionsPS4":"TvAgE","sharePS4":"TbNT7","stick":"FkFaw"});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PS4Images/index.ts



const PS4Images = {
  [types_ButtonType.A]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonA, PS4Icons.ABXY),
  [types_ButtonType.B]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonB, PS4Icons.ABXY),
  [types_ButtonType.X]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonX, PS4Icons.ABXY),
  [types_ButtonType.Y]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonY, PS4Icons.ABXY),
  [types_ButtonType.START]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonStart, PS4Icons.optionsPS4),
  [types_ButtonType.LEFT_TRIGGER]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonLT, PS4Icons.flatTriggers),
  [types_ButtonType.RIGHT_TRIGGER]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonRT, PS4Icons.flatTriggers),
  [types_ButtonType.LEFT_BUMPER]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonLB, PS4Icons.bumpers),
  [types_ButtonType.RIGHT_BUMPER]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonRB, PS4Icons.bumpers),
  [types_ButtonType.LEFT]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonLeft, PS4Icons.dButton),
  [types_ButtonType.RIGHT]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonRight, PS4Icons.dButton),
  [types_ButtonType.UP]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonUp, PS4Icons.dButton),
  [types_ButtonType.DOWN]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonDown, PS4Icons.dButton),
  [types_ButtonType.SELECT]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonTouchpad, PS4Icons.sharePS4),
  [types_ButtonType.L3]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonL3, PS4Icons.stick),
  [types_ButtonType.R3]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonR3, PS4Icons.stick),
  [types_ButtonType.LEFT_ANALOG_LEFT]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonLS, PS4Icons.stick),
  [types_ButtonType.RIGHT_ANALOG_LEFT]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonRS, PS4Icons.stick),
  ['large']: PS4Icons.large,
  ['small']: PS4Icons.small
};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PS5Images/PS5Icons.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PS5Icons = ({"PS5ButtonA":"s5WBf","small":"z6TF3","PS5ButtonB":"Kv7uC","PS5ButtonX":"kYWOu","PS5ButtonY":"WtpwV","PS5ButtonStart":"lACg4","PS5ButtonLT":"wxIDB","PS5ButtonRT":"X2Vmd","PS5ButtonLB":"tHBmF","PS5ButtonRB":"n1nsL","PS5ButtonLeft":"FOhDs","PS5ButtonRight":"xALny","PS5ButtonUp":"h2Qqa","PS5ButtonDown":"f8TY5","PS5ButtonTouchpad":"f2Ygw","PS5ButtonL3":"qxa8S","PS5ButtonR3":"KhF5i","PS5ButtonLS":"lEWFT","PS5ButtonRS":"GcMtB","large":"YG8U4","iconSize":"oYpoG","ABXY":"rgQQy","triggers":"HSGw6","bumpers":"NHxos","flatTriggers":"bWa3v","dButton":"bkeIb","optionsPS5":"M2OrT","sharePS5":"M_q6y","stick":"EtpTm"});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PS5Images/index.ts



const PS5Images = {
  [types_ButtonType.A]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonA, PS5Icons.ABXY),
  [types_ButtonType.B]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonB, PS5Icons.ABXY),
  [types_ButtonType.X]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonX, PS5Icons.ABXY),
  [types_ButtonType.Y]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonY, PS5Icons.ABXY),
  [types_ButtonType.START]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonStart, PS5Icons.optionsPS5),
  [types_ButtonType.LEFT_TRIGGER]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonLT, PS5Icons.flatTriggers),
  [types_ButtonType.RIGHT_TRIGGER]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonRT, PS5Icons.flatTriggers),
  [types_ButtonType.LEFT_BUMPER]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonLB, PS5Icons.bumpers),
  [types_ButtonType.RIGHT_BUMPER]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonRB, PS5Icons.bumpers),
  [types_ButtonType.LEFT]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonLeft, PS5Icons.dButton),
  [types_ButtonType.RIGHT]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonRight, PS5Icons.dButton),
  [types_ButtonType.UP]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonUp, PS5Icons.dButton),
  [types_ButtonType.DOWN]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonDown, PS5Icons.dButton),
  [types_ButtonType.SELECT]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonTouchpad, PS5Icons.sharePS5),
  [types_ButtonType.L3]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonL3, PS5Icons.stick),
  [types_ButtonType.R3]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonR3, PS5Icons.stick),
  [types_ButtonType.LEFT_ANALOG_LEFT]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonLS, PS5Icons.stick),
  [types_ButtonType.RIGHT_ANALOG_LEFT]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonRS, PS5Icons.stick),
  ['large']: PS5Icons.large,
  ['small']: PS5Icons.small
};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/NintendoImages/NintendoIcons.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NintendoIcons = ({"NintendoButtonA":"qRaP6","small":"P1SbE","NintendoButtonB":"AI6pj","NintendoButtonX":"_MHws","NintendoButtonY":"B5rVg","NintendoButtonStart":"sp3nW","NintendoButtonLT":"Vdaoj","NintendoButtonRT":"_O7W7","NintendoButtonLB":"oQWb_","NintendoButtonRB":"u1YVo","NintendoButtonLeft":"tkRUh","NintendoButtonRight":"e3hRs","NintendoButtonUp":"znMgA","NintendoButtonDown":"Ghttt","NintendoButtonSelect":"jyA7I","NintendoButtonL3":"ejTg5","NintendoButtonR3":"wIh1n","NintendoButtonLS":"uxDU0","NintendoButtonRS":"RBEvC","iconSize":"K_Ucb","ABXY":"MC54K","triggers":"BXc9M","bumpers":"Yh8am","flatTriggers":"f12Q1","dButton":"chFOJ","homeNintendo":"lfQSn","minusNintendo":"gnCaZ","stick":"ApnkV","large":"h7tik"});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/NintendoImages/index.ts



const NintendoImages = {
  [types_ButtonType.A]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonA, NintendoIcons.ABXY),
  [types_ButtonType.B]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonB, NintendoIcons.ABXY),
  [types_ButtonType.X]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonX, NintendoIcons.ABXY),
  [types_ButtonType.Y]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonY, NintendoIcons.ABXY),
  [types_ButtonType.START]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonStart, NintendoIcons.homeNintendo),
  [types_ButtonType.LEFT_TRIGGER]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonLT, NintendoIcons.flatTriggers),
  [types_ButtonType.RIGHT_TRIGGER]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonRT, NintendoIcons.flatTriggers),
  [types_ButtonType.LEFT_BUMPER]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonLB, NintendoIcons.bumpers),
  [types_ButtonType.RIGHT_BUMPER]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonRB, NintendoIcons.bumpers),
  [types_ButtonType.LEFT]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonLeft, NintendoIcons.dButton),
  [types_ButtonType.RIGHT]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonRight, NintendoIcons.dButton),
  [types_ButtonType.UP]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonUp, NintendoIcons.dButton),
  [types_ButtonType.DOWN]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonDown, NintendoIcons.dButton),
  [types_ButtonType.SELECT]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonSelect, NintendoIcons.minusNintendo),
  [types_ButtonType.L3]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonL3, NintendoIcons.stick),
  [types_ButtonType.R3]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonR3, NintendoIcons.stick),
  [types_ButtonType.LEFT_ANALOG_LEFT]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonLS, NintendoIcons.stick),
  [types_ButtonType.RIGHT_ANALOG_LEFT]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonRS, NintendoIcons.stick),
  ['large']: NintendoIcons.large,
  ['small']: NintendoIcons.small
};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/Gamepad.tsx








function ButtonIconGamepad({
  button,
  theme = 'light'
}) {
  const platformSelected = usePlatformSelected();
  const buttonFacet = (0,react_facet_src.useFacetWrap)(button);
  const buttonClassnames = (0,react_facet_src.useFacetMap)((buttonValue, platformSelected) => {
    const platformAssets = mapPlatformEnumToImages(platformSelected);

    if (!platformAssets[buttonValue]) {
      return '';
    }

    return classnames_default()(platformAssets[buttonValue], {
      [platformAssets['large']]: theme === 'large',
      [platformAssets['small']]: theme === 'small'
    });
  }, [theme], [buttonFacet, platformSelected]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: buttonClassnames
  });
}

const mapPlatformEnumToImages = platform => {
  if (platform === Platform.XBOX) {
    return XboxImages;
  }

  if (platform === Platform.PS4) {
    return PS4Images;
  }

  if (platform === Platform.PS5) {
    return PS5Images;
  }

  if (platform === Platform.NX_HANDHELD || platform === Platform.NX_TV) {
    return NintendoImages;
  }

  return XboxImages;
};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/Keyboard.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Keyboard = ({"ButtonIconKeyboard":"bWVyX"});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PCImages/PCImages.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PCImages = ({"KeyboardKeyW":"auvwE","small":"roch1","KeyboardKeyA":"tBb_V","KeyboardKeyV":"iCLcl","KeyboardKeyS":"YOlJ6","KeyboardKeyT":"oMhZB","KeyboardKeyD":"VyL1w","KeyboardKeyQ":"tafjE","KeyboardKeyZ":"Hoaaj","KeyboardKeyE":"tpVOe","KeyboardKeyM":"Drtqa","KeyboardKeyR":"Zb3UU","KeyboardKeyX":"QxQ1Y","KeyboardKeyY":"QrQyh","KeyboardKeyF":"q9B4F","KeyboardKeyC":"tz71H","KeyboardKey1":"cuPgL","KeyboardKey2":"e5wNF","KeyboardKey3":"ppvtq","KeyboardKey4":"Y81IB","KeyboardKey5":"m3hWH","KeyboardKey6":"_2osj","KeyboardKey7":"GKXym","KeyboardKey8":"czhOA","KeyboardKey9":"qHgTt","KeyboardKey0":"TbhIT","KeyboardKeyUp":"b7nKj","KeyboardKeyRight":"Lz1in","KeyboardKeyDown":"j_BNz","KeyboardKeyLeft":"OE2P1","KeyboardKeyESC":"Smnr0","KeyboardKeyBracketOpen":"uSqYm","KeyboardKeyBracketClose":"ekxWu","KeyboardKeyTab":"w8Ue4","KeyboardKeyShift":"PnyQi","KeyboardKeyEnter":"DaFVW","KeyboardKeySpace":"s89WE","KeyboardKeyCtrl":"sWwMn","darkTheme":"XJCBH","KeyboardKeyMouseLeft":"JqJ5A","KeyboardKeyMouseRight":"P_s1j","KeyboardKeyMouseCenter":"SWSY_","KeyboardKeyMouseScroll":"m3IeL","KeyboardKeyMouse":"T27KG","ButtonIconKeyboard":"BsHaW","ButtonIconKeyboardKey":"G7Zxr","large":"Gnnm7","ButtonIconKeyboardSpecialKey":"PITVu","ButtonIconKeyboardMouseButton":"SRDuY"});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PCImages/index.ts



const PCImages_PCImages = {
  [KeyboardKey.TAB]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyTab, PCImages.ButtonIconKeyboardSpecialKey),
  [KeyboardKey.ENTER]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyEnter, PCImages.ButtonIconKeyboardSpecialKey),
  [KeyboardKey.SHIFT]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyShift, PCImages.ButtonIconKeyboardSpecialKey),
  [KeyboardKey.ESCAPE]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyESC, PCImages.ButtonIconKeyboardSpecialKey),
  [KeyboardKey.SPACE]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeySpace, PCImages.ButtonIconKeyboardSpecialKey),
  [KeyboardKey.CTRL]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyCtrl, PCImages.ButtonIconKeyboardSpecialKey),
  [KeyboardKey.BRACKET_OPEN]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyBracketOpen),
  [KeyboardKey.BRACKET_CLOSE]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyBracketClose),
  [KeyboardKey.UP]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyUp),
  [KeyboardKey.RIGHT]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyRight),
  [KeyboardKey.DOWN]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyDown),
  [KeyboardKey.LEFT]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyLeft),
  [KeyboardKey.KEY_0]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey0),
  [KeyboardKey.KEY_1]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey1),
  [KeyboardKey.KEY_2]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey2),
  [KeyboardKey.KEY_3]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey3),
  [KeyboardKey.KEY_4]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey4),
  [KeyboardKey.KEY_5]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey5),
  [KeyboardKey.KEY_6]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey6),
  [KeyboardKey.KEY_7]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey7),
  [KeyboardKey.KEY_8]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey8),
  [KeyboardKey.KEY_9]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey9),
  [KeyboardKey.KEY_A]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyA),
  [KeyboardKey.KEY_C]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyC),
  [KeyboardKey.KEY_D]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyD),
  [KeyboardKey.KEY_E]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyE),
  [KeyboardKey.KEY_F]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyF),
  [KeyboardKey.KEY_M]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyM),
  [KeyboardKey.KEY_Q]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyQ),
  [KeyboardKey.KEY_R]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyR),
  [KeyboardKey.KEY_S]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyS),
  [KeyboardKey.KEY_T]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyT),
  [KeyboardKey.KEY_V]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyV),
  [KeyboardKey.KEY_W]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyW),
  [KeyboardKey.KEY_X]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyX),
  [KeyboardKey.KEY_Y]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyY),
  [KeyboardKey.KEY_Z]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyZ),
  [KeyboardKey.MOUSE_MOVEMENT]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyMouse, PCImages.ButtonIconKeyboardMouseButton),
  [KeyboardKey.MOUSE_BUTTON_LEFT]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyMouseLeft, PCImages.ButtonIconKeyboardMouseButton),
  [KeyboardKey.MOUSE_BUTTON_MIDDLE]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyMouseCenter, PCImages.ButtonIconKeyboardMouseButton),
  [KeyboardKey.MOUSE_BUTTON_RIGHT]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyMouseRight, PCImages.ButtonIconKeyboardMouseButton),
  [KeyboardKey.MOUSE_WHEEL]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyMouseScroll, PCImages.ButtonIconKeyboardMouseButton),
  [-2]: PCImages.large,
  // large icon sizing
  [-3]: PCImages.small // small icon sizing

};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/Keyboard.tsx





const ButtonIconKeyboard = ({
  keyCode,
  theme = 'light'
}) => {
  const keyCodeFacet = (0,react_facet_src.useFacetWrap)(keyCode);
  const classnameFacet = (0,react_facet_src.useFacetMap)(keyCode => {
    return PCImages_PCImages[keyCode] != null ? classnames_default()(PCImages_PCImages[keyCode], {
      [PCImages_PCImages[-2]]: theme === 'large',
      [PCImages_PCImages[-3]]: theme === 'small'
    }) : Keyboard.ButtonIconKeyboard;
  }, [theme], [keyCodeFacet]);
  const textFacet = (0,react_facet_src.useFacetMap)(keyCode => {
    return PCImages_PCImages[keyCode] == null ? String.fromCharCode(keyCode) : '';
  }, [], [keyCodeFacet]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: classnameFacet
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: textFacet
  }));
};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/index.ts


const ButtonIcon = {
  Gamepad: ButtonIconGamepad,
  Keyboard: ButtonIconKeyboard
};
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/InputHint.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InputHint = ({"InputHint":"r2rQH","hovered":"LJ0gR","pressed":"MMiKH","hintKeyBox":"X7C6X","hintGutter":"lX5qc","hidden":"Ob6kp"});
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/InputHint.tsx






function InputHint_InputHint(props) {
  const {
    label,
    theme = 'light',
    hidden = false,
    onClick,
    onHoverChanged
  } = props;
  const classNames = (0,react_facet_src.useFacetMap)(isHidden => classnames_default()(InputHint.InputHint, {
    [InputHint.hidden]: isHidden
  }), [], [(0,react_facet_src.useFacetWrap)(hidden)]);
  const content = /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: InputHint.hintKeyBox
  }, 'button' in props ? /*#__PURE__*/react.createElement(ButtonIcon.Gamepad, {
    button: props.button,
    theme: theme
  }) : /*#__PURE__*/react.createElement(ButtonIcon.Keyboard, {
    keyCode: props.keyCode,
    theme: theme
  })), /*#__PURE__*/react.createElement("div", {
    className: InputHint.hintGutter
  }), /*#__PURE__*/react.createElement("fast-text", {
    text: label
  }));

  if (onClick) {
    return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
      gamepadIndex: 0,
      narrationText: label,
      inputLegend: label,
      onHoverChanged: onHoverChanged,
      onClick: onClick,
      className: classNames,
      classNameHovered: InputHint.hovered,
      classNamePressed: InputHint.pressed,
      nonFocusable: true
    }, content);
  }

  return /*#__PURE__*/react.createElement("fast-div", {
    className: classNames
  }, content);
}
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/InputLegend.tsx








const InputLegend_INPUT_LEGEND_BASE_HEIGHT = 4;
function InputLegend_InputLegend({
  shouldDisplayKeyboard,
  isClickable = false
}) {
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(KeyboardInputLegend, {
    isClickable: isClickable,
    visible: (0,react_facet_src.useFacetMap)(isKeyboard => isKeyboard && !!shouldDisplayKeyboard, [shouldDisplayKeyboard], [useIsFocusInputKeyboard()])
  }), /*#__PURE__*/react.createElement(GamepadInputLegend, {
    isClickable: isClickable,
    visible: useIsFocusInputGamepad()
  }));
}

function KeyboardInputLegend({
  isClickable,
  visible
}) {
  const {
    swapABButtons,
    swapXYButtons
  } = useButtonMap();
  const inputLegends = useAvailableInputLegends();
  const callback = useInputLegendCallback();
  const [keyboardGamepadMapFacet] = useKeyboardGamepadMap();
  const keyboardGamepadMapValue = (0,react_facet_src.useFacetUnwrap)(keyboardGamepadMapFacet);
  const keyboardGamepadMap = keyboardGamepadMapValue === react_facet_src.NO_VALUE ? DEFAULT_KEYBOARD_GAMEPAD_MAP : keyboardGamepadMapValue;
  return /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(visible => visible ? InputLegend.InputLegend : InputLegend.hidden, [], [visible])
  }, /*#__PURE__*/react.createElement(InputLegend_InputLegend.Wrapper, {
    left: /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[swapABButtons ? types_ButtonType.A : types_ButtonType.B][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT;

        return (_inputLegends$ButtonT = inputLegends[types_ButtonType.B]) !== null && _inputLegends$ButtonT !== void 0 ? _inputLegends$ButtonT : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.B) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.B] != null, [], [inputLegends])
    }),
    right: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[types_ButtonType.LEFT][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT2;

        return (_inputLegends$ButtonT2 = inputLegends[types_ButtonType.LEFT]) !== null && _inputLegends$ButtonT2 !== void 0 ? _inputLegends$ButtonT2 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.LEFT) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.LEFT] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[types_ButtonType.RIGHT][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT3;

        return (_inputLegends$ButtonT3 = inputLegends[types_ButtonType.RIGHT]) !== null && _inputLegends$ButtonT3 !== void 0 ? _inputLegends$ButtonT3 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.RIGHT) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.RIGHT] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[types_ButtonType.UP][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT4;

        return (_inputLegends$ButtonT4 = inputLegends[types_ButtonType.UP]) !== null && _inputLegends$ButtonT4 !== void 0 ? _inputLegends$ButtonT4 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.UP) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.UP] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[types_ButtonType.DOWN][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT5;

        return (_inputLegends$ButtonT5 = inputLegends[types_ButtonType.DOWN]) !== null && _inputLegends$ButtonT5 !== void 0 ? _inputLegends$ButtonT5 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.DOWN) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.DOWN] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[swapXYButtons ? types_ButtonType.Y : types_ButtonType.X][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT6;

        return (_inputLegends$ButtonT6 = inputLegends[types_ButtonType.X]) !== null && _inputLegends$ButtonT6 !== void 0 ? _inputLegends$ButtonT6 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.X) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.X] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[swapXYButtons ? types_ButtonType.X : types_ButtonType.Y][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT7;

        return (_inputLegends$ButtonT7 = inputLegends[types_ButtonType.Y]) !== null && _inputLegends$ButtonT7 !== void 0 ? _inputLegends$ButtonT7 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.Y) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.Y] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[types_ButtonType.START][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT8;

        return (_inputLegends$ButtonT8 = inputLegends[types_ButtonType.START]) !== null && _inputLegends$ButtonT8 !== void 0 ? _inputLegends$ButtonT8 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.START) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.START] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[swapABButtons ? types_ButtonType.B : types_ButtonType.A][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT9;

        return (_inputLegends$ButtonT9 = inputLegends[types_ButtonType.A]) !== null && _inputLegends$ButtonT9 !== void 0 ? _inputLegends$ButtonT9 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.A) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.A] != null, [], [inputLegends])
    }))
  }));
}

function GamepadInputLegend({
  isClickable,
  visible
}) {
  const {
    swapABButtons,
    swapXYButtons
  } = useButtonMap();
  const inputLegends = useAvailableInputLegends();
  const callback = useInputLegendCallback();
  return /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(visible => visible ? InputLegend.InputLegend : InputLegend.hidden, [], [visible])
  }, /*#__PURE__*/react.createElement(InputLegend_InputLegend.Wrapper, {
    left: /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: swapABButtons ? types_ButtonType.A : types_ButtonType.B,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT10;

        return (_inputLegends$ButtonT10 = inputLegends[types_ButtonType.B]) !== null && _inputLegends$ButtonT10 !== void 0 ? _inputLegends$ButtonT10 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.A) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.B] == null, [], [inputLegends])
    }),
    right: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: types_ButtonType.LEFT,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT11;

        return (_inputLegends$ButtonT11 = inputLegends[types_ButtonType.LEFT]) !== null && _inputLegends$ButtonT11 !== void 0 ? _inputLegends$ButtonT11 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.LEFT) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.LEFT] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: types_ButtonType.RIGHT,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT12;

        return (_inputLegends$ButtonT12 = inputLegends[types_ButtonType.RIGHT]) !== null && _inputLegends$ButtonT12 !== void 0 ? _inputLegends$ButtonT12 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.RIGHT) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.RIGHT] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: types_ButtonType.UP,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT13;

        return (_inputLegends$ButtonT13 = inputLegends[types_ButtonType.UP]) !== null && _inputLegends$ButtonT13 !== void 0 ? _inputLegends$ButtonT13 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.UP) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.UP] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: types_ButtonType.DOWN,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT14;

        return (_inputLegends$ButtonT14 = inputLegends[types_ButtonType.DOWN]) !== null && _inputLegends$ButtonT14 !== void 0 ? _inputLegends$ButtonT14 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.DOWN) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.DOWN] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: swapXYButtons ? types_ButtonType.Y : types_ButtonType.X,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT15;

        return (_inputLegends$ButtonT15 = inputLegends[types_ButtonType.X]) !== null && _inputLegends$ButtonT15 !== void 0 ? _inputLegends$ButtonT15 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.X) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.X] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: swapXYButtons ? types_ButtonType.X : types_ButtonType.Y,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT16;

        return (_inputLegends$ButtonT16 = inputLegends[types_ButtonType.Y]) !== null && _inputLegends$ButtonT16 !== void 0 ? _inputLegends$ButtonT16 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.Y) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.Y] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: types_ButtonType.START,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT17;

        return (_inputLegends$ButtonT17 = inputLegends[types_ButtonType.START]) !== null && _inputLegends$ButtonT17 !== void 0 ? _inputLegends$ButtonT17 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.START) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.START] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: swapABButtons ? types_ButtonType.B : types_ButtonType.A,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT18;

        return (_inputLegends$ButtonT18 = inputLegends[types_ButtonType.A]) !== null && _inputLegends$ButtonT18 !== void 0 ? _inputLegends$ButtonT18 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.A) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.A] == null, [], [inputLegends])
    }))
  }));
}

InputLegend_InputLegend.displayName = 'InputLegend';
InputLegend_InputLegend.Wrapper = InputLegendWrapper;
InputLegend_InputLegend.InputHint = InputHint_InputHint;
InputLegend_InputLegend.Space = InputLegendSpace;
;// CONCATENATED MODULE: ./packages/ui/src/Modal/Modal.tsx
function Modal_extends() { Modal_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Modal_extends.apply(this, arguments); }

/**
 * Narration for modals with children that are added/removed dynamically will not
 * work entirely correct. This is planned to be addressed at a later date.
 * More info: https://github.com/Mojang/minecraft-ui/pull/3278#discussion_r854986350
 */


















const preventEventPropagation = e => {
  e.stopPropagation();
};

const Modal_noop = () => {};
/**
 * ModalManagerProvider
 * -
 * Handles focus states when moving through multiple modals.
 * It currently only supports a one directional flow (so no going back to previous modals).
 *
 * onMount can be used to keep track of which Modals are mounted so we can manage
 * focusable state when going between them.
 *
 * isModalVisible can be used to inform parts of the app whether or not
 * they're behind a modal so they can do things like disable GlobalShortcuts.
 */


const ModalMountContext = (0,react.createContext)({
  isModalVisible: (0,react_facet_src.createFacet)({
    initialValue: false
  }),
  onMount: () => Modal_noop
});

function useOnModalMount(defaultFocusAlias) {
  const {
    onMount
  } = (0,react.useContext)(ModalMountContext);
  (0,react.useEffect)(() => onMount(defaultFocusAlias), [onMount, defaultFocusAlias]);
}

function useIsAnyModalVisible() {
  return (0,react.useContext)(ModalMountContext).isModalVisible;
}

function ModalFocusManagerProvider({
  children
}) {
  const [modalFocusableId, setModalFocusableId] = (0,react_facet_src.useFacetState)(undefined);
  const [isModalVisible, setIsModalVisible] = (0,react_facet_src.useFacetState)(false);
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  const restoreFocusRef = (0,react.useRef)(Modal_noop);
  const value = (0,react.useMemo)(() => ({
    isModalVisible,
    onMount: defaultFocusAlias => {
      setIsModalVisible(true); // Focus the preferred child in the modal.

      if (defaultFocusAlias != null) {
        const restoreFocus = setFocusedId(defaultFocusAlias); // If this is the first modal being mounted, then save a reference to
        // the restoreFocus so we can get back to the original focusable when it closes.

        if (modalFocusableId.get() == null) {
          restoreFocusRef.current = restoreFocus != react_facet_src.NO_VALUE ? restoreFocus : Modal_noop;
        }
      } // Save a reference to this modal so we can decide later when it unmounts
      // if we should return to the original focusable.


      setModalFocusableId(defaultFocusAlias); // Unmount

      return () => {
        // If the modal being unmounted is the most recently mounted one
        if (modalFocusableId.get() === defaultFocusAlias) {
          // Then restore focus back to the original focusable before we stacked modals.
          restoreFocusRef.current(); // Unset our reference

          setModalFocusableId(undefined);
          setIsModalVisible(false);
        }
      };
    }
  }), [isModalVisible, modalFocusableId, setFocusedId, setIsModalVisible, setModalFocusableId]);
  return /*#__PURE__*/react.createElement(ModalMountContext.Provider, {
    value: value
  }, children);
}
/**
 * Modal Narration
 */


const ModalNarrationApi = (0,react.createContext)({
  getId: () => 0,
  set: () => {}
});

const useModalNarrationApi = () => (0,react.useContext)(ModalNarrationApi);

const ModalTitleText = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: ''
}));

const useModalTitleText = () => (0,react.useContext)(ModalTitleText);

const ModalBodyText = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: ''
}));

const useModalBodyText = () => (0,react.useContext)(ModalBodyText);
/**
 * Modal
 */


function Modal_Modal_Modal({
  children,
  defaultFocusAlias,
  narrationId,
  overlay = true,
  onOverlayClick,
  role = 'neutral'
}) {
  const {
    t
  } = useLocalization('Modal');
  const childId = (0,react.useRef)(0);
  const [narrationText, setNarrationText] = (0,react_facet_src.useFacetState)([]);
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  const [initialNarrationText, setInitialNarrationText] = (0,react_facet_src.useFacetState)('');
  const initialNarrationTextRef = (0,react_facet_src.useFacetRef)(initialNarrationText); // Keep a constantly updated reference to the body text. In situations where the
  // Modal.Content has no InteractivePrimitives, this body copy will be used as
  // a NarrationContext wrapper on Modal.Content.

  const bodyNarrationText = (0,react_facet_src.useFacetMap)(text => {
    const cleaned = text.filter(str => str.length > 0);
    const withComponentType = cleaned.slice(1);
    const result = withComponentType.join(' . ');
    return result;
  }, [], [narrationText]); // Take a snapshot of the body text on initial mount for initial contextual narration

  (0,react_facet_src.useFacetEffect)(text => {
    const cleaned = text.filter(str => str.length > 0);
    const withComponentType = [cleaned[0], t('.narrationModalComponentType'), ...cleaned.slice(1)];
    const result = withComponentType.join(' . ');
    setInitialNarrationText(result);
  }, [setInitialNarrationText, t], [narrationText]);
  const ref = (0,react.useRef)(null);
  const titleText = (0,react_facet_src.useFacetMemo)(text => text[0], [], [narrationText]);
  useOnModalMount(defaultFocusAlias);
  const getNarrationText = (0,react.useCallback)(() => initialNarrationTextRef.current !== react_facet_src.NO_VALUE ? initialNarrationTextRef.current : '', [initialNarrationTextRef]);
  const ConditionalOverlay = overlay ? Modal_Modal_Modal.Overlay : react.Fragment;
  const overlayProps = overlay ? {
    onClick: onOverlayClick
  } : {};
  return /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(ConditionalOverlay, overlayProps, /*#__PURE__*/react.createElement(ModalTitleText.Provider, {
    value: titleText
  }, /*#__PURE__*/react.createElement(ModalBodyText.Provider, {
    value: bodyNarrationText
  }, /*#__PURE__*/react.createElement(ModalNarrationApi.Provider, {
    value: (0,react.useMemo)(() => ({
      getId: () => childId.current++,
      set: (childId, text) => setNarrationText(prev => {
        if (prev === react_facet_src.NO_VALUE) {
          return []; // Shouldn't ever happen as we default to an array
        }

        prev[childId] = text === false ? '' : text;
        return prev;
      })
    }), [setNarrationText])
  }, /*#__PURE__*/react.createElement(NarrationContext, {
    getText: getNarrationText,
    id: `modal-${narrationId}`
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: classnames_default()(Modal_Modal.container, semanticClassNames.border.base),
    onClick: preventEventPropagation
  }, /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    scrollRef: ref,
    bounded: true
  }, children))))))));
}
/**
 * This hook should be used on child Modal components (eg. Modal.Text) to
 * help configure the narration text. It receives a unique id from the Modal
 * and uses this as an key to set the narration text at a higher level.
 */

const useSetModalNarrationText = (text, throttleThresholdMs = 0) => {
  const modalNarrationApi = useModalNarrationApi();
  const [id, setId] = (0,react_facet_src.useFacetState)(react_facet_src.NO_VALUE); // Get a unique id for this child

  (0,react.useEffect)(() => {
    // Exit early if we have an id (shouldn't happen)
    if (id.get() != react_facet_src.NO_VALUE) return;
    setId(modalNarrationApi.getId());
  }, [id, setId, modalNarrationApi]);
  const updatedAt = (0,react.useRef)(); // Set the narration text against our unique id

  (0,react_facet_src.useFacetEffect)((id, text) => {
    if (updatedAt.current == null || Date.now() - updatedAt.current > throttleThresholdMs) {
      modalNarrationApi.set(id, text);
      updatedAt.current = Date.now();
    }
  }, [modalNarrationApi, throttleThresholdMs], [id, (0,react_facet_src.useFacetWrap)(text)]);
};
/**
 * Modal Header
 */


const ModalHeader = ({
  children,
  onBack,
  onClose,
  closeButtonGamepadAlias,
  hideCloseButton,
  role = 'inherit'
}) => {
  var _ref;

  const {
    t
  } = useLocalization('Modal'); // Set up narration context in Modal

  useSetModalNarrationText(children);
  const closeInputLegendLoc = t('.closeInputLegend');
  const backInputLegendLoc = t('.backInputLegend');
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  const wrappedHideCloseButton = (0,react_facet_src.useFacetWrap)(hideCloseButton !== null && hideCloseButton !== void 0 ? hideCloseButton : false);
  const headerButtonClassName = (0,react_facet_src.useFacetMap)(hide => hide ? Modal_Modal.hide : Modal_Modal.headerButton, [], [wrappedHideCloseButton]);
  const shortcutOptions = (0,react_facet_src.useFacetMap)(hideCloseButton => ({
    button: types_ButtonType.B,
    inputLegend: onBack != null ? backInputLegendLoc : closeInputLegendLoc,
    disabled: hideCloseButton === true
  }), [onBack, closeInputLegendLoc, backInputLegendLoc], [wrappedHideCloseButton]);
  const closeButtonInputLegend = (0,react_facet_src.useFacetMap)(hideCloseButton => hideCloseButton ? false : closeInputLegendLoc, [closeInputLegendLoc], [wrappedHideCloseButton]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Modal_Modal.header, semanticClassNames.background.base, semanticClassNames.text.base)
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular"
  }), /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: shortcutOptions,
    onClick: (_ref = onBack !== null && onBack !== void 0 ? onBack : onClose) !== null && _ref !== void 0 ? _ref : Modal_noop
  }), /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: -2
  }, /*#__PURE__*/react.createElement("div", {
    className: Modal_Modal.headerButton
  }, onBack && /*#__PURE__*/react.createElement(NavigationButton_NavigationButton // Hardcoding this role until the Modal is
  // updated to work with semantic tokens.
  , {
    role: "neutral",
    inputLegend: backInputLegendLoc,
    narrationText: t('.backNarration'),
    onClick: onBack,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(IconArrowBackWhite_IconArrowBackWhite, null))), /*#__PURE__*/react.createElement("div", {
    className: Modal_Modal.spacer
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, children)), /*#__PURE__*/react.createElement("div", {
    className: Modal_Modal.spacer
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: headerButtonClassName
  }, onClose && /*#__PURE__*/react.createElement(NavigationButton_NavigationButton // Hardcoding this role until the Modal is
  // updated to work with semantic tokens.
  , {
    role: "neutral",
    inputLegend: closeButtonInputLegend,
    narrationText: t('.closeNarration'),
    onClick: onClose,
    gamepadIndex: 1,
    gamepadAlias: closeButtonGamepadAlias
  }, /*#__PURE__*/react.createElement(IconCrossWhite_IconCrossWhite, null))))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Modal_Modal.headerShadow, semanticClassNames.shadow.base)
  }));
};
/**
 * Modal Text
 */


const ModalText = ({
  image,
  children,
  gamepadIndex,
  narrationText,
  center = false
}) => {
  const hasInteractiveSibling = useHasInteractiveSiblings(); // Set up narration context in Modal

  useSetModalNarrationText(narrationText);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: hasInteractiveSibling,
    gamepadIndex: gamepadIndex,
    narrationText: narrationText,
    className: classnames_default()(Modal_Modal.textContent, {
      [Modal_Modal.centerOneLineText]: center
    }),
    classNameFocused: focusClass
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    inset: true
  }), image == null ? null : /*#__PURE__*/react.createElement(react.Fragment, null, image, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement("span", {
    className: Modal_Modal.wordWrap
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: center ? 'center' : 'left'
  }, children)));
};
/**
 * Modal Paragraph
 */


const ModalParagraphs = ({
  children,
  narrationText,
  spaceBetweenParagraphs = 5,
  gamepadIndex
}) => {
  const hasInteractiveSibling = useHasInteractiveSiblings(); // Set up narration context in Modal

  useSetModalNarrationText(narrationText); // Filter out conditionally rendered paragraphs passed in as false

  const filteredChildren = children.filter(child => child);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: hasInteractiveSibling,
    gamepadIndex: gamepadIndex,
    narrationText: narrationText,
    className: Modal_Modal.paragraphsWrapper
  }, filteredChildren.map((child, index) => /*#__PURE__*/react.createElement(react.Fragment, {
    key: index
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Modal_Modal.paragraphPadding, Modal_Modal.wordWrap)
  }, child), spaceBetweenParagraphs != null && index < filteredChildren.length - 1 && /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: spaceBetweenParagraphs
  }))));
};
/**
 * Modal List
 */


const ModalList = ({
  items,
  gamepadIndex
}) => {
  return /*#__PURE__*/react.createElement(MaybeColumn, {
    gamepadIndex: gamepadIndex
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: items
  }, (item, index) => {
    return /*#__PURE__*/react.createElement(ModalListInner, {
      items: items,
      item: item,
      index: index
    });
  })));
};

const ModalListInner = ({
  items,
  item,
  index
}) => {
  const showSpacing = (0,react_facet_src.useFacetMap)(items => items.length - 1 !== index, [index], [items]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(ModalListItem, {
    gamepadIndex: index,
    text: item
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showSpacing
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  })));
};

const MaybeColumn = ({
  children,
  gamepadIndex
}) => {
  const hasInteractiveSibling = (0,react_facet_src.useFacetUnwrap)(useHasInteractiveSiblings());
  return hasInteractiveSibling === true ? /*#__PURE__*/react.createElement(Column, {
    shouldSkipLandmarkInVisual: true,
    options: {
      index: gamepadIndex
    }
  }, children) : /*#__PURE__*/react.createElement(react.Fragment, null, children);
};

const ModalListItem = ({
  gamepadIndex,
  text
}) => {
  const textWithBullet = (0,react_facet_src.useFacetMap)(text => `• ${text}`, [], [text]);
  const hasInteractiveSibling = useHasInteractiveSiblings(); // Set up narration context in Modal

  useSetModalNarrationText(text);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: hasInteractiveSibling,
    gamepadIndex: gamepadIndex,
    narrationText: text,
    className: Modal_Modal.listTextContent
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "left"
  }, textWithBullet));
};
/**
 * Modal Content
 */


const Content = ({
  children,
  gamepadAlias,
  scrollable = true,
  role = 'neutral80'
}) => {
  const modalTitleText = useModalTitleText();
  const modalBodyText = useModalBodyText();
  const [hasChildInteractivePrimitives, setHasChildInteractivePrimitives] = (0,react.useState)(false);
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: modalTitleText
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(semanticClassNames.background.base, semanticClassNames.text.base, {
      [Modal_Modal.contentScrollable]: scrollable
    })
  }, scrollable ? /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: -1,
    floating: true,
    emptyFocusableGamepadAlias: gamepadAlias,
    emptyFocusableNarrationText: hasChildInteractivePrimitives ? '' : modalBodyText
  }, children, /*#__PURE__*/react.createElement(ScrollView_ScrollView.SiblingState, {
    callback: setHasChildInteractivePrimitives
  })) : children));
};
/**
 * Modal Buttons
 */


const Buttons = ({
  children,
  horizontal = false,
  role = 'inherit',
  header
}) => {
  const GamepadContainer = horizontal ? GamepadRow_GamepadRow : GamepadColumn_GamepadColumn;
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(GamepadContainer, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 1000
  }, header, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Modal_Modal.buttons, semanticClassNames.background.base, {
      [Modal_Modal.buttonsHorizontal]: horizontal
    })
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel",
    left: false,
    right: false
  }), children));
};
/**
 * Modal Overlay
 */


const Overlay = ({
  onClick,
  children,
  role = 'inherit'
}) => {
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Modal_Modal.overlay, semanticClassNames.overlay.base),
    onClick: onClick
  }, /*#__PURE__*/react.createElement("div", {
    className: Modal_Modal.wrapper
  }, children, /*#__PURE__*/react.createElement(InputLegend_InputLegend.Space, null)));
};
/**
 * Modal Progress
 */


function ModalProgress({
  percentage
}) {
  const {
    t
  } = useLocalization('Modal');
  const percentageFacet = (0,react_facet_src.useFacetWrap)(percentage);
  const percentageText = (0,react_facet_src.useFacetMap)(percentageValue => t('.progressPercentage', [`${Math.round(percentageValue * 100)}`]), [t], [percentageFacet]); // Set up narration context in Modal

  useSetModalNarrationText(percentageText, 2000);
  return /*#__PURE__*/react.createElement("div", {
    className: Modal_Modal.progress
  }, /*#__PURE__*/react.createElement(ProgressBar_ProgressBar, {
    percentage: percentageFacet
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "center"
  }, percentageText));
}
/**
 * Modal Spinner
 */


const ModalSpinner = () => {
  return /*#__PURE__*/react.createElement("div", {
    className: Modal_Modal.spinner
  }, /*#__PURE__*/react.createElement(Spinner_Spinner, null));
};
/**
 * Modal Checkbox
 */


const ModalCheckbox = props => {
  var _props$gamepadIndex;

  return /*#__PURE__*/react.createElement(Checkbox_Checkbox, Modal_extends({}, props, {
    gamepad: {
      index: (_props$gamepadIndex = props.gamepadIndex) !== null && _props$gamepadIndex !== void 0 ? _props$gamepadIndex : 0
    },
    small: true
  }));
};
/**
 * Modal Text Field
 */


const ModalTextField = props => {
  return /*#__PURE__*/react.createElement(TextField, Modal_extends({}, props, {
    transparent: true
  }));
};

Modal_Modal_Modal.Header = ModalHeader;
Modal_Modal_Modal.Text = ModalText;
Modal_Modal_Modal.Paragraphs = ModalParagraphs;
Modal_Modal_Modal.List = ModalList;
Modal_Modal_Modal.Content = Content;
Modal_Modal_Modal.Buttons = Buttons;
Modal_Modal_Modal.Overlay = Overlay;
Modal_Modal_Modal.Progress = ModalProgress;
Modal_Modal_Modal.Spinner = ModalSpinner;
Modal_Modal_Modal.Checkbox = ModalCheckbox;
Modal_Modal_Modal.TextField = ModalTextField;
Modal_Modal_Modal.FocusManager = ModalFocusManagerProvider;
Modal_Modal_Modal.useIsAnyModalVisible = useIsAnyModalVisible;
;// CONCATENATED MODULE: ./packages/engine/src/Application.tsx






















function Application({
  children,
  defaultRoute,
  developmentTranslations,
  errorComponent,
  gamepadAdapterVersion = GamepadAdapterVersion.LEGACY,
  scalingMode = 'default',
  keyboardGamepadMap = DEFAULT_KEYBOARD_GAMEPAD_MAP,
  isInputLegendClickable,
  semanticTokens,
  sharedFacetDriver = requestFacet,
  wrapperComponent = react.Fragment,
  deviceInformationOptions = {},
  shouldUseNarrationQueueSystem = false
}) {
  const Wrapper = wrapperComponent;
  return /*#__PURE__*/react.createElement(SemanticTokensCollectionsManager, null, /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensCollectionProvider, {
    collection: semanticTokens
  }, /*#__PURE__*/react.createElement(react_facet_src.SharedFacetDriverProvider, {
    value: sharedFacetDriver
  }, /*#__PURE__*/react.createElement(GamepadAdapterProvider, {
    version: gamepadAdapterVersion
  }, /*#__PURE__*/react.createElement(LocalizationEngineProvider, {
    developmentTranslations: developmentTranslations
  }, /*#__PURE__*/react.createElement(ControllerSpecificButtonTranslationsProvider, null, /*#__PURE__*/react.createElement(GamepadPolyfillInitializer, null, /*#__PURE__*/react.createElement(DeviceInformationEngineProvider, deviceInformationOptions, /*#__PURE__*/react.createElement(SplitScreenEngineProvider, null, /*#__PURE__*/react.createElement(SafeZoneEngineProvider, null, /*#__PURE__*/react.createElement(FeatureFlagsEngineProvider, null, /*#__PURE__*/react.createElement(SoundEngineProvider, null, /*#__PURE__*/react.createElement(UIEngineProvider, {
    scalingMode: scalingMode
  }, /*#__PURE__*/react.createElement(ErrorBoundary, {
    errorComponent: errorComponent
  }, /*#__PURE__*/react.createElement(TextFieldEngineProvider, null, /*#__PURE__*/react.createElement(RouterEngineProvider, {
    keyboardGamepadMap: keyboardGamepadMap,
    isInputLegendClickable: isInputLegendClickable
  }, /*#__PURE__*/react.createElement(NarratorEngineProvider, {
    shouldUseQueueSystem: shouldUseNarrationQueueSystem
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.FocusManager, null, /*#__PURE__*/react.createElement(RenderTrackingEngineProvider, null, /*#__PURE__*/react.createElement(RedirectWrapper, {
    from: "/",
    to: defaultRoute
  }), /*#__PURE__*/react.createElement(ModalManager, null, /*#__PURE__*/react.createElement(Wrapper, null, /*#__PURE__*/react.createElement(Switch_Switch, null, children))))))))))))))))))))));
}
;// CONCATENATED MODULE: ./packages/engine/src/facets/defineFakeFacet.ts

function defineFakeFacet(facetName, fakeConstructor) {
  const update = data => {
    // Delay updating the facet state until the next frame to better mimic how state changes works in the real engine
    requestAnimationFrame(() => engine.trigger(`facet:updated:${facetName}`, data));
  };

  const onError = errorCode => {
    engine.trigger(`facet:error:${facetName}`, errorCode);
  };

  engine.on('facet:request', facets => {
    // Delay the result of the facet request to the next frame to simulate the real engine behavior
    requestAnimationFrame(() => {
      if (facets.indexOf(facetName) !== -1) {
        fakeConstructor(update, onError);
      }
    });
  });
}
;// CONCATENATED MODULE: ./packages/engine/src/trigger.ts

/**
 * Internal method to trigger engine events. Only use it if you know exactly what you are doing.
 *
 * You most likely can solve your problem by using just Facets instead.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any

const trigger = (type, ...args) => {
  return engine.trigger(type, ...args);
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/performanceSharedFacet.ts

/**
 * Shared facet used for performance measurements.
 */

const PERFORMANCE_SHARED_FACET = 'core.performanceFacet';
/**
 * We don't want to have this exposed as a regular sharedFacet, since we will used this Facet on performance test screens,
 * where we usually don't have any FacetProvider infrastructure.
 */

const observePerformanceSharedFacet = update => {
  const updateEventName = `facet:updated:${PERFORMANCE_SHARED_FACET}`;
  engine.on(updateEventName, update);
  engine.trigger('facet:request', [PERFORMANCE_SHARED_FACET]);
  return () => {
    engine.off(updateEventName, update);
  };
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/socialFacet.ts

const SOCIAL_FACET = 'core.social';
/**
 * React Hook that requests the facet
 */

const socialFacet = (0,react_facet_src.sharedFacet)(SOCIAL_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/facets/user.ts

const USER_FACET = 'core.user';
/**
 * React Hook that requests the facet
 */

const userFacet = (0,react_facet_src.facet)(USER_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/facets/vrModeSharedFacet.ts

let VRMode;

(function (VRMode) {
  VRMode[VRMode["NoVR"] = 0] = "NoVR";
  VRMode[VRMode["VRFull3DWorld"] = 1] = "VRFull3DWorld";
  VRMode[VRMode["VRVirtual2DScreen"] = 2] = "VRVirtual2DScreen";
})(VRMode || (VRMode = {}));

const VR_MODE_SHARED_FACET = 'core.vrMode';
const vrModeSharedFacet = (0,react_facet_src.sharedFacet)(VR_MODE_SHARED_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/render.ts

const render = (element, container) => {
  return (0,react_facet_src.render)(element, container);
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/animationFacet.ts
const animationFacetDefaultState = {
  screenAnimationEnabled: true
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/customScalingFacet.ts
const customScalingDefaultState = {
  scalingModeOverride: undefined,
  fixedGuiScaleModifier: 0,
  MIN_FIXED_GUI_SCALE_MODIFIER: -3,
  MAX_FIXED_GUI_SCALE_MODIFIER: 4,
  guiAccessibilityScaling: false
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/setup/utils.ts



let detectInputInitialized = false;
const onMouseHandlers = (/* unused pure expression or super */ null && ([]));
const onTouchHandlers = (/* unused pure expression or super */ null && ([]));
const onGamepadHandlers = (/* unused pure expression or super */ null && ([]));

const initializeDetectInput = () => {
  detectInputInitialized = true; // Setup touch detection
  // We keep track of the time stamp of the last touchend event since it will also trigger
  // a mousedown event and we want to avoid calling the detect mouse handlers in those cases.

  let timeStampLastTouchEndEvent = -1;

  const shouldIgnoreMouseEvent = event => timeStampLastTouchEndEvent === event.timeStamp;

  const touchDetected = () => {
    onTouchHandlers.forEach(handler => handler());
  };

  const handleTouchEnd = event => {
    timeStampLastTouchEndEvent = event.timeStamp;
    touchDetected();
  };

  window.addEventListener('touchstart', touchDetected);
  window.addEventListener('touchend', handleTouchEnd); // Setup mouse detection

  const mouseDetected = event => {
    if (shouldIgnoreMouseEvent(event)) {
      return;
    }

    onMouseHandlers.forEach(handler => handler());
  };

  window.addEventListener('mousemove', mouseDetected);
  window.addEventListener('mousedown', mouseDetected);
  window.addEventListener('wheel', mouseDetected); // Setup gamepad detection

  let cleanupGamepadPolyfill = () => undefined;

  if (!isPolyfillInitialized()) {
    cleanupGamepadPolyfill = initializePolyfill();
  }

  const cleanupGamepad = onGamepadInput(gamepads => {
    onGamepadHandlers.forEach(handler => handler(gamepads));
  }); // Clean up handlers ("beforeunload" only works in the browser, not in the player)

  window.addEventListener('beforeunload', () => {
    window.removeEventListener('touchstart', touchDetected);
    window.removeEventListener('touchend', handleTouchEnd);
    window.removeEventListener('mousemove', mouseDetected);
    window.removeEventListener('mousedown', mouseDetected);
    window.removeEventListener('wheel', mouseDetected);
    cleanupGamepad();
    cleanupGamepadPolyfill();
  });
};

const utils_detectInput = ({
  onMouse,
  onTouch,
  onGamepad
}) => {
  if (!detectInputInitialized) initializeDetectInput();
  onMouseHandlers.push(onMouse);
  onTouchHandlers.push(onTouch);
  onGamepadHandlers.push(onGamepad);
}; // Not by any means a complete way of checking if this is a touch device, but good enough for our fake facets
// The gameface player is always exposing ontouchstart, but we are only running the player for desktop, so setting it to false in that case.

const IS_TOUCH_DEVICE =  false && 0;
const DEFAULT_PLATFORM = IS_TOUCH_DEVICE ? Platform.IOS : Platform.WIN32;
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/deviceInformationFacet.ts


function deviceInformationFacet_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function deviceInformationFacet_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { deviceInformationFacet_ownKeys(Object(source), true).forEach(function (key) { deviceInformationFacet_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { deviceInformationFacet_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function deviceInformationFacet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



const GUI_SCALE_VALUES = [1, 2, 3, 4, 5, 6, 7, 8];

function getDefaultSupportedInputMethods(platform = DEFAULT_PLATFORM) {
  switch (platform) {
    case Platform.IOS:
    case Platform.GOOGLE:
    case Platform.AMAZON_HANDHELD:
      return [types_InputMethod.TOUCH, types_InputMethod.GAMEPAD, types_InputMethod.MOUSE];

    case Platform.NX_TV:
      return [types_InputMethod.GAMEPAD];

    case Platform.NX_HANDHELD:
      return [types_InputMethod.GAMEPAD, types_InputMethod.TOUCH];

    case Platform.UWP:
    case Platform.XBOX:
    case Platform.PS4:
    case Platform.GEARVR:
    case Platform.AMAZON_TV:
    case Platform.PS5:
    case Platform.WIN32:
    case Platform.MACOS:
    default:
      return [types_InputMethod.GAMEPAD, types_InputMethod.MOUSE];
  }
}

const deviceInformationFacetDefaultState = {
  inputMethods: getDefaultSupportedInputMethods(),
  platform: DEFAULT_PLATFORM,
  arvrPlatform: ARVRPlatform.ARVR_None,
  isLowMemoryDevice: false,
  guiScaleModifier: 0,
  guiScaleBase: getGuiScaleIndexForLargeScreen(window.innerWidth, window.innerHeight),
  pixelsPerMillimeter: 3.779527559,
  // 96dpi,
  displayWidth: 1920,
  displayHeight: 1080,
  storageSize: Math.pow(1024, 4),
  storageUsed: Math.pow(1024, 4) * 0.75,
  isStorageFull: false,
  isStorageLow: false,
  isUsingAlternativeStorage: false,
  isOnline: true
};
function deviceInformationFacetWithPlatform(platform) {
  return deviceInformationFacet_objectSpread(deviceInformationFacet_objectSpread({}, deviceInformationFacetDefaultState), {}, {
    platform: platform
  });
}
const deviceInformationAlternativeStorageFacetState = deviceInformationFacet_objectSpread(deviceInformationFacet_objectSpread({}, deviceInformationFacetDefaultState), {}, {
  isUsingAlternativeStorage: true
});
const deviceInformationSharedFacetCustomState = overrides => deviceInformationFacet_objectSpread(deviceInformationFacet_objectSpread({}, deviceInformationFacetDefaultState), overrides);
function deviceInformationSharedFacetFactory(proxy, {
  storageSize,
  storageUsed,
  isStorageFull,
  isStorageLow
} = deviceInformationFacetDefaultState) {
  Object.assign(proxy, _clone(deviceInformationFacetDefaultState));
  window.addEventListener('resize', () => {
    proxy.guiScaleBase = getGuiScaleIndexForLargeScreen(window.innerWidth, window.innerHeight);
  });
  proxy.storageSize = storageSize !== null && storageSize !== void 0 ? storageSize : proxy.storageSize;
  proxy.storageUsed = storageUsed !== null && storageUsed !== void 0 ? storageUsed : proxy.storageUsed;
  proxy.isStorageFull = isStorageFull !== null && isStorageFull !== void 0 ? isStorageFull : proxy.isStorageFull;
  proxy.isStorageLow = isStorageLow !== null && isStorageLow !== void 0 ? isStorageLow : proxy.isStorageLow;
  detectInput({
    onMouse: () => {
      if (!proxy.inputMethods.includes(InputMethod.MOUSE)) {
        proxy.inputMethods.push(InputMethod.MOUSE);
      }
    },
    onTouch: () => {
      if (!proxy.inputMethods.includes(InputMethod.TOUCH)) {
        proxy.inputMethods.push(InputMethod.TOUCH);
      }
    },
    onGamepad: () => {
      if (!proxy.inputMethods.includes(InputMethod.GAMEPAD)) {
        proxy.inputMethods.push(InputMethod.GAMEPAD);
      }
    }
  });
  return proxy;
}

function getGuiScaleIndexForLargeScreen(width, height) {
  const widthNeeded = 376;
  const heightNeeded = 250;
  const widthScale = width / widthNeeded;
  const heightScale = height / heightNeeded; // This will ensure we are using an allowed GUI SCALE.  It will clamp to the biggest available GUI SCALE that is smaller or equal to the desired one

  const index = getGuiScaleIndex(Math.min(heightScale, widthScale));
  const scale = GUI_SCALE_VALUES[index];
  return scale;
}

function getGuiScaleIndex(scale) {
  let scaleIndex = 0;
  const guiScaleSize = GUI_SCALE_VALUES.length;

  for (let index = 0; index < guiScaleSize; ++index) {
    if (resolveGuiScale(index) > scale) {
      break;
    }

    scaleIndex = index;
  }

  return scaleIndex;
}

function resolveGuiScale(index) {
  const clampedIndex = Math.min(GUI_SCALE_VALUES.length - 1, Math.max(0, index));
  return GUI_SCALE_VALUES[clampedIndex];
}
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/featureFlagsFacet.ts
const featureFlagsFacetDefaultState = {
  flags: ['vanilla.achievementsReward', 'vanilla.editor.enableUI']
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/inputFacet.ts

const inputFacetDefaultState = {
  acceptInputFromAllControllers: true,
  gameControllerId: '0',
  swapABButtons: false,
  swapXYButtons: false,
  currentInputType: types_InputMethod.GAMEPAD
};
// EXTERNAL MODULE: ./node_modules/printf/lib/printf.js
var printf = __webpack_require__(15523);
var printf_default = /*#__PURE__*/__webpack_require__.n(printf);
;// CONCATENATED MODULE: ./packages/engine/src/developmentTranslations.ts
function getDevelopmentTranslation(key) {
  var _window$__globalDevCo;

  /**
   * Global variable containing all the development translations
   * It is populated via the Webpack loader configured to handle translatinos.json files
   */
  const translations = (_window$__globalDevCo = window.__globalDevCoreUITranslations) !== null && _window$__globalDevCo !== void 0 ? _window$__globalDevCo : {};
  return translations[key];
}
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/localeFacet.ts


const localeFacetDefaultState = {
  locale: 'en_US',

  formatDate(timestampInSeconds) {
    const date = new Date(timestampInSeconds * 1000);
    return `${date.toLocaleDateString()}`;
  },

  translate(key) {
    const translation = getDevelopmentTranslation(key);

    if (translation == null) {
      console.error(`Missing translation for key "${key}"`);
      return key;
    }

    return translation;
  },

  translateWithParameters(key, params) {
    const translation = getDevelopmentTranslation(key);

    if (translation == null) {
      console.error(`Missing translation for key "${key}"`);
      return key;
    }

    return printf_default()(translation, ...params);
  }

};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/safeZoneFacet.ts
const safeZoneFacetDefaultState = {
  safeAreaX: 1,
  safeAreaY: 1,
  screenPositionX: 0,
  screenPositionY: 0
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/splitScreenFacet.ts

const splitScreenFacetDefaultState = {
  numActivePlayers: 1,
  splitScreenPosition: 0,
  splitScreenDirection: SplitScreen_SplitScreenDirection.HORIZONTAL
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/images/templateAlex.png
const templateAlex_namespaceObject = __webpack_require__.p + "assets/templateAlex-f66e6.png";
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/userFacet.ts

const userFacetDefaultState = {
  userName: 'Alex',
  profilePictureUrl: templateAlex_namespaceObject
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/vrMode.ts

const vrModeSharedFacetDefaultState = {
  mode: VRMode.NoVR
};
const vrModeSharedFacetRealityState = {
  mode: VRMode.VRFull3DWorld
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/index.ts










;// CONCATENATED MODULE: ./packages/engine/src/index.ts






















 // NOTE: This is fine to export as long as fixtures doesn't define fake facets globally






// EXTERNAL MODULE: ./games/vanilla/translations/src/en_US.lang
var en_US = __webpack_require__(14290);
var en_US_default = /*#__PURE__*/__webpack_require__.n(en_US);
// EXTERNAL MODULE: ./packages/ui/src/uiTranslations/en_US.lang
var uiTranslations_en_US = __webpack_require__(89592);
var uiTranslations_en_US_default = /*#__PURE__*/__webpack_require__.n(uiTranslations_en_US);
// EXTERNAL MODULE: ./packages/ui-internal/src/uiInternalTranslations/en_US.lang
var uiInternalTranslations_en_US = __webpack_require__(62052);
var uiInternalTranslations_en_US_default = /*#__PURE__*/__webpack_require__.n(uiInternalTranslations_en_US);
;// CONCATENATED MODULE: ./games/vanilla/translations/src/index.ts
function src_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function src_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { src_ownKeys(Object(source), true).forEach(function (key) { src_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { src_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function src_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






const allTranslationsUsedByVanilla = src_objectSpread(src_objectSpread(src_objectSpread({}, (en_US_default())), (uiTranslations_en_US_default())), (uiInternalTranslations_en_US_default()));


;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useTimeout.tsx

/**
 * Hook that returns false and waits for a given duration before returning true.
 * Can be cancelled by passing true to the shouldCancel parameter.
 */

function useTimeout(shouldCancel, duration) {
  const [hasTimedOut, setTimedOut] = (0,react_facet_src.useFacetState)(false);
  (0,react_facet_src.useFacetEffect)(shouldCancel => {
    if (shouldCancel) return;
    const timeout = setTimeout(() => {
      setTimedOut(true);
    }, duration);
    return () => {
      clearTimeout(timeout);
    };
  }, [duration, setTimedOut], [shouldCancel]);
  return hasTimedOut;
}
;// CONCATENATED MODULE: ./packages/react-render-tracking/src/RenderTrackingEvent.tsx




/**
 * Used to fire a contentful (the page is starting to show something) or meaningful (the page is useable) paint event.
 */
function RenderTrackingEvent({
  type,
  renderingCompleted
}) {
  const renderTrackingApi = useRenderTrackingApi();
  const isRouteActive = useRouteActive();
  const renderingCompletedFacet = (0,react_facet_src.useFacetWrap)(renderingCompleted);
  (0,react_facet_src.useFacetEffect)((isRouteActive, renderingCompleted) => {
    if (!renderingCompleted || !isRouteActive) return; // We fire this after a frame to allow for any
    // <RenderTrackingDelay> components to initialise

    const rafId = requestAnimationFrame(() => {
      if (type === 'contentful') {
        renderTrackingApi.contentfulPaint();
      } else {
        renderTrackingApi.meaningfulPaint();
      }
    });
    return () => {
      cancelAnimationFrame(rafId);
    };
  }, [renderTrackingApi, type], [isRouteActive, renderingCompletedFacet]);
  return null;
}
;// CONCATENATED MODULE: ./packages/react-feature-flag/src/useFeatureFlag.tsx

function useFeatureFlag(featureFlag) {
  const flags = useFlags(); // Disable lint check because we actually want each value in the array
  // eslint-disable-next-line react-hooks/exhaustive-deps

  return flags.indexOf(featureFlag) != -1;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementsRoute/images/emptyStatesAllCompleted.png
const emptyStatesAllCompleted_namespaceObject = __webpack_require__.p + "assets/emptyStatesAllCompleted-0fcd8.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementsRoute/images/emptyStatesNoProgress.png
const emptyStatesNoProgress_namespaceObject = __webpack_require__.p + "assets/emptyStatesNoProgress-02663.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementsRoute/images/errorMessage.png
const errorMessage_namespaceObject = __webpack_require__.p + "assets/errorMessage-080e8.png";
;// CONCATENATED MODULE: ./packages/gameface-hacks/src/find.ts
function find_find(array, f) {
  for (let i = 0; i < array.length; i++) {
    if (f(array[i], i, array)) {
      return array[i];
    }
  }
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/achievementsFacet.ts


const ACHIEVEMENTS_FACET = 'vanilla.achievements';
/**
 * Feature flag to enable rendering of achievements rewards
 * Currently Persona work is not completed, we will enable this once that is done.
 * https://dev-mc.visualstudio.com/Minecraft/_workitems/edit/333996
 */

const REWARD_FEATURE_FLAG = 'vanilla.achievementsReward';
let AchievementFacetStatus;

(function (AchievementFacetStatus) {
  AchievementFacetStatus[AchievementFacetStatus["LOADING"] = 0] = "LOADING";
  AchievementFacetStatus[AchievementFacetStatus["LOADED"] = 1] = "LOADED";
})(AchievementFacetStatus || (AchievementFacetStatus = {}));

const achievementsFacet = (0,react_facet_src.sharedFacet)(ACHIEVEMENTS_FACET);
const groupedAchievementsSelector = (0,react_facet_src.sharedSelector)(achievementsData => {
  return groupAchievements(achievementsData.data.achievements);
}, [achievementsFacet]);
const lockedAchievementsSelector = (0,react_facet_src.sharedSelector)(achievementsData => {
  return filterLocked(achievementsData.data.achievements);
}, [achievementsFacet]);
const lockedOrInProgressAchievementsSelector = (0,react_facet_src.sharedSelector)(achievementsData => {
  return filterLockedOrInProgress(achievementsData.data.achievements);
}, [achievementsFacet]);
const completedAchievementsSelector = (0,react_facet_src.sharedSelector)(achievementsData => {
  return sortCompleted(achievementsData.data.achievements);
}, [achievementsFacet]);
const isAchievementsLoadedSelector = (0,react_facet_src.sharedSelector)(facet => {
  return facet.status === AchievementFacetStatus.LOADED;
}, [achievementsFacet]);
const achievementDetailSelector = (0,react_facet_src.sharedDynamicSelector)(id => [(facet, isLoaded) => {
  const achievement = find_find(facet.data.achievements, achievement => achievement.id === id);
  return {
    isLoaded,
    achievement
  };
}, [achievementsFacet, isAchievementsLoadedSelector]]);
const achievementsSummarySelector = (0,react_facet_src.sharedSelector)(facet => {
  const summary = {
    loaded: facet.status === AchievementFacetStatus.LOADED,
    unlocked: facet.data.achievementsUnlocked,
    total: facet.data.maxAchievements,
    inProgressCount: facet.data.achievements.filter(isAchievementInProgress).length,
    rewardsTotal: countRewards(facet.data.achievements),
    rewardsUnlocked: countUnlockedRewards(facet.data.achievements),
    gamerScore: facet.data.currentGamerScore,
    maxGamerScore: facet.data.maxGamerScore,
    hoursPlayed: facet.data.hoursPlayed
  };
  return summary;
}, [achievementsFacet], react_facet_src.shallowObjectEqualityCheck);
function isAchievementInProgress(achievement) {
  return achievement.isLocked && achievement.progress > 0;
}
function isAchievementCompleted(achievement) {
  return !achievement.isLocked;
}
function isAchievementLockedOrInProgress(achievement) {
  return achievement.isLocked;
}
function isAchievementLocked(achievement) {
  return achievement.isLocked && !achievement.progress;
}
function isAchievementRewardOwned(achievement) {
  return !!(!achievement.isLocked || achievement.isRewardOwned);
}
function countUnlockedRewards(achievements) {
  return achievements.filter(achievement => achievement.hasReward && isAchievementRewardOwned(achievement)).length;
}
function countRewards(achievements) {
  return achievements.filter(achievement => achievement.hasReward).length;
}
function sortCompleted(achievements) {
  return achievements.filter(isAchievementCompleted).sort(compareByDateUnlockedDescending);
}
function filterLocked(achievements) {
  return achievements.filter(isAchievementLocked);
}
function filterLockedOrInProgress(achievements) {
  return achievements.filter(isAchievementLockedOrInProgress).sort(compareProgressDescending);
}
function groupAchievements(achievements) {
  const inProgress = [];
  const completedUnsorted = [];
  const lockedUnsorted = [];
  achievements.forEach(achievement => {
    if (isAchievementLocked(achievement)) {
      lockedUnsorted.push(achievement);
    } else if (isAchievementCompleted(achievement)) {
      completedUnsorted.push(achievement);
    } else {
      inProgress.push(achievement);
    }
  }); // Sorts the inProgress array in-place

  inProgress.sort(compareProgressDescending);
  const locked = lockedUnsorted;
  const completed = sortCompleted(completedUnsorted);
  return {
    inProgress,
    locked,
    completed
  };
}
/**
 * Compare two achievements progress.
 * Considers achievements with rewards first than those without.
 */

function compareProgressDescending(achievementA, achievementB) {
  if (!achievementA.hasReward && achievementB.hasReward) {
    return 1;
  }

  if (achievementA.hasReward && !achievementB.hasReward) {
    return -1;
  }

  if (achievementA.progress < achievementB.progress) {
    return 1;
  }

  if (achievementA.progress > achievementB.progress) {
    return -1;
  }

  return 0;
}
/**
 * Compare two achievements by completed date. Latest first.
 */

function compareByDateUnlockedDescending(achievementA, achievementB) {
  if (achievementA.dateUnlocked < achievementB.dateUnlocked) {
    return 1;
  }

  if (achievementA.dateUnlocked > achievementB.dateUnlocked) {
    return -1;
  }

  return 0;
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/buildSettingsFacet.ts

const BUILD_SETTINGS_FACET = 'vanilla.buildSettings';
const buildSettingsFacet = (0,react_facet_src.sharedFacet)(BUILD_SETTINGS_FACET);
const isDevBuildSelector = (0,react_facet_src.sharedSelector)(facet => facet.isDevBuild, [buildSettingsFacet]);
const isEduBuildSelector = (0,react_facet_src.sharedSelector)(facet => facet.isEduBuild, [buildSettingsFacet]);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/clipboardFacet.ts

const CLIPBOARD_FACET = 'vanilla.clipboard';
const clipboardFacet = (0,react_facet_src.sharedFacet)(CLIPBOARD_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/compareGameVersions.ts
// returns < 0 if lhs is older than rhs, > 0 if lhs is newer, and 0 if they are equal
function compareGameVersions(lhs, rhs) {
  if (lhs.major - rhs.major !== 0) {
    return lhs.major - rhs.major;
  }

  if (lhs.minor - rhs.minor !== 0) {
    return lhs.minor - rhs.minor;
  }

  if (lhs.patch - rhs.patch !== 0) {
    return lhs.patch - rhs.patch;
  }

  if (lhs.revision - rhs.revision !== 0) {
    return lhs.revision - rhs.revision;
  }

  return 0;
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/createNewWorldFacet.ts

let DifficultyEnum;

(function (DifficultyEnum) {
  DifficultyEnum[DifficultyEnum["PEACEFUL"] = 0] = "PEACEFUL";
  DifficultyEnum[DifficultyEnum["EASY"] = 1] = "EASY";
  DifficultyEnum[DifficultyEnum["NORMAL"] = 2] = "NORMAL";
  DifficultyEnum[DifficultyEnum["HARD"] = 3] = "HARD";
})(DifficultyEnum || (DifficultyEnum = {}));

let DaylightCycleEnum;

(function (DaylightCycleEnum) {
  DaylightCycleEnum[DaylightCycleEnum["NORMAL"] = 0] = "NORMAL";
  DaylightCycleEnum[DaylightCycleEnum["ALWAYS_DAY"] = 1] = "ALWAYS_DAY";
  DaylightCycleEnum[DaylightCycleEnum["LOCK_TIME"] = 2] = "LOCK_TIME";
})(DaylightCycleEnum || (DaylightCycleEnum = {}));

let ExperimentalFeatureCategory;

(function (ExperimentalFeatureCategory) {
  ExperimentalFeatureCategory[ExperimentalFeatureCategory["GAMEPLAY"] = 0] = "GAMEPLAY";
  ExperimentalFeatureCategory[ExperimentalFeatureCategory["ADD_ON_CREATORS"] = 1] = "ADD_ON_CREATORS";
  ExperimentalFeatureCategory[ExperimentalFeatureCategory["INTERNAL_TESTS"] = 2] = "INTERNAL_TESTS";
})(ExperimentalFeatureCategory || (ExperimentalFeatureCategory = {}));

let GeneralMultiplayerWarningStateEnum;

(function (GeneralMultiplayerWarningStateEnum) {
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["NONE"] = 0] = "NONE";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["CHECK_INTERNET_CONNECTION"] = 1] = "CHECK_INTERNET_CONNECTION";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["DISCONNECTED_THIRD_PARTY_WITH_SUBSCRIPTION"] = 2] = "DISCONNECTED_THIRD_PARTY_WITH_SUBSCRIPTION";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["LOCAL_MULTIPLAYER_PRIVILEGES_BLOCKED_THIRD_PARTY"] = 3] = "LOCAL_MULTIPLAYER_PRIVILEGES_BLOCKED_THIRD_PARTY";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["MULTIPLAYER_PRIVILEGES_BLOCKED_THIRD_PARTY"] = 4] = "MULTIPLAYER_PRIVILEGES_BLOCKED_THIRD_PARTY";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["MULTIPLAYER_PRIVILEGES_BLOCKED"] = 5] = "MULTIPLAYER_PRIVILEGES_BLOCKED";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["MULTIPLAYER_PRIVILEGES_BLOCKED_ON_CONSOLE"] = 6] = "MULTIPLAYER_PRIVILEGES_BLOCKED_ON_CONSOLE";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["CROSS_PLATFORM_DISABLED"] = 7] = "CROSS_PLATFORM_DISABLED";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["NON_MULTIPLAYER_SKIN_EQUIPPED"] = 8] = "NON_MULTIPLAYER_SKIN_EQUIPPED";
})(GeneralMultiplayerWarningStateEnum || (GeneralMultiplayerWarningStateEnum = {}));

let CreateOnRealmsError;

(function (CreateOnRealmsError) {
  CreateOnRealmsError[CreateOnRealmsError["UNASSIGNED_DEV_VERSION"] = 0] = "UNASSIGNED_DEV_VERSION";
  CreateOnRealmsError[CreateOnRealmsError["MEMBER_OF_TOO_MANY_REALMS"] = 1] = "MEMBER_OF_TOO_MANY_REALMS";
  CreateOnRealmsError[CreateOnRealmsError["CANNOT_CONNECT_TO_REALM"] = 2] = "CANNOT_CONNECT_TO_REALM";
  CreateOnRealmsError[CreateOnRealmsError["UNKNOWN"] = 3] = "UNKNOWN";
})(CreateOnRealmsError || (CreateOnRealmsError = {}));

let CreateWorldError;

(function (CreateWorldError) {
  CreateWorldError[CreateWorldError["NOT_ENOUGH_STORAGE"] = 0] = "NOT_ENOUGH_STORAGE";
})(CreateWorldError || (CreateWorldError = {}));

let PlayerAccess;

(function (PlayerAccess) {
  PlayerAccess[PlayerAccess["INVITED"] = 1] = "INVITED";
  PlayerAccess[PlayerAccess["FRIENDS"] = 2] = "FRIENDS";
  PlayerAccess[PlayerAccess["FRIENDS_OF_FRIENDS"] = 3] = "FRIENDS_OF_FRIENDS";
})(PlayerAccess || (PlayerAccess = {}));

let createNewWorldFacet_PlayerPermissions;

(function (PlayerPermissions) {
  PlayerPermissions[PlayerPermissions["VISITOR"] = 0] = "VISITOR";
  PlayerPermissions[PlayerPermissions["MEMBER"] = 1] = "MEMBER";
  PlayerPermissions[PlayerPermissions["OPERATOR"] = 2] = "OPERATOR";
})(createNewWorldFacet_PlayerPermissions || (createNewWorldFacet_PlayerPermissions = {}));

const CREATE_NEW_WORLD_FACET = 'vanilla.createNewWorld';
const createNewWorldFacet = (0,react_facet_src.sharedFacet)(CREATE_NEW_WORLD_FACET);
const isEditorWorldSelector = (0,react_facet_src.sharedSelector)(facet => facet.isEditorWorld, [createNewWorldFacet]);
const isUsingTemplateSelector = (0,react_facet_src.sharedSelector)(facet => facet.isUsingTemplate, [createNewWorldFacet]);
const generalSettingsSelector = (0,react_facet_src.sharedSelector)(facet => facet.worldCreationData.general, [createNewWorldFacet]);
const multiplayerSelector = (0,react_facet_src.sharedSelector)(facet => facet.worldCreationData.multiplayer, [createNewWorldFacet]);
const cheatsSettingsSelector = (0,react_facet_src.sharedSelector)(facet => facet.worldCreationData.cheats, [createNewWorldFacet]);
const advancedSettingsSelector = (0,react_facet_src.sharedSelector)(facet => facet.worldCreationData.advanced, [createNewWorldFacet]);
const betaFeaturesEnabledSelector = (0,react_facet_src.sharedSelector)(facet => facet.worldCreationData.betaFeatures.some(feature => feature.isEnabled), [createNewWorldFacet]);
const scriptingCodingSettingsSelector = (0,react_facet_src.sharedSelector)(facet => facet.worldCreationData.scriptingCoding, [createNewWorldFacet]);
const isLockedTemplateSelector = (0,react_facet_src.sharedSelector)(facet => facet.isLockedTemplate, [createNewWorldFacet]);
const applyTemplateSelector = (0,react_facet_src.sharedSelector)(facet => facet.applyTemplate.bind(facet), [createNewWorldFacet]);
const showUnlockSettingsModal = (0,react_facet_src.createFacet)({
  initialValue: false
});
const betaFeatureToggledFacet = (0,react_facet_src.createFacet)({
  initialValue: {
    userTriedToActivateToggle: false,
    doSetToggleValue: () => {},
    userHasAcceptedBetaFeatures: false
  }
});
const achievementsDisabledSelector = (0,react_facet_src.sharedSelector)(facet => facet.isAchievementsDisabled, [createNewWorldFacet]);
const ENABLE_CREATE_WORLD_GRAY_BUTTON = 'vanilla.useGrayCreateOnRealmsButton';
;// CONCATENATED MODULE: ./games/vanilla/engine/src/debugSettingsFacet.ts

const DEBUG_SETTINGS_FACET = 'vanilla.debugSettings';
const debugSettingsFacet = (0,react_facet_src.sharedFacet)(DEBUG_SETTINGS_FACET);
let BiomeDimension;

(function (BiomeDimension) {
  BiomeDimension[BiomeDimension["OVERWORLD"] = 0] = "OVERWORLD";
  BiomeDimension[BiomeDimension["NETHER"] = 1] = "NETHER";
})(BiomeDimension || (BiomeDimension = {}));
;// CONCATENATED MODULE: ./games/vanilla/engine/src/editWorldFacet.ts

let ReadWorldError;

(function (ReadWorldError) {
  ReadWorldError[ReadWorldError["IncorrectWorldId"] = 0] = "IncorrectWorldId";
  ReadWorldError[ReadWorldError["UnexpectedError"] = 1] = "UnexpectedError";
})(ReadWorldError || (ReadWorldError = {}));

let WriteWorldError;

(function (WriteWorldError) {
  WriteWorldError[WriteWorldError["IncorrectWorldId"] = 0] = "IncorrectWorldId";
  WriteWorldError[WriteWorldError["UnableToCreateWorldDirectoryPath"] = 1] = "UnableToCreateWorldDirectoryPath";
  WriteWorldError[WriteWorldError["UnableToCreateResourcePackDirectoryPath"] = 2] = "UnableToCreateResourcePackDirectoryPath";
  WriteWorldError[WriteWorldError["UnableToCreateBehaviorDirectoryPath"] = 3] = "UnableToCreateBehaviorDirectoryPath";
  WriteWorldError[WriteWorldError["InsufficientDiskSpace"] = 4] = "InsufficientDiskSpace";
})(WriteWorldError || (WriteWorldError = {}));

let PackType;

(function (PackType) {
  PackType[PackType["None"] = 0] = "None";
  PackType[PackType["World"] = 1] = "World";
  PackType[PackType["WorldTemplate"] = 2] = "WorldTemplate";
  PackType[PackType["Resource"] = 3] = "Resource";
  PackType[PackType["Behavior"] = 4] = "Behavior";
  PackType[PackType["Skin"] = 5] = "Skin";
  PackType[PackType["ItemCollection"] = 6] = "ItemCollection";
})(PackType || (PackType = {}));

let PackActionError;

(function (PackActionError) {
  PackActionError[PackActionError["InvalidWorldId"] = 0] = "InvalidWorldId";
  PackActionError[PackActionError["InvalidPackType"] = 1] = "InvalidPackType";
  PackActionError[PackActionError["InvalidPackId"] = 2] = "InvalidPackId";
  PackActionError[PackActionError["ContentTierIncompatible"] = 3] = "ContentTierIncompatible";
  PackActionError[PackActionError["ContentTierIncompatibleMemory"] = 4] = "ContentTierIncompatibleMemory";
  PackActionError[PackActionError["ContentTierIncompatibleRayTracing"] = 5] = "ContentTierIncompatibleRayTracing";
  PackActionError[PackActionError["AddDependenciesError"] = 6] = "AddDependenciesError";
  PackActionError[PackActionError["PackSelectErrorNoStore"] = 7] = "PackSelectErrorNoStore";
  PackActionError[PackActionError["PackSelectErrorRequiredDependency"] = 8] = "PackSelectErrorRequiredDependency";
  PackActionError[PackActionError["DataWarning"] = 9] = "DataWarning";
  PackActionError[PackActionError["UnownedContent"] = 10] = "UnownedContent";
  PackActionError[PackActionError["NeedToDownloadPack"] = 11] = "NeedToDownloadPack";
  PackActionError[PackActionError["UnexpectedError"] = 12] = "UnexpectedError";
})(PackActionError || (PackActionError = {}));

let PackDownloadError;

(function (PackDownloadError) {
  PackDownloadError[PackDownloadError["HasPendingOrActiveImports"] = 0] = "HasPendingOrActiveImports";
  PackDownloadError[PackDownloadError["HasUnownedPacks"] = 1] = "HasUnownedPacks";
  PackDownloadError[PackDownloadError["RealmsPlusEnded"] = 2] = "RealmsPlusEnded";
  PackDownloadError[PackDownloadError["MissingDlcDependencies"] = 3] = "MissingDlcDependencies";
  PackDownloadError[PackDownloadError["MissingDlcWorldTemplate"] = 4] = "MissingDlcWorldTemplate";
  PackDownloadError[PackDownloadError["NoInternet"] = 5] = "NoInternet";
  PackDownloadError[PackDownloadError["HasPerformanceIssues"] = 6] = "HasPerformanceIssues";
  PackDownloadError[PackDownloadError["NotEnoughDiskSpace"] = 7] = "NotEnoughDiskSpace";
  PackDownloadError[PackDownloadError["WifiRequiredYetNotAccessible"] = 8] = "WifiRequiredYetNotAccessible";
  PackDownloadError[PackDownloadError["MissingRequiredWorldTemplateRequestUserApproval"] = 9] = "MissingRequiredWorldTemplateRequestUserApproval";
  PackDownloadError[PackDownloadError["InvalidPack"] = 10] = "InvalidPack";
  PackDownloadError[PackDownloadError["InvalidWorld"] = 11] = "InvalidWorld";
  PackDownloadError[PackDownloadError["UnexpectedError"] = 12] = "UnexpectedError";
})(PackDownloadError || (PackDownloadError = {}));

let PackDownloaderStatus;

(function (PackDownloaderStatus) {
  PackDownloaderStatus[PackDownloaderStatus["Idle"] = 0] = "Idle";
  PackDownloaderStatus[PackDownloaderStatus["Downloading"] = 1] = "Downloading";
  PackDownloaderStatus[PackDownloaderStatus["Importing"] = 2] = "Importing";
})(PackDownloaderStatus || (PackDownloaderStatus = {}));

const EDIT_WORLD_FACET = 'vanilla.worldEditor';
const editWorldFacet = (0,react_facet_src.sharedFacet)(EDIT_WORLD_FACET);
const editWorldMultiplayerSelector = (0,react_facet_src.sharedSelector)(facet => facet.worldData.multiplayer, [editWorldFacet]);
const multiplayerSettingsSelectorEditWorld = (0,react_facet_src.sharedSelector)(facet => facet.worldData.multiplayer, [editWorldFacet]);
const advancedSettingsSelectorEditWorld = (0,react_facet_src.sharedSelector)(facet => facet.worldData.advanced, [editWorldFacet]);
const achievementsDisabledModalEditFacet = (0,react_facet_src.createFacet)({
  initialValue: {
    visible: false
  }
});
const achievementsDisabledSelectorEditWorld = (0,react_facet_src.sharedSelector)(facet => facet.isAchievementsEditDisabled, [editWorldFacet]);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/inboxFacet.ts

const INBOX_FACET = 'vanilla.inbox'; // One week in seconds

const ONE_WEEK = 604800;
let InvitationType;

(function (InvitationType) {
  InvitationType[InvitationType["NONE"] = 0] = "NONE";
  InvitationType[InvitationType["REALMS"] = 1] = "REALMS";
  InvitationType[InvitationType["GAME"] = 2] = "GAME";
})(InvitationType || (InvitationType = {}));

let InvitationStatus;

(function (InvitationStatus) {
  InvitationStatus[InvitationStatus["NONE"] = 0] = "NONE";
  InvitationStatus[InvitationStatus["ACCEPTED"] = 1] = "ACCEPTED";
  InvitationStatus[InvitationStatus["REJECTED"] = 2] = "REJECTED";
  InvitationStatus[InvitationStatus["EXPIRED"] = 3] = "EXPIRED";
  InvitationStatus[InvitationStatus["JOIN"] = 5] = "JOIN";
})(InvitationStatus || (InvitationStatus = {}));

let InboxMessageType;

(function (InboxMessageType) {
  InboxMessageType[InboxMessageType["NEWS"] = 0] = "NEWS";
  InboxMessageType[InboxMessageType["INVITES"] = 1] = "INVITES";
  InboxMessageType[InboxMessageType["REALMS"] = 2] = "REALMS";
})(InboxMessageType || (InboxMessageType = {}));

function categoryDataToStringValue(value) {
  switch (value) {
    case InboxMessageType.NEWS:
      return 'news';

    case InboxMessageType.INVITES:
      return 'invites';

    case InboxMessageType.REALMS:
      return 'realms';
  }
}
function stringValueCategoryToData(value) {
  switch (value) {
    case 'news':
      return InboxMessageType.NEWS;

    case 'invites':
      return InboxMessageType.INVITES;

    case 'realms':
      return InboxMessageType.REALMS;
  }
}
const inboxSharedFacet = (0,react_facet_src.sharedFacet)(INBOX_FACET);
function groupMessageData(inboxMessages) {
  const newsData = {
    recent: [],
    history: []
  };
  const invitesData = {
    recent: [],
    history: []
  };
  const realmsData = {
    recent: [],
    history: []
  };
  inboxMessages.forEach(message => {
    const today = msToDays(Date.now());
    const dateRecieved = secondsToDays(message.dateReceived);
    const isRecent = today - dateRecieved <= secondsToDays(ONE_WEEK);

    switch (message.announcementType) {
      case InboxMessageType.NEWS:
        {
          if (isRecent) {
            newsData.recent.push(message);
          } else {
            newsData.history.push(message);
          }

          break;
        }

      case InboxMessageType.INVITES:
        {
          if (isRecent) {
            invitesData.recent.push(message);
          } else {
            invitesData.history.push(message);
          }

          break;
        }

      case InboxMessageType.REALMS:
        {
          if (isRecent) {
            realmsData.recent.push(message);
          } else {
            realmsData.history.push(message);
          }

          break;
        }
    }
  });
  return {
    newsData,
    invitesData,
    realmsData
  };
}
const categorizedMessagesSelector = (0,react_facet_src.sharedSelector)(inbox => {
  return groupMessageData(inbox.inboxMessages);
}, [inboxSharedFacet]);
function secondsToDays(seconds) {
  return Math.floor(seconds / 60 / 60 / 24);
}
function msToDays(ms) {
  return secondsToDays(Math.floor(ms / 1000));
}
// EXTERNAL MODULE: ./games/vanilla/engine/src/levelDataBindings.ts
var levelDataBindings = __webpack_require__(35107);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/marketplaceSuggestionsFacet.ts
 // The way that the data driven marketplace page works is that you have to
// provide the title and page id of where you want to end up, and this
// information depends on where we're routing _from_.
//
// This GetMorePacksData interface is a way to make this state accessible to the
// JavaScript code so that these dynamic route query paramers can be accessed.
//
// The reason this can't be done from the backend is because the code that
// handles the routing doesn't know any details about the page we're currently
// on, and its the marketplace suggestions that determine which data driven
// page we should navigate to.

const MARKETPLACE_SUGGESTIONS_FACET = 'vanilla.marketplaceSuggestions';
const marketplaceSuggestionsFacet = (0,react_facet_src.sharedFacet)(MARKETPLACE_SUGGESTIONS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/notificationOptionsFacet.ts

const NOTIFICATION_OPTIONS_FACET = 'vanilla.notificationOptions';
const notificationOptionsFacet = (0,react_facet_src.sharedFacet)(NOTIFICATION_OPTIONS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/optionsFacet.ts
 // the order of this enum should synch with NewInteractionModel enum in minecraftpe

let TouchControlSchemeEnum;

(function (TouchControlSchemeEnum) {
  TouchControlSchemeEnum[TouchControlSchemeEnum["TOUCH"] = 0] = "TOUCH";
  TouchControlSchemeEnum[TouchControlSchemeEnum["CROSSHAIR"] = 1] = "CROSSHAIR";
  TouchControlSchemeEnum[TouchControlSchemeEnum["CLASSIC"] = 2] = "CLASSIC";
})(TouchControlSchemeEnum || (TouchControlSchemeEnum = {}));

const OPTIONS_FACET = 'vanilla.options';
const optionsFacet = (0,react_facet_src.sharedFacet)(OPTIONS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/playerMessagingServiceFacet.ts


const PLAYER_MESSAGING_SERVICE_FACET = 'vanilla.playermessagingservice';
let PlayerMessagingServiceFacetStatus;

(function (PlayerMessagingServiceFacetStatus) {
  PlayerMessagingServiceFacetStatus[PlayerMessagingServiceFacetStatus["LOADING"] = 0] = "LOADING";
  PlayerMessagingServiceFacetStatus[PlayerMessagingServiceFacetStatus["IMAGE_RETRIEVAL"] = 1] = "IMAGE_RETRIEVAL";
  PlayerMessagingServiceFacetStatus[PlayerMessagingServiceFacetStatus["LOADED"] = 2] = "LOADED";
})(PlayerMessagingServiceFacetStatus || (PlayerMessagingServiceFacetStatus = {}));

const playerMessagingServiceFacet = (0,react_facet_src.sharedFacet)(PLAYER_MESSAGING_SERVICE_FACET);
const applyReportClick = (0,react_facet_src.sharedSelector)(facet => facet.reportClick.bind(facet), [playerMessagingServiceFacet]);
const applyReportDismiss = (0,react_facet_src.sharedSelector)(facet => facet.reportDismiss.bind(facet), [playerMessagingServiceFacet]);
const isMessagingLoadedSelector = (0,react_facet_src.sharedSelector)(facet => {
  return facet.status != PlayerMessagingServiceFacetStatus.LOADING;
}, [playerMessagingServiceFacet]);
const messageDetailSelector = (0,react_facet_src.sharedDynamicSelector)(id => [(facet, isLoaded) => {
  const message = find_find(facet.data.messages, message => message.id === id);
  return {
    isLoaded,
    message
  };
}, [playerMessagingServiceFacet, isMessagingLoadedSelector]]);
function getAdditionalProperty(props, propName) {
  const filtered = props.filter(prop => prop.key == propName);
  if (filtered.length > 0) return filtered[0];
  return undefined;
}

function filterMessagesSurface(messages, surface) {
  return messages.filter(message => message.surface == surface);
}

const messagesBySurfaceSelector = (0,react_facet_src.sharedDynamicSelector)(surface => [(facet, isLoaded) => {
  const messages = filterMessagesSurface(facet.data.messages, surface);
  return {
    isLoaded,
    messages
  };
}, [playerMessagingServiceFacet, isMessagingLoadedSelector]]);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/playerReportFacet.ts

const PLAYER_REPORT_FACET = 'vanilla.playerReport';
const playerReportFacet = (0,react_facet_src.sharedFacet)(PLAYER_REPORT_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/profanityFilterFacet.ts

const PROFANITY_FILTER_FACET = 'vanilla.profanityFilter';
const profanityFilterFacet = (0,react_facet_src.sharedFacet)(PROFANITY_FILTER_FACET);
;// CONCATENATED MODULE: ./packages/gameface-hacks/src/slice.ts
// FIXME remove this once gameface supports slice on all platforms
function slice(oldArray, start, end) {
  let length = oldArray == null ? 0 : oldArray.length;

  if (!length) {
    return [];
  }

  start = start == null ? 0 : start;
  end = end == null ? length : end;

  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }

  end = end > length ? length : end;

  if (end < 0) {
    end += length;
  }

  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  let index = -1;
  const newArray = new Array(length);

  while (++index < length) {
    newArray[index] = oldArray[index + start];
  }

  return newArray;
}
;// CONCATENATED MODULE: ./packages/gameface-hacks/src/filter.ts
function filter(array, f) {
  const result = [];

  for (let i = 0; i < array.length; i++) {
    if (f(array[i], i, array)) {
      result.push(array[i]);
    }
  }

  return result;
}
;// CONCATENATED MODULE: ./packages/gameface-hacks/src/localeCompare.ts
function localeCompare(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/types.ts
let types_PromptActionVariant; // Intended to be the primary prompt interface

(function (PromptActionVariant) {
  PromptActionVariant[PromptActionVariant["Primary"] = 0] = "Primary";
  PromptActionVariant[PromptActionVariant["Secondary"] = 1] = "Secondary";
})(types_PromptActionVariant || (types_PromptActionVariant = {}));

// Argument for `/tabbed-upsell`
let TabbedUpsellScreenDefaultTab;

(function (TabbedUpsellScreenDefaultTab) {
  TabbedUpsellScreenDefaultTab["MINECRAFT"] = "minecraft";
  TabbedUpsellScreenDefaultTab["XBL"] = "xbl";
  TabbedUpsellScreenDefaultTab["ACHIEVEMENTS"] = "achievements";
  TabbedUpsellScreenDefaultTab["MULTIPLAYER"] = "multiplayer";
  TabbedUpsellScreenDefaultTab["SERVER"] = "server";
  TabbedUpsellScreenDefaultTab["STORE"] = "store";
  TabbedUpsellScreenDefaultTab["CREATIVE"] = "creative";
  TabbedUpsellScreenDefaultTab["PACKS"] = "packs";
  TabbedUpsellScreenDefaultTab["SEEDS"] = "seeds";
})(TabbedUpsellScreenDefaultTab || (TabbedUpsellScreenDefaultTab = {}));

let types_GameMode;

(function (GameMode) {
  GameMode[GameMode["SURVIVAL"] = 0] = "SURVIVAL";
  GameMode[GameMode["CREATIVE"] = 1] = "CREATIVE";
  GameMode[GameMode["ADVENTURE"] = 2] = "ADVENTURE";
})(types_GameMode || (types_GameMode = {}));

let AsyncStatefulFunctionState;
/**
 * Asynchronous functions that can have a persistent result.
 *
 * For a detailed explanation, see:
 * https://github.com/Mojang/minecraft-ui/pull/4571
 */

(function (AsyncStatefulFunctionState) {
  AsyncStatefulFunctionState[AsyncStatefulFunctionState["Idle"] = 0] = "Idle";
  AsyncStatefulFunctionState[AsyncStatefulFunctionState["InProgress"] = 1] = "InProgress";
  AsyncStatefulFunctionState[AsyncStatefulFunctionState["Completed"] = 2] = "Completed";
})(AsyncStatefulFunctionState || (AsyncStatefulFunctionState = {}));
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmsStoriesFacet.ts



let RealmsStoriesFacetStatus;

(function (RealmsStoriesFacetStatus) {
  RealmsStoriesFacetStatus[RealmsStoriesFacetStatus["UNLOADED"] = -1] = "UNLOADED";
  RealmsStoriesFacetStatus[RealmsStoriesFacetStatus["LOADING"] = 0] = "LOADING";
  RealmsStoriesFacetStatus[RealmsStoriesFacetStatus["LOADED"] = 1] = "LOADED";
})(RealmsStoriesFacetStatus || (RealmsStoriesFacetStatus = {}));

let RealmPlayerRoleEnum;

(function (RealmPlayerRoleEnum) {
  RealmPlayerRoleEnum[RealmPlayerRoleEnum["NONMEMBER"] = -1] = "NONMEMBER";
  RealmPlayerRoleEnum[RealmPlayerRoleEnum["VISITOR"] = 0] = "VISITOR";
  RealmPlayerRoleEnum[RealmPlayerRoleEnum["MEMBER"] = 1] = "MEMBER";
  RealmPlayerRoleEnum[RealmPlayerRoleEnum["OPERATOR"] = 2] = "OPERATOR";
  RealmPlayerRoleEnum[RealmPlayerRoleEnum["OWNER"] = 3] = "OWNER";
})(RealmPlayerRoleEnum || (RealmPlayerRoleEnum = {}));

let RealmMemberFilterOption;

(function (RealmMemberFilterOption) {
  RealmMemberFilterOption[RealmMemberFilterOption["All"] = 0] = "All";
  RealmMemberFilterOption[RealmMemberFilterOption["Online"] = 1] = "Online";
  RealmMemberFilterOption[RealmMemberFilterOption["Operators"] = 2] = "Operators";
  RealmMemberFilterOption[RealmMemberFilterOption["Members"] = 3] = "Members";
  RealmMemberFilterOption[RealmMemberFilterOption["Visitors"] = 4] = "Visitors";
  RealmMemberFilterOption[RealmMemberFilterOption["Friends"] = 5] = "Friends";
})(RealmMemberFilterOption || (RealmMemberFilterOption = {}));

let RealmMemberSortOption;

(function (RealmMemberSortOption) {
  RealmMemberSortOption[RealmMemberSortOption["MostRecent"] = 0] = "MostRecent";
  RealmMemberSortOption[RealmMemberSortOption["AlphabeticalAscending"] = 1] = "AlphabeticalAscending";
  RealmMemberSortOption[RealmMemberSortOption["AlphabeticalDescending"] = 2] = "AlphabeticalDescending";
  RealmMemberSortOption[RealmMemberSortOption["LeastRecent"] = 3] = "LeastRecent";
})(RealmMemberSortOption || (RealmMemberSortOption = {}));

let FetchResult;

(function (FetchResult) {
  FetchResult[FetchResult["SUCCESS"] = 0] = "SUCCESS";
  FetchResult[FetchResult["INTERNAL_ERROR"] = 1] = "INTERNAL_ERROR";
  FetchResult[FetchResult["FETCH_FAILED"] = 2] = "FETCH_FAILED";
})(FetchResult || (FetchResult = {}));

let PostResult;

(function (PostResult) {
  PostResult[PostResult["SUCCESS"] = 0] = "SUCCESS";
  PostResult[PostResult["INPUT_INVALID"] = 1] = "INPUT_INVALID";
  PostResult[PostResult["INTERNAL_ERROR"] = 2] = "INTERNAL_ERROR";
  PostResult[PostResult["UPLOAD_FAILED"] = 3] = "UPLOAD_FAILED";
})(PostResult || (PostResult = {}));

const REALMS_STORIES_FACET = 'vanilla.realmsStories';
const realmsStoriesFacet = (0,react_facet_src.sharedFacet)(REALMS_STORIES_FACET);
const REALM_PLAYER_LAST_LOGIN_MAP = new Map();
const REPLACEMENT_REALM_PLAYER_GAMER_TAG = '76b0b1a7-b594-43fc-bb8c-9e60c48669a2';
const isRealmsStoriesLoadedSelector = (0,react_facet_src.sharedSelector)(facet => {
  return facet.status === RealmsStoriesFacetStatus.LOADED;
}, [realmsStoriesFacet]);
const realmStoriesSelector = (0,react_facet_src.sharedSelector)(facet => {
  return slice(facet.data.stories, 0);
}, [realmsStoriesFacet]);
const realmNewStoriesCountSelector = (0,react_facet_src.sharedSelector)(facet => {
  return filter(facet.data.stories, story => !story.hasViewed).length;
}, [realmsStoriesFacet]);
const realmStorySelector = (0,react_facet_src.sharedDynamicSelector)(id => [facet => {
  const realmStory = find_find(facet.data.stories, story => story.id === id);
  const isCommentsLoaded = realmStory ? realmStory.fetchComments.result === FetchResult.SUCCESS : false;
  return {
    isCommentsLoaded,
    realmStory
  };
}, [realmsStoriesFacet]]);
const realmStoryCommentsSelector = (0,react_facet_src.sharedDynamicSelector)(id => [facet => {
  const story = find_find(facet.data.stories, story => story.id === id);
  return story && story.fetchComments.result === FetchResult.SUCCESS ? story.comments : react_facet_src.NO_VALUE;
}, [realmsStoriesFacet, isRealmsStoriesLoadedSelector]]);
function selectMostRecentRealmPlayers(players) {
  // Build player last login map if its empty
  if (REALM_PLAYER_LAST_LOGIN_MAP.entries.length === 0) {
    players.forEach(player => {
      REALM_PLAYER_LAST_LOGIN_MAP.set(player.gamerTag, getLatestRealmPlayerSessionLogin(player));
    });
  }

  return sortRealmPlayerByMostRecent(players);
}
const groupedRealmPlayersByRoleSelector = (0,react_facet_src.sharedSelector)(facet => {
  return groupRealmPlayersByRole(facet.data.members);
}, [realmsStoriesFacet]);
function groupRealmPlayersByRole(players) {
  const allPlayers = [];
  const members = [];
  const operators = [];
  const visitors = [];
  const online = [];
  players.forEach(player => {
    REALM_PLAYER_LAST_LOGIN_MAP.set(player.gamerTag, getLatestRealmPlayerSessionLogin(player));
    allPlayers.push(player);

    if (player.isOnline) {
      online.push(player);
    }

    if (player.role === RealmPlayerRoleEnum.MEMBER) {
      members.push(player);
    } else if (player.role === RealmPlayerRoleEnum.OPERATOR || player.role === RealmPlayerRoleEnum.OWNER) {
      operators.push(player);
    } else if (player.role === RealmPlayerRoleEnum.VISITOR) {
      visitors.push(player);
    }
  });
  return {
    allPlayers,
    members,
    online,
    operators,
    visitors
  };
} // This method adds a fake realm player to the beginning of a list of players. It's used for displaying the vertical add button on the Members Tabs.

function addButtonReplacementPlayer(players) {
  const replacementPlayer = {
    gamerTag: REPLACEMENT_REALM_PLAYER_GAMER_TAG,
    role: RealmPlayerRoleEnum.NONMEMBER,
    isOnline: false,
    profileStatus: RealmsStoriesFacetStatus.LOADED,
    fetchSessions: {
      run: () => {},
      cancel: () => false,
      clear: () => {},
      result: FetchResult.SUCCESS,
      state: AsyncStatefulFunctionState.Completed
    },
    recentSessions: []
  };
  const displayPlayers = [];

  for (let i = -1; i < players.length; i++) {
    if (i == -1) {
      displayPlayers.push(replacementPlayer);
    } else if (i >= 0 && players[i].gamerTag !== REPLACEMENT_REALM_PLAYER_GAMER_TAG) {
      displayPlayers.push(players[i]);
    }
  }

  return displayPlayers;
}
function filterRealmPlayersByGamerTagSearch(players, value) {
  return players.filter(player => player.gamerTag.toLocaleLowerCase().includes(value.toLocaleLowerCase()));
}
function sortRealmPlayerGamerTagAlphabeticallyAscending(members) {
  return members.sort(compareGamerTagAlphabeticallyAscending);
}
function compareGamerTagAlphabeticallyAscending(memberA, memberB) {
  const gamerTagA = memberA.gamerTag.toLocaleLowerCase();
  const gamerTagB = memberB.gamerTag.toLocaleLowerCase();
  return localeCompare(gamerTagA, gamerTagB);
}
function sortRealmPlayerGamerTagAlphabeticallyDescending(members) {
  return members.sort(compareGamerTagAlphabeticallyDescending);
}
function compareGamerTagAlphabeticallyDescending(memberA, memberB) {
  return compareGamerTagAlphabeticallyAscending(memberB, memberA);
}
function sortRealmPlayerByMostRecent(members) {
  return members.sort(comparePlayerLastLoginDescending);
}
function comparePlayerLastLoginDescending(playerA, playerB) {
  const lastLoginB = REALM_PLAYER_LAST_LOGIN_MAP.has(playerB.gamerTag) ? REALM_PLAYER_LAST_LOGIN_MAP.get(playerB.gamerTag) : 0;
  const lastLoginA = REALM_PLAYER_LAST_LOGIN_MAP.has(playerA.gamerTag) ? REALM_PLAYER_LAST_LOGIN_MAP.get(playerA.gamerTag) : 0;
  return lastLoginB - lastLoginA;
}
function sortRealmPlayerByLeastActive(members) {
  return members.sort(comparePlayerLastLoginAscending);
}
function comparePlayerLastLoginAscending(playerA, playerB) {
  return comparePlayerLastLoginDescending(playerB, playerA);
}
function getLatestRealmPlayerSessionLogin(player) {
  player.fetchSessions.run();

  if (player.fetchSessions.result === FetchResult.SUCCESS && player.recentSessions.length > 0) {
    return player.recentSessions[0].login;
  }

  return 0;
}

function forceTwoDigits(num) {
  return (num < 10 && num >= 0 ? '0' : '') + num;
}

function convertSecondsToTime(seconds) {
  const date = new Date(seconds * 1000);
  const minutes = forceTwoDigits(date.getUTCMinutes());
  return `${date.getUTCHours()}:${minutes}`;
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/resourcePacksFacet.ts

let resourcePacksFacet_ResourcePacksFacetStatus; // Original prompt interface for download modal
// Intended to be deprecated when the above becomes mainstream

(function (ResourcePacksFacetStatus) {
  ResourcePacksFacetStatus[ResourcePacksFacetStatus["Idle"] = 0] = "Idle";
  ResourcePacksFacetStatus[ResourcePacksFacetStatus["CheckingResourcePacks"] = 1] = "CheckingResourcePacks";
  ResourcePacksFacetStatus[ResourcePacksFacetStatus["StartDownload"] = 2] = "StartDownload";
  ResourcePacksFacetStatus[ResourcePacksFacetStatus["DownloadingResourcePacks"] = 3] = "DownloadingResourcePacks";
  ResourcePacksFacetStatus[ResourcePacksFacetStatus["ActivateDownloadedPack"] = 4] = "ActivateDownloadedPack";
  ResourcePacksFacetStatus[ResourcePacksFacetStatus["WaitingForPrompt"] = 5] = "WaitingForPrompt";
})(resourcePacksFacet_ResourcePacksFacetStatus || (resourcePacksFacet_ResourcePacksFacetStatus = {}));

const RESOURCE_PACKS_FACET = 'vanilla.resourcePacks';
const resourcePacksFacet = (0,react_facet_src.sharedFacet)(RESOURCE_PACKS_FACET);
const resourcePackApiSelector = (0,react_facet_src.sharedSelector)(facet => {
  return {
    cancelDownload: facet.cancelDownload.bind(facet),
    confirmDownload: facet.confirmDownload.bind(facet),
    activate: facet.activate.bind(facet),
    deactivate: facet.deactivate.bind(facet)
  };
}, [resourcePacksFacet]);
const resourcePackStatusSelector = (0,react_facet_src.sharedSelector)(facet => facet.status, [resourcePacksFacet]);
const texturePackSelectors = {
  activePacks: (0,react_facet_src.sharedSelector)(facet => facet.texturePacks.active, [resourcePacksFacet]),
  activeGlobalPacks: (0,react_facet_src.sharedSelector)(facet => facet.texturePacks.activeGlobal, [resourcePacksFacet]),
  inactivePacks: (0,react_facet_src.sharedSelector)(facet => facet.texturePacks.available, [resourcePacksFacet]),
  realmsPlusPacks: (0,react_facet_src.sharedSelector)(facet => facet.texturePacks.realms, [resourcePacksFacet]),
  featuredPacks: (0,react_facet_src.sharedSelector)(facet => facet.texturePacks.unowned, [resourcePacksFacet])
};
const behaviorPacksEnabledSelector = (0,react_facet_src.sharedSelector)(facet => facet.behaviorPacks.active.length > 0, [resourcePacksFacet]);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/screenTechStackFacet.ts

let ScreenName;

(function (ScreenName) {
  ScreenName["PlayScreen"] = "/play";
  ScreenName["EditWorldScreen"] = "/edit-world";
})(ScreenName || (ScreenName = {}));

let UITechStack;

(function (UITechStack) {
  UITechStack[UITechStack["JsonUI"] = 0] = "JsonUI";
  UITechStack[UITechStack["OreUI"] = 1] = "OreUI";
})(UITechStack || (UITechStack = {}));

const SCREEN_TECH_STACK_FACET = 'vanilla.screenTechStack';
const screenTechStackFacet = (0,react_facet_src.sharedFacet)(SCREEN_TECH_STACK_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/seedTemplateFacet.ts

const SEED_TEMPLATES_FACET = 'vanilla.seedTemplates';
const seedTemplatesFacet = (0,react_facet_src.sharedFacet)(SEED_TEMPLATES_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/simulationDistanceFacet.ts

const SIMULATION_DISTANCE_FACET = 'vanilla.simulationDistanceOptions';
const simulationDistanceFacet = (0,react_facet_src.sharedFacet)(SIMULATION_DISTANCE_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/telemetryFacet.ts

const TELEMETRY_FACET = 'vanilla.telemetry';
const telemetryFacet = (0,react_facet_src.sharedFacet)(TELEMETRY_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/userAccountFacet.ts
 //The order of this enum should match the PostSignInAction enum in Minecraftpe's UserAccountFacet.h

let PostSignInAction;

(function (PostSignInAction) {
  PostSignInAction[PostSignInAction["DO_NOTHING"] = 0] = "DO_NOTHING";
  PostSignInAction[PostSignInAction["SAVE_ENTITLEMENTS"] = 1] = "SAVE_ENTITLEMENTS";
})(PostSignInAction || (PostSignInAction = {}));

const USER_ACCOUNT_FACET = 'vanilla.userAccount';
const userAccountFacet = (0,react_facet_src.sharedFacet)(USER_ACCOUNT_FACET);
const isTrialAccountSelector = (0,react_facet_src.sharedSelector)(facet => facet.isTrialAccount, [userAccountFacet]);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/vanillaFeatureFlags.ts
//Vanilla feature flags
const DISABLE_ANIMATED_SIGN_IN_SCREENS = 'vanilla.disableAnimatedSignInScreens';
;// CONCATENATED MODULE: ./games/vanilla/engine/src/webBrowserFacet.ts

let WebBrowserLink;

(function (WebBrowserLink) {
  WebBrowserLink[WebBrowserLink["NewWorldCreationFeedbackPage"] = 0] = "NewWorldCreationFeedbackPage";
  WebBrowserLink[WebBrowserLink["PlayScreenFeedbackPage"] = 1] = "PlayScreenFeedbackPage";
  WebBrowserLink[WebBrowserLink["EditWorldScreenFeedbackPage"] = 2] = "EditWorldScreenFeedbackPage";
  WebBrowserLink[WebBrowserLink["DeathScreenFeedbackPage"] = 3] = "DeathScreenFeedbackPage";
})(WebBrowserLink || (WebBrowserLink = {}));

const WEB_BROWSER_FACET = 'vanilla.webBrowserFacet';
const webBrowserFacet = (0,react_facet_src.sharedFacet)(WEB_BROWSER_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/worldListFacet.ts

const WORLD_LIST_FACET = 'vanilla.worldList';
const worldListFacet = (0,react_facet_src.sharedFacet)(WORLD_LIST_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/worldStartupFacet.ts

let StartLocalWorldResult;

(function (StartLocalWorldResult) {
  StartLocalWorldResult[StartLocalWorldResult["Ok"] = 0] = "Ok";
  StartLocalWorldResult[StartLocalWorldResult["WorldNotInLevelList"] = 1] = "WorldNotInLevelList";
  StartLocalWorldResult[StartLocalWorldResult["StartupAlreadyInProgress"] = 2] = "StartupAlreadyInProgress";
  StartLocalWorldResult[StartLocalWorldResult["GameServerStarterNotReady"] = 3] = "GameServerStarterNotReady";
})(StartLocalWorldResult || (StartLocalWorldResult = {}));

const WORLD_STARTUP_FACET = 'vanilla.worldStartup';
const worldStartupFacet_worldStartupFacet = (0,react_facet_src.sharedFacet)(WORLD_STARTUP_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/worldTemplateListFacet.ts

const WORLD_TEMPLATE_LIST_FACET = 'vanilla.worldTemplateList';
const worldTemplateListFacet = (0,react_facet_src.sharedFacet)(WORLD_TEMPLATE_LIST_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/worldTransferFacet.ts

// This enum should be synced with:
// 	MinecraftPe::handheld/src-client/common/client/world/WorldTransferer.h
let WorldTransferResult;

(function (WorldTransferResult) {
  WorldTransferResult[WorldTransferResult["Success"] = 0] = "Success";
  WorldTransferResult[WorldTransferResult["FailureUnknown"] = 1] = "FailureUnknown";
  WorldTransferResult[WorldTransferResult["FailureNoFile"] = 2] = "FailureNoFile";
  WorldTransferResult[WorldTransferResult["FailureZipError"] = 3] = "FailureZipError";
  WorldTransferResult[WorldTransferResult["FailurePremiumContent"] = 4] = "FailurePremiumContent";
  WorldTransferResult[WorldTransferResult["FailureEditionMismatch"] = 5] = "FailureEditionMismatch";
  WorldTransferResult[WorldTransferResult["FailureEditorMismatch"] = 6] = "FailureEditorMismatch";
  WorldTransferResult[WorldTransferResult["UnsupportedPlatform"] = 7] = "UnsupportedPlatform";
  WorldTransferResult[WorldTransferResult["AlreadyInProgress"] = 8] = "AlreadyInProgress";
  WorldTransferResult[WorldTransferResult["InterruptedByUser"] = 9] = "InterruptedByUser";
})(WorldTransferResult || (WorldTransferResult = {}));

const WORLD_TRANSFER_FACET = 'vanilla.worldTransfer';
const worldTransferFacet = (0,react_facet_src.sharedFacet)(WORLD_TRANSFER_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/index.ts































;// CONCATENATED MODULE: ./packages/ui/src/GlassPane/GlassPane.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const GlassPane = ({"glassPane":"mneRL"});
;// CONCATENATED MODULE: ./packages/ui/src/GlassPane/GlassPane.tsx




function GlassPane_GlassPane({
  onClick,
  innerRef,
  children,
  role = 'neutral50'
}) {
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  const glassPaneClassNames = classnames_default()(GlassPane.glassPane, semanticClassNames.overlay.base);
  return children != null ? /*#__PURE__*/react.createElement("div", {
    onClick: onClick,
    className: glassPaneClassNames,
    ref: innerRef
  }, children) : /*#__PURE__*/react.createElement("div", {
    onClick: onClick,
    className: glassPaneClassNames,
    ref: innerRef
  });
}
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/NavigationBarLayout.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NavigationBarLayout = ({"NavigationBarLayout":"JAtEp","NavigationBarLayoutChildrenWrapper":"jCHoJ","NavigationBarLayoutChildren":"LH19k"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/NavigationBar/NavigationBar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NavigationBar = ({"NavigationBar":"KfhFh","NavigationBarShadow":"V4fHo","NavigationBarDropShadow":"twp35","center":"S9tQ7","left":"C0sd8","right":"m2lNR","NavigationBarSafeZoneWrapper":"xCDda"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/NavigationBar/NavigationBar.tsx





function NavigationBar_NavigationBar({
  left,
  center,
  right,
  safeZone,
  innerRef,
  role = 'neutral20',
  showDropShadow = true
}) {
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(NavigationBar.NavigationBar, semanticClassNames.background.base)
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      paddingTop: safeZone && safeZone.top + 'px',
      paddingRight: safeZone && safeZone.right + 'px',
      paddingLeft: safeZone && safeZone.left + 'px'
    }
  }, /*#__PURE__*/react.createElement("div", {
    ref: innerRef,
    className: NavigationBar.NavigationBarSafeZoneWrapper
  }, /*#__PURE__*/react.createElement("div", {
    className: NavigationBar.left
  }, left), /*#__PURE__*/react.createElement("div", {
    className: NavigationBar.center
  }, center), /*#__PURE__*/react.createElement("div", {
    className: NavigationBar.right
  }, right)), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    top: false,
    right: false,
    left: false,
    role: role
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(NavigationBar.NavigationBarShadow, semanticClassNames.shadow.base)
  }), showDropShadow && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(NavigationBar.NavigationBarDropShadow)
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel",
    role: role,
    top: false,
    right: false,
    left: false
  }))));
}
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBack/images/arrowBack.png
const arrowBack_namespaceObject = __webpack_require__.p + "assets/arrowBack-b77b1.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBack/IconArrowBack.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowBack = ({"iconArrowBack":"WLynF"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBack/IconArrowBack.tsx




const IconArrowBack_IconArrowBack = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconArrowBack.iconArrowBack,
  src: arrowBack_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/BackButton/BackButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BackButton = ({"emptySpace":"QZTxX"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/BackButton/BackButton.tsx










function BackButton_BackButton({
  onClick,
  disabled,
  showEmptySpaceWhenGamepad = false,
  role = 'inherit'
}) {
  const isPointerSupported = useIsPointerSupported();
  const isFocusInputGamepad = useIsFocusInputGamepad();
  const showBackButton = (0,react_facet_src.useFacetMap)((isPointerInputSupported, isFocusInputGamepad) => isPointerInputSupported || !isFocusInputGamepad, [], [isPointerSupported, isFocusInputGamepad]);
  const showEmptySpace = (0,react_facet_src.useFacetMap)(showBackButton => showEmptySpaceWhenGamepad && !showBackButton, [showEmptySpaceWhenGamepad], [showBackButton]);
  const {
    t
  } = useLocalization('BackButton');
  const shortcutOptions = (0,react_facet_src.useFacetMap)(isAnyModalVisible => ({
    button: types_ButtonType.B,
    inputLegend: t('.back'),
    disabled: isAnyModalVisible
  }), [t], [Modal_Modal_Modal.useIsAnyModalVisible()]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: shortcutOptions,
    onClick: onClick
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showBackButton
  }, /*#__PURE__*/react.createElement(DefaultBackButton, {
    onClick: onClick,
    disabled: disabled,
    role: role
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showEmptySpace
  }, /*#__PURE__*/react.createElement("div", {
    className: BackButton.emptySpace
  })));
}

function DefaultBackButton({
  onClick,
  disabled,
  role = 'inherit'
}) {
  const {
    t
  } = useLocalization('BackButton');
  const {
    sound: {
      [role]: semanticSound
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(NavigationButton_NavigationButton, {
    narrationText: [t('.narrationGoBack'), t('.narrationComponentType')].join(' . '),
    gamepadIndex: 0,
    inputLegend: t('.back'),
    onClick: onClick,
    disabled: disabled,
    soundEffectPressed: semanticSound.press,
    role: role
  }, /*#__PURE__*/react.createElement(IconArrowBack_IconArrowBack, null));
}
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/MenuButton/images/filter.png
const images_filter_namespaceObject = __webpack_require__.p + "assets/filter-93196.png";
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/MenuButton/images/hamburger.png
const hamburger_namespaceObject = __webpack_require__.p + "assets/hamburger-3fe0f.png";
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/MenuButton/MenuButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MenuButton = ({"burger":"ATA6g","selected":"G44L7","highlighted":"flc7y","touchedDown":"QCYoq","focused":"jSYWL","icon":"w6_7m"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/MenuButton/MenuButton.tsx









function MenuButton_MenuButton({
  onClick,
  selected,
  type = 'hamburger',
  gamepadIndex
}) {
  const {
    t
  } = useLocalization('MenuButton');
  return /*#__PURE__*/react.createElement(react.Fragment, null, type === 'hamburger' && /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: {
      button: types_ButtonType.START,
      inputLegend: t('.menu')
    },
    onClick: onClick
  }), /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    narrationText: false,
    className: classnames_default()(MenuButton.burger, {
      [MenuButton.selected]: selected
    }),
    classNamePressed: MenuButton.touchedDown,
    classNameHovered: MenuButton.highlighted,
    classNameFocused: MenuButton.focused,
    gamepadIndex: gamepadIndex,
    inputLegend: t('.toggle'),
    onClick: onClick
  }, selected && /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel",
    reversed: true
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: MenuButton.icon,
    imageRendering: "pixelated",
    src: type === 'filter' ? images_filter_namespaceObject : hamburger_namespaceObject
  })));
}
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/CollapsableSideBar/CollapsableSideBar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const CollapsableSideBar = ({"collapsableSideBar":"G1xD7","collapsableSideBarDark":"deJBY","collapsed":"eknQ4","borderRight":"sJUSR","borderLeft":"d5YO7","floatingRight":"b8Law","floatingLeft":"efBI4"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/CollapsableSideBar/CollapsableSideBar.tsx






function CollapsableSideBar_CollapsableSideBar({
  children,
  collapsed = false,
  floating = false,
  onDismiss,
  gamepadIndex,
  align = 'left'
}) {
  const ref = (0,react.useRef)(null);
  const handleOnClick = (0,react.useCallback)(event => {
    event.stopPropagation();
  }, []);
  const collapsableSideBar = /*#__PURE__*/react.createElement(Column, {
    options: {
      defaultFocusedChildBehavior: 'remember',
      index: gamepadIndex
    },
    shouldSkipLandmarkInVisual: true
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    onClick: handleOnClick,
    className: classnames_default()({
      [CollapsableSideBar.collapsed]: collapsed,
      [CollapsableSideBar.collapsableSideBar]: align === 'left',
      [CollapsableSideBar.collapsableSideBarDark]: align === 'right',
      [CollapsableSideBar.borderRight]: align === 'left',
      [CollapsableSideBar.borderLeft]: align === 'right'
    })
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 0
  }, children)));
  return floating ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      [CollapsableSideBar.floatingRight]: align === 'right',
      [CollapsableSideBar.floatingLeft]: align === 'left',
      [CollapsableSideBar.collapsed]: collapsed
    })
  }, collapsableSideBar), !collapsed && /*#__PURE__*/react.createElement(GlassPane_GlassPane, {
    onClick: onDismiss
  })) : collapsableSideBar;
}
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/NavigationBarLayout.tsx











function NavigationBarLayout_NavigationBarLayout({
  children,
  collapsedLeftSidebar = true,
  collapsedRightSidebar = true,
  onToggleCollapsedLeftSidebar = NavigationBarLayout_noop,
  onToggleCollapsedRightSidebar = NavigationBarLayout_noop,
  innerRef,
  left,
  center,
  right,
  leftSidebar,
  rightSidebar,
  footer,
  narrationText,
  navigationBarRole,
  navigationBarShowDropShadow = true
}) {
  const narrationTextFacet = (0,react_facet_src.useFacetMap)(text => text !== null && text !== void 0 ? text : '', [], [(0,react_facet_src.useFacetWrap)(narrationText)]);
  const safeZone = useSafeZone();
  const isNarrow = useIsWindowNarrow();
  const ref = (0,react.useRef)(null);
  const navigationBarRef = (0,react.useRef)(null);
  const {
    version: gamepadAdapterVersion
  } = useGamepadAdapter();
  const defaultFocusedChildBehavior = gamepadAdapterVersion === GamepadAdapterVersion.VISUAL ? undefined : !collapsedRightSidebar ? 'last' : 'first';
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: narrationTextFacet
  }, /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", {
    ref: innerRef,
    className: NavigationBarLayout.NavigationBarLayout
  }, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    scrollRef: navigationBarRef,
    defaultFocusedChildBehavior: "first",
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(NavigationBar_NavigationBar, {
    innerRef: navigationBarRef,
    left: /*#__PURE__*/react.createElement(react.Fragment, null, left, isNarrow && leftSidebar != null && /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout.MenuButton, {
      selected: !collapsedLeftSidebar,
      onClick: onToggleCollapsedLeftSidebar,
      gamepadIndex: 0
    })),
    center: center,
    right: /*#__PURE__*/react.createElement(react.Fragment, null, right, rightSidebar != null && /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout.MenuButton, {
      type: "filter",
      selected: !collapsedRightSidebar,
      onClick: onToggleCollapsedRightSidebar,
      gamepadIndex: 1
    })),
    safeZone: safeZone,
    role: navigationBarRole,
    showDropShadow: navigationBarShowDropShadow
  })), /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    scrollRef: ref,
    gamepadIndex: 1,
    defaultFocusedChildBehavior: defaultFocusedChildBehavior
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: NavigationBarLayout.NavigationBarLayoutChildrenWrapper
  }, /*#__PURE__*/react.createElement("div", {
    className: NavigationBarLayout.NavigationBarLayoutChildren,
    style: {
      left: safeZone.left + 'px',
      right: safeZone.right + 'px',
      bottom: safeZone.bottom + 'px'
    }
  }, leftSidebar != null && /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 0,
    disabled: collapsedLeftSidebar && isNarrow
  }, /*#__PURE__*/react.createElement(CollapsableSideBar_CollapsableSideBar, {
    align: "left",
    onDismiss: onToggleCollapsedLeftSidebar,
    floating: isNarrow,
    collapsed: isNarrow && collapsedLeftSidebar,
    gamepadIndex: 0
  }, leftSidebar)), /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 1,
    disabled: !collapsedLeftSidebar && isNarrow && Boolean(leftSidebar)
  }, children), rightSidebar != null && /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 2,
    disabled: collapsedRightSidebar
  }, /*#__PURE__*/react.createElement(CollapsableSideBar_CollapsableSideBar, {
    align: "right",
    onDismiss: onToggleCollapsedRightSidebar,
    floating: isNarrow,
    collapsed: collapsedRightSidebar,
    gamepadIndex: 0
  }, rightSidebar)))), footer))));
}
NavigationBarLayout_NavigationBarLayout.displayName = 'NavigationBarLayout';
NavigationBarLayout_NavigationBarLayout.BackButton = BackButton_BackButton;
NavigationBarLayout_NavigationBarLayout.MenuButton = MenuButton_MenuButton;

const NavigationBarLayout_noop = () => {};
;// CONCATENATED MODULE: ./packages/ui/src/Grid/Grid.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Grid = ({"grid":"ntKoM","gridGutters":"ff9nb","gridTablet":"U7wpy","gridNarrow":"QkM5F","row":"RdcBM","rowFullHeight":"RLVUP","column":"HC8D1","size0":"QfUEI","size1":"Utxph","size2":"Dg54A","size3":"MMNOr","size4":"vkrmB","size5":"Vg8dV","size6":"prur7","size7":"PbjpE","size8":"KbazU","size9":"M3EqJ","size10":"sjbd3","size11":"Pp_FL","size12":"tylz3","sizeNarrow0":"ms6DS","sizeNarrow1":"JOyPB","sizeNarrow2":"LG4ow","sizeNarrow3":"jyNdx","sizeNarrow4":"fgAuI","sizeNarrow5":"lGz_T","sizeNarrow6":"drXOL","sizeNarrow7":"VDLgd","sizeNarrow8":"A06Gv"});
;// CONCATENATED MODULE: ./packages/ui/src/Grid/Grid.tsx






const Grid_Column = props => {
  const {
    disabled,
    defaultFocusedChildAlias,
    defaultFocusedChildBehavior,
    wideSize,
    narrowSize
  } = props;
  const sizeStyle = classnames_default()(Grid[`size${wideSize}`], Grid[`sizeNarrow${narrowSize}`]);
  const className = classnames_default()(Grid.column, sizeStyle);

  if ('gamepadIndex' in props) {
    return /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
      shouldSkipLandmarkInVisual: true,
      gamepadIndex: props.gamepadIndex,
      disabled: disabled,
      defaultFocusedChildAlias: defaultFocusedChildAlias,
      defaultFocusedChildBehavior: defaultFocusedChildBehavior
    }, /*#__PURE__*/react.createElement("div", {
      className: className
    }, props.children));
  } // Column used as a spacer


  return /*#__PURE__*/react.createElement("div", {
    className: className
  });
};

function Grid_Row({
  children,
  gamepadIndex,
  disabled,
  defaultFocusedChildAlias,
  defaultFocusedChildBehavior,
  fullHeight,
  className
}) {
  return /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    gamepadIndex: gamepadIndex,
    shouldSkipLandmarkInVisual: true,
    disabled: disabled,
    defaultFocusedChildAlias: defaultFocusedChildAlias,
    defaultFocusedChildBehavior: defaultFocusedChildBehavior
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Grid.row, className, {
      [Grid.rowFullHeight]: fullHeight
    })
  }, children));
}

function Grid_Grid({
  children,
  noGutters = false
}) {
  const breakpoint = useWindowBreakpoint();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Grid.grid, {
      [Grid.gridNarrow]: breakpoint === 'narrow',
      [Grid.gridTablet]: breakpoint === 'tablet',
      [Grid.gridGutters]: breakpoint === 'desktop' || !noGutters
    })
  }, children);
}
Grid_Grid.displayName = 'Grid';
Grid_Grid.Column = Grid_Column;
Grid_Grid.Row = Grid_Row;
;// CONCATENATED MODULE: ./packages/ui/src/EmptyStateMessage/EmptyStateMessage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const EmptyStateMessage = ({"EmptyStateMessage":"dST3K","EmptyStateMessageBorderless":"iBeh_","completedIllustration":"fMTts","singleButtonContainer":"PIvFb","twoButtonContainer":"JJ32W","tripleButtonContainer":"WDNdm"});
;// CONCATENATED MODULE: ./packages/ui/src/EmptyStateMessage/EmptyStateMessage.tsx














function useFocusButton(buttons, autofocus) {
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  (0,react_facet_src.useFacetEffect)(buttons => {
    if (!autofocus) {
      return;
    }

    const buttonToFocus = buttons.find(b => b === null || b === void 0 ? void 0 : b.gamepadAlias);

    if ((buttonToFocus === null || buttonToFocus === void 0 ? void 0 : buttonToFocus.gamepadAlias) != null) {
      setFocusedId(buttonToFocus.gamepadAlias);
    }
  }, [autofocus, setFocusedId], [buttons]);
}

function EmptyStateButton({
  item,
  autofocus,
  gamepadIndex,
  numberOfSiblings,
  horizontal,
  linebreak
}) {
  const {
    t
  } = useLocalization('EmptyStateMessage');
  const onClick = (0,react_facet_src.useFacetCallback)(item => item.onClick, [], [item]);
  const inputLegend = (0,react_facet_src.useFacetMap)(item => {
    var _item$inputLegend;

    return (_item$inputLegend = item.inputLegend) !== null && _item$inputLegend !== void 0 ? _item$inputLegend : t('.buttonSelectInputLegend');
  }, [t], [item]);
  const text = (0,react_facet_src.useFacetMap)(item => item.text, [], [item]);
  const imgSrc = (0,react_facet_src.useFacetMap)(item => item.imgSrc, [], [item]);
  const isLastButton = (0,react_facet_src.useFacetMap)(numberOfSiblings => gamepadIndex === numberOfSiblings - 1, [gamepadIndex], [numberOfSiblings]); // Leaving these unwrapped until the underlying Pressable/Button components
  // are updated to accept FacetProp types for these props

  const variant = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(item => {
    var _item$variant;

    return (_item$variant = item.variant) !== null && _item$variant !== void 0 ? _item$variant : 'secondary';
  }, [], [item]));
  const gamepadAlias = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(item => item.gamepadAlias, [], [item]));
  const horizontalUnwrapped = (0,react_facet_src.useFacetUnwrap)(horizontal);
  const linebreakUnwrapped = (0,react_facet_src.useFacetUnwrap)(linebreak);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    linebreak: linebreakUnwrapped === true,
    horizontal: horizontalUnwrapped === true,
    delayedClick: true,
    variant: variant == react_facet_src.NO_VALUE ? 'secondary' : variant,
    onClick: onClick,
    inputLegend: inputLegend,
    autofocus: autofocus,
    gamepadAlias: gamepadAlias == react_facet_src.NO_VALUE ? undefined : gamepadAlias,
    gamepadIndex: gamepadIndex,
    imgSrc: imgSrc
  }, text), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLastButton,
    condition: false
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  })));
}

function EmptyStateButtons(props) {
  const {
    buttons,
    autofocus,
    gamepadIndex
  } = props;
  const breakpoint = useWindowBreakpoint();
  const numberOfButtons = (0,react_facet_src.useFacetMap)(buttons => buttons.length, [], [buttons]);
  const isMoreThanOneButton = (0,react_facet_src.useFacetMap)(numberOfButtons => numberOfButtons > 1, [], [numberOfButtons]);
  const shouldLinebreak = (0,react_facet_src.useFacetMap)( // If there are three buttons on a wide/medium viewport, then linebreak.
  // Don't linebreak lots of buttons on narrow viewport as they can easily
  // overflow when the buttons get too small.
  numberOfButtons => numberOfButtons <= 2 || numberOfButtons > 2 && !(breakpoint === 'narrow'), [breakpoint], [numberOfButtons]);
  useFocusButton(buttons, autofocus);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Row, {
    shouldSkipLandmarkInVisual: true,
    options: {
      index: gamepadIndex
    }
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(numberOfButtons => numberOfButtons === 1 ? EmptyStateMessage.singleButtonContainer : numberOfButtons === 2 ? EmptyStateMessage.twoButtonContainer : EmptyStateMessage.tripleButtonContainer, [], [numberOfButtons])
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: buttons
  }, (item, index) => /*#__PURE__*/react.createElement(EmptyStateButton, {
    linebreak: shouldLinebreak,
    horizontal: isMoreThanOneButton,
    item: item,
    gamepadIndex: index,
    autofocus: autofocus,
    numberOfSiblings: numberOfButtons
  })))));
} // A helper type for ensuring that we receive either the text prop, the title
// prop, or both. The component requires at least one of them.


function EmptyStateMessage_EmptyStateMessage({
  gamepadIndex,
  title,
  text,
  imgSrc,
  imgClass,
  buttons: buttonsFacetProp,
  autofocus,
  borderless = false,
  gamepadAlias,
  role = 'neutral80'
}) {
  const {
    t
  } = useLocalization('EmptyStateMessage');
  const imgSrcFacet = (0,react_facet_src.useFacetWrap)(imgSrc);
  const {
    color: {
      [role]: semanticClassNames
    },
    variant
  } = useSemanticTokens();
  const className = classnames_default()(EmptyStateMessage.EmptyStateMessage, semanticClassNames.background.base, semanticClassNames.border.base, {
    [EmptyStateMessage.EmptyStateMessageBorderless]: borderless
  });
  const imgClasses = classnames_default()(EmptyStateMessage.completedIllustration, imgClass);
  const buttons = (0,react_facet_src.useFacetWrap)(buttonsFacetProp !== null && buttonsFacetProp !== void 0 ? buttonsFacetProp : []);
  const hasButton = (0,react_facet_src.useFacetMap)(buttons => buttons != null && buttons.length > 0, [], [buttons]);
  const narrationText = (0,react_facet_src.useFacetMap)( // If there is a button, we instead narrate the title when it's focused, then
  // the button, and then the text (via the Button's narrationSuffix prop)
  (title, text, hasButton) => hasButton ? title : `${title} . ${t('.narrationTextBlock')} . ${text}`, [t], [(0,react_facet_src.useFacetWrap)(title !== null && title !== void 0 ? title : ''), (0,react_facet_src.useFacetWrap)(text !== null && text !== void 0 ? text : ''), hasButton]);
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: narrationText
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: (0,react_facet_src.useFacetMap)(hasButton => !hasButton, [], [hasButton]),
    className: className,
    classNameFocused: focusClass,
    gamepadIndex: gamepadIndex,
    narrationText: false,
    autofocus: autofocus,
    gamepadAlias: gamepadAlias
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement("div", {
    className: semanticClassNames.text.base
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "secondaryButton",
    color: "inherit",
    align: "center"
  }, title)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(imgSrc => imgSrc != null, [], [imgSrcFacet])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    imageRendering: "pixelated",
    src: imgSrc,
    className: imgClasses
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(semanticClassNames.text.base, variant.dimmest)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit",
    align: "center"
  }, text)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasButton
  }, /*#__PURE__*/react.createElement(EmptyStateButtons, {
    buttons: buttons,
    gamepadIndex: gamepadIndex,
    autofocus: autofocus
  }))));
}
;// CONCATENATED MODULE: ./packages/ui/src/TabBar/TabBar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const TabBar = ({"tabBar":"skOQQ","tab":"vaqPZ","tabContainer":"d2Oi5","outerTab":"nYWhJ","tabEdge":"y6Sow","tabPressed":"Asqnc","indicator":"osEZN","tabFocused":"Fd_3e","hintContainerLeft":"kNiYk","hintContainerRight":"QmvqS","hintLeftKey":"UbMe_","hintRightKey":"psX5S","contentContainer":"vQ853","condensed":"zgD8j","hidden":"XlhDT","bumperHintWrapper":"z4iyJ"});
;// CONCATENATED MODULE: ./packages/ui/src/TabBar/TabBar.tsx
















function TabBar_TabBar({
  tabs,
  gamepadIndex,
  gamepadAliasNamespace,
  value,
  onChange,
  enableGamepadShortcuts,
  onTabHoveredSoundEffect,
  onTabPressedSoundEffect,
  isCondensed = false,
  autofocus = false,
  role = 'neutral'
}) {
  const ref = (0,react.useRef)(null);
  const enableGamepadShortcutsFacet = (0,react_facet_src.useFacetWrap)(enableGamepadShortcuts !== null && enableGamepadShortcuts !== void 0 ? enableGamepadShortcuts : false);
  const tabsFacet = (0,react_facet_src.useFacetWrap)(tabs);
  const tabsLength = (0,react_facet_src.useFacetMap)(tabs => tabs.length, [], [tabsFacet]);
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const {
    color: {
      [role]: semanticClassNames
    },
    sound: {
      [role]: semanticSound
    }
  } = useSemanticTokens();
  const triggerSoundEffect = useSoundEffectTrigger();
  const onChangeWithSound = (0,react_facet_src.useFacetCallback)((pressedSoundEffect, currentValue) => (value, usingGamepadShortcut) => {
    if (currentValue === value) {
      return;
    }

    const soundEffect = pressedSoundEffect !== null && pressedSoundEffect !== void 0 ? pressedSoundEffect : semanticSound.toggle;

    if (soundEffect != null) {
      triggerSoundEffect(soundEffect);
    }

    onChange(value, usingGamepadShortcut);
  }, [onChange, semanticSound.toggle, triggerSoundEffect], [(0,react_facet_src.useFacetWrap)(onTabPressedSoundEffect), valueFacet]);
  const rowOptions = (0,react_facet_src.useFacetMap)(value => {
    const options = {
      index: gamepadIndex,
      defaultFocusedChildBehavior: 'remember',
      defaultFocusedChildAlias: getFocusAlias(gamepadAliasNamespace, value == null ? '' : value)
    };
    return options;
  }, [gamepadIndex, gamepadAliasNamespace], [valueFacet]); // Tab label, tab, selected | not selected, x of y

  return /*#__PURE__*/react.createElement(Row, {
    options: rowOptions,
    shouldSkipLandmarkInVisual: true,
    scrollRef: ref
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: classnames_default()(TabBar.tabBar, semanticClassNames.text.base, semanticClassNames.text.disable)
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: tabsFacet
  }, (tab, index) => /*#__PURE__*/react.createElement(Tab, {
    autofocus: autofocus && index === 0,
    gamepadAliasNamespace: gamepadAliasNamespace,
    key: `tab_${index}`,
    index: index,
    length: tabsLength,
    tab: tab,
    selectedTab: valueFacet,
    onChange: onChangeWithSound,
    onTabHoveredSoundEffect: onTabHoveredSoundEffect,
    isCondensed: isCondensed
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: enableGamepadShortcutsFacet
  }, /*#__PURE__*/react.createElement(BumperHints, {
    value: valueFacet,
    onChange: onChangeWithSound,
    tabs: tabsFacet
  }))));
}

const BumperHints = function ({
  value,
  tabs,
  onChange
}) {
  const isFocusInputGamepad = useIsFocusInputGamepad();
  const isFocusInputKeyboard = useIsFocusInputKeyboard();
  const isFocusInputAvailable = useIsFocusInputAvailable();
  const tabIndexToValue = (0,react_facet_src.useFacetCallback)(tabs => selectedIndex => {
    return tabs[selectedIndex].value;
  }, [], [tabs]);
  const tabValueToIndex = (0,react_facet_src.useFacetCallback)(tabs => newValue => {
    return tabs.findIndex(({
      value
    }) => value === newValue);
  }, [], [tabs]);
  const selectedIndex = (0,react_facet_src.useFacetMap)(value => tabValueToIndex(value), [tabValueToIndex], [value]);
  const leftBumperPress = (0,react_facet_src.useFacetCallback)(selectedIndex => () => {
    const newSelectedIndex = selectedIndex - 1;

    if (newSelectedIndex > -1) {
      const result = tabIndexToValue(newSelectedIndex);

      if (result !== react_facet_src.NO_VALUE) {
        onChange(result, true);
      }
    }
  }, [tabIndexToValue, onChange], [selectedIndex]);
  const rightBumperPress = (0,react_facet_src.useFacetCallback)((tabs, selectedIndex) => () => {
    const newSelectedIndex = selectedIndex + 1;

    if (newSelectedIndex < tabs.length) {
      const result = tabIndexToValue(newSelectedIndex);

      if (result !== react_facet_src.NO_VALUE) {
        onChange(result, true);
      }
    }
  }, [tabIndexToValue, onChange], [tabs, selectedIndex]);
  const isAnyModalVisible = Modal_Modal_Modal.useIsAnyModalVisible();
  const leftBumperOptions = (0,react_facet_src.useFacetMap)(isAnyModalVisible => ({
    button: types_ButtonType.LEFT_BUMPER,
    disabled: isAnyModalVisible
  }), [], [isAnyModalVisible]);
  const rightBumperOptions = (0,react_facet_src.useFacetMap)(isAnyModalVisible => ({
    button: types_ButtonType.RIGHT_BUMPER,
    disabled: isAnyModalVisible
  }), [], [isAnyModalVisible]);
  const gamepadBumperClassName = (0,react_facet_src.useFacetMap)(isGamepad => isGamepad ? TabBar.bumperHintWrapper : `${TabBar.bumperHintWrapper} ${TabBar.hidden}`, [], [isFocusInputGamepad]);
  const keyboardBumperClassName = (0,react_facet_src.useFacetMap)(isKeyboard => isKeyboard ? TabBar.bumperHintWrapper : `${TabBar.bumperHintWrapper} ${TabBar.hidden}`, [], [isFocusInputKeyboard]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isFocusInputAvailable
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: leftBumperOptions,
    onClick: leftBumperPress
  }), /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: rightBumperOptions,
    onClick: rightBumperPress
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: gamepadBumperClassName
  }, /*#__PURE__*/react.createElement("div", {
    className: TabBar.hintContainerLeft
  }, /*#__PURE__*/react.createElement(ButtonIcon.Gamepad, {
    button: types_ButtonType.LEFT_BUMPER
  })), /*#__PURE__*/react.createElement("div", {
    className: TabBar.hintContainerRight
  }, /*#__PURE__*/react.createElement(ButtonIcon.Gamepad, {
    button: types_ButtonType.RIGHT_BUMPER
  }))), /*#__PURE__*/react.createElement("fast-div", {
    className: keyboardBumperClassName
  }, /*#__PURE__*/react.createElement("div", {
    className: TabBar.hintLeftKey
  }, /*#__PURE__*/react.createElement(ButtonIcon.Keyboard, {
    keyCode: KeyboardKey.KEY_Q
  })), /*#__PURE__*/react.createElement("div", {
    className: TabBar.hintRightKey
  }, /*#__PURE__*/react.createElement(ButtonIcon.Keyboard, {
    keyCode: KeyboardKey.KEY_E
  })))));
};

function Tab({
  gamepadAliasNamespace,
  selectedTab,
  onChange,
  index,
  length,
  tab,
  onTabHoveredSoundEffect,
  onTabPressedSoundEffect,
  isCondensed = false,
  autofocus = false,
  role = 'neutral'
}) {
  const {
    t
  } = useLocalization('TabBar');
  const {
    narrateText
  } = useNarrateText();
  const {
    color: {
      [role]: semanticClassNames
    },
    modifier
  } = useSemanticTokens();
  const isSelected = (0,react_facet_src.useFacetMap)((selected, tab) => selected === tab.value, [], [selectedTab, tab]);
  const selected = (0,react_facet_src.useFacetUnwrap)(isSelected);
  const narrationText = (0,react_facet_src.useFacetMap)((tab, isSelected, length) => [tab.label, t('.narrationComponentType'), t('.selectedTab', [`${index + 1}`, `${length}`]), t(`.${isSelected ? 'selected' : 'notSelected'}`)].join(' . '), [index, t], [tab, isSelected, length]);
  const className = (0,react_facet_src.useFacetMap)(isSelected => {
    return classnames_default()(TabBar.tab, semanticClassNames.background.interactive, semanticClassNames.text.base, semanticClassNames.text.disable, semanticClassNames.border.base, {
      [TabBar.condensed]: isCondensed,
      [modifier.pressed]: isSelected,
      [TabBar.tabPressed]: isSelected
    });
  }, [isCondensed, modifier, semanticClassNames], [isSelected]);
  const onClick = (0,react_facet_src.useFacetCallback)(tab => () => {
    narrateText(t('.selected'));
    onChange(tab.value, false);
  }, [narrateText, onChange, t], [tab]);
  const gamepadAlias = (0,react_facet_src.useFacetMap)(tab => getFocusAlias(gamepadAliasNamespace, tab.value), [gamepadAliasNamespace], [tab]);
  const inputLegend = (0,react_facet_src.useFacetMap)(isSelected => isSelected ? false : t('.open'), [t], [isSelected]);
  const icons = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)((tab, isSelected) => tab.icons && /*#__PURE__*/react.createElement(react.Fragment, null, tab.icons[isSelected ? 'selected' : 'unselected'], /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  })), [], [tab, isSelected]));
  const label = (0,react_facet_src.useFacetMap)(tab => tab.label, [], [tab]);

  if (selected === react_facet_src.NO_VALUE) {
    return null;
  }

  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    autofocus: autofocus,
    className: className,
    classNameFocused: classnames_default()(TabBar.tabFocused, focusClass),
    classNamePressed: TabBar.tabPressed,
    onClick: onClick,
    gamepadAlias: gamepadAlias,
    gamepadIndex: index,
    inputLegend: inputLegend,
    soundEffectHovered: onTabHoveredSoundEffect,
    soundEffectPressed: onTabPressedSoundEffect,
    narrationText: narrationText
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    role: "neutral"
  }), /*#__PURE__*/react.createElement("div", {
    className: TabBar.tabContainer
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    role: "neutral"
  }), /*#__PURE__*/react.createElement("div", {
    className: TabBar.outerTab,
    style:  false ? 0 : {}
  }, /*#__PURE__*/react.createElement("div", {
    className: TabBar.contentContainer
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit",
    verticalAlign: "center"
  }, icons !== react_facet_src.NO_VALUE && icons != null && icons, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, label))))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(TabBar.tabEdge, semanticClassNames.shadow.base)
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isSelected
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(TabBar.indicator, semanticClassNames.icon.base)
  })));
}

function getFocusAlias(gamepadAliasNamespace, value) {
  return `tab-bar-${gamepadAliasNamespace}-${value}`;
}

TabBar_TabBar.getFocusAlias = getFocusAlias;
// EXTERNAL MODULE: ./node_modules/@react-facet/deferred-mount/dist/index.js
var dist = __webpack_require__(1170);
;// CONCATENATED MODULE: ./packages/ui/src/SectionList/SectionList.tsx








function SectionList({
  header,
  renderItem,
  renderSectionHeader,
  data,
  gamepadIndex,
  itemSeparator,
  sectionSeparator,
  loading = false,
  footer,
  renderTracker,
  padSpinnerVertically
}) {
  const isRenderingPaused = (0,dist.useIsPaused)();
  const dataFacet = (0,react_facet_src.useFacetWrap)(data);
  const nonEmptySectionsFacet = (0,react_facet_src.useFacetMap)(sections => filter(sections, section => section.data.length > 0), [], [dataFacet]);
  const loadingValueRaw = (0,react_facet_src.useFacetUnwrap)(loading);
  const loadingValue = loadingValueRaw !== react_facet_src.NO_VALUE ? loadingValueRaw : false;
  return /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(ScrollViewContainer, {
    loading: loadingValue,
    gamepadIndex: gamepadIndex,
    renderTracker: renderTracker,
    padSpinnerVertically: padSpinnerVertically
  }, header != null && /*#__PURE__*/react.createElement(react.Fragment, null, header, itemSeparator), isRenderingPaused === false && /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: nonEmptySectionsFacet
  }, (section, index) => /*#__PURE__*/react.createElement(Section, {
    section: section,
    sectionIndex: index,
    sections: nonEmptySectionsFacet,
    renderSectionHeader: renderSectionHeader,
    renderItem: renderItem,
    sectionSeparator: sectionSeparator
  })), footer));
}

function Section({
  section: sectionFacet,
  sectionIndex,
  sections,
  renderSectionHeader,
  renderItem,
  sectionSeparator,
  itemSeparator
}) {
  const dataFacet = (0,react_facet_src.useFacetMap)(section => section.data, [], [sectionFacet]);
  const countFacet = (0,react_facet_src.useFacetMap)(section => section.data.length, [], [sectionFacet]);
  const titleFacet = (0,react_facet_src.useFacetMap)(section => section.title, [], [sectionFacet]);
  const roleFacet = (0,react_facet_src.useFacetMap)(section => section.role, [], [sectionFacet]);
  const sectionHeader = renderSectionHeader(titleFacet, roleFacet);
  const {
    t
  } = useLocalization('SectionList');
  return (
    /*#__PURE__*/
    // We need a column wrapping each section so that the indexes from
    // the buttons of each section don't overlap
    react.createElement(GamepadColumn_GamepadColumn, {
      shouldSkipLandmarkInVisual: true,
      gamepadIndex: sectionIndex,
      key: sectionIndex
    }, /*#__PURE__*/react.createElement(NarrationContextFacetified, {
      text: (0,react_facet_src.useFacetMap)(sections => {
        const section = sections[sectionIndex];
        return t('.groupNarration', [section.title, `${sectionIndex + 1}`, `${sections.length}`]);
      }, [sectionIndex, t], [sections])
    }, sectionIndex > 0 && sectionSeparator, sectionHeader, itemSeparator, /*#__PURE__*/react.createElement(react_facet_src.Map, {
      array: dataFacet
    }, (itemFacet, index) => /*#__PURE__*/react.createElement(react.Fragment, null, index > 0 && itemSeparator, renderItem({
      itemFacet,
      index,
      sectionIndex,
      listLengthFacet: countFacet
    })))))
  );
}

const NarrationContextFacetified = ({
  text,
  children
}) => {
  var _useFacetUnwrap;

  const textValueRaw = (_useFacetUnwrap = (0,react_facet_src.useFacetUnwrap)(text)) !== null && _useFacetUnwrap !== void 0 ? _useFacetUnwrap : '';
  const textValue = textValueRaw !== react_facet_src.NO_VALUE ? textValueRaw : '';
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: textValue
  }, children);
};

function ScrollViewContainer({
  loading,
  gamepadIndex,
  children,
  renderTracker,
  padSpinnerVertically
}) {
  const isDeferringFacet = (0,dist.useIsDeferring)();
  const isPaused = (0,dist.useIsPaused)();
  const isLoading = (0,react_facet_src.useFacetMap)(isDeferring => loading || isDeferring || isPaused, [loading, isPaused], [isDeferringFacet]);
  return /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    loading: isLoading,
    gamepadIndex: gamepadIndex,
    renderTracker: renderTracker,
    padSpinnerVertically: padSpinnerVertically
  }, children);
}
;// CONCATENATED MODULE: ./packages/ui/src/ListHeader/ListHeader.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ListHeader = ({"tagHeaderWrapper":"YimiS","header":"uydZW","tag":"ZXwO7"});
;// CONCATENATED MODULE: ./packages/ui/src/ListHeader/ListHeader.tsx






const ListHeader_ListHeader = ({
  label = '',
  role = 'neutral'
}) => {
  const roleFacet = (0,react_facet_src.useFacetWrap)(role);
  const {
    color
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("fast-div", {
    className: ListHeader.tagHeaderWrapper
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(role => classnames_default()(ListHeader.header, color[role].background.base, color[role].border.base, color[role].text.base), [color], [roleFacet])
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: label
  }))), /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(role => classnames_default()(ListHeader.tag, color[role].background.base, color[role].border.base), [color], [roleFacet])
  }));
};
;// CONCATENATED MODULE: ./packages/ui/src/FlatList/FlatList.tsx




function FlatList({
  loading,
  emptyMessage,
  header,
  renderItem,
  data,
  gamepadIndex,
  scrollIntoViewAlign,
  scrollIntoViewSpeedFactor,
  itemSeparator,
  footer,
  renderTracker,
  horizontal = false,
  padSpinnerVertically,
  scrollViewRef
}) {
  const isRenderingPaused = (0,dist.useIsPaused)();
  const dataFacet = (0,react_facet_src.useFacetWrap)(data);
  const countFacet = (0,react_facet_src.useFacetMap)(data => data.length, [], [dataFacet]);
  const countValue = (0,react_facet_src.useFacetUnwrap)(countFacet);
  const loadingValueRaw = (0,react_facet_src.useFacetUnwrap)(loading);
  const loadingValue = loadingValueRaw !== react_facet_src.NO_VALUE ? loadingValueRaw : false;
  return /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(FlatList_ScrollViewContainer, {
    padSpinnerVertically: padSpinnerVertically,
    loading: loadingValue,
    gamepadIndex: gamepadIndex,
    scrollIntoViewAlign: scrollIntoViewAlign,
    scrollIntoViewSpeedFactor: scrollIntoViewSpeedFactor,
    renderTracker: renderTracker,
    horizontal: horizontal,
    scrollViewRef: scrollViewRef
  }, header != null && /*#__PURE__*/react.createElement(react.Fragment, null, header, itemSeparator), isRenderingPaused === false && /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: dataFacet
  }, (item, index) => /*#__PURE__*/react.createElement(react.Fragment, null, index > 0 && itemSeparator, renderItem({
    itemFacet: item,
    index,
    listLengthFacet: countFacet
  }))),
  /**
   * We need to deffer the empty message, since the DeferredMountProvider will be waiting
   * for something to be mounted using DeferredMount so that it will run its process and complete
   * any deferred rendering
   *
   * Removing this would cause an spinner to be shown for all eternity.
   */
  countValue != null && countValue === 0 && /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(react.Fragment, null, emptyMessage)), footer != null && /*#__PURE__*/react.createElement(react.Fragment, null, itemSeparator, footer)));
}
function FlatList_ScrollViewContainer({
  loading,
  gamepadIndex,
  children,
  scrollIntoViewAlign,
  scrollIntoViewSpeedFactor,
  renderTracker,
  horizontal,
  padSpinnerVertically,
  scrollViewRef
}) {
  const isDeferringFacet = (0,dist.useIsDeferring)();
  const isPaused = (0,dist.useIsPaused)();
  const isLoading = (0,react_facet_src.useFacetMap)(isDeferring => loading || isDeferring || isPaused, [loading, isPaused], [isDeferringFacet]);
  return /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    padSpinnerVertically: padSpinnerVertically,
    loading: isLoading,
    gamepadIndex: gamepadIndex,
    scrollIntoViewAlign: scrollIntoViewAlign,
    scrollIntoViewSpeedFactor: scrollIntoViewSpeedFactor,
    renderTracker: renderTracker,
    horizontal: horizontal,
    innerRef: scrollViewRef
  }, children);
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/progress.png
const progress_namespaceObject = __webpack_require__.p + "assets/progress-27e63.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/gamerscore.png
const gamerscore_namespaceObject = __webpack_require__.p + "assets/gamerscore-43cf3.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/clock.png
const clock_namespaceObject = __webpack_require__.p + "assets/clock-f02fd.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/rewards.png
const rewards_namespaceObject = __webpack_require__.p + "assets/rewards-1ac83.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle0.png
const bottle0_namespaceObject = __webpack_require__.p + "assets/bottle0-85a72.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle1.png
const bottle1_namespaceObject = __webpack_require__.p + "assets/bottle1-6d884.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle2.png
const bottle2_namespaceObject = __webpack_require__.p + "assets/bottle2-89b45.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle3.png
const bottle3_namespaceObject = __webpack_require__.p + "assets/bottle3-f280f.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle4.png
const bottle4_namespaceObject = __webpack_require__.p + "assets/bottle4-9d636.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle5.png
const bottle5_namespaceObject = __webpack_require__.p + "assets/bottle5-7a0bc.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle6.png
const bottle6_namespaceObject = __webpack_require__.p + "assets/bottle6-6d98c.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle7.png
const bottle7_namespaceObject = __webpack_require__.p + "assets/bottle7-7d4eb.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle8.png
const bottle8_namespaceObject = __webpack_require__.p + "assets/bottle8-e355d.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle9.png
const bottle9_namespaceObject = __webpack_require__.p + "assets/bottle9-1c23e.png";
;// CONCATENATED MODULE: ./packages/ui/src/Summary/Summary.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Summary = ({"summary":"i2Nr0","spinner":"NQGrD","spinnerHidden":"ejkbA","divider":"juifw","data":"dIbWH","dataText":"VHEDr"});
;// CONCATENATED MODULE: ./packages/ui/src/Summary/Summary.tsx








Summary_Summary.Data = function Data({
  value,
  label,
  icon
}) {
  const {
    color: {
      inherit: semanticClassNames
    },
    variant
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Summary.data, semanticClassNames.background.base)
  }, icon, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Summary.dataText, semanticClassNames.text.base)
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(semanticClassNames.text.base, variant.dimmest)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, label)), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, value)));
};

Summary_Summary.Divider = function Divider() {
  const {
    color: {
      inherit: semanticClassNames
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Summary.divider, semanticClassNames.shadow.base)
  });
};

function Summary_Summary({
  children,
  role = 'neutral80'
}) {
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Summary.summary, semanticClassNames.background.base, semanticClassNames.border.base)
  }, children));
}

const SummarySpinner = ({
  hidden
}) => {
  return /*#__PURE__*/react.createElement(TransitionPrimitive, {
    visible: !hidden,
    timeout: 500
  }, status => /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Summary.spinner, {
      [Summary.spinnerHidden]: status === 'exited' || status === 'exiting' || status === 'unmounted'
    })
  }, /*#__PURE__*/react.createElement(Spinner_Spinner, null)));
};

Summary_Summary.displayName = 'Summary';
Summary_Summary.SummarySpinner = SummarySpinner;
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/AchievementsSummary.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AchievementsSummary = ({"icon":"nC7ze","iconWrapper":"XOt1L","featuredData":"xVp12","featuredDataUpper":"KtzUL","featuredDataUpperDescription":"bJlOL","innerfeaturedDataPercentage":"BH570","bottle":"HJp4C","loadingSummaryPlaceholder":"knzR5"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/AchievementsSummary.tsx






















function getBottle(percentageUnlocked) {
  if (percentageUnlocked === 0) return bottle0_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 2) return bottle2_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 3) return bottle3_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 4) return bottle4_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 5) return bottle5_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 6) return bottle6_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 7) return bottle7_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 8) return bottle8_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 9 || Math.round(percentageUnlocked * 10) === 10) return bottle9_namespaceObject;
  return bottle1_namespaceObject;
}

function AchievementsSummary_AchievementsSummary({
  inProgress,
  achievementsUnlocked,
  achievementsTotal,
  rewardsUnlocked,
  rewardsTotal,
  gamerScore,
  gamerScoreTotal,
  hoursPlayed,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization('AchievementsSummary');
  const hasRewards = rewardsTotal != null && rewardsTotal > 0;
  const hasRewardsUnlocked = rewardsUnlocked != null && rewardsUnlocked > 0;
  const gamerscore = `${gamerScore}` + '/' + `${gamerScoreTotal}`;
  const percentageUnlocked = achievementsTotal === 0 ? 0 : achievementsUnlocked / achievementsTotal;
  const presentationProcent = !!achievementsTotal && !!achievementsUnlocked && percentageUnlocked * 100 > 98 ? Math.floor(percentageUnlocked * 100) : Math.ceil(percentageUnlocked * 100);
  const narrationIsEnabled = useNarrationEnabled();
  const narrationText = [t('.narratorTextBlock'), t('.narratorSummary'), t('.narratorIndex', ['1', '4']), t('.narratorPercentage', [`${presentationProcent}`]), t('.narratorCompletedAchievements', [`${achievementsUnlocked}`, `${achievementsTotal}`]), t('.narratorInProgress', [`${inProgress}`]), hasRewardsUnlocked && hasRewards ? t('.narratorCompletedRewards', [`${rewardsUnlocked}`, `${rewardsTotal}`]) : '', t('.narratorGamerscore', [`${gamerScore}`, `${gamerScoreTotal}`]), t('.narratorTimePlayed', [`${hoursPlayed}`])];
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    inputLegend: false,
    className: '',
    autofocus: true,
    classNameHovered: '',
    classNameFocused: focusClass,
    classNamePressed: '',
    disabled: !narrationIsEnabled,
    gamepadIndex: gamepadIndex,
    narrationText: narrationText.join(' - '),
    onClick: () => {}
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    withoutBorders: true,
    disabled: !narrationIsEnabled
  }), /*#__PURE__*/react.createElement(Summary_Summary, null, /*#__PURE__*/react.createElement("div", {
    className: AchievementsSummary.featuredData
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular"
  }), /*#__PURE__*/react.createElement("div", {
    className: AchievementsSummary.featuredDataUpper
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    imageRendering: "pixelated",
    src: getBottle(percentageUnlocked),
    className: AchievementsSummary.bottle
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "header2",
    color: "white",
    shadow: true
  }, presentationProcent), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "header3",
    color: "white",
    shadow: true
  }, /*#__PURE__*/react.createElement("div", {
    className: AchievementsSummary.innerfeaturedDataPercentage
  }, "%"))), /*#__PURE__*/react.createElement("div", {
    className: AchievementsSummary.featuredDataUpperDescription
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "white"
  }, t('.percentage', [`${achievementsUnlocked}`, `${achievementsTotal}`])))), /*#__PURE__*/react.createElement(Summary_Summary.Divider, null), /*#__PURE__*/react.createElement(Summary_Summary.Data, {
    icon: /*#__PURE__*/react.createElement("div", {
      className: AchievementsSummary.iconWrapper
    }, /*#__PURE__*/react.createElement(Image_Image_Image, {
      src: progress_namespaceObject,
      imageRendering: "pixelated",
      className: AchievementsSummary.icon
    })),
    label: t('.progress'),
    value: inProgress
  }), /*#__PURE__*/react.createElement(Summary_Summary.Divider, null), hasRewards && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Summary_Summary.Data, {
    icon: /*#__PURE__*/react.createElement("div", {
      className: AchievementsSummary.iconWrapper
    }, /*#__PURE__*/react.createElement(Image_Image_Image, {
      src: rewards_namespaceObject,
      imageRendering: "pixelated",
      className: AchievementsSummary.icon
    })),
    label: t('.rewards'),
    value: `${rewardsUnlocked !== null && rewardsUnlocked !== void 0 ? rewardsUnlocked : 0}` + '/' + `${rewardsTotal}`
  }), /*#__PURE__*/react.createElement(Summary_Summary.Divider, null)), /*#__PURE__*/react.createElement(Summary_Summary.Data, {
    icon: /*#__PURE__*/react.createElement("div", {
      className: AchievementsSummary.iconWrapper
    }, /*#__PURE__*/react.createElement(Image_Image_Image, {
      src: gamerscore_namespaceObject,
      imageRendering: "pixelated",
      className: AchievementsSummary.icon
    })),
    label: t('.gamerscore'),
    value: gamerscore
  }), /*#__PURE__*/react.createElement(Summary_Summary.Divider, null), /*#__PURE__*/react.createElement(Summary_Summary.Data, {
    icon: /*#__PURE__*/react.createElement("div", {
      className: AchievementsSummary.iconWrapper
    }, /*#__PURE__*/react.createElement(Image_Image_Image, {
      src: clock_namespaceObject,
      imageRendering: "pixelated",
      className: AchievementsSummary.icon
    })),
    label: t('.time'),
    value: t('.hoursPlayed', [`${hoursPlayed}`])
  })));
}

// When narration is enabled in combination with a gamepad, the summary should not be narrated until the facet is loaded. To avoid this, Loading not containing InteractivePrimitive is returned
function Loading({
  loading
}) {
  return /*#__PURE__*/react.createElement(Summary_Summary, null, /*#__PURE__*/react.createElement("div", {
    className: AchievementsSummary.loadingSummaryPlaceholder
  }, /*#__PURE__*/react.createElement(Summary_Summary.SummarySpinner, {
    hidden: !loading
  })));
}

AchievementsSummary_AchievementsSummary.displayName = 'AchievementsSummary';
AchievementsSummary_AchievementsSummary.Loading = Loading;
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingRed/images/pingRed.png
const pingRed_namespaceObject = __webpack_require__.p + "assets/pingRed-c43cb.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingRed/IconPingRed.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconPingRed = ({"iconPingRed":"DeSbe"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingRed/IconPingRed.tsx




const IconPingRed_IconPingRed = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconPingRed.iconPingRed,
  src: pingRed_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingYellow/images/pingYellow.png
const pingYellow_namespaceObject = __webpack_require__.p + "assets/pingYellow-7aa95.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingYellow/IconPingYellow.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconPingYellow = ({"iconPingYellow":"HxqCq"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingYellow/IconPingYellow.tsx




const IconPingYellow_IconPingYellow = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconPingYellow.iconPingYellow,
  src: pingYellow_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingGreen/images/pingGreen.png
const pingGreen_namespaceObject = __webpack_require__.p + "assets/pingGreen-cff4e.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingGreen/IconPingGreen.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconPingGreen = ({"iconPingGreen":"V0B0o"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingGreen/IconPingGreen.tsx




const IconPingGreen_IconPingGreen = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconPingGreen.iconPingGreen,
  src: pingGreen_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ListItem = ({"listItem":"YtiPa","action":"JEpL_","additionalAction":"hKrf6","fitContent":"WTHvW","main":"Czp6I","rowCell":"OkAos","alignStart":"uLBvt","alignCenter":"TCu2R","columnCell":"FX1uD","cell":"ncwRl","hovered":"ExDsu","focused":"_7LiN","pressed":"OWgmn","icon":"lmdxd","tall":"sPd5G","tallAdditionalAction":"GxN1j"});
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItem.tsx













const TallContext = (0,react.createContext)(false);

const useTallListItem = () => (0,react.useContext)(TallContext);

function ListItemAction({
  autofocus,
  children,
  onClick,
  inputLegend,
  narrationText,
  gamepadAlias,
  soundEffectPressed,
  onFocusChanged,
  onHoverChanged,
  gamepadIndex = 0,
  role = 'neutral'
}) {
  const {
    color: {
      [role]: semanticClassNames
    },
    sound: {
      [role]: semanticSound
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    autofocus: autofocus,
    gamepadAlias: gamepadAlias,
    className: classnames_default()(ListItem.action, semanticClassNames.background.interactive, semanticClassNames.text.base),
    classNameHovered: ListItem.hovered,
    classNameFocused: classnames_default()(ListItem.focused, focusClass),
    classNamePressed: classnames_default()(ListItem.pressed),
    gamepadIndex: gamepadIndex,
    inputLegend: inputLegend,
    narrationText: narrationText,
    onClick: onClick,
    onFocusChanged: onFocusChanged,
    onHoverChanged: onHoverChanged,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.press
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel"
  }), children));
}

function ActionShortcut({
  onClick,
  shortcut,
  inputLegend
}) {
  const inputLegendFacet = (0,react_facet_src.useFacetWrap)(inputLegend);
  return /*#__PURE__*/react.createElement(ParentShortcut_ParentShortcut, {
    options: (0,react_facet_src.useFacetMap)(inputLegend => ({
      button: shortcut,
      inputLegend
    }), [shortcut], [inputLegendFacet]),
    onClick: onClick
  });
}

function ListItemAdditionalAction({
  children,
  onClick,
  onGamepadClick,
  onUp,
  onDown,
  onLeft,
  onRight,
  onMouseDown,
  shortcut,
  inputLegend,
  narrationText,
  gamepadAlias,
  hidden = false,
  fitContent = false,
  gamepadIndex = 0,
  innerRef,
  touchDetectionDelay,
  soundEffectPressed,
  role = 'neutral'
}) {
  const hiddenFacet = (0,react_facet_src.useFacetWrap)(hidden);
  const tall = useTallListItem();
  const {
    color: {
      [role]: semanticClassNames
    },
    sound: {
      [role]: semanticSound
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(hidden => !hidden, [], [hiddenFacet])
  }, /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: role
  }, shortcut != null ? /*#__PURE__*/react.createElement(ActionShortcut, {
    onClick: onClick,
    shortcut: shortcut,
    inputLegend: inputLegend
  }) : null, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    className: classnames_default()(ListItem.additionalAction, semanticClassNames.background.interactive, {
      [ListItem.fitContent]: fitContent,
      [ListItem.tallAdditionalAction]: tall
    }),
    touchDetectionDelay: touchDetectionDelay,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.press,
    classNameHovered: ListItem.hovered,
    classNameFocused: classnames_default()(ListItem.focused, focusClass),
    classNamePressed: ListItem.pressed,
    gamepadIndex: gamepadIndex,
    gamepadAlias: gamepadAlias,
    inputLegend: inputLegend,
    onClick: onClick,
    onGamepadClick: onGamepadClick,
    onUp: onUp,
    onDown: onDown,
    onLeft: onLeft,
    onRight: onRight,
    onMouseDown: onMouseDown,
    narrationText: narrationText,
    innerRef: innerRef
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel"
  }), children)));
}
function ListItemCell({
  children,
  direction = 'column',
  align = 'end'
}) {
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ListItem.cell, {
      [ListItem.rowCell]: direction === 'row',
      [ListItem.columnCell]: direction === 'column',
      [ListItem.alignStart]: align === 'start',
      [ListItem.alignCenter]: align === 'center'
    })
  }, children);
}
function ListItemMain({
  children,
  role = 'inherit'
}) {
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ListItem.main, semanticClassNames.background.interactive)
  }, children);
}

/**
 * ListItem root component.
 * It can defer the rendering of its children when used in a SectionList, FlatList or a context with DeferredMountProvider.
 */
function ListItem_ListItem({
  tall = false,
  children,
  isFocusable = false,
  narrationText,
  gamepadAlias,
  gamepadIndex,
  innerRef,
  defaultFocusedChildBehavior,
  role = 'neutral80'
}) {
  const gamepadIndexFacet = (0,react_facet_src.useFacetWrap)(gamepadIndex);
  const defaultFocusedChildBehaviorFacet = (0,react_facet_src.useFacetWrap)(defaultFocusedChildBehavior);
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  const narrationTextFacet = (0,react_facet_src.useFacetWrap)(narrationText !== null && narrationText !== void 0 ? narrationText : false);
  return /*#__PURE__*/react.createElement(TallContext.Provider, {
    value: tall
  }, /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: isFocusable,
    gamepadAlias: gamepadAlias,
    className: classnames_default()(ListItem.listItem, semanticClassNames.border.base, semanticClassNames.text.base, {
      [ListItem.tall]: tall
    }),
    innerRef: innerRef,
    classNameFocused: classnames_default()(ListItem.focused, focusClass),
    gamepadIndex: gamepadIndex,
    inputLegend: false,
    narrationText: narrationTextFacet
  }, isFocusable && /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(Row, {
    shouldSkipLandmarkInVisual: true,
    options: (0,react_facet_src.useFacetMap)((gamepadIndex, defaultFocusedChildBehavior) => ({
      index: gamepadIndex,
      defaultFocusedChildBehavior
    }), [], [gamepadIndexFacet, defaultFocusedChildBehaviorFacet])
  }, children)))));
}

const getIcon = type => {
  switch (type) {
    case 'green':
      return /*#__PURE__*/react.createElement(IconPingGreen_IconPingGreen, null);

    case 'red':
      return /*#__PURE__*/react.createElement(IconPingRed_IconPingRed, null);

    case 'yellow':
      return /*#__PURE__*/react.createElement(IconPingYellow_IconPingYellow, null);
  }
};

function ListItemIcon({
  type,
  variant,
  color,
  text
}) {
  const icon = getIcon(type);
  return /*#__PURE__*/react.createElement("div", {
    className: ListItem.icon
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: variant,
    color: color
  }, text), icon);
}
ListItem_ListItem.Action = ListItemAction;
ListItem_ListItem.AdditionalAction = ListItemAdditionalAction;
ListItem_ListItem.Main = ListItemMain;
ListItem_ListItem.Cell = ListItemCell;
ListItem_ListItem.Icon = ListItemIcon;
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/AchievementListItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AchievementListItem = ({"gamerPointsWrapper":"RRHee","imageGamerPoints":"qMjzA","rewardImg":"wfNbX","lockedIcon":"Wi8gq","rewardImgCellUnlocked":"B60cn","rewardImgCellLocked":"tAQd5","rewardLockedOverlay":"HK9NP","achievement":"tdDq6","achievementLocked":"YsHy2","frame":"Wz_PE"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/images/locked.png
const locked_namespaceObject = __webpack_require__.p + "assets/locked-b7e1e.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/images/gamerscoreGrey.png
const gamerscoreGrey_namespaceObject = __webpack_require__.p + "assets/gamerscoreGrey-f5174.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/images/greyframe.png
const greyframe_namespaceObject = __webpack_require__.p + "assets/greyframe-dd39b.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/images/unlockedFrame.png
const unlockedFrame_namespaceObject = __webpack_require__.p + "assets/unlockedFrame-f9ecc.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/images/placeholder.png
const placeholder_namespaceObject = __webpack_require__.p + "assets/placeholder-15b68.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/images/placeholderReward.png
const placeholderReward_namespaceObject = __webpack_require__.p + "assets/placeholderReward-5e651.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/AchievementListItem.tsx
















function AchievementListItem_AchievementListItem({
  autofocus,
  item,
  gamepadAlias,
  onClick,
  index,
  listLength
}) {
  return /*#__PURE__*/react.createElement(ListItem_ListItem, {
    gamepadIndex: index
  }, /*#__PURE__*/react.createElement(Action, {
    autofocus: autofocus,
    item: item,
    gamepadAlias: gamepadAlias,
    onClick: onClick,
    index: index,
    listLength: listLength
  }));
}
/**
 * Separated Action component so that it can be properly deferred by the ListItem (see its implementation)
 */

const Action = ({
  autofocus,
  item,
  gamepadAlias,
  onClick,
  index,
  listLength
}) => {
  const {
    t
  } = useLocalization('AchievementListItem');
  const hasRewardFeatureFlag = useFeatureFlag(REWARD_FEATURE_FLAG);
  return /*#__PURE__*/react.createElement(ListItem_ListItem.Action, {
    narrationText: (0,react_facet_src.useFacetMap)((item, listLength) => [item.name, t('.siblingNarration', [`${index + 1}`, `${listLength}`]), item.progress !== 0 && item.progress > 0 && item.progress < 1 ? t('.percentageNarration', [`${Math.round(item.progress * 100)}`]) : '', t('.gamerscoreNarration', [`${item.gamerScore}`]), hasRewardFeatureFlag && item.hasReward ? item.isLocked ? t('.rewardLockedNarration') : t('.rewardUnlockedNarration') : '', item.description].join(' . '), [index, t, hasRewardFeatureFlag], [item, listLength]),
    inputLegend: t('.view'),
    onClick: onClick,
    gamepadAlias: gamepadAlias,
    autofocus: autofocus
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(item => classnames_default()(AchievementListItem.achievement, {
      [AchievementListItem.achievementLocked]: item.isLocked
    }), [], [item])
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: AchievementListItem.frame,
    imageRendering: "pixelated",
    src: (0,react_facet_src.useFacetMap)(item => item.isLocked ? greyframe_namespaceObject : unlockedFrame_namespaceObject, [], [item])
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: AchievementListItem.achievement,
    imageRendering: "pixelated",
    src: (0,react_facet_src.useFacetMap)(item => {
      var _item$image;

      return (_item$image = item.image) !== null && _item$image !== void 0 ? _item$image : placeholder_namespaceObject;
    }, [], [item])
  })), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  })), /*#__PURE__*/react.createElement(ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "white"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, (0,react_facet_src.useFacetMap)(item => item.name, [], [item]))), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "grey"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, (0,react_facet_src.useFacetMap)(item => item.description, [], [item]))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => !!item.progress && item.progress !== 1, [], [item])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(ProgressBar_ProgressBar, {
    percentage: (0,react_facet_src.useFacetMap)(item => item.progress, [], [item])
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => !!item.gamerScore, [], [item])
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/react.createElement("div", {
    className: AchievementListItem.gamerPointsWrapper
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: AchievementListItem.imageGamerPoints,
    src: gamerscoreGrey_namespaceObject,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, (0,react_facet_src.useFacetMap)(item => item.gamerScore, [], [item]))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => hasRewardFeatureFlag && item.hasReward, [hasRewardFeatureFlag], [item])
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(item => item.isLocked ? AchievementListItem.rewardImgCellLocked : AchievementListItem.rewardImgCellUnlocked, [], [item])
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => item.isLocked, [], [item])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: AchievementListItem.lockedIcon,
    imageRendering: "pixelated",
    src: locked_namespaceObject
  }), /*#__PURE__*/react.createElement("div", {
    className: AchievementListItem.rewardLockedOverlay
  }))), /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: AchievementListItem.rewardImg,
    src: (0,react_facet_src.useFacetMap)(item => {
      var _item$rewardImage;

      return (_item$rewardImage = item.rewardImage) !== null && _item$rewardImage !== void 0 ? _item$rewardImage : placeholderReward_namespaceObject;
    }, [], [item])
  })), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }))));
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/components/Narration.tsx



const Narration = ({
  text
}) => {
  const textRaw = (0,react_facet_src.useFacetUnwrap)(text);
  const textData = textRaw !== react_facet_src.NO_VALUE ? textRaw : '';
  const {
    narrationPutNode
  } = useNarrationPutNode();
  const {
    narrateById
  } = useNarrateById();
  const narrationId = narrationPutNode(textData);
  (0,react.useEffect)(() => {
    narrateById(narrationId);
  }, [narrateById, narrationId]);
  return null;
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/TabWrapper/TabWrapper.tsx






function TabWrapper({
  component,
  tab
}) {
  const params = useRouteParams();
  const visible = params.tab === tab;
  const parentRouteActive = useRouteActive();
  const isRouteActive = (0,react_facet_src.useFacetMap)(parentRouteActive => visible && parentRouteActive, [visible], [parentRouteActive]);
  return /*#__PURE__*/react.createElement(RouteActiveProvider, {
    active: isRouteActive
  }, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 0,
    disabled: !visible
  }, /*#__PURE__*/react.createElement(RouteInstantTransition_RouteInstantTransition, {
    visible: visible,
    contentComponent: component,
    unmountOnExit: false,
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingDelay, {
      type: "contentful",
      renderingCompleted: isContentShown
    })
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/TabWrapper/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementsRoute/AchievementsRoute.tsx
















const LOADING_TIMEOUT = 10000;
const LOADING_WARNING = 1500;
const AchievementsRoute = () => {
  const glassPaneRef = (0,react.useRef)(null);
  const {
    t
  } = useLocalization('Achievements');
  const historyAPI = RouteHistory_useRouteHistory();
  const hasLoadingFailedFacet = useTimeout((0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector), LOADING_TIMEOUT);
  const loadingTakingTimeFacet = useTimeout((0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector), LOADING_WARNING);
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane, {
    innerRef: glassPaneRef
  }, /*#__PURE__*/react.createElement(NarrationContext, {
    text: t('.narration.title')
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)((loadingTakingTime, hasLoadingFailed) => loadingTakingTime && !hasLoadingFailed, [], [loadingTakingTimeFacet, hasLoadingFailedFacet])
  }, /*#__PURE__*/react.createElement(Narration, {
    text: t('.narration.loadingMessage')
  })), /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout, {
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: () => historyAPI.goBack()
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography, {
      variant: "header5A",
      color: "black"
    }, t('.title'))
  }, /*#__PURE__*/react.createElement(Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)((hasLoadingFailed, hasLoaded) => hasLoadingFailed && !hasLoaded, [], [hasLoadingFailedFacet, (0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector)])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: 2,
    narrowSize: 1
  }), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 8,
    narrowSize: 6
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    autofocus: true,
    gamepadAlias: "ach-load-error-empty-state",
    imgSrc: errorMessage_namespaceObject,
    gamepadIndex: 0,
    title: t('.errorMessageTitle'),
    text: t('.errorMessage')
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)((hasLoadingFailed, hasLoaded) => !(hasLoadingFailed && !hasLoaded), [], [hasLoadingFailedFacet, (0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector)])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 3,
    narrowSize: 3
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(SummaryWrapper, null)), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 9,
    narrowSize: 5
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Tabs, null), /*#__PURE__*/react.createElement(TabWrapper, {
    tab: undefined,
    component: AllTab
  }), /*#__PURE__*/react.createElement(TabWrapper, {
    tab: "locked",
    component: LockedTab
  }), /*#__PURE__*/react.createElement(TabWrapper, {
    tab: "completed",
    component: CompletedTab
  })))))))));
};

const Tabs = () => {
  const {
    t
  } = useLocalization('Achievements');
  const historyAPI = RouteHistory_useRouteHistory();
  const params = useRouteParams();
  const tabs = [{
    label: t('.all'),
    value: 'all'
  }, {
    label: t('.locked'),
    value: 'locked'
  }, {
    label: t('.completed'),
    value: 'completed'
  }];
  return /*#__PURE__*/react.createElement(TabBar_TabBar, {
    gamepadAliasNamespace: "achievement-screen",
    gamepadIndex: 0,
    value: params.tab ? params.tab : 'all',
    onChange: (newValue, usingGamepadShortcut) => {
      if (usingGamepadShortcut) {
        historyAPI.replaceWithPreviousFocus(`/achievements/${newValue !== 'all' ? newValue : ''}`);
      } else {
        historyAPI.replaceKeepingFocus(`/achievements/${newValue !== 'all' ? newValue : ''}`);
      }
    },
    tabs: tabs,
    enableGamepadShortcuts: true
  });
};

const AllTab = () => {
  const {
    t
  } = useLocalization('Achievements');
  const narration = t('.narration.tab', [t('.all'), '2', '4']) + ' . ' + t('.narration.selected');
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: narration
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(SectionList, {
    gamepadIndex: 1,
    header: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 4
    }),
    loading: (0,react_facet_src.useFacetMap)(loaded => !loaded, [], [(0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector)]),
    data: (0,react_facet_src.useFacetMap)(allAchievementsSorted => [{
      role: 'informativeTint',
      title: t('.inProgress'),
      data: allAchievementsSorted.inProgress
    }, {
      role: 'secondary',
      title: t('.locked'),
      data: allAchievementsSorted.locked
    }, {
      role: 'successTint',
      title: t('.completed'),
      data: allAchievementsSorted.completed
    }], [t], [(0,react_facet_src.useSharedFacet)(groupedAchievementsSelector)]),
    footer: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputLegend_InputLegend.Space, {
      extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing, {
        size: 1
      })
    }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 1
    })),
    sectionSeparator: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 4
    }),
    renderSectionHeader: (title, role) => /*#__PURE__*/react.createElement(ListHeader_ListHeader, {
      role: role,
      label: title
    }),
    renderItem: ({
      itemFacet,
      index,
      sectionIndex,
      listLengthFacet
    }) => /*#__PURE__*/react.createElement(AchievementListItemWrapper, {
      filterName: "all",
      item: itemFacet,
      index: index,
      sectionIndex: sectionIndex,
      listLength: listLengthFacet
    }),
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingEvent, {
      type: "meaningful",
      renderingCompleted: isContentShown
    }),
    padSpinnerVertically: true
  })));
};

const LockedTab = () => {
  const {
    t
  } = useLocalization('Achievements');
  const narration = t('.narration.tab', [t('.locked'), '3', '4']) + ' . ' + t('.narration.selected');
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: narration
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(FlatList, {
    header: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 2
    }),
    loading: (0,react_facet_src.useFacetMap)(loaded => !loaded, [], [(0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector)]),
    gamepadIndex: 1,
    emptyMessage: /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
      autofocus: true,
      gamepadAlias: "ach-locked-empty-state",
      imgSrc: (0,react_facet_src.useFacetMap)(achievements => achievements.length === 0 ? emptyStatesAllCompleted_namespaceObject : undefined, [], [(0,react_facet_src.useSharedFacet)(lockedOrInProgressAchievementsSelector)]),
      gamepadIndex: 0,
      title: t('.lockedEmptyTitle'),
      text: t('.lockedEmptyText')
    }),
    data: (0,react_facet_src.useSharedFacet)(lockedOrInProgressAchievementsSelector),
    footer: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputLegend_InputLegend.Space, {
      extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing, {
        size: 1
      })
    }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 1
    })),
    renderItem: ({
      itemFacet,
      index,
      listLengthFacet
    }) => /*#__PURE__*/react.createElement(AchievementListItemWrapper, {
      filterName: "locked",
      item: itemFacet,
      index: index,
      listLength: listLengthFacet
    }),
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingEvent, {
      type: "meaningful",
      renderingCompleted: isContentShown
    }),
    padSpinnerVertically: true
  })));
};

const CompletedTab = () => {
  const {
    t
  } = useLocalization('Achievements');
  const narration = t('.narration.tab', [t('.completed'), '4', '4']) + ' . ' + t('.narration.selected');
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: narration
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(FlatList, {
    header: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 2
    }),
    loading: (0,react_facet_src.useFacetMap)(loaded => !loaded, [], [(0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector)]),
    gamepadIndex: 1,
    emptyMessage: /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
      autofocus: true,
      gamepadAlias: "ach-completed-empty-state",
      imgSrc: (0,react_facet_src.useFacetMap)(achievements => achievements.length === 0 ? emptyStatesNoProgress_namespaceObject : undefined, [], [(0,react_facet_src.useSharedFacet)(completedAchievementsSelector)]),
      gamepadIndex: 0,
      title: t('.completedEmptyTitle'),
      text: t('.completedEmptyText')
    }),
    data: (0,react_facet_src.useSharedFacet)(completedAchievementsSelector),
    footer: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputLegend_InputLegend.Space, {
      extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing, {
        size: 1
      })
    }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 1
    })),
    renderItem: ({
      itemFacet,
      index,
      listLengthFacet
    }) => /*#__PURE__*/react.createElement(AchievementListItemWrapper, {
      item: itemFacet,
      index: index,
      listLength: listLengthFacet,
      filterName: "completed"
    }),
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingEvent, {
      type: "meaningful",
      renderingCompleted: isContentShown
    }),
    padSpinnerVertically: true
  })));
};

const SummaryWrapper = () => {
  const summary = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(achievementsSummarySelector));
  const hasRewardFeatureFlag = useFeatureFlag(REWARD_FEATURE_FLAG);
  if (summary === react_facet_src.NO_VALUE) return null; // To avoid narrating the AchievementsSummary before the facet values have been received, a non interactive loading placeholder is returned until it is

  if (!summary.loaded) return /*#__PURE__*/react.createElement(AchievementsSummary_AchievementsSummary.Loading, {
    loading: !summary.loaded
  });
  return /*#__PURE__*/react.createElement(AchievementsSummary_AchievementsSummary, {
    gamepadIndex: 0,
    inProgress: summary.inProgressCount,
    achievementsUnlocked: summary.unlocked,
    achievementsTotal: summary.total,
    rewardsTotal: hasRewardFeatureFlag ? summary.rewardsTotal : 0,
    rewardsUnlocked: hasRewardFeatureFlag ? summary.rewardsUnlocked : undefined,
    gamerScore: summary.gamerScore,
    gamerScoreTotal: summary.maxGamerScore,
    hoursPlayed: summary.hoursPlayed
  });
};

const AchievementListItemWrapper = ({
  item,
  index,
  listLength,
  filterName,
  sectionIndex = 0
}) => {
  const historyAPI = RouteHistory_useRouteHistory();
  const narrationIsEnabled = useNarrationEnabled();
  return /*#__PURE__*/react.createElement(AchievementListItem_AchievementListItem, {
    item: item,
    gamepadAlias: (0,react_facet_src.useFacetMap)(item => `achievement-${filterName}-${item.id}`, [filterName], [item]),
    autofocus: index === 0 && sectionIndex === 0 && !narrationIsEnabled,
    onClick: (0,react_facet_src.useFacetCallback)(item => () => {
      historyAPI.push(`/achievement-detail/${item.id}`);
    }, [historyAPI], [item]),
    index: index,
    listLength: listLength
  });
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementsRoute/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementDetails/AchievementDetails.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AchievementDetails = ({"achievementImage":"TKfnq","achievementImageContainer":"n2uci","achievementUnlocked":"hXgLU","achievementLocked":"sgJds","frame":"ERib5","details":"akZA4","textWrapper":"eXwnH","gamerscoreIcon":"GooYD"});
;// CONCATENATED MODULE: ./packages/ui/src/Window/Images/locked.png
const Images_locked_namespaceObject = __webpack_require__.p + "assets/locked-b7e1e.png";
;// CONCATENATED MODULE: ./packages/ui/src/Window/Images/checkIcon.png
const checkIcon_namespaceObject = __webpack_require__.p + "assets/checkIcon-bcfbf.png";
;// CONCATENATED MODULE: ./packages/ui/src/Window/Window.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Window = ({"window":"xHU3n","transparent":"dDMcJ","header":"P3s5b","headerLocked":"Gddt6","headerCompleted":"S2bxD","lockedIcon":"kLdrM","checkIcon":"X2i3D","date":"PoM_H","spinner":"xzfzB"});
;// CONCATENATED MODULE: ./packages/ui/src/Window/Window.tsx










function Header({
  children,
  variant,
  date
}) {
  const {
    f
  } = useLocalization('Window');
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Window.header, {
      [Window.headerCompleted]: variant === 'completed',
      [Window.headerLocked]: variant === 'locked'
    })
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular"
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    imageRendering: "pixelated",
    className: classnames_default()({
      [Window.lockedIcon]: variant === 'locked',
      [Window.checkIcon]: variant === 'completed'
    }),
    src: variant === 'locked' ? Images_locked_namespaceObject : checkIcon_namespaceObject
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "white"
  }, children), variant === 'completed' && date != null && /*#__PURE__*/react.createElement("div", {
    className: Window.date
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "white"
  }, f.formatDate(date))));
}

function Window_Window({
  children,
  variant = 'locked',
  title,
  date,
  loading
}) {
  return !!loading ? /*#__PURE__*/react.createElement("div", {
    className: Window.transparent
  }, /*#__PURE__*/react.createElement(WindowSpinner, null)) : /*#__PURE__*/react.createElement("div", {
    className: Window.window
  }, /*#__PURE__*/react.createElement(Header, {
    date: date,
    variant: variant
  }, title), children);
}

const WindowSpinner = () => {
  return /*#__PURE__*/react.createElement("div", {
    className: Window.spinner
  }, /*#__PURE__*/react.createElement(Spinner_Spinner, null));
};
;// CONCATENATED MODULE: ./packages/ui/src/DescriptionList/DescriptionList.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const DescriptionList = ({"descriptionList":"hy23n","description":"VTr_m","progressWrapper":"ptFWK","percentageWrapper":"I0mfv"});
;// CONCATENATED MODULE: ./packages/ui/src/DescriptionList/DescriptionList.tsx








function DescriptionList_DescriptionList({
  children,
  role = 'neutral100'
}) {
  return /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement("div", {
    className: DescriptionList.descriptionList
  }, children));
}

DescriptionList_DescriptionList.Pair = function Pair({
  label,
  value,
  icon
}) {
  const {
    color: {
      inherit: semanticClassNames
    },
    variant
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(DescriptionList.description, semanticClassNames.background.base, semanticClassNames.text.base, variant.dimmer)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, label), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, icon, value));
};

DescriptionList_DescriptionList.Progress = function Progress({
  label,
  value,
  total
}) {
  const {
    t
  } = useLocalization('DescriptionList');
  const {
    color: {
      inherit: semanticClassNames
    },
    variant
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(DescriptionList.progressWrapper, semanticClassNames.background.base)
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(DescriptionList.description, semanticClassNames.text.base, variant.dimmer)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, label !== null && label !== void 0 ? label : t('.progressLabel')), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, value, "/", total)), /*#__PURE__*/react.createElement("div", {
    className: DescriptionList.percentageWrapper
  }, /*#__PURE__*/react.createElement(ProgressBar_ProgressBar, {
    tall: true,
    percentage: value / total
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  })));
};

DescriptionList_DescriptionList.displayName = 'DescriptionList';
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementDetails/images/gamerscoreIcon.png
const gamerscoreIcon_namespaceObject = __webpack_require__.p + "assets/gamerscoreIcon-0c23f.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementDetails/images/greyframe.png
const AchievementDetails_images_greyframe_namespaceObject = __webpack_require__.p + "assets/greyframe-dd39b.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementDetails/images/unlockedBorder.png
const unlockedBorder_namespaceObject = __webpack_require__.p + "assets/unlockedBorder-2f13b.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementDetails/images/placeholder.png
const AchievementDetails_images_placeholder_namespaceObject = __webpack_require__.p + "assets/placeholder-15b68.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementDetails/AchievementDetails.tsx












function AchievementDetails_AchievementDetails({
  title,
  description = '',
  image,
  gamerscore = 0,
  progress = 0,
  autofocus = false,
  progressTarget = 0,
  isLocked,
  dateUnlocked = 0,
  loading,
  completedOnAnotherPlatform,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization('AchievementDetails');
  const narrationIsEnabled = useNarrationEnabled();
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    inputLegend: false,
    className: '',
    classNameHovered: '',
    classNameFocused: focusClass,
    classNamePressed: '',
    disabled: !narrationIsEnabled,
    autofocus: narrationIsEnabled && autofocus,
    gamepadIndex: gamepadIndex,
    narrationText: false,
    onClick: () => {}
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    withoutBorders: true,
    disabled: !narrationIsEnabled
  }), /*#__PURE__*/react.createElement(Window_Window, {
    loading: loading,
    title: isLocked ? t('.locked') : t('.completed'),
    variant: isLocked ? 'locked' : 'completed',
    date: dateUnlocked
  }, /*#__PURE__*/react.createElement("div", {
    className: AchievementDetails.details
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 5
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(AchievementDetails.achievementImageContainer, {
      [AchievementDetails.achievementLocked]: isLocked
    })
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: classnames_default()(AchievementDetails.achievementImage, AchievementDetails.frame),
    imageRendering: "pixelated",
    src: isLocked ? AchievementDetails_images_greyframe_namespaceObject : unlockedBorder_namespaceObject
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: classnames_default()(AchievementDetails.achievementImage),
    imageRendering: "pixelated",
    src: image !== null && image !== void 0 ? image : AchievementDetails_images_placeholder_namespaceObject
  }), !isLocked && /*#__PURE__*/react.createElement("div", {
    className: AchievementDetails.achievementUnlocked
  })), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    className: AchievementDetails.textWrapper
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "header5B",
    color: "white"
  }, title), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "paragraphs",
    color: "grey"
  }, description)), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 5
  })), /*#__PURE__*/react.createElement(DescriptionList_DescriptionList, null, /*#__PURE__*/react.createElement(DescriptionList_DescriptionList.Pair, {
    label: t('.gamerscore'),
    value: `${gamerscore}`,
    icon: /*#__PURE__*/react.createElement(Image_Image_Image, {
      className: AchievementDetails.gamerscoreIcon,
      imageRendering: "pixelated",
      src: gamerscoreIcon_namespaceObject
    })
  }), completedOnAnotherPlatform && /*#__PURE__*/react.createElement(DescriptionList_DescriptionList.Pair, {
    label: t('.anotherPlatform'),
    value: t('.yes')
  }), progress && progress !== 0 && progress !== 1 ? /*#__PURE__*/react.createElement(DescriptionList_DescriptionList.Progress, {
    value: Math.round(progress * progressTarget),
    total: progressTarget
  }) : null)));
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementReward/AchievementReward.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AchievementReward = ({"reward":"tZxVg","innerReward":"SKSAr","rewardImage":"D98f5","rewardImageLocked":"CJ4sp","rewardImageBorder":"A2FSq","rewardImageBorderLocked":"ehHcI","rewardImageWrapper":"UzVku","lockedIcon":"yD_x4","unlockedIcon":"PCWpA","rewardText":"KAXsx","rewardHeader":"QcClj","buttonWrapper":"TAaUi"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementReward/images/rewardUnlockedFrame.png
const rewardUnlockedFrame_namespaceObject = __webpack_require__.p + "assets/rewardUnlockedFrame-7f44b.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementReward/images/rewardLockedFrame.png
const rewardLockedFrame_namespaceObject = __webpack_require__.p + "assets/rewardLockedFrame-35e6e.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementReward/images/unlockedIconGrey.png
const unlockedIconGrey_namespaceObject = __webpack_require__.p + "assets/unlockedIconGrey-2939d.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementReward/images/lockedIconGrey.png
const lockedIconGrey_namespaceObject = __webpack_require__.p + "assets/lockedIconGrey-c2c6d.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementReward/AchievementReward.tsx












function AchievementReward_AchievementReward({
  image,
  title,
  isOwned,
  onClickView
}) {
  const {
    t
  } = useLocalization('AchievementReward');
  const rewardNarrationText = [isOwned ? t('.narration.rewardUnlocked') : t('.narration.rewardLocked'), title].join(' - ');
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: rewardNarrationText
  }, /*#__PURE__*/react.createElement("div", {
    className: AchievementReward.reward
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular"
  }), /*#__PURE__*/react.createElement("div", {
    className: AchievementReward.innerReward
  }, /*#__PURE__*/react.createElement("div", {
    className: AchievementReward.rewardText
  }, /*#__PURE__*/react.createElement("div", {
    className: AchievementReward.rewardHeader
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "grey"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, t('.reward'))), isOwned ? /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: unlockedIconGrey_namespaceObject,
    imageRendering: "pixelated",
    className: AchievementReward.unlockedIcon
  }) : /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: lockedIconGrey_namespaceObject,
    imageRendering: "pixelated",
    className: AchievementReward.lockedIcon
  })), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    align: "center",
    color: "white"
  }, title)), /*#__PURE__*/react.createElement("div", {
    className: AchievementReward.rewardImageWrapper
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: image,
    imageRendering: "pixelated",
    className: classnames_default()(AchievementReward.rewardImage, {
      [AchievementReward.rewardImageLocked]: !isOwned
    })
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: isOwned ? rewardUnlockedFrame_namespaceObject : rewardLockedFrame_namespaceObject,
    imageRendering: "pixelated",
    className: isOwned ? AchievementReward.rewardImageBorder : AchievementReward.rewardImageBorderLocked
  })), /*#__PURE__*/react.createElement("div", {
    className: AchievementReward.buttonWrapper
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    delayedClick: true,
    onClick: onClickView,
    gamepadIndex: 0,
    autofocus: true,
    inputLegend: t('.viewReward'),
    variant: "secondary"
  }, t('.viewReward'))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementDetailsRoute/AchievementDetailsRoute.tsx












const AchievementDetailsRoute_LOADING_TIMEOUT = 10000;
const AchievementDetailsRoute_LOADING_WARNING = 1500;

const getProgressNarrationText = ({
  isLocked,
  progress,
  progressTarget
}, t) => {
  const progressValue = Math.ceil(progress * progressTarget);
  const progressPercentage = Math.round(progress * 100);
  return isLocked && progress > 0 && progress < 1 ? [t('.narration.progress'), t('.narration.percentage', [`${progressValue}`, `${progressTarget}`]), `${progressPercentage}%`] : [];
};

const AchievementDetailsRoute = () => {
  const {
    t,
    f
  } = useLocalization('AchievementDetailsRoute');
  const historyAPI = RouteHistory_useRouteHistory();
  const params = useRouteParams();
  const hasRewardFeatureFlag = useFeatureFlag(REWARD_FEATURE_FLAG);
  const data = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(achievementDetailSelector(params.id)));
  const isLoaded = !!(data !== react_facet_src.NO_VALUE && data.isLoaded);
  const achievement = data === react_facet_src.NO_VALUE ? undefined : data.achievement;
  const hasLoadingFailedFacet = useTimeout((0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector), AchievementDetailsRoute_LOADING_TIMEOUT);
  const loadingTakingTimeFacet = useTimeout((0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector), AchievementDetailsRoute_LOADING_WARNING);
  const hasLoadingFailed = (0,react_facet_src.useFacetUnwrap)(hasLoadingFailedFacet);
  const loadingTakingTime = (0,react_facet_src.useFacetUnwrap)(loadingTakingTimeFacet);
  const is404 = isLoaded && !achievement;
  (0,react.useEffect)(() => {
    if (is404) historyAPI.goBack();
  }, [is404, historyAPI]);
  const hasReward = Boolean(hasRewardFeatureFlag && achievement && achievement.rewardName != null && achievement.rewardImage);
  const narration = achievement != null ? [achievement.isLocked ? t('.narration.locked') : t('.narration.completed'), // Is the "not unlocked" value either 0 or negative?
  // dateUnlocked is not nullable currently, so we suppose "not unlocked" is 0 or negative
  achievement.dateUnlocked > 0 ? f.formatDate(achievement.dateUnlocked) : '', achievement.name, achievement.description, ...(achievement.gamerScore !== 0 ? [t('.narration.gamerscore'), `${achievement.gamerScore}`] : []), ...getProgressNarrationText(achievement, t)].join(' . ') : '';
  if (data === react_facet_src.NO_VALUE) return null;
  const completedOnAnotherPlatform = hasRewardFeatureFlag && achievement && achievement.hasReward && achievement.isRewardOwned && achievement.isLocked;
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(NarrationContext, {
    text: t('.narration.title')
  }, (loadingTakingTime === react_facet_src.NO_VALUE ? false : loadingTakingTime) && (hasLoadingFailed === react_facet_src.NO_VALUE ? true : !hasLoadingFailed) && /*#__PURE__*/react.createElement(Narration, {
    text: t('.narration.loadingMessage')
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: isLoaded
  }), /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout, {
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: () => historyAPI.goBack()
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography, {
      variant: "header5A",
      color: "black"
    }, t('.title'))
  }, (hasLoadingFailed === react_facet_src.NO_VALUE ? false : hasLoadingFailed) ? /*#__PURE__*/react.createElement(Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: 2,
    narrowSize: 1
  }), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 8,
    narrowSize: 6
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    autofocus: true,
    gamepadAlias: "ach-details-empty-state",
    gamepadIndex: 0,
    text: t('.errorMessage')
  })))) : /*#__PURE__*/react.createElement(NarrationContext, {
    text: narration
  }, /*#__PURE__*/react.createElement(Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0
  }, (!hasReward || !isLoaded) && /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: 2,
    narrowSize: 1
  }), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 8,
    narrowSize: hasReward && isLoaded ? 5 : 6
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 0,
    focusableIfScrollable: true,
    autofocusFocusable: !hasReward
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), achievement ? /*#__PURE__*/react.createElement(AchievementDetails_AchievementDetails, {
    loading: false,
    title: achievement.name,
    image: achievement.image,
    description: achievement.description,
    progress: achievement.progress,
    progressTarget: achievement.progressTarget,
    isLocked: achievement.isLocked,
    dateUnlocked: achievement.dateUnlocked,
    gamerscore: achievement.gamerScore,
    autofocus: !hasReward,
    gamepadIndex: 0,
    completedOnAnotherPlatform: !!completedOnAnotherPlatform
  }) : /*#__PURE__*/react.createElement(AchievementDetails_AchievementDetails, {
    gamepadIndex: 0,
    loading: true
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(InputLegend_InputLegend.Space, null))), hasReward && achievement && achievement.rewardName != null && achievement.rewardImage != null && /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 4,
    narrowSize: 3
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 0,
    loading: !isLoaded
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(AchievementReward_AchievementReward, {
    title: achievement.rewardName,
    onClickView: () => {
      historyAPI.push(`/persona?itemId=${achievement.rewardId}`);
    },
    isOwned: isAchievementRewardOwned(achievement),
    image: achievement.rewardImage
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(InputLegend_InputLegend.Space, null)))))))));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementDetailsRoute/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RenderDistanceWarningRoute/RenderDistanceWarningRoute.tsx








const RenderDistanceWarningRoute = () => {
  const historyAPI = RouteHistory_useRouteHistory();
  const optionsWrapped = (0,react_facet_src.useSharedFacet)(optionsFacet);
  const options = (0,react_facet_src.useFacetUnwrap)(optionsWrapped);
  const initialRenderDistance = (0,react.useRef)();
  const {
    t
  } = useLocalization('RenderDistanceWarningRoute');
  const isNarrationEnabled = useNarrationEnabled();
  const onUseRecommendedSettings = (0,react_facet_src.useFacetCallback)(options => () => {
    options.renderDistance = options.defaultRenderDistance;
    options.showRenderDistanceWarningModal = false;
    historyAPI.goBack();
  }, [historyAPI], [optionsWrapped]);
  const onUseCurrentSettings = (0,react_facet_src.useFacetCallback)(options => () => {
    options.showRenderDistanceWarningModal = false;
    historyAPI.goBack();
  }, [historyAPI], [optionsWrapped]);
  if (options == react_facet_src.NO_VALUE) return null; // Store initial value to prevent flicking to the new value after we update it

  if (initialRenderDistance.current == null) {
    initialRenderDistance.current = options.renderDistance;
  }

  const recommendedSettingsButtonLabel = [t('.useRecommendedSettingsButton'), t(options.defaultRenderDistance > 1 ? '.chunksPluralCaption' : '.chunksSingularCaption', [`${options.defaultRenderDistance}`])].join(' ');
  const currentSettingsChunkSuffix = initialRenderDistance.current > 1 ? '.chunksPluralCaption' : '.chunksSingularCaption';
  const currentSettingsButtonLabel = [t('.useCurrentSettingsButton'), t(currentSettingsChunkSuffix, [`${initialRenderDistance.current}`])].join(' ');
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: `${t('.title')}. ${t('.body1')}. ${t('.body2')}`
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    focusableIfScrollable: !isNarrationEnabled
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${t('.body1')}. ${t('.body2')}`,
    spaceBetweenParagraphs: 5,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong"
  }, t('.body1')), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong"
  }, t('.body2')))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    autofocus: true,
    inputLegend: t('.confirmInputLegend'),
    variant: "primary",
    onClick: onUseRecommendedSettings
  }, recommendedSettingsButtonLabel), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.confirmInputLegend'),
    variant: "secondary",
    onClick: onUseCurrentSettings
  }, currentSettingsButtonLabel))));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RenderDistanceWarningRoute/index.tsx

;// CONCATENATED MODULE: ./packages/ui/src/SideMenu/SideMenu.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SideMenu = ({"sideMenu":"ktO0j","item":"vPqz2","listItem":"iWrTh","itemHovered":"rtKPV","itemSelected":"qaKqk","itemFocused":"B2m9T","focusOutline":"pwcli","itemMain":"_ooLj","itemCell":"Wfm8X","divider":"OlLk0","footer":"H9jOa"});
;// CONCATENATED MODULE: ./packages/ui/src/Divider/Divider.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Divider = ({"divider":"Fk8ro","innerDivider":"TPz7W"});
;// CONCATENATED MODULE: ./packages/ui/src/Divider/Divider.tsx




function Divider_Divider({
  role = 'inherit'
}) {
  const {
    color,
    variant
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("fast-div", {
    className: Divider.divider
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: classnames_default()(Divider.innerDivider, color[role].bevel.base, variant.reversed)
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/SideMenu/SideMenu.tsx













function SideMenu_SideMenu({
  children,
  footer,
  gamepadIndex,
  loading,
  autofocus,
  scrollViewRef,
  role = 'neutral80'
}) {
  const ref = (0,react.useRef)(null);
  const breakpoint = useWindowBreakpoint();
  const {
    t
  } = useLocalization('SideMenu');
  const {
    color: {
      [role]: semanticClassNames
    },
    variant
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(NarrationContext, {
    text: t('.narrationRoleMenu')
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: gamepadIndex,
    floating: breakpoint !== 'desktop',
    defaultFocusedChildBehavior: "remember",
    loading: loading,
    autofocus: autofocus // gray80, but inline vars don't seem to work in GF player
    ,
    spinnerBackgroundColor: "#313233",
    innerRef: scrollViewRef
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: classnames_default()(SideMenu.sideMenu, semanticClassNames.background.base, semanticClassNames.border.base)
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), children, footer != null && /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort"
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(SideMenu.footer, semanticClassNames.text.base, variant.dimmer)
  }, footer)), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement(InputLegend_InputLegend.Space, {
    extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 1
    })
  }))));
}
function Item({
  children,
  role = 'inherit'
}) {
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(SideMenu.item, semanticClassNames.background.base)
  }, children);
}
function SideMenu_ListItem({
  onSelect,
  children,
  selected,
  value,
  gamepadIndex,
  narrationText,
  inputLegend,
  soundEffectPressed,
  role = 'inherit'
}) {
  const {
    t
  } = useLocalization('SideMenu.ListItem');
  const {
    narrateText
  } = useNarrateText();
  const index = (0,react.useContext)(ItemListIndex);
  const count = (0,react.useContext)(ItemListCount);
  const {
    color: {
      [role]: semanticClassNames
    },
    modifier,
    sound: {
      [role]: semanticSound
    }
  } = useSemanticTokens();
  const indexNarration = (0,react_facet_src.useFacetMap)(count => t('.narrationIndex', [`${index + 1}`, `${count}`]), [t, index], [count]);
  const narrationTextMapped = (0,react_facet_src.useFacetMap)((narrationText, selected, indexNarration) => `${narrationText} ${t('.narrationRoleMenuItem')} ${indexNarration} ${t(selected ? '.narrationSelected' : '.narrationUnselected')}`, [t], [narrationText, selected, indexNarration]);
  const soundEffectPressedFacet = (0,react_facet_src.useFacetMap)((soundEffectPressed, selected) => {
    return !selected ? soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.toggle : undefined;
  }, [semanticSound.toggle], [(0,react_facet_src.useFacetWrap)(soundEffectPressed), selected]);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    className: (0,react_facet_src.useFacetMap)(selected => {
      const semanticClassNamesList = selected ? [semanticClassNames.background.select, semanticClassNames.bevel.select] : [semanticClassNames.background.interactive, semanticClassNames.bevel.interactive];
      return classnames_default()(SideMenu.listItem, semanticClassNamesList, {
        [SideMenu.itemSelected]: selected,
        [modifier.selected]: selected
      });
    }, [semanticClassNames, modifier], [selected]),
    classNameFocused: classnames_default()(focusClass, SideMenu.itemFocused),
    classNameHovered: (0,react_facet_src.useFacetMap)(selected => selected ? undefined : SideMenu.itemHovered, [], [selected]),
    onClick: (0,react_facet_src.useFacetCallback)(value => () => {
      narrateText(t('.narrationSelected'));
      onSelect(value);
    }, [t, narrateText, onSelect], [value]),
    gamepadIndex: gamepadIndex,
    inputLegend: (0,react_facet_src.useFacetMap)(selected => selected ? false : inputLegend, [inputLegend], [selected]),
    soundEffectPressed: soundEffectPressedFacet,
    narrationText: narrationTextMapped
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    className: SideMenu.focusOutline
  }), children);
}

SideMenu_SideMenu.ItemMain = function ({
  children
}) {
  return /*#__PURE__*/react.createElement("div", {
    className: SideMenu.itemMain
  }, children);
};

SideMenu_SideMenu.ItemCell = function ({
  children
}) {
  return /*#__PURE__*/react.createElement("div", {
    className: SideMenu.itemCell
  }, children);
};

SideMenu_SideMenu.Divider = function SideMenuDivider({
  label,
  role = 'inherit'
}) {
  const {
    color: {
      [role]: semanticClassNames
    },
    variant
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort"
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(SideMenu.divider, semanticClassNames.text.base, variant.dimmer)
  }, label)), /*#__PURE__*/react.createElement(Divider_Divider, null));
};

const zeroFacet = (0,react_facet_src.createFacet)({
  initialValue: 0
});
const ItemListCount = (0,react.createContext)(zeroFacet);
const ItemListIndex = (0,react.createContext)(0);
function ItemList({
  items,
  renderItem,
  initialGamepadIndex
}) {
  return /*#__PURE__*/react.createElement(ItemListCount.Provider, {
    value: (0,react_facet_src.useFacetMap)(items => items.length, [], [items])
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: items
  }, (item, index) => {
    return /*#__PURE__*/react.createElement(ItemListIndex.Provider, {
      value: index
    }, renderItem({
      item,
      gamepadIndex: index + initialGamepadIndex
    }));
  }));
}
SideMenu_SideMenu.displayName = 'SideMenu';
SideMenu_SideMenu.ItemList = ItemList;
SideMenu_SideMenu.ListItem = SideMenu_ListItem;
SideMenu_SideMenu.Item = Item;
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/advanced-icon.png
const advanced_icon_namespaceObject = __webpack_require__.p + "assets/advanced-icon-34af9.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/experimental-features-icon.png
const experimental_features_icon_namespaceObject = __webpack_require__.p + "assets/experimental-features-icon-94de6.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/cheats-icon.png
const cheats_icon_namespaceObject = __webpack_require__.p + "assets/cheats-icon-fa15a.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/debug-icon.png
const debug_icon_namespaceObject = __webpack_require__.p + "assets/debug-icon-df18b.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/general-icon.png
const general_icon_namespaceObject = __webpack_require__.p + "assets/general-icon-e1776.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/resource-packs-icon.png
const resource_packs_icon_namespaceObject = __webpack_require__.p + "assets/resource-packs-icon-17c91.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/multiplayer-icon.png
const multiplayer_icon_namespaceObject = __webpack_require__.p + "assets/multiplayer-icon-a3920.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/behaviour-packs-icon.png
const behaviour_packs_icon_namespaceObject = __webpack_require__.p + "assets/behaviour-packs-icon-cf4d9.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/scripting-coding-icon.png
const scripting_coding_icon_namespaceObject = __webpack_require__.p + "assets/scripting-coding-icon-7fe30.png";
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/common.ts
// Safe to import from both node and web




// EXTERNAL MODULE: ./games/vanilla/tokens/src/soundDefinitions.json
var soundDefinitions = __webpack_require__(52910);
;// CONCATENATED MODULE: ./games/vanilla/tokens/src/soundDefinitions.fixtures.json
const soundDefinitions_fixtures_namespaceObject = {};
;// CONCATENATED MODULE: ./games/vanilla/tokens/src/tokens.ts




const vanillaTokens = collectionCreator({
  id: 'vanilla',
  sound: {
    neutral: {
      reject: 'note.bass',
      press: 'random.click',
      contract: 'random.click',
      expand: 'random.click',
      toggle: 'random.click',
      lift: 'random.click',
      click: 'random.click'
    },
    primary: {
      press: 'tokens.vanilla.release'
    }
  },
  color: {
    neutral: {
      background: {
        default: palette.gray70,
        hovered: palette.gray60,
        pressed: palette.gray80,
        disabled: palette.gray30
      },
      text: {
        dimmer: {
          default: palette.gray30,
          disabled: palette.gray30
        },
        dimmest: {
          default: palette.gray40
        },
        regular: {
          default: palette.white,
          disabled: palette.gray70
        }
      },
      shadow: {
        default: palette.gray80,
        disabled: palette.gray40
      },
      dropShadow: {
        default: palette.blackOpacity25
      },
      icon: {
        regular: {
          default: palette.white,
          disabled: palette.gray70
        },
        dimmer: {
          default: palette.gray30
        },
        dimmest: {
          default: palette.gray40
        }
      },
      border: {
        regular: {
          default: palette.gray100,
          disabled: palette.gray50
        }
      },
      caret: {
        regular: {
          default: palette.green30
        }
      },
      specular: {
        default: {
          top: palette.whiteOpacity20,
          bottom: palette.whiteOpacity10
        }
      },
      bevel: {
        default: {
          top: palette.whiteOpacity10,
          bottom: palette.blackOpacity30
        }
      },
      outline: {
        default: palette.white
      },
      highlight: {
        default: 'transparent',
        hovered: palette.blackOpacity10
      },
      overlay: {
        default: palette.blackOpacity70
      }
    },
    neutral20: {
      background: {
        default: palette.gray20,
        hovered: palette.gray10,
        pressed: palette.gray30
      },
      shadow: {
        default: palette.gray40
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      icon: {
        regular: {
          default: palette.white
        }
      },
      outline: {
        default: palette.black
      },
      specular: {
        default: {
          top: palette.whiteOpacity30,
          bottom: palette.whiteOpacity20
        }
      }
    },
    neutral50: {
      background: {
        default: palette.gray50,
        hovered: palette.gray40,
        pressed: palette.gray60
      },
      border: {
        regular: {
          default: palette.gray100,
          disabled: palette.gray50
        }
      },
      overlay: {
        default: palette.blackOpacity50
      }
    },
    neutral60: {
      background: {
        default: palette.gray60,
        hovered: palette.gray50,
        pressed: palette.gray70
      },
      border: {
        dimmest: {
          default: palette.gray50
        }
      },
      text: {
        regular: {
          default: palette.white
        }
      }
    },
    neutral80: {
      background: {
        default: palette.gray80,
        hovered: palette.gray70,
        selected: palette.gray70,
        pressed: palette.gray90
      },
      shadow: {
        default: palette.gray90
      },
      text: {
        regular: {
          default: palette.white
        },
        dimmer: {
          default: palette.gray30
        },
        dimmest: {
          default: palette.gray40
        }
      },
      caret: {
        regular: {
          default: palette.green30
        }
      },
      bevel: {
        default: {
          top: palette.whiteOpacity10,
          bottom: palette.blackOpacity40
        },
        hovered: {
          top: palette.whiteOpacity10,
          bottom: palette.blackOpacity40
        },
        pressed: {
          top: palette.blackOpacity80,
          bottom: palette.whiteOpacity10
        },
        selected: {
          top: palette.blackOpacity40,
          bottom: palette.whiteOpacity10
        }
      }
    },
    neutral100: {
      background: {
        default: palette.gray100
      },
      text: {
        regular: {
          default: palette.white
        },
        dimmer: {
          default: palette.gray30
        },
        dimmest: {
          default: palette.gray40
        }
      }
    },
    primary: {
      background: {
        default: palette.green50,
        hovered: palette.green40,
        pressed: palette.green60
      },
      shadow: {
        default: palette.green70
      },
      text: {
        regular: {
          default: palette.white
        }
      },
      icon: {
        regular: {
          default: palette.white,
          disabled: palette.gray40
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      },
      specular: {
        default: {
          top: palette.whiteOpacity20,
          bottom: palette.whiteOpacity10
        }
      }
    },
    primaryTint: {
      background: {
        default: palette.green30
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    secondary: {
      background: {
        default: palette.gray30,
        hovered: palette.gray10,
        pressed: palette.gray40
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      icon: {
        regular: {
          default: palette.gray100
        }
      },
      shadow: {
        default: palette.gray60
      },
      border: {
        regular: {
          default: palette.gray100
        }
      },
      specular: {
        default: {
          top: palette.whiteOpacity60,
          bottom: palette.whiteOpacity40
        }
      }
    },
    success: {
      background: {
        default: palette.green50
      },
      text: {
        regular: {
          default: palette.white
        }
      }
    },
    successTint: {
      background: {
        default: palette.green10
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    informative: {
      background: {
        default: palette.blue20
      },
      text: {
        regular: {
          default: palette.white
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    informativeTint: {
      background: {
        default: palette.blue10
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    destructive: {
      background: {
        default: palette.red50,
        hovered: palette.red10,
        pressed: palette.red60
      },
      text: {
        regular: {
          default: palette.white
        }
      },
      icon: {
        regular: {
          default: palette.white
        }
      },
      shadow: {
        default: palette.red80
      },
      specular: {
        default: {
          top: palette.whiteOpacity20,
          bottom: palette.whiteOpacity10
        }
      }
    },
    destructiveTint: {
      background: {
        default: palette.red10
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    notice: {
      background: {
        default: palette.orange20
      }
    },
    noticeTint: {
      background: {
        default: palette.yellow10
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    paper: {
      background: {
        default: palette.white
      },
      text: {
        regular: {
          default: palette.black,
          disabled: palette.gray70
        }
      },
      icon: {
        regular: {
          default: palette.black,
          disabled: palette.gray70
        }
      },
      border: {
        regular: {
          default: palette.gray100,
          disabled: palette.gray50
        }
      },
      caret: {
        regular: {
          default: palette.black
        }
      },
      specular: {
        default: {
          top: palette.whiteOpacity20,
          bottom: palette.whiteOpacity10
        }
      },
      bevel: {
        default: {
          top: palette.whiteOpacity10,
          bottom: palette.blackOpacity30
        }
      },
      outline: {
        default: palette.gray100
      },
      highlight: {
        default: 'transparent',
        hovered: palette.blackOpacity10
      }
    }
  }
});
const realmsTokens = collectionCreator({
  id: 'realms',
  sound: {
    secondary: {
      press: 'tokens.vanilla.release'
    }
  },
  color: {
    primary: {
      background: {
        default: palette.deepBlue50,
        hovered: palette.deepBlue40,
        pressed: palette.deepBlue60
      },
      border: {
        regular: {
          default: palette.gray100
        }
      },
      overlay: {
        default: palette.deepBlueOpacity50
      },
      shadow: {
        default: palette.deepBlue70
      },
      text: {
        regular: {
          default: palette.white
        }
      },
      icon: {
        regular: {
          default: palette.white
        }
      },
      specular: {
        default: {
          top: 'rgba(182, 81, 245, 0.4)',
          bottom: 'rgba(208, 131, 255, 0.5)'
        }
      },
      caret: {
        regular: {
          default: palette.black
        }
      },
      bevel: {
        default: {
          top: palette.whiteOpacity10,
          bottom: palette.blackOpacity30
        }
      },
      outline: {
        default: palette.white
      }
    },
    primaryTint: {
      background: {
        default: palette.deepBlue10
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    informative: {
      background: {
        default: palette.deepBlue20
      },
      text: {
        regular: {
          default: palette.white
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    }
  }
});
;// CONCATENATED MODULE: ./games/vanilla/tokens/src/index.ts

;// CONCATENATED MODULE: ./packages/ui/src/Spritesheet/Spritesheet.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Spritesheet = ({"Spritesheet":"c9joz","spritesheetAnimation":"ghQXH"});
;// CONCATENATED MODULE: ./packages/ui/src/Spritesheet/Spritesheet.tsx



function Spritesheet_Spritesheet(props) {
  const classNameFacet = (0,react_facet_src.useFacetWrap)(props.className);
  const classNameMapped = (0,react_facet_src.useFacetMap)((className = '') => `${Spritesheet.Spritesheet} ${className}`, [], [classNameFacet]);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(props.disabled);
  const pausedFacet = (0,react_facet_src.useFacetWrap)(props.paused);
  const display = (0,react_facet_src.useFacetMap)(isDisabled => isDisabled ? 'none' : 'flex', [], [disabledFacet]);
  const animationPlayState = (0,react_facet_src.useFacetMap)(isPaused => isPaused ? 'paused' : 'running', [], [pausedFacet]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: classNameMapped,
    style: {
      display,
      backgroundImage: `url(${props.src})`,
      animationPlayState,
      animationName: Spritesheet.spritesheetAnimation,
      animationDirection: props.animationDirection || 'normal',

      /**
       * Gameface currently doesn't support the steps(jump-mode) parameter
       * in animation-timing-function. This parameter is needed for us to see
       * the final frame of a spritesheet image. The suggested fix until then
       * is to just add an extra empty frame to the end of the spritesheet image.
       *
       * When jump-mode is eventually supported, we should use jump-none.
       */
      animationTimingFunction: `steps(${props.frames})`,
      animationIterationCount: typeof props.repeat === 'number' ? props.repeat.toString() : 'infinite',
      animationDuration: `${props.duration || 500}ms`,
      imageRendering: props.imageRendering,
      width: `calc(${props.width * 10 / (props.frames + 1)} * var(--base1Scale))`,
      height: `calc(${props.height * 10} * var(--base1Scale))`,
      backgroundSize: `calc(${props.width * 10} * var(--base1Scale)) calc(${props.height * 10} * var(--base1Scale))`
    }
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/IllustrativeMenuIcon/IllustrativeMenuIcon.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IllustrativeMenuIcon = ({"icon":"f2nZb","iconShineAnimation":"EvXg5"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/IllustrativeMenuIcon/images/icon-highlight-spritesheet.png
const icon_highlight_spritesheet_namespaceObject = __webpack_require__.p + "assets/icon-highlight-spritesheet-87ec6.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/IllustrativeMenuIcon/IllustrativeMenuIcon.tsx






const IllustrativeMenuIcon_IllustrativeMenuIcon = ({
  iconSrc,
  selected
}) => /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(Image_Image_Image, {
  src: iconSrc,
  className: IllustrativeMenuIcon.icon,
  imageRendering: "pixelated"
}), /*#__PURE__*/react.createElement("div", {
  className: IllustrativeMenuIcon.iconShineAnimation
}, /*#__PURE__*/react.createElement(Spritesheet_Spritesheet, {
  disabled: (0,react_facet_src.useFacetMap)(selected => !selected, [], [(0,react_facet_src.useFacetWrap)(selected !== null && selected !== void 0 ? selected : false)]),
  src: icon_highlight_spritesheet_namespaceObject,
  frames: 8,
  duration: 500,
  width: 21.6,
  height: 2.4,
  repeat: 1,
  imageRendering: 'pixelated'
})));
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/IllustrativeMenuIcon/index.ts

;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldImage/WorldImage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const WorldImage = ({"image":"T3q0T","border":"JsKa7"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldImage/WorldImage.tsx





function WorldImage_WorldImage({
  imgSrc,
  role = 'inherit',
  border = true
}) {
  const {
    color
  } = useSemanticTokens();
  const imageUrlString = (0,react_facet_src.useFacetMap)(imgSrc => 'url(' + imgSrc + ')', [], [imgSrc]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: classnames_default()(WorldImage.image, {
      [`${color[role].border.base}`]: border,
      [WorldImage.border]: border
    }),
    style: {
      backgroundImage: imageUrlString
    }
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/context/WorldModeContext.ts

const WorldModeContext = react.createContext('create');
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/context/index.ts


;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/WorldSettingsSideMenu.tsx























const difficultyTranslationKeys = {
  [DifficultyEnum.PEACEFUL]: '.difficultyPeacefulLabel',
  [DifficultyEnum.EASY]: '.difficultyEasyLabel',
  [DifficultyEnum.NORMAL]: '.difficultyNormalLabel',
  [DifficultyEnum.HARD]: '.difficultyHardLabel'
};
const gameModeTranslationKeys = {
  [types_GameMode.ADVENTURE]: '.gameModeAdventureLabel',
  [types_GameMode.CREATIVE]: '.gameModeCreativeLabel',
  [types_GameMode.SURVIVAL]: '.gameModeSurvivalLabel'
};

function getMenuItems(isDevBuild, isEduBuild) {
  const menuItems = [{
    label: '.generalTabLabel',
    image: general_icon_namespaceObject,
    value: 'general'
  }, {
    label: '.advancedTabLabel',
    image: advanced_icon_namespaceObject,
    value: 'advanced'
  }, {
    label: '.multiplayerTabLabel',
    image: multiplayer_icon_namespaceObject,
    value: 'multiplayer'
  }];

  if (isEduBuild) {
    menuItems.push({
      label: '.scriptingCodingTabLabel',
      image: scripting_coding_icon_namespaceObject,
      value: 'scripting-coding'
    });
  }

  menuItems.push({
    label: '.cheatsTabLabel',
    image: cheats_icon_namespaceObject,
    value: 'cheats'
  }, {
    label: '.resourcePacksTabLabel',
    image: resource_packs_icon_namespaceObject,
    value: 'resource-packs'
  }, {
    label: '.behaviorPacksTabLabel',
    image: behaviour_packs_icon_namespaceObject,
    value: 'behavior-packs'
  });

  if (!isEduBuild || isDevBuild) {
    menuItems.push({
      label: '.experimentalFeaturesTabLabel',
      image: experimental_features_icon_namespaceObject,
      value: 'experimental'
    });
  }

  if (isDevBuild) {
    menuItems.push({
      label: '.debugTabLabel',
      image: debug_icon_namespaceObject,
      value: 'debug'
    });
  }

  return menuItems;
}

const CREATE_BUTTON_ALIAS = 'cnw-create-button';
const PLAY_BUTTON_ALIAS = 'ew-play-button';

function WorldSettingsSideMenu({
  onMainActionClick,
  onMainRealmsActionClick,
  worldPreviewImage,
  showSpinner,
  showRealmsButton,
  worldPacks,
  generalData
}) {
  const {
    t
  } = useLocalization('CreateNewWorldSideMenu');
  const {
    t: t2
  } = useLocalization('CreateNewWorld.general'); // the "create" button hint uses translations from the general tab

  const mode = (0,react.useContext)(WorldModeContext);
  const createLabel = t('.create');
  const createOnRealmLabel = t('.createOnRealm');
  const playLabel = t('.play');
  const transferToRealmsLabel = t('.transferToRealms');
  const loading = (0,react_facet_src.useFacetMap)((showSpinner, isDeferring) => showSpinner || isDeferring, [], [showSpinner, (0,dist.useIsDeferring)()]);
  const heroButtonHint = (0,react_facet_src.useFacetMap)(generalData => {
    const gameMode = gameModeTranslationKeys[generalData.gameMode];
    const difficulty = difficultyTranslationKeys[generalData.difficulty];
    const worldName = generalData.worldName != '' ? generalData.worldName : t2('.worldNamePlaceholder');
    const translationKey = mode === 'edit' ? '.narrationPlayButtonHint' : '.narrationCreateButtonHint';
    return t(translationKey, [t2(gameMode), t2(difficulty), worldName]);
  }, [t, t2, mode], [generalData]);
  const grayCNWButton = useFeatureFlag(ENABLE_CREATE_WORLD_GRAY_BUTTON);
  const menuItems = (0,react_facet_src.useFacetMap)((isDevBuild, isEduBuild) => getMenuItems(isDevBuild, isEduBuild), [], [(0,react_facet_src.useSharedFacet)(isDevBuildSelector), (0,react_facet_src.useSharedFacet)(isEduBuildSelector)]);
  const scrollViewRef = (0,react.useRef)(null);
  const scrollToTop = (0,react.useCallback)(() => {
    if (scrollViewRef.current) {
      if (scrollViewRef.current.scrollHeight) {
        scrollViewRef.current.scrollTop = 0;
      } else {
        requestAnimationFrame(scrollToTop);
      }
    }
  }, []);
  (0,react_facet_src.useFacetEffect)(scrollToTop, [scrollToTop], [worldPreviewImage]);
  return /*#__PURE__*/react.createElement(SideMenu_SideMenu, {
    gamepadIndex: 1,
    loading: loading,
    autofocus: true,
    scrollViewRef: scrollViewRef
  }, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(WorldImage_WorldImage, {
    imgSrc: worldPreviewImage
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: mode === 'edit' ? PLAY_BUTTON_ALIAS : CREATE_BUTTON_ALIAS,
    narrationSuffix: heroButtonHint,
    variant: "hero",
    onClick: onMainActionClick,
    gamepadIndex: 0,
    inputLegend: mode === 'create' ? createLabel : playLabel
  }, mode === 'create' ? createLabel : playLabel))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRealmsButton
  }, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensCollectionProvider, {
    collection: realmsTokens
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    narrationSuffix: heroButtonHint,
    linebreak: true,
    variant: grayCNWButton ? 'secondary' : 'primary',
    onClick: onMainRealmsActionClick,
    gamepadIndex: 1,
    inputLegend: mode === 'create' ? createOnRealmLabel : transferToRealmsLabel
  }, mode === 'create' ? createOnRealmLabel : transferToRealmsLabel))))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(SideMenu_SideMenu.ItemList, {
    items: menuItems,
    initialGamepadIndex: 2,
    renderItem: props => /*#__PURE__*/react.createElement(SideMenuItem, {
      item: props.item,
      gamepadIndex: props.gamepadIndex,
      worldPacks: worldPacks
    })
  }));
}

const filterPackTab = (prefix, type, noActivePacks) => `/${prefix}/${type}/${noActivePacks ? 'available' : 'active'}`;

function SideMenuItem({
  item,
  gamepadIndex,
  worldPacks
}) {
  const {
    t
  } = useLocalization('CreateNewWorldSideMenu');
  const historyAPI = RouteHistory_useRouteHistory();
  const label = (0,react_facet_src.useFacetMap)(item => item.label.includes('.debugTabLabel') ? 'Debug' : t(item.label), [t], [item]);
  const params = useRouteParams();
  const selected = (0,react_facet_src.useFacetMap)(item => params.tab === item.value, [params], [item]);
  const mode = (0,react.useContext)(WorldModeContext);
  const textureActivePacks = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.active, [], [worldPacks]);
  const behaviorActivePacks = (0,react_facet_src.useFacetMap)(facet => facet.behaviorPacks.active, [], [worldPacks]);
  return /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(SideMenu_SideMenu.ListItem, {
    narrationText: label,
    onSelect: (0,react_facet_src.useFacetCallback)((item, activeTexturePacks, activeBehaviorPacks) => () => {
      // Avoid redirecting to the already selected tab
      if (item.value === params.tab) return;
      const prefix = mode === 'edit' ? `edit-world/${params.id}` : 'create-new-world'; // If the resource or behavior packs tab is selected, the redirect should go to either active or available tab

      if (item.value === 'resource-packs') historyAPI.replaceKeepingFocus(filterPackTab(prefix, item.value, activeTexturePacks.length === 0));else if (item.value === 'behavior-packs') historyAPI.replaceKeepingFocus(filterPackTab(prefix, item.value, activeBehaviorPacks.length === 0));else {
        historyAPI.replaceKeepingFocus(`/${prefix}/${item.value}`);
      }
    }, [historyAPI, params, mode], [item, textureActivePacks, behaviorActivePacks]),
    value: (0,react_facet_src.useFacetMap)(item => item.value, [], [item]),
    selected: selected,
    gamepadIndex: gamepadIndex,
    inputLegend: t('.inputLegendSelect')
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu.ItemCell, null, /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
    iconSrc: (0,react_facet_src.useFacetMap)(item => item.image, [], [item]),
    selected: selected
  })), /*#__PURE__*/react.createElement(SideMenu_SideMenu.ItemMain, null, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body"
  }, label))));
}

function DeferredMountContainer(props) {
  return /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(WorldSettingsSideMenu, props));
}
;// CONCATENATED MODULE: ./packages/ui/src/PanelButton/PanelButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PanelButton = ({"buttonsContainer":"KIftG"});
;// CONCATENATED MODULE: ./packages/ui/src/PanelButton/PanelButton.tsx





function PanelButton_PanelButton({
  title,
  description,
  buttons,
  gamepadIndex,
  defaultFocusedChildBehavior
}) {
  const gamepadOptions = (0,react_facet_src.useFacetMap)(gamepadIndex => {
    return {
      index: gamepadIndex,
      defaultFocusedChildBehavior
    };
  }, [defaultFocusedChildBehavior], [(0,react_facet_src.useFacetWrap)(gamepadIndex)]);
  return /*#__PURE__*/react.createElement(Panel_Panel, null, title != null && /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, null, title), description != null && /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, null, description), buttons != null && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Row, {
    shouldSkipLandmarkInVisual: true,
    options: gamepadOptions
  }, /*#__PURE__*/react.createElement("div", {
    className: PanelButton.buttonsContainer
  }, buttons))));
}

function ButtonSpacing() {
  return /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  });
}

PanelButton_PanelButton.ButtonSpacing = ButtonSpacing;
;// CONCATENATED MODULE: ./packages/ui/src/SectionHeader/SectionHeader.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SectionHeader = ({"description":"Ddo87"});
;// CONCATENATED MODULE: ./packages/ui/src/SectionHeader/SectionHeader.tsx






function SectionHeader_SectionHeader({
  title,
  description,
  role = 'neutral'
}) {
  const {
    color: {
      [role]: semanticClassNames
    },
    variant
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(semanticClassNames.background.base, semanticClassNames.text.base)
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "sectionHeader",
    color: "inherit"
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement("fast-text", {
    text: title
  })), description != null && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(SectionHeader.description, semanticClassNames.text.base, variant.dimmer)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: description
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/Toggles/Toggle.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Toggle = ({"toggle":"nUoyP","labelContainer":"gcCW_","centerLabel":"b73Js","container":"jxTxF","focused":"lHZ6b","pressed":"DLmmU","bottomEdge":"hV7S1","selectedIndicator":"L83HZ","selected":"NGP2h","disabled":"vWkm_","selectedToggle":"bJ4Tv"});
;// CONCATENATED MODULE: ./packages/ui/src/Toggles/Toggle.tsx









function Toggle_Toggle({
  gamepadIndex,
  gamepadAlias,
  children,
  icons,
  disabled,
  selected,
  onClick,
  extraSpeechProps: {
    index,
    groupSize,
    description
  },
  onFocusChanged,
  wrapText,
  soundEffectPressed,
  onRole = 'primary',
  offRole = 'secondary'
}) {
  const {
    t
  } = useLocalization('Toggle');
  const {
    color: {
      [offRole]: semanticClassNamesOff,
      [onRole]: semanticClassNamesOn
    }
  } = useSemanticTokens();
  const narrationText = [children, t('.narrationOptionType'), t('.count', [`${index + 1}`, `${groupSize}`]), selected ? t('.narrationSelected') : t('.narrationUnselected'), description !== null && description !== void 0 ? description : ''].join(' . ');
  const containerClassName = classnames_default()(Toggle.container, {
    [Toggle.pressed]: selected,
    [Toggle.disabled]: disabled
  });
  const toggleClassName = classnames_default()(Toggle.toggle, [selected ? [semanticClassNamesOn.background.base, semanticClassNamesOn.background.disable] : semanticClassNamesOff.background.interactive], [selected ? [semanticClassNamesOn.text.base, semanticClassNamesOn.text.disable] : semanticClassNamesOff.text.interactive], {
    [Toggle.disabled]: disabled
  });
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    narrationText: narrationText,
    className: classnames_default()(containerClassName, semanticClassNamesOff.border.base, semanticClassNamesOff.border.disable),
    classNameFocused: classnames_default()(Toggle.focused, focusClass),
    classNamePressed: Toggle.pressed,
    soundEffectPressed: soundEffectPressed,
    gamepadIndex: gamepadIndex,
    gamepadAlias: gamepadAlias,
    inputLegend: t('.select'),
    onClick: onClick,
    onFocusChanged: onFocusChanged,
    disabled: disabled
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    role: selected ? 'primary' : 'secondary',
    disabled: disabled
  }), /*#__PURE__*/react.createElement("div", {
    className: toggleClassName
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    role: selected ? 'primary' : 'secondary',
    disabled: disabled
  }), /*#__PURE__*/react.createElement("div", {
    className: Toggle.labelContainer
  }, wrapText ? /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit",
    align: wrapText ? 'center' : undefined
  }, icons ? disabled ? icons.disabled : selected ? icons.selected : icons.unselected : null, (0,react_facet_src.isFacet)(children) ? /*#__PURE__*/react.createElement("fast-text", {
    text: children
  }) : children) : /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit",
    align: wrapText ? 'center' : undefined
  }, icons ? disabled ? icons.disabled : selected ? icons.selected : icons.unselected : null, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, {
    className: Toggle.centerLabel
  }, children))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()([selected ? [semanticClassNamesOn.icon.base, semanticClassNamesOn.icon.disable] : undefined], {
      [Toggle.selectedIndicator]: selected,
      [Toggle.disabled]: disabled
    })
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Toggle.bottomEdge, semanticClassNamesOff.shadow.interactive, {
      [Toggle.disabled]: disabled
    })
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/Toggles/Toggles.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Toggles = ({"toggles":"RJ8Px"});
// EXTERNAL MODULE: ./node_modules/ramda/src/propEq.js
var propEq = __webpack_require__(18371);
var propEq_default = /*#__PURE__*/__webpack_require__.n(propEq);
// EXTERNAL MODULE: ./node_modules/ramda/src/find.js
var src_find = __webpack_require__(46376);
var find_default = /*#__PURE__*/__webpack_require__.n(src_find);
;// CONCATENATED MODULE: ./packages/ui-internal/src/DropdownMenu/DropdownMenu.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const DropdownMenu = ({"wrapper":"BHtky","lastItem":"fD1Jz","inner":"YsLjj"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/DropdownMenu/DropdownMenu.tsx
function DropdownMenu_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function DropdownMenu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DropdownMenu_ownKeys(Object(source), true).forEach(function (key) { DropdownMenu_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DropdownMenu_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function DropdownMenu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








function DropdownMenu_DropdownMenu({
  children,
  gamepadIndex,
  footer,
  menuRole = 'secondary',
  itemRole = 'neutral60',
  style = {}
}) {
  const {
    color: {
      [menuRole]: semanticClassNamesMenu,
      [itemRole]: semanticClassNamesItem
    },
    variant
  } = useSemanticTokens();
  const wrappingRef = (0,react.useRef)(null);
  const columnOptions = (0,react_facet_src.useFacetMap)(gamepadIndex => {
    return {
      index: gamepadIndex,
      disabled: gamepadIndex === -1,
      bounded: true
    };
  }, [], [(0,react_facet_src.useFacetWrap)(gamepadIndex)]);
  return /*#__PURE__*/react.createElement(Column, {
    options: columnOptions,
    scrollRef: wrappingRef
  }, /*#__PURE__*/react.createElement("fast-div", {
    ref: wrappingRef,
    className: DropdownMenu.wrapper,
    style: DropdownMenu_objectSpread(DropdownMenu_objectSpread({}, style),  true ? {
      marginTop: 'var(--base1Scale)'
    } : 0)
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(DropdownMenu.inner, semanticClassNamesMenu.border.base)
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(DropdownMenu.lastItem, semanticClassNamesItem.border.base, variant.dimmest)
  }, /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: itemRole
  }, children)))), footer));
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/DropdownMenu/DropdownItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const DropdownItem = ({"dropdownItem":"MneaI","show":"opARO","hide":"jhxB_"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/DropdownMenu/DropdownItem.tsx









function DropdownItem_DropdownItem({
  item,
  onClick,
  isSelected,
  soundEffectPressed,
  soundEffectHovered,
  role = 'inherit',
  onFocusChanged,
  disabled,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization('DropdownItem');
  const itemFacet = (0,react_facet_src.useFacetWrap)(item);
  const isSelectedWrapped = (0,react_facet_src.useFacetWrap)(isSelected);
  const gamepadAliasFacet = (0,react_facet_src.useFacetMap)(item => item.gamepadAlias, [], [itemFacet]);
  const label = (0,react_facet_src.useFacetMap)(item => item.label, [], [itemFacet]);
  const {
    color: {
      [role]: {
        background,
        text,
        border
      }
    },
    modifier,
    variant
  } = useSemanticTokens();
  const narrationText = (0,react_facet_src.useFacetMap)((item, isSelected) => {
    var _item$description;

    return [item.label, t('.elementType'), item.enumeration, isSelected ? t('.selected') : t('.unselected'), (_item$description = item.description) !== null && _item$description !== void 0 ? _item$description : ''].join(' . ');
  }, [t], [itemFacet, isSelectedWrapped]);
  const interactivePrimitiveClassnames = (0,react_facet_src.useFacetMap)(isSelected => {
    return classnames_default()(DropdownItem.dropdownItem, background.interactive, border.interactive, variant.dimmest, {
      [modifier.selected]: isSelected
    });
  }, [background.interactive, border.interactive, modifier.selected, variant.dimmest], [isSelectedWrapped]);
  const iconClassName = (0,react_facet_src.useFacetMap)(isSelected => isSelected ? DropdownItem.show : DropdownItem.hide, [], [isSelectedWrapped]);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    className: interactivePrimitiveClassnames,
    classNameFocused: classnames_default()(DropdownItem.dropdownFocusedItem, focusClass),
    classNameHovered: DropdownItem.dropdownItemHover,
    gamepadIndex: gamepadIndex,
    gamepadAlias: gamepadAliasFacet,
    narrationText: narrationText,
    inputLegend: t('.select'),
    onClick: onClick,
    soundEffectPressed: soundEffectPressed,
    soundEffectHovered: soundEffectHovered,
    onFocusChanged: onFocusChanged,
    disabled: disabled
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    role: role
  }), /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, {
    className: text.interactive
  }, label), /*#__PURE__*/react.createElement("fast-div", {
    className: iconClassName
  }, /*#__PURE__*/react.createElement(IconCheckWhite_IconCheckWhite, null)));
}
const DropdownItemWrapper = ({
  item,
  onChange,
  currentValue,
  soundEffectPressed,
  soundEffectHovered,
  onFocusChanged,
  disabled,
  gamepadIndex
}) => {
  const handleClick = (0,react_facet_src.useFacetCallback)(item => () => {
    onChange(item.value);
  }, [onChange], [item]);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const gamepadIndexFacet = (0,react_facet_src.useFacetMap)(isDisabled => isDisabled ? -1 : gamepadIndex + 1, [gamepadIndex], [disabledFacet]);
  const currentValueFacet = (0,react_facet_src.useFacetWrap)(currentValue);
  return /*#__PURE__*/react.createElement(DropdownItem_DropdownItem, {
    item: item,
    isSelected: (0,react_facet_src.useFacetMap)((item, currentValue) => item.value === currentValue, [], [item, currentValueFacet]),
    gamepadIndex: gamepadIndexFacet,
    onClick: handleClick,
    soundEffectPressed: soundEffectPressed,
    soundEffectHovered: soundEffectHovered,
    onFocusChanged: onFocusChanged,
    disabled: disabledFacet
  });
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowDown/images/arrowDown.png
const arrowDown_namespaceObject = __webpack_require__.p + "assets/arrowDown-8543c.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowDown/IconArrowDown.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowDown = ({"iconArrowDown":"fYSEY"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowDown/IconArrowDown.tsx




const IconArrowDown_IconArrowDown = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconArrowDown.iconArrowDown,
  src: arrowDown_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseDropdown/BaseDropdown.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseDropdown = ({"baseDropdownWrapperMenu":"D93jN","baseDropdown":"UKRdZ","baseDropdownOpen":"fIk9X","baseDropdownBevelOpen":"rQRSc","withMouse":"oNoil","hasScroll":"KVO62","baseToggleInnerWrapper":"NKSLw","noSelection":"hqWc9","baseArrowPosition":"boDJV","hide":"ZSOVX"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseDropdown/BaseDropdown.tsx



function BaseDropdown_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function BaseDropdown_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BaseDropdown_ownKeys(Object(source), true).forEach(function (key) { BaseDropdown_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BaseDropdown_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BaseDropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

















const emptyText = (0,react_facet_src.createFacet)({
  initialValue: ''
});
function BaseDropdown_BaseDropdown({
  options,
  value,
  onChange,
  isOpen: isOpenProp,
  onClick,
  onOpenClose,
  dropdownRef,
  disabled,
  onFocusChanged,
  onHoverChanged,
  placeholder,
  footer,
  gamepadAlias,
  soundEffectPressed,
  soundEffectItemHovered,
  narrationText,
  shouldOnlyHandleBackButtonPressWhenDropdownIsOpen = true,
  isElevated = true,
  hideDownArrow = false,
  menuRole = 'secondary',
  itemRole = 'neutral60',
  dropdownMenuStyle,
  onBackButtonPressProps
}) {
  const {
    color: {
      [menuRole]: semanticClassNamesMenu
    }
  } = useSemanticTokens();
  const {
    narrateText
  } = useNarrateText();
  const isOpenPropFacet = (0,react_facet_src.useFacetWrap)(isOpenProp);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const [isOpen, setIsOpen] = (0,react_facet_src.useFacetState)(false);
  const [isFocused, setIsFocused] = (0,react_facet_src.useFacetState)(false);
  const [isInnerItemFocused, setIsInnerItemFocused] = (0,react_facet_src.useFacetState)(false);
  const placeholderFacet = (0,react_facet_src.useFacetWrap)(placeholder);
  (0,react_facet_src.useFacetEffect)(isOpen => {
    if (isOpen != null) {
      setIsOpen(isOpen);
    }
  }, [setIsOpen], [isOpenPropFacet]);
  const localRef = (0,react.useRef)(null);
  const ref = dropdownRef || localRef;
  (0,react_facet_src.useFacetEffect)(isOpen => onOpenClose && onOpenClose(isOpen), [onOpenClose], [isOpen]);
  const {
    t
  } = useLocalization('BaseDropdown');
  const optionsFacet = (0,react_facet_src.useFacetWrap)(options);
  const selectedValueFacet = (0,react_facet_src.useFacetWrap)(value);
  const currentOptionFacet = (0,react_facet_src.useFacetMap)((options, selectedValue) => find_default()(propEq_default()('value', selectedValue))(options), [], [optionsFacet, selectedValueFacet]);
  useOnClickOutside(ref, () => {
    setIsOpen(false);
    setFocus(false);
    setTimeout(() => narrateText(t('.stateCollapsed')), 0);
  }, isOpen);
  const isPointerMouse = useIsPointerInputMouse();
  const itemHeightInPixels = useSizeInPixels(4.8);
  const maxHeightInPixels = useSizeInPixels(30);
  const classNameFacet = (0,react_facet_src.useFacetMap)((options, isOpen, currentOption, isMouse) => {
    const hasScroll = options.length * itemHeightInPixels > maxHeightInPixels;
    return classnames_default()({
      [BaseDropdown.baseDropdownBevelOpen]: isOpen,
      [BaseDropdown.withMouse]: isMouse,
      [BaseDropdown.hasScroll]: hasScroll,
      [BaseDropdown.noSelection]: currentOption == null
    });
  }, [itemHeightInPixels, maxHeightInPixels], [optionsFacet, isOpen, currentOptionFacet, isPointerMouse]);

  const handleFocusChange = focus => {
    setIsFocused(focus);
    onFocusChanged === null || onFocusChanged === void 0 ? void 0 : onFocusChanged(focus);
  };

  const handleHoverChange = hover => {
    onHoverChanged === null || onHoverChanged === void 0 ? void 0 : onHoverChanged(hover);
  };

  const outerClassNameFacet = (0,react_facet_src.useFacetMap)(isOpen => classnames_default()(BaseDropdown.baseDropdown, {
    [BaseDropdown.baseDropdownOpen]: isOpen
  }), [], [isOpen]);
  const uniqueIdentifier = useUniqueIdentifier();
  const pressableGamepadAlias = gamepadAlias != null ? gamepadAlias : `dd-bevel-${uniqueIdentifier}`;
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  const setFocus = (0,react.useCallback)(isOpen => {
    if (isOpen) {
      const firstIndexAlias = gamepadAlias != null ? `${gamepadAlias}-0` : `dd-bevel-${uniqueIdentifier}-0`; // We delay this by a frame, as it runs too quickly on the
      // Gameface player and causes buggy scroll behavior (ADO:737546)

      const raf = typeof requestAnimationFrame != 'undefined' ? requestAnimationFrame : mockRequestAnimationFrame;
      raf(() => {
        setFocusedId(firstIndexAlias);
      });
    } else {
      setFocusedId(pressableGamepadAlias);
    }
  }, [gamepadAlias, uniqueIdentifier, setFocusedId, pressableGamepadAlias]);
  const handleBackButtonPress = (0,react_facet_src.useFacetCallback)(isOpen => () => {
    if (isOpen) {
      setIsOpen(false);
      setFocus(false);
      setTimeout(() => narrateText(t('.stateCollapsed')), 0);
    }

    onBackButtonPressProps && onBackButtonPressProps(isOpen);
  }, [onBackButtonPressProps, setIsOpen, setFocus, narrateText, t], [isOpen]);
  const handleClick = (0,react_facet_src.useFacetCallback)(isOpen => () => {
    const isNowOpen = !isOpen;
    setIsOpen(isNowOpen);
    onClick && onClick(isNowOpen);
    setFocus(isNowOpen);
  }, [setIsOpen, onClick, setFocus], [isOpen]);
  const handleChange = (0,react_facet_src.useFacetCallback)(options => value => {
    onChange(value);
    handleClick();

    const currentValue = find_default()(propEq_default()('value', value))(options); // As soon as the narration context supports custom narration id's we can remove this and use that instead.


    setTimeout(() => narrateText([t('.selected'), currentValue === null || currentValue === void 0 ? void 0 : currentValue.narrationSuffix].join(' . ')), 0);
  }, [onChange, handleClick, narrateText, t], [optionsFacet]);
  const shouldHandleBackButtonPress = (0,react_facet_src.useFacetMap)((isOpen, isFocused, isInnerItemFocused) => {
    return (isOpen || !shouldOnlyHandleBackButtonPressWhenDropdownIsOpen) && (isFocused || isInnerItemFocused);
  }, [shouldOnlyHandleBackButtonPressWhenDropdownIsOpen], [isOpen, isFocused, isInnerItemFocused]);
  const optionsWithEnumerationAndGamepadAlias = (0,react_facet_src.useFacetMemo)(options => {
    return options.map((option, index) => {
      return BaseDropdown_objectSpread(BaseDropdown_objectSpread({}, option), {}, {
        enumeration: t('.enumeration', [`${index + 1}`, `${options.length}`]),
        gamepadAlias: gamepadAlias != null ? `${gamepadAlias}-${index}` : `dd-bevel-${uniqueIdentifier}-${index}`
      });
    });
  }, [t, gamepadAlias, uniqueIdentifier], [optionsFacet]);
  const {
    sound: {
      neutral: semanticSound
    }
  } = useSemanticTokens();
  const baseDropdownWrapperMenuClassnames = (0,react_facet_src.useFacetMap)((isOpen, disabled) => classnames_default()(BaseDropdown.baseDropdownWrapperMenu, {
    [BaseDropdown.hide]: !isOpen || disabled === true
  }), [], [isOpen, disabledFacet]);
  const isClosedOrDisabled = (0,react_facet_src.useFacetMap)((isOpen, disabled) => !isOpen || disabled === true, [], [isOpen, disabledFacet]);
  const dropdownMenuNarrationText = (0,react_facet_src.useFacetMap)(isOpen => isOpen ? t('.stateExpanded') : '', [t], [isOpen]);
  const parentShortcutOptions = (0,react_facet_src.useFacetMap)(shouldHandleBackButtonPress => {
    return {
      button: types_ButtonType.B,
      disabled: !shouldHandleBackButtonPress
    };
  }, [], [shouldHandleBackButtonPress]);
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: narrationText !== null && narrationText !== void 0 ? narrationText : emptyText
  }, /*#__PURE__*/react.createElement("fast-div", {
    ref: ref,
    className: outerClassNameFacet
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: classNameFacet
  }, /*#__PURE__*/react.createElement(Pressable_Pressable, {
    reflection: "specular",
    variant: menuRole,
    narrationText: "",
    onClick: handleClick,
    gamepadIndex: 0,
    inputLegend: t('.open'),
    onFocusChanged: handleFocusChange,
    onHoverChanged: handleHoverChange,
    shouldNotDepressWhenPressed: true,
    height: 4.2,
    isElevated: isElevated,
    disabled: disabledFacet,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.press,
    gamepadAlias: pressableGamepadAlias
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: classnames_default()(BaseDropdown.baseToggleInnerWrapper, semanticClassNamesMenu.text.interactive)
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, (0,react_facet_src.useFacetMap)((currentOption, placeholder) => currentOption ? currentOption.label : placeholder != null ? `${placeholder}...` : '', [], [currentOptionFacet, placeholderFacet])), !hideDownArrow && /*#__PURE__*/react.createElement("div", {
    className: BaseDropdown.baseArrowPosition
  }, /*#__PURE__*/react.createElement(IconArrowDown_IconArrowDown, null))))), /*#__PURE__*/react.createElement(NarrationContext, {
    text: dropdownMenuNarrationText
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: baseDropdownWrapperMenuClassnames
  }, /*#__PURE__*/react.createElement(DropdownMenu_DropdownMenu, {
    gamepadIndex: (0,react_facet_src.useFacetMap)(isClosedOrDisabled => isClosedOrDisabled ? -1 : 1, [], [isClosedOrDisabled]),
    footer: footer,
    menuRole: menuRole,
    itemRole: itemRole,
    style: dropdownMenuStyle
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: optionsWithEnumerationAndGamepadAlias
  }, (item, index) => /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(DropdownItemWrapper, {
    item: item,
    gamepadIndex: index,
    onChange: handleChange,
    key: index,
    currentValue: selectedValueFacet,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.press,
    soundEffectHovered: soundEffectItemHovered !== null && soundEffectItemHovered !== void 0 ? soundEffectItemHovered : semanticSound.hover,
    onFocusChanged: setIsInnerItemFocused,
    disabled: isClosedOrDisabled
  })))))), /*#__PURE__*/react.createElement(ParentShortcut_ParentShortcut, {
    options: parentShortcutOptions,
    onClick: handleBackButtonPress
  })));
} // Needed for visual regression test workaround (TODO: Find cleaner way)

const mockRequestAnimationFrame = fn => fn();
;// CONCATENATED MODULE: ./packages/ui/src/Dropdown/Dropdown.tsx








// If you change this make sure to also update the DropdownItem.css file
const DROPDOWN_ITEM_HEIGHT_REM = 4.8; // If you change this make sure to also update the DropdownMenu.css file

const DROPDOWN_MENU_MAX_HEIGHT_REM = 30;
function Dropdown({
  description,
  gamepadIndex,
  onChange,
  wrapperRef,
  onFocusChanged,
  placeholder,
  label,
  options,
  value,
  disabled,
  disabledNarrationSuffix,
  soundEffectPressed,
  gamepadAlias
}) {
  // we need a wrapper component here so that the Column context is defined
  // and the inner button to toggle the dropdown menu is inside of it.
  // If we had the column and the focusable inside the same component
  // they would become siblings, and their gamepad indexes would collide
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const indexFacet = (0,react_facet_src.useFacetWrap)(gamepadIndex);
  return /*#__PURE__*/react.createElement(Column, {
    shouldSkipLandmarkInVisual: true,
    options: (0,react_facet_src.useFacetMap)(index => ({
      index
    }), [], [indexFacet])
  }, /*#__PURE__*/react.createElement(DropdownInnerComponent, {
    options: options,
    value: valueFacet,
    disabled: disabledFacet,
    disabledNarrationSuffix: disabledNarrationSuffix,
    label: label,
    description: description,
    placeholder: placeholder,
    onChange: onChange,
    wrapperRef: wrapperRef,
    onFocusChanged: onFocusChanged,
    soundEffectPressed: soundEffectPressed,
    gamepadAlias: gamepadAlias
  }));
}

function useDropdownHeight(options, dropdownRef, wrapperRef) {
  const dropdownItemHeightInPixels = useSizeInPixels(DROPDOWN_ITEM_HEIGHT_REM);
  const dropdownMenuMaxHeightInPixels = useSizeInPixels(DROPDOWN_MENU_MAX_HEIGHT_REM);
  const numberOfOptions = (0,react_facet_src.useFacetMap)(options => options.length, [], [(0,react_facet_src.useFacetWrap)(options)]);
  const [panelHeight, setPanelHeight] = (0,react_facet_src.useFacetState)('');
  const [dropdownMenuHeight, setDropdownMenuHeight] = (0,react_facet_src.useFacetState)('');
  const panelStyle = {
    height: panelHeight
  };
  const dropdownMenuStyle = {
    height: dropdownMenuHeight
  }; // We'll use this function to determine if we should apply any changes to
  // the panels height when the dropdown changes between opened and closed.

  const calculateNewHeight = isOpen => {
    var _wrapperRef$current;

    // Exit early if we don't have the values we need to perform the calculation
    const wrapper = wrapperRef === null || wrapperRef === void 0 ? void 0 : wrapperRef.current;
    const parent = wrapperRef === null || wrapperRef === void 0 ? void 0 : (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 ? void 0 : _wrapperRef$current.parentElement;
    const dropdown = dropdownRef.current;
    const numOfOptions = numberOfOptions.get();

    if (!dropdown || numOfOptions === react_facet_src.NO_VALUE) {
      return;
    }

    if (wrapper && parent) {
      const originalHeight = wrapper.getBoundingClientRect().height;
      const dropdownOffset = dropdown.offsetTop;
      const dropdownHeight = numOfOptions * dropdownItemHeightInPixels;
      const dropdownPaddingBottom = 12;
      const expandedHeight = Math.min(Math.max(originalHeight, dropdownOffset + dropdownHeight + dropdownPaddingBottom), dropdownMenuMaxHeightInPixels + dropdownOffset + dropdownPaddingBottom); // Check if the dropdown fits within the parents scroll height. If not we'll
      // publish a new facet value that is going to grow the height of the panel.

      const shouldPanelExpandIfDropdownOpens = parent.scrollHeight < wrapper.offsetTop + expandedHeight;
      const height = isOpen && shouldPanelExpandIfDropdownOpens ? `${expandedHeight}px` : '';
      setPanelHeight(height);
    } else {
      // If we don't have a wrapper and parent, we want to clamp the height of the menu to the available space in the viewport
      const dropdownRect = dropdown.getBoundingClientRect();

      if (dropdownRect.height === 0) {
        return;
      }

      const height = window.innerHeight - dropdownRect.top;

      if (height < dropdownMenuMaxHeightInPixels) {
        setDropdownMenuHeight(isOpen ? `${height}px` : '');
      } else {
        setDropdownMenuHeight('');
      }
    }
  };

  return [panelStyle, dropdownMenuStyle, calculateNewHeight];
}

function DropdownInnerComponent({
  options,
  label,
  description,
  placeholder,
  value,
  onChange,
  wrapperRef,
  disabled,
  disabledNarrationSuffix,
  onFocusChanged,
  soundEffectPressed,
  gamepadAlias,
  menuRole = 'secondary',
  itemRole = 'neutral60'
}) {
  const {
    t
  } = useLocalization('Dropdown');
  const isNarrationEnabled = useNarrationEnabled();
  const optionsFacet = (0,react_facet_src.useFacetWrap)(options);
  const selectedOption = (0,react_facet_src.useFacetMap)((options, selectedValue) => options.find(option => option.value === selectedValue), [], [optionsFacet, value]);
  const selectedValueLabel = (0,react_facet_src.useFacetMap)(selectedOption => {
    var _selectedOption$label;

    return (_selectedOption$label = selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.label) !== null && _selectedOption$label !== void 0 ? _selectedOption$label : '';
  }, [], [selectedOption]);
  const selectedValueDescription = (0,react_facet_src.useFacetMap)(selectedOption => {
    var _selectedOption$descr;

    return (_selectedOption$descr = selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.description) !== null && _selectedOption$descr !== void 0 ? _selectedOption$descr : '';
  }, [], [selectedOption]);
  const hasSelectedToggleDescription = (0,react_facet_src.useFacetMap)(selectedValueDescription => Boolean(selectedValueDescription), [], [selectedValueDescription]); // We are able to pass an optional wrapperRef to this component. We'll grow the height of the panel,
  // for a consistent background, if the dropdown items expands outside of the wrappers parent container.

  const dropdownRef = (0,react.useRef)(null);
  const [panelStyle, dropdownMenuStyle, calculateNewHeight] = useDropdownHeight(options, dropdownRef, wrapperRef);
  const baseDropdownNarrationText = (0,react_facet_src.useFacetMap)((selectedValueLabel, selectedValueDescription) => [selectedValueLabel, t('.toggleElementType'), t('.selected'), selectedValueDescription, disabledNarrationSuffix].join(' . '), [t, disabledNarrationSuffix], [selectedValueLabel, selectedValueDescription]);
  const isDisabled = (0,react_facet_src.useFacetWrap)(disabled !== null && disabled !== void 0 ? disabled : false);
  const isPanelFocusable = (0,react_facet_src.useFacetMap)(isDisabled => isNarrationEnabled && isDisabled === true, [isNarrationEnabled], [isDisabled]);
  const narrationText = (0,react_facet_src.useFacetMap)((baseDropdownNarrationText, isDisabled) => [label, t('.narrationComponentType'), isDisabled ? t('.narrationDisabled') : '', t('.stateCollapsed'), // If the dropdown is disabled, we need to add extra narration here to match
  // the narration that is calculated in the BaseDropdown. The reason we can't
  // add it in the BaseDropdown is because the Panel below needs to be the focusable element.
  isDisabled ? baseDropdownNarrationText : ''].join(' . '), [t, label], [baseDropdownNarrationText, isDisabled]);
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: narrationText
  }, /*#__PURE__*/react.createElement(Panel_Panel, {
    style: panelStyle,
    focusable: isPanelFocusable,
    gamepadIndex: 0,
    narrationText: ''
  }, /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, {
    disabled: disabled
  }, label), description != null && /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, null, description), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(BaseDropdown_BaseDropdown, {
    narrationText: baseDropdownNarrationText,
    options: options,
    value: value,
    onChange: onChange,
    disabled: disabled,
    placeholder: placeholder,
    onFocusChanged: onFocusChanged,
    footer: /*#__PURE__*/react.createElement(InputLegend_InputLegend.Space, null),
    soundEffectPressed: soundEffectPressed,
    onOpenClose: calculateNewHeight,
    dropdownRef: dropdownRef,
    gamepadAlias: gamepadAlias,
    menuRole: menuRole,
    itemRole: itemRole,
    dropdownMenuStyle: dropdownMenuStyle
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasSelectedToggleDescription
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, {
    disabled: disabled
  }, selectedValueDescription)))));
}
;// CONCATENATED MODULE: ./packages/ui/src/Toggles/Toggles.tsx
function Toggles_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function Toggles_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Toggles_ownKeys(Object(source), true).forEach(function (key) { Toggles_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Toggles_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Toggles_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












let id = 0;

const Toggles_noop = () => {};

function Toggles_Toggles({
  gamepad,
  options,
  title,
  description,
  onChange = Toggles_noop,
  disabled = false,
  value,
  wrapToggleText,
  onMountComplete,
  soundEffectPressed,
  disabledNarrationSuffix
}) {
  const {
    sound: {
      neutral: semanticSound
    }
  } = useSemanticTokens();
  const wrappingRef = (0,react.useRef)(null);
  const optionsFacet = (0,react_facet_src.useFacetWrap)(options);
  const optionsCountRaw = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(options => options.length, [], [optionsFacet]));
  const optionsCount = optionsCountRaw !== react_facet_src.NO_VALUE ? optionsCountRaw : 0; // the minimum width for one item in REM, when you multiply it by the options cont, it gives you the break-point width in REM

  const minimumItemWidth = 15;
  const smallerThanResult = useIsComponentSmallerThan(wrappingRef, optionsCount * minimumItemWidth);
  const biggerThanSize = (0,react_facet_src.useFacetMap)(result => result === 'bigger', [], [smallerThanResult]);
  const smallerThanSize = (0,react_facet_src.useFacetMap)(result => result === 'smaller', [], [smallerThanResult]);
  const isNarrationEnabled = useNarrationEnabled();
  (0,react_facet_src.useFacetEffect)((bigger, smaller) => {
    if ((bigger || smaller) && onMountComplete != null) {
      onMountComplete();
    }
  }, [onMountComplete], [biggerThanSize, smallerThanSize]);
  return /*#__PURE__*/react.createElement(Row, {
    shouldSkipLandmarkInVisual: true,
    options: Toggles_objectSpread(Toggles_objectSpread({}, gamepad), {}, {
      disabled: (0,react_facet_src.useFacetUnwrap)(disabled) === true && !isNarrationEnabled
    }),
    scrollRef: wrappingRef
  }, /*#__PURE__*/react.createElement("div", {
    ref: wrappingRef
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: smallerThanSize
  }, /*#__PURE__*/react.createElement(Dropdown, {
    label: title,
    description: description,
    gamepadIndex: 0,
    options: options,
    value: value,
    onChange: onChange,
    disabled: disabled,
    disabledNarrationSuffix: disabledNarrationSuffix,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.toggle,
    wrapperRef: wrappingRef
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: biggerThanSize
  }, /*#__PURE__*/react.createElement(InternalToggles, {
    disabledNarrationSuffix: disabledNarrationSuffix,
    options: options,
    title: title,
    description: description,
    onChange: onChange,
    disabled: disabled,
    value: value,
    wrapToggleText: wrapToggleText,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.toggle
  }))));
}

function InternalToggles({
  options: optionsProp,
  title,
  description,
  onChange = Toggles_noop,
  disabled: disabledProp = false,
  value: valueProp,
  wrapToggleText,
  soundEffectPressed,
  disabledNarrationSuffix
}) {
  var _options$find;

  const options = (0,react_facet_src.useFacetUnwrap)(optionsProp);
  const value = (0,react_facet_src.useFacetUnwrap)(valueProp);
  const disabled = (0,react_facet_src.useFacetUnwrap)(disabledProp);
  const focusAlias = (0,react.useRef)(`MCT-${id++}`);
  const {
    narrateText
  } = useNarrateText();
  const {
    t
  } = useLocalization('Toggle');
  const isNarrationEnabled = useNarrationEnabled();
  if (options === react_facet_src.NO_VALUE || value === react_facet_src.NO_VALUE || disabled === react_facet_src.NO_VALUE) return null;
  const selectedIndex = options.findIndex(option => {
    return option.value === value;
  });
  const selectedToggleDescription = (_options$find = options.find(option => option.value === value && option.description)) === null || _options$find === void 0 ? void 0 : _options$find.description;

  function handleClickOnToggle(index) {
    if (options === react_facet_src.NO_VALUE) return;
    onChange(options[index].value);
  }

  const disabledNarrationText = disabled && isNarrationEnabled ? [title !== null && title !== void 0 ? title : '', t('.narrationComponentType'), t('.narrationDisabled'), options[selectedIndex].label, t('.narrationOptionType'), t('.narrationSelected'), selectedToggleDescription !== null && selectedToggleDescription !== void 0 ? selectedToggleDescription : '', disabledNarrationSuffix !== null && disabledNarrationSuffix !== void 0 ? disabledNarrationSuffix : ''].join(' . ') : '';
  return /*#__PURE__*/react.createElement(Panel_Panel, {
    focusable: disabled && isNarrationEnabled,
    gamepadIndex: 0,
    narrationText: disabledNarrationText
  }, title != null && /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, {
    disabled: disabled
  }, title), description != null ? /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, null, description) : null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement("div", {
    className: Toggles.toggles
  }, /*#__PURE__*/react.createElement(NarrationContext, {
    text: `${title !== null && title !== void 0 ? title : ''} ${t('.narrationComponentType')}`
  }, options.map((option, index) => {
    return /*#__PURE__*/react.createElement(Toggle_Toggle, {
      key: index,
      icons: option.icons,
      onClick: () => {
        const option = options[index];
        narrateText([t('.narrationSelected'), option.narrationSuffix].join(' . '));
        handleClickOnToggle(index);
      },
      selected: selectedIndex === index,
      gamepadIndex: index,
      gamepadAlias: `${focusAlias.current}.${index}`,
      extraSpeechProps: {
        index,
        groupSize: options.length,
        description: option.description
      },
      disabled: disabled,
      wrapText: wrapToggleText,
      soundEffectPressed: selectedIndex === index ? undefined : soundEffectPressed
    }, option.label);
  }))), selectedToggleDescription != null && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, null, selectedToggleDescription)));
}

Toggles_Toggles.displayName = 'Toggles';
Toggles_Toggles.Toggle = Toggle_Toggle;
;// CONCATENATED MODULE: ./packages/react-dnd/src/PointerBlocker.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PointerBlocker = ({"blockPointer":"hVSP2"});
;// CONCATENATED MODULE: ./packages/react-dnd/src/PointerBlocker.tsx
/**
 * This component is used to prevent mouse hovers on focusables when the user
 * is dragging and dropping. Triggering mouse hovers during this action will
 * trigger narration that is probably not relevant to the user.
 */



const SetDisablePointer = (0,react.createContext)(() => {});
const useSetDisablePointerHoverEvents = () => (0,react.useContext)(SetDisablePointer);
function PointerBlocker_PointerBlocker({
  children
}) {
  const [disabled, setDisabled] = (0,react_facet_src.useFacetState)(false);
  return /*#__PURE__*/react.createElement(SetDisablePointer.Provider, {
    value: setDisabled
  }, children, /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(disabled => disabled ? PointerBlocker.blockPointer : '', [], [disabled])
  }));
}
;// CONCATENATED MODULE: ./packages/react-dnd/src/Provider.tsx




const DRAG_Z_INDEX = 4;
const DragAndDropProviderApi = (0,react.createContext)(null);
const useDragAndDropProviderApi = () => (0,react.useContext)(DragAndDropProviderApi);
const DragAndDropIsDragging = (0,react.createContext)(null);
const DraggableStatesFacetProvider = (0,react.createContext)(null);
const useDraggableStatesFacet = () => (0,react.useContext)(DraggableStatesFacetProvider);
const DroppableStatesFacetProvider = (0,react.createContext)(null);
const useDroppableStatesFacet = () => (0,react.useContext)(DroppableStatesFacetProvider);
function DragAndDropProvider({
  children
}) {
  const isPointerMouse = useIsPointerInputMouse();
  const draggableStatesFacet = (0,react.useMemo)(() => (0,react_facet_src.createFacet)({
    initialValue: {}
  }), []);
  const droppableStatesFacet = (0,react.useMemo)(() => (0,react_facet_src.createFacet)({
    initialValue: {}
  }), []);
  const isUserDragging = (0,react_facet_src.useFacetMap)(draggableStates => findDragged(draggableStates) != null, [], [draggableStatesFacet]); // When the user drags, we want to disable mouse hover events

  const setDisablePointerHoverEvents = useSetDisablePointerHoverEvents();
  (0,react_facet_src.useFacetEffect)(setDisablePointerHoverEvents, [setDisablePointerHoverEvents], [isUserDragging]);
  const focusDragMove = (0,react_facet_src.useFacetCallback)((draggableStates, droppableStates) => direction => {
    const draggedState = findDragged(draggableStates);
    if (draggedState == null || draggedState.dragging != 'gamepad') return; // Update the dragging element's transform so it snaps to the next droppable position

    draggableStatesFacet.setWithCallback(draggableStates => {
      const dirVal = direction === 'up' ? -1 : direction === 'down' ? 1 : 0;
      const newDragIndex = draggedState.gamepadHoverIndex + dirVal;
      const draggedDroppable = findDroppableByIndex(droppableStates, draggedState.index);

      for (const id in droppableStates) {
        const dropState = droppableStates[id];

        if (dropState.index === newDragIndex) {
          var _dropState$ref$curren;

          const dropBounds = (_dropState$ref$curren = dropState.ref.current) === null || _dropState$ref$curren === void 0 ? void 0 : _dropState$ref$curren.getBoundingClientRect();

          if (draggedState.startX == null || draggedState.startY == null) {
            var _draggedDroppable$ref;

            const dragBounds = draggedDroppable === null || draggedDroppable === void 0 ? void 0 : (_draggedDroppable$ref = draggedDroppable.ref.current) === null || _draggedDroppable$ref === void 0 ? void 0 : _draggedDroppable$ref.getBoundingClientRect();

            if (dragBounds != null) {
              var _dragBounds$left, _dragBounds$top;

              draggedState.startX = (_dragBounds$left = dragBounds.left) !== null && _dragBounds$left !== void 0 ? _dragBounds$left : 0;
              draggedState.startY = (_dragBounds$top = dragBounds.top) !== null && _dragBounds$top !== void 0 ? _dragBounds$top : 0;
            }
          }

          if (dropBounds == null) break;
          const snapBackToOrigin = newDragIndex === draggedState.index;
          draggedState.gamepadHoverIndex = newDragIndex;

          if (snapBackToOrigin) {
            draggedState.transform = `translate(0, 0)`;
          } else {
            draggedState.transform = `translate(${dropBounds.left - draggedState.startX + draggedState.gamepadDragXOffsetPx}px, ${dropBounds.top - draggedState.startY + draggedState.gamepadDragYOffsetPx}px)`;
          }

          break;
        }
      }

      return draggableStates;
    });
    droppableStatesFacet.setWithCallback(droppableStates => {
      if (droppableStates != react_facet_src.NO_VALUE) {
        for (const id in droppableStates) {
          const state = droppableStates[id];
          const moveUp = draggedState.index < state.index && draggedState.gamepadHoverIndex >= state.index;
          const moveDown = draggedState.index > state.index && draggedState.gamepadHoverIndex <= state.index;
          state.displacement = moveUp ? -1 : moveDown ? 1 : 0;
          state.hovering = draggedState.gamepadHoverIndex === state.index;
        }
      }

      return droppableStates;
    });
  }, [draggableStatesFacet, droppableStatesFacet], [draggableStatesFacet, droppableStatesFacet]);
  const pointerMoveHandler = (0,react_facet_src.useFacetCallback)((draggableStates, droppableStates, isPointerMouse) => event => {
    const draggedState = findDragged(draggableStates); // Fix touch bug on browser when triggering right click

    if (!isPointerMouse && event.touches == null) {
      return;
    }

    const {
      clientX,
      clientY
    } = isPointerMouse ? event : event.touches[0];
    const closestDroppableState = findClosestDroppable(clientX, clientY, droppableStates);
    if (draggedState == null) return; // Update the dragging element's transform so it follows the pointer/finger

    draggableStatesFacet.setWithCallback(draggableStates => {
      if (draggedState.startX != null && draggedState.startY != null) {
        var _closestDroppableStat;

        const x = draggedState.pointerAxisLock === 'y' ? 0 : clientX - draggedState.startX;
        const y = draggedState.pointerAxisLock === 'x' ? 0 : clientY - draggedState.startY;
        draggedState.transform = `translate(${x}px, ${y}px)`;
        draggedState.pointerHoverIndex = (_closestDroppableStat = closestDroppableState === null || closestDroppableState === void 0 ? void 0 : closestDroppableState.index) !== null && _closestDroppableStat !== void 0 ? _closestDroppableStat : draggedState.index; // Set a flag when the user has dragged the draggable beyond the
        // initial drag start area for the first time. Can be useful for
        // triggering initial drag

        if (draggedState.pointerHoverIndex !== (draggedState === null || draggedState === void 0 ? void 0 : draggedState.index)) {
          draggedState.hasDraggedPointerBeyondStartArea = true;
        }
      }

      return draggableStates;
    }); // Update the displacement and hovering values of all droppables

    droppableStatesFacet.setWithCallback(droppableStates => {
      if (closestDroppableState != null && droppableStates != react_facet_src.NO_VALUE) {
        for (const id in droppableStates) {
          const state = droppableStates[id];
          const moveUp = draggedState.index < state.index && closestDroppableState.index >= state.index;
          const moveDown = draggedState.index > state.index && closestDroppableState.index <= state.index;
          state.displacement = moveUp ? -1 : moveDown ? 1 : 0;
          state.hovering = false;
        }

        closestDroppableState.hovering = true;
      }

      return droppableStates;
    });
  }, [draggableStatesFacet, droppableStatesFacet], [draggableStatesFacet, droppableStatesFacet, isPointerMouse]);
  /**
   * Register the mouseup and mousemove listener
   */

  (0,react.useEffect)(() => {
    const mouseUpHandler = () => {
      window.removeEventListener('mousemove', pointerMoveHandler);
      window.removeEventListener('touchmove', pointerMoveHandler);
      let dragData;
      draggableStatesFacet.setWithCallback(draggableStates => {
        if (draggableStates != react_facet_src.NO_VALUE) {
          for (const id in draggableStates) {
            const state = draggableStates[id];

            if (state.dragging != false) {
              dragData = state.data;
            }

            state.hasDraggedPointerBeyondStartArea = false;
            state.dragging = false;
            state.transform = '';
            state.zIndex = '';
            state.startX = null;
            state.startY = null;
          }
        }

        return draggableStates;
      });
      droppableStatesFacet.setWithCallback(droppableStates => {
        if (droppableStates != react_facet_src.NO_VALUE) {
          for (const id in droppableStates) {
            const state = droppableStates[id];

            if (state.hovering === true) {
              state.onDrop(dragData, state.data);
            }

            state.displacement = null;
            state.hovering = false;
          }
        }

        return droppableStates;
      });
    };

    window.addEventListener('mouseup', mouseUpHandler);
    window.addEventListener('touchend', mouseUpHandler);
    return () => {
      window.removeEventListener('mouseup', mouseUpHandler);
      window.removeEventListener('touchend', mouseUpHandler);
    };
  }, [pointerMoveHandler, draggableStatesFacet, droppableStatesFacet]);
  const vrPlatform = useVRPlatform();
  const api = (0,react.useMemo)(() => ({
    addDraggable: options => {
      if (options.id == null) return;
      draggableStatesFacet.setWithCallback(draggableStates => {
        if (draggableStates != react_facet_src.NO_VALUE) {
          var _options$gamepadDragX, _options$gamepadDragY;

          draggableStates[options.id] = {
            id: options.id,
            gamepadHoverIndex: options.index,
            pointerHoverIndex: options.index,
            hasDraggedPointerBeyondStartArea: false,
            ref: options.ref,
            data: options.data,
            index: options.index,
            dragging: false,
            transform: '',
            zIndex: '',
            startX: null,
            startY: null,
            pointerAxisLock: options.pointerAxisLock,
            gamepadDragXOffsetPx: (_options$gamepadDragX = options.gamepadDragXOffsetPx) !== null && _options$gamepadDragX !== void 0 ? _options$gamepadDragX : 0,
            gamepadDragYOffsetPx: (_options$gamepadDragY = options.gamepadDragYOffsetPx) !== null && _options$gamepadDragY !== void 0 ? _options$gamepadDragY : 0
          };
        }

        return draggableStates;
      });
    },
    removeDraggable: id => {
      if (!id) return;
      draggableStatesFacet.setWithCallback(draggableStates => {
        if (draggableStates != react_facet_src.NO_VALUE) {
          delete draggableStates[id];
        }

        return draggableStates;
      });
    },
    addDroppable: options => {
      if (options.id == null) return; // This function gets recursively called until the element
      // is rendered (and getBoundingClientRect returns a value)

      function registerDroppable(options) {
        var _options$ref$current;

        const bounds = (_options$ref$current = options.ref.current) === null || _options$ref$current === void 0 ? void 0 : _options$ref$current.getBoundingClientRect(); // If we can't get the element bounds this frame, wait and try again

        if (bounds == null || bounds.width === 0 && bounds.height === 0) {
          requestAnimationFrame(() => registerDroppable(options));
          return;
        } // Wait an extra frame - TODO: Is this raf needed?


        requestAnimationFrame(() => {
          // Now that we have the element bounds, register it as a droppable zone
          droppableStatesFacet.setWithCallback(droppableStates => {
            if (bounds == null || droppableStates == react_facet_src.NO_VALUE) {
              return droppableStates;
            }

            droppableStates[options.id] = {
              data: options.data,
              index: options.index,
              hovering: false,
              centerX: bounds.left + bounds.width / 2,
              centerY: bounds.top + bounds.height / 2,
              left: bounds.left,
              top: bounds.top,
              displacement: null,
              ref: options.ref,
              onDrop: options.onDrop
            };
            return droppableStates;
          });
        });
      }

      registerDroppable(options);
    },
    removeDroppable: id => {
      droppableStatesFacet.setWithCallback(droppableStates => {
        if (droppableStates != react_facet_src.NO_VALUE) {
          delete droppableStates[id];
        }

        return droppableStates;
      });
    },
    pointerDragStart: (id, x, y) => {
      window.addEventListener('mousemove', pointerMoveHandler);
      window.addEventListener('touchmove', pointerMoveHandler); // When pointer dragging starts, we store the
      // boundaries for all the droppable areas.

      droppableStatesFacet.setWithCallback(droppableStates => {
        if (droppableStates != react_facet_src.NO_VALUE) {
          var _droppableStates$id;

          // If the user drops the item instantly we will still narrate the position.
          if (((_droppableStates$id = droppableStates[id]) === null || _droppableStates$id === void 0 ? void 0 : _droppableStates$id.hovering) != null) {
            droppableStates[id].hovering = true;
          }

          for (const id in droppableStates) {
            var _state$ref$current;

            if (droppableStates == null) break;
            const state = droppableStates[id];
            const bounds = (_state$ref$current = state.ref.current) === null || _state$ref$current === void 0 ? void 0 : _state$ref$current.getBoundingClientRect();
            if (bounds == null) continue;
            state.centerX = bounds.left + bounds.width / 2;
            state.centerY = bounds.top + bounds.height / 2;
            state.left = bounds.left;
            state.top = bounds.top;
            state.displacement = 0;
          }
        }

        return droppableStates;
      });
      draggableStatesFacet.setWithCallback(draggableStates => {
        if (draggableStates != react_facet_src.NO_VALUE) {
          draggableStates[id].dragging = 'pointer';
          const ref = draggableStates[id].ref.current; // We calculate an initial offset to handle if the dragged element
          // is moved due to a layout change when dragging starts.

          const bounds = ref === null || ref === void 0 ? void 0 : ref.getBoundingClientRect();
          if (bounds == null) return draggableStates;
          const axisLock = draggableStates[id].pointerAxisLock;
          const xDist = axisLock === 'y' ? 0 : x - bounds.left;
          const yDist = axisLock === 'x' ? 0 : y - bounds.top; // This will be true if a layout change caused the element to from from outside the cursor

          const clickInitializedOutOfBounds = yDist > bounds.height || xDist > bounds.width;

          if (clickInitializedOutOfBounds) {
            draggableStates[id].transform = `translate(${xDist}px, ${yDist}px)`;
          } else {
            draggableStates[id].transform = `translate(0, 0)`;
          }

          draggableStates[id].zIndex = DRAG_Z_INDEX;
          draggableStates[id].startX = clickInitializedOutOfBounds ? x - xDist : x;
          draggableStates[id].startY = clickInitializedOutOfBounds ? y - yDist : y;
        }

        return draggableStates;
      });
    },
    focusDragStop: () => {
      const draggables = draggableStatesFacet.get();

      if (draggables != react_facet_src.NO_VALUE) {
        const dragged = findDragged(draggables);

        if ((dragged === null || dragged === void 0 ? void 0 : dragged.dragging) === 'gamepad') {
          api.focusDragToggle(dragged.id);
        }
      }
    },

    /**
     * Toggles the dragging state of a given focusable.
     * Used for focus interactions (eg. gamepad, keyboard)
     *
     * @param id The id of the target draggable
     */
    focusDragToggle: id => {
      draggableStatesFacet.setWithCallback(draggableStates => {
        if (draggableStates != react_facet_src.NO_VALUE) {
          const state = draggableStates[id]; // Stop dragging if we're already dragging

          if (state.dragging != false) {
            window.removeEventListener('mousemove', api.focusDragStop);
            window.removeEventListener('touchstart', api.focusDragStop);
            state.dragging = false;
            state.zIndex = '';
            state.transform = '';
            state.gamepadHoverIndex = state.index; // Loop through each droppable and reset their states.

            droppableStatesFacet.setWithCallback(droppableStates => {
              if (droppableStates != react_facet_src.NO_VALUE) {
                for (const id in droppableStates) {
                  const dropState = droppableStates[id]; // If this droppable was also currently being hovered by the
                  // dragged item, then call the onDrop handler for that droppable.

                  if (dropState.hovering === true) {
                    dropState.onDrop(state.data, dropState.data);
                  }

                  dropState.displacement = null;
                  dropState.hovering = false;
                }
              }

              return droppableStates;
            });
          } // Start dragging
          else {
              if (vrPlatform.get() === ARVRPlatform.ARVR_None) {
                window.addEventListener('mousemove', api.focusDragStop);
                window.addEventListener('touchstart', api.focusDragStop);
              }

              state.dragging = 'gamepad';
              state.zIndex = DRAG_Z_INDEX; // Set the displacement of all droppables to 0

              droppableStatesFacet.setWithCallback(droppableStates => {
                if (droppableStates != react_facet_src.NO_VALUE) {
                  var _droppableStates$id2;

                  // If the user drops the item instantly we will still narrate the position.
                  if (((_droppableStates$id2 = droppableStates[id]) === null || _droppableStates$id2 === void 0 ? void 0 : _droppableStates$id2.hovering) != null) {
                    droppableStates[id].hovering = true;
                  }

                  for (const id in droppableStates) {
                    const state = droppableStates[id];
                    state.displacement = 0;
                  }
                }

                return droppableStates;
              });
            }
        }

        return draggableStates;
      });
    },
    focusDragMove
  }), [pointerMoveHandler, focusDragMove, draggableStatesFacet, droppableStatesFacet, vrPlatform]);
  return /*#__PURE__*/react.createElement(DragAndDropProviderApi.Provider, {
    value: api
  }, /*#__PURE__*/react.createElement(DroppableStatesFacetProvider.Provider, {
    value: droppableStatesFacet
  }, /*#__PURE__*/react.createElement(DraggableStatesFacetProvider.Provider, {
    value: draggableStatesFacet
  }, /*#__PURE__*/react.createElement(DragAndDropIsDragging.Provider, {
    value: isUserDragging
  }, children))));
}
/**
 * Finds the dragged item in a DraggablesStateMap
 */

function findDragged(draggableStates) {
  for (const id in draggableStates) {
    const state = draggableStates[id];
    if (state.dragging === false) continue;
    return draggableStates[id];
  }
}
/**
 * Finds the closest droppable to an x/y position in a given DroppablesStateMap
 */

function findClosestDroppable(x, y, droppableStates) {
  if (droppableStates == null) return null;
  let closestDroppable = null;
  let closestDistance = null;

  for (const id in droppableStates) {
    const state = droppableStates[id];

    if (state.centerX == null || state.centerY == null) {
      continue;
    }

    const distance = Math.hypot(x - state.centerX, y - state.centerY);

    if (closestDistance == null || distance < closestDistance) {
      closestDistance = distance;
      closestDroppable = state;
    }
  }

  return closestDroppable;
}
function findDroppableByIndex(droppableStates, index) {
  if (droppableStates == null) return null;

  for (const id in droppableStates) {
    const state = droppableStates[id];
    if (state.index === index) return state;
  }
}
;// CONCATENATED MODULE: ./packages/react-dnd/src/useIsUserDragging.ts


const useIsUserDragging = () => (0,react.useContext)(DragAndDropIsDragging);
;// CONCATENATED MODULE: ./packages/ui/src/Form/Form.tsx




function Form({
  gamepadIndex,
  children,
  role = 'neutral'
}) {
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(semanticClassNames.background.base, semanticClassNames.text.base)
  }, /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: gamepadIndex
  }, children));
}
;// CONCATENATED MODULE: ./packages/react-narrator/src/serializeNarrationDataAttributes.ts
const serializeNarrationDataAttributes = narrationDataAttributesCollection => {
  let result = '';
  const length = narrationDataAttributesCollection.length;

  for (let index = 0; index < length; index++) {
    const currentItem = narrationDataAttributesCollection[index];

    if (currentItem.before != null) {
      result += ' . ' + currentItem.before;
    }

    if (currentItem.text != null) {
      result += ' . ' + currentItem.text;
    }

    if (currentItem.as != null) {
      result += ' . ' + currentItem.as;
    }

    if (currentItem.after != null) {
      result += ' . ' + currentItem.after;
    }
  }

  return result.slice(3);
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/collectNarrationTextFromChildren.ts
const collectNarrationDataAttributes = node => {
  const nodesToNarrate = node.querySelectorAll('[data-narrate]');
  const nodeAmount = nodesToNarrate.length;
  const result = [];

  for (let index = 0; index < nodeAmount; index++) {
    const currentNode = nodesToNarrate[index];
    const dataNarrate = currentNode.getAttribute('data-narrate');
    const dataNarrateAs = currentNode.getAttribute('data-narrate-as');
    const dataNarrateAfter = currentNode.getAttribute('data-narrate-after');
    const dataNarrateBefore = currentNode.getAttribute('data-narrate-before');
    const narrationDataAttributes = {};

    if (dataNarrate != null && dataNarrate !== '') {
      narrationDataAttributes.text = dataNarrate;
    } else {
      const textContent = currentNode.textContent;

      if (textContent != null) {
        narrationDataAttributes.text = textContent;
      } else {
        if (false) {}
      }
    }

    if (dataNarrateAfter != null && dataNarrateAfter !== '') {
      narrationDataAttributes.after = dataNarrateAfter;
    }

    if (dataNarrateAs != null && dataNarrateAs !== '') {
      narrationDataAttributes.as = dataNarrateAs;
    }

    if (dataNarrateBefore != null && dataNarrateBefore !== '') {
      narrationDataAttributes.before = dataNarrateBefore;
    }

    result.push(narrationDataAttributes);
  }

  return result;
};
;// CONCATENATED MODULE: ./packages/ui/src/Banner/Banner.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Banner = ({"banner":"geCU1","defaultCursor":"HWLBO"});
;// CONCATENATED MODULE: ./packages/ui/src/Banner/bannerContext.tsx

const bannerContext = (0,react.createContext)({});
;// CONCATENATED MODULE: ./packages/ui/src/Link/Link.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Link = ({"link":"iTfr1","withUnderlinePolyfill":"zaq0M","linkBrowserOnly":"UEzHB","withUnderlinePolyfillBrowserOnly":"_d1Tg","underlinePolyfill":"BeCTv","linkFocused":"vLdsX"});
;// CONCATENATED MODULE: ./packages/ui/src/Link/Link.tsx








function Link_Link({
  children,
  gamepadIndex,
  disabled,
  onClick,
  withUnderlinePolyfill,
  soundEffectPressed,
  focusRefOverride,
  __testAlias,
  role = 'inherit'
}) {
  var _rawColors$role, _rawColors$role$text, _rawColors$role$text$;

  const {
    t
  } = useLocalization('Link');
  const {
    color: {
      [role]: semanticClassNames
    },
    rawColors,
    sound: {
      [role]: semanticSound
    }
  } = useSemanticTokens();
  const contextualNarrationText = (0,react_facet_src.useFacetMap)(text => `${text} . ${t('.narrationComponentType')}`, [t], [(0,react_facet_src.useFacetWrap)(children)]);
  const rawTextColor = rawColors === null || rawColors === void 0 ? void 0 : (_rawColors$role = rawColors[role]) === null || _rawColors$role === void 0 ? void 0 : (_rawColors$role$text = _rawColors$role.text) === null || _rawColors$role$text === void 0 ? void 0 : (_rawColors$role$text$ = _rawColors$role$text.regular) === null || _rawColors$role$text$ === void 0 ? void 0 : _rawColors$role$text$.default;
  const linkStyles = (0,react.useMemo)(() => {
    return {
      textDecorationColor: rawTextColor
    };
  }, [rawTextColor]);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    tag: "span",
    className: classnames_default()(Link.link, semanticClassNames.highlight.hover, semanticClassNames.text.base, {
      [Link.linkBrowserOnly]: "gameface" === 'browser',
      [Link.withUnderlinePolyfill]: withUnderlinePolyfill,
      [Link.withUnderlinePolyfillBrowserOnly]: withUnderlinePolyfill && "gameface" === 'browser'
    }),
    gamepadAlias: __testAlias,
    classNameFocused: classnames_default()(focusClass, Link.linkFocused),
    gamepadIndex: gamepadIndex,
    focusRefOverride: focusRefOverride,
    inputLegend: t('.open') // Links are narrated as button to follow the accessibility standard
    ,
    narrationText: contextualNarrationText,
    onClick: onClick,
    disabled: disabled,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.click,
    style: linkStyles
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    role: role,
    disabled: disabled,
    withoutBorders: true
  }), (0,react_facet_src.isFacet)(children) ? /*#__PURE__*/react.createElement("fast-text", {
    text: children
  }) : children, withUnderlinePolyfill && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Link.underlinePolyfill),
    style: {
      borderBottomColor: rawTextColor
    }
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/Banner/BannerLink.tsx





const BannerLink = ({
  children,
  onClick,
  soundEffectPressed,
  gamepadIndex,
  __testAlias
}) => {
  const bannerRef = (0,react.useContext)(bannerContext);
  const {
    sound: {
      inherit: semanticSound
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit"
  }, /*#__PURE__*/react.createElement(Link_Link, {
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.click,
    withUnderlinePolyfill: true,
    onClick: onClick,
    focusRefOverride: bannerRef.ref,
    gamepadIndex: gamepadIndex !== null && gamepadIndex !== void 0 ? gamepadIndex : 0,
    __testAlias: __testAlias
  }, children));
};
;// CONCATENATED MODULE: ./packages/ui/src/Banner/BannerText.tsx


function BannerText({
  children
}) {
  return /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit",
    shouldNarrate: true
  }, children);
}
;// CONCATENATED MODULE: ./packages/ui/src/Banner/Banner.tsx











function Banner_Banner({
  children,
  role,
  gamepadIndex,
  narrationId,
  __testAlias
}) {
  const interactivePrimitiveRef = (0,react.useRef)(null);
  const isNarrationEnabled = useNarrationEnabled();
  const {
    color: {
      [role]: semanticClassNames
    },
    sound: {
      [role]: semanticSound
    }
  } = useSemanticTokens();
  const {
    t
  } = useLocalization('Banner');

  const hasInteractiveLink = children => {
    if (Array.isArray(children)) {
      return children.filter(child => hasInteractiveLink(child)).length > 0;
    }

    if (children != null && typeof children === 'object' && 'type' in children) {
      return children.type === BannerLink;
    }

    return false;
  };

  const getTTSNarration = (0,react.useCallback)(() => {
    if (interactivePrimitiveRef.current == null) return '';
    return serializeNarrationDataAttributes(collectNarrationDataAttributes(interactivePrimitiveRef.current)) + ' . ' + t('.narrationComponentTypeTextBox');
  }, [t]);
  const getContextNarration = (0,react.useCallback)(() => {
    if (interactivePrimitiveRef.current == null) return '';
    return serializeNarrationDataAttributes(collectNarrationDataAttributes(interactivePrimitiveRef.current));
  }, []);
  const bannerContextValue = (0,react.useMemo)(() => {
    return {
      ref: interactivePrimitiveRef
    };
  }, []);
  const builtNarrationId = (0,react.useMemo)(() => `banner.${role}.${narrationId}`, [role, narrationId]);
  const isBannerInteractive = isNarrationEnabled && !hasInteractiveLink(children);
  return /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: isBannerInteractive,
    innerRef: interactivePrimitiveRef,
    gamepadAlias: __testAlias,
    className: classnames_default()(Banner.banner, semanticClassNames.background.base, semanticClassNames.text.base, {
      [Banner.defaultCursor]: isNarrationEnabled && !hasInteractiveLink(children)
    }),
    classNameFocused: focusClass,
    inputLegend: false,
    gamepadIndex: gamepadIndex !== null && gamepadIndex !== void 0 ? gamepadIndex : 0,
    getNarrationText: getTTSNarration,
    narrationId: builtNarrationId,
    soundEffectPressed: semanticSound.click
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    disabled: !isNarrationEnabled,
    withoutBorders: true
  }), /*#__PURE__*/react.createElement(NarrationContext, {
    getText: getContextNarration,
    id: builtNarrationId
  }, /*#__PURE__*/react.createElement(bannerContext.Provider, {
    value: bannerContextValue
  }, isBannerInteractive && /*#__PURE__*/react.createElement(Focus_Focus, {
    inset: true
  }), children))));
}
Banner_Banner.displayName = 'Banner';
Banner_Banner.Text = BannerText;
Banner_Banner.Link = BannerLink;
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Notifications/MulitplayerWarnings.ts



function isNintendoPlatform(platform) {
  return platform === Platform.NX_HANDHELD || platform === Platform.NX_TV;
}

function isPlaystationPlatform(platform) {
  return platform === Platform.PS4;
}

function getWarningMessage(warningState, platform, t) {
  // Same on all platforms
  if (warningState === GeneralMultiplayerWarningStateEnum.CHECK_INTERNET_CONNECTION) {
    return t('.multiplayerWarnings.checkInternetConnection');
  } // Separate message for Playstation and Nintendo, N/A for other


  if (warningState === GeneralMultiplayerWarningStateEnum.DISCONNECTED_THIRD_PARTY_WITH_SUBSCRIPTION) {
    if (isPlaystationPlatform(platform)) return t('.multiplayerWarnings.playstationDisconnectedThirdPartyWithSubscription');
    if (isNintendoPlatform(platform)) return t('.multiplayerWarnings.nintendoDisconnectedThirdPartyWithSubscription');
  } // Separate message for Nintendo, N/A for other


  if (warningState === GeneralMultiplayerWarningStateEnum.LOCAL_MULTIPLAYER_PRIVILEGES_BLOCKED_THIRD_PARTY) {
    return t('.multiplayerWarnings.nintendoLocalMultiplayerPrivilegesBlockedThirdParty');
  } // Separate message for Playstation and Nintendo, N/A for other


  if (warningState === GeneralMultiplayerWarningStateEnum.MULTIPLAYER_PRIVILEGES_BLOCKED_THIRD_PARTY) {
    if (isPlaystationPlatform(platform)) return t('.multiplayerWarnings.playstationMultiplayerPrivilegesBlockedThirdParty');
    if (isNintendoPlatform(platform)) return t('.multiplayerWarnings.nintendoMultiplayerPrivilegesBlockedThirdParty');
  } // Same on all platforms


  if (warningState === GeneralMultiplayerWarningStateEnum.MULTIPLAYER_PRIVILEGES_BLOCKED) {
    return t('.multiplayerWarnings.multiplayerPrivilegesBlocked');
  } // Same on all platforms


  if (warningState === GeneralMultiplayerWarningStateEnum.MULTIPLAYER_PRIVILEGES_BLOCKED_ON_CONSOLE) {
    return t('.multiplayerWarnings.multiplayerPrivilegesBlockedOnConsole');
  } // Separate message for Playstation, N/A for other


  if (warningState === GeneralMultiplayerWarningStateEnum.CROSS_PLATFORM_DISABLED) {
    return t('.multiplayerWarnings.playstationCrossPlatformDisabled');
  }

  if (warningState === GeneralMultiplayerWarningStateEnum.NON_MULTIPLAYER_SKIN_EQUIPPED) {
    return t('.multiplayerWarnings.nonMultiplayerSkinEquipped');
  }

  return '';
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Notifications/images/achievement-bottle.png
const achievement_bottle_namespaceObject = __webpack_require__.p + "assets/achievement-bottle-1487f.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Notifications/Notifications.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Notifications = ({"notificationBottle":"TBzZf","notifications":"eegnV","panelContent":"Wb7RU"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useAchievementsDisabledMessages.tsx




function checkIfMessagesChanged() {
  let previousValue = null;
  return function (nextValue) {
    if (!previousValue) {
      previousValue = nextValue;
      return false;
    }

    if (nextValue.length !== previousValue.length) {
      previousValue = nextValue;
      return false;
    }

    for (const message of nextValue) {
      if (!previousValue.includes(message)) {
        previousValue = nextValue;
        return false;
      }
    }

    return true;
  };
}

function useAchievementsDisabledMessages() {
  const {
    t
  } = useLocalization('CreateNewWorld.achievementsDisabledMessages');
  const achievementsDisabledMessages = (0,react_facet_src.useFacetMemo)((general, advanced, cheats, multiplayer, experiments, behaviorPacks) => {
    const settingMessage = [];

    if (general.gameMode === types_GameMode.CREATIVE) {
      settingMessage.push(t('.creativeMode'));
    }

    if (advanced.useFlatWorld) {
      settingMessage.push(t('.flatWorld'));
    }

    if (cheats.cheatsEnabled) {
      settingMessage.push(t('.cheatsEnabled'));
    }

    if (multiplayer.playerPermissions === createNewWorldFacet_PlayerPermissions.OPERATOR) {
      settingMessage.push(t('.operator'));
    }

    if (experiments) {
      settingMessage.push(t('.experiments'));
    }

    if (behaviorPacks) {
      settingMessage.push(t('.behaviorPacks'));
    }

    return settingMessage;
  }, [t], [(0,react_facet_src.useSharedFacet)(generalSettingsSelector), (0,react_facet_src.useSharedFacet)(advancedSettingsSelector), (0,react_facet_src.useSharedFacet)(cheatsSettingsSelector), (0,react_facet_src.useSharedFacet)(multiplayerSelector), (0,react_facet_src.useSharedFacet)(betaFeaturesEnabledSelector), (0,react_facet_src.useSharedFacet)(behaviorPacksEnabledSelector)], checkIfMessagesChanged);
  return achievementsDisabledMessages;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/AchievementsDisabledModal/AchievementsDisabledModal.tsx







const CLOSE_BUTTON_GAMEPAD_ALIAS = 'achievements-disabled-back';
const AchievementsDisabledModal = registerModal(() => {
  const {
    t
  } = useLocalization('AchievementDisabledModal');
  const hideModal = useHideModal(); // Determine which achievement tooltip message to show based on all relevant settings

  const achievementsDisabledMessages = useAchievementsDisabledMessages(); // If more than one setting has affected achievements, a different message should be shown to reflect this

  const achievementsDisabledMessageTranslation = (0,react_facet_src.useFacetMap)(achievementsDisabledMessage => achievementsDisabledMessage.length === 1 ? t('.oneSettingMessage') : t('.multipleSettingsMessage'), [t], [achievementsDisabledMessages]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: achievementsDisabledMessageTranslation,
    gamepadIndex: 0
  }, achievementsDisabledMessageTranslation), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: achievementsDisabledMessages,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: "achievements-disabled-back",
    inputLegend: t('.closeInputLegend'),
    variant: "secondary",
    onClick: hideModal
  }, t('.goBackButtonText'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/AchievementsDisabledModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/CreateOnRealmsErrorModal/CreateOnRealmsErrorModal.tsx






const CreateOnRealmsErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS = 'create-on-realms-error-back';
const CreateOnRealmsErrorModal = registerModal(() => {
  const {
    t
  } = useLocalization('CreateNewWorld');
  const world = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const onClose = (0,react_facet_src.useFacetCallback)(world => () => {
    // acknowledge error handled by setting it to null again
    world.createOnRealms.error = null;
  }, [], [world]);
  const prefix = (0,react_facet_src.useFacetMap)(world => {
    switch (world.createOnRealms.error) {
      case CreateOnRealmsError.UNASSIGNED_DEV_VERSION:
        return '.createOnRealmsError.unassignedDevVersion';

      case CreateOnRealmsError.MEMBER_OF_TOO_MANY_REALMS:
        return '.createOnRealmsError.memberOfTooManyRealms';

      case CreateOnRealmsError.CANNOT_CONNECT_TO_REALM:
        return '.createOnRealmsError.cannotConnectToRealm';

      case CreateOnRealmsError.UNKNOWN:
      default:
        return '.createOnRealmsError.unknown';
    }
  }, [], [world]);
  const title = (0,react_facet_src.useFacetMap)(prefix => t(`${prefix}.title`), [t], [prefix]);
  const message = (0,react_facet_src.useFacetMap)(prefix => t(`${prefix}.message`), [t], [prefix]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CreateOnRealmsErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: message,
    center: true
  }, message)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CreateOnRealmsErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.createOnRealmsError.close'),
    variant: "secondary",
    onClick: onClose
  }, t('.createOnRealmsError.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/CreateOnRealmsErrorModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/CreateWorldErrorModal/CreateWorldErrorModal.tsx






const CreateWorldErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS = 'create-world-error-back';
const CreateWorldErrorModal = registerModal(function () {
  const {
    t
  } = useLocalization('CreateNewWorld');
  const createWorld = (0,react_facet_src.useFacetMap)(facet => facet.createWorld, [], [(0,react_facet_src.useSharedFacet)(createNewWorldFacet)]);
  const onClose = (0,react_facet_src.useFacetCallback)(createWorld => () => {
    // acknowledge error handled by setting it to null again
    createWorld.error = null;
  }, [], [createWorld]);
  const title = t(`.createWorldError.notEnoughStorage.title`);
  const message = t(`.createWorldError.notEnoughStorage.message`);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CreateWorldErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: message,
    center: true
  }, message), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CreateWorldErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.createWorldError.close'),
    variant: "secondary",
    onClick: onClose
  }, t('.createWorldError.close')))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/CreateWorldErrorModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/OptBackModal/OptBackModal.tsx





const STAY_BUTTON_GAMEPAD_ALIAS = 'stay-button-alias';
const OptBackModal = registerModal(({
  optOutCallback
}) => {
  const {
    t
  } = useLocalization('CreateNewWorld.optBackModal');
  const hideModal = useHideModal();

  const optOut = () => {
    hideModal();
    optOutCallback();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: STAY_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.message'),
    gamepadIndex: 0,
    center: true
  }, t('.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: STAY_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.stayInputLegend'),
    variant: "primary",
    onClick: hideModal
  }, t('.stayButton')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.goBackInputLegend'),
    variant: "secondary",
    onClick: optOut,
    gamepadIndex: 1
  }, t('.goBackButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/OptBackModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/LeavingCNWForMarketplaceModal/LeavingCNWForMarketplaceModal.tsx






const LeavingCNWForMarketplaceModalContext = (0,react_facet_src.createFacetContext)({
  isVisible: false,
  packId: '',
  show: () => {},
  close: () => {}
});
const useLeavingCNWForMarketplaceModalContext = () => (0,react.useContext)(LeavingCNWForMarketplaceModalContext);
const LeavingCNWForMarketplaceModalProvider = ({
  children
}) => {
  return /*#__PURE__*/react.createElement(LeavingCNWForMarketplaceModalContext.Provider, {
    value: useInitialModalContextValue()
  }, children);
};

function useInitialModalContextValue() {
  const [isVisible, setIsVisible] = (0,react_facet_src.useFacetState)(false);
  const [packId, setPackId] = (0,react_facet_src.useFacetState)('');
  const showModal = (0,react_facet_src.useFacetCallback)(() => packId => {
    setIsVisible(true);
    setPackId(packId);
  }, [setIsVisible, setPackId], []);
  const closeModal = (0,react_facet_src.useFacetCallback)(() => () => {
    setIsVisible(false);
    setPackId('');
  }, [setIsVisible, setPackId], []);
  return (0,react_facet_src.useFacetMap)((isVisible, packId) => {
    return {
      isVisible: isVisible,
      packId: packId,
      show: showModal,
      close: closeModal
    };
  }, [showModal, closeModal], [isVisible, packId]);
}

const CONTINUE_BUTTON_GAMEPAD_ALIAS = 'leaving-cnw-for-marketplace-modal-continue'; // the packId usually contains extra version information appended
// to the id e.g `ee4fdd53-d555-4618-b450-2a064d75b156_1.0.38`.
// We cut off the extra version info from the end of the string

const UUID_LENGTH = 36;

function marketPlacePackRouteFromPackId(contentId) {
  return `/marketplace?packId=${contentId.substring(0, UUID_LENGTH)}`;
}

const LeavingCNWForMarketplaceModal = () => {
  const {
    t
  } = useLocalization('CreateNewWorld.leavingCNWForMarketplaceModal');
  const historyAPI = RouteHistory_useRouteHistory();
  const modalContext = useLeavingCNWForMarketplaceModalContext();
  const isVisible = (0,react_facet_src.useFacetMap)(modalContext => modalContext.isVisible, [], [modalContext]);
  const packId = (0,react_facet_src.useFacetMap)(modalContext => modalContext.packId, [], [modalContext]);
  const closeModal = (0,react_facet_src.useFacetCallback)(modalContext => () => modalContext.close(), [], [modalContext]);
  const onMarketPlaceClick = (0,react_facet_src.useFacetCallback)(packId => () => {
    historyAPI.push(marketPlacePackRouteFromPackId(packId));
    closeModal();
  }, [historyAPI, closeModal], [packId]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isVisible
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Overlay, {
    onClick: closeModal
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CONTINUE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.message'),
    gamepadIndex: 0,
    center: true
  }, t('.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.cancel'),
    variant: "primary",
    onClick: closeModal
  }, t('.cancel')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: CONTINUE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.continue'),
    variant: "secondary",
    onClick: () => {
      onMarketPlaceClick();
      closeModal();
    }
  }, t('.continue'))))));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/LeavingCNWForMarketplaceModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/LoseYourChangesModal/LoseYourChangesModal.tsx





const LoseYourChangesModal_CONTINUE_BUTTON_GAMEPAD_ALIAS = 'lyc-modal-continue';
const LoseYourChangesModal = registerModal(({
  onLeave
}) => {
  const {
    t
  } = useLocalization('CreateNewWorld.loseYourChangesModal');
  const closeModal = useHideModal();
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: LoseYourChangesModal_CONTINUE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.message'),
    gamepadIndex: 0,
    center: true
  }, t('.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: LoseYourChangesModal_CONTINUE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.continueInputLegend'),
    variant: "secondary",
    onClick: closeModal
  }, t('.continueButton')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.leaveInputLegend'),
    variant: "destructive",
    onClick: () => {
      closeModal();
      onLeave();
    }
  }, t('.leaveButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/SavingWorldModal/SavingWorldModal.tsx




const SavingWorldModal = registerModal(() => {
  const {
    t
  } = useLocalization('CreateNewWorld.savingWorldModal');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.header')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Spinner, null)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/EditWorldErrorModal/EditWorldErrorModal.tsx







const EDIT_WORLD_ERROR_CONTINUE = 'lyc-modal-continue';
const EditWorldErrorModal = registerModal(() => {
  const historyAPI = RouteHistory_useRouteHistory();
  const {
    t
  } = useLocalization('CreateNewWorld.editWorldErrorModal');
  const editWorldSharedFacet = (0,react_facet_src.useSharedFacet)(editWorldFacet);
  const readError = (0,react_facet_src.useFacetMap)(facet => {
    return facet.loadWorld.result;
  }, [], [editWorldSharedFacet]);
  const writeError = (0,react_facet_src.useFacetMap)(facet => {
    return facet.duplicateWorld.result || facet.saveLocalWorld.result;
  }, [], [editWorldSharedFacet]);
  const showModal = (0,react_facet_src.useFacetMap)((readError, writeError) => readError != null || writeError != null, [], [readError, writeError]);
  const errorType = (0,react_facet_src.useFacetMap)((readError, writeError, showModal) => {
    if (!showModal) {
      return null;
    }

    switch (readError) {
      case ReadWorldError.IncorrectWorldId:
      case ReadWorldError.UnexpectedError:
        return 'unexpected';
    }

    switch (writeError) {
      case WriteWorldError.IncorrectWorldId:
      case WriteWorldError.UnableToCreateWorldDirectoryPath:
        return 'unexpected';

      case WriteWorldError.InsufficientDiskSpace:
        return 'storage';
    }
  }, [], [readError, writeError, showModal]);
  const errorMessageTitle = (0,react_facet_src.useFacetMap)(facet => {
    return facet === 'storage' ? t('.storageError.title') : t('.unexpectedError.title');
  }, [t], [errorType]);
  const errorMessageDescription = (0,react_facet_src.useFacetMap)(facet => {
    return facet === 'storage' ? t('.storageError.description') : t('.unexpectedError.description');
  }, [t], [errorType]);
  const editWorldErrorModalClose = (0,react_facet_src.useFacetCallback)(facet => () => {
    if (facet.loadWorld.result != null) {
      facet.loadWorld.clear();
      historyAPI.goBack();
    } else if (facet.duplicateWorld.result != null) {
      facet.duplicateWorld.clear();
    } else if (facet.saveLocalWorld.result != null) {
      facet.saveLocalWorld.clear();
    }
  }, [historyAPI], [editWorldSharedFacet]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: editWorldErrorModalClose,
    defaultFocusAlias: EDIT_WORLD_ERROR_CONTINUE
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: editWorldErrorModalClose
  }, errorMessageTitle), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: errorMessageDescription,
    gamepadIndex: 0,
    center: true
  }, errorMessageDescription)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: EDIT_WORLD_ERROR_CONTINUE,
    inputLegend: t('.closeButton'),
    variant: "secondary",
    onClick: editWorldErrorModalClose
  }, t('.closeButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/hooks/useWorldID.ts
 // grabs and decodes the world ID from the route URL

function useWorldID() {
  const {
    id: worldID
  } = useRouteParams();
  return worldID != null ? decodeURIComponent(worldID) : null;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/DeleteWorldModal/DeleteWorldModal.tsx









const DELETE_WORLD_CONTINUE = 'lyc-modal-continue';
const DeleteWorldModal = registerModal(() => {
  const {
    t
  } = useLocalization('CreateNewWorld.deleteWorldModal');
  const historyAPI = RouteHistory_useRouteHistory();
  const editWorldSharedFacet = (0,react_facet_src.useSharedFacet)(editWorldFacet);
  const worldId = useWorldID();
  const closeModal = useHideModal();
  const deleteWorldCallback = (0,react_facet_src.useFacetCallback)(editWorldSharedFacet => () => {
    if (worldId != null) editWorldSharedFacet.deleteWorld(worldId);
    historyAPI.goBack();
  }, [worldId, historyAPI], [editWorldSharedFacet]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: closeModal,
    defaultFocusAlias: DELETE_WORLD_CONTINUE
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.message'),
    gamepadIndex: 0
  }, t('.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: DELETE_WORLD_CONTINUE,
    inputLegend: t('.continueInputLegend'),
    variant: "secondary",
    onClick: closeModal
  }, t('.continueButton')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.deleteInputLegend'),
    variant: "destructive",
    onClick: deleteWorldCallback
  }, t('.deleteButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/MultiplayerPlatformLockedModal/MultiplayerPlatformLockedModal.tsx








const GO_BACK_BUTTON_GAMEPAD_ALIAS = 'mpl-modal-go-back';
const MultiplayerPlatformLockedModal = registerModal(({
  multiplayerData,
  activePacks,
  onDeactivatePack
}) => {
  const {
    t
  } = useLocalization('CreateNewWorld.multiplayerPlatformLockedModal');
  const hideModal = useHideModal();
  const platformLockedPacks = (0,react_facet_src.useFacetMap)(activePacks => filter(activePacks, pack => pack.isPlatformLocked), [], [activePacks]);
  const titleText = (0,react_facet_src.useFacetMap)(platformLockedPacks => platformLockedPacks.length > 1 ? t('.titlePlural') : t('.titleSingular'), [t], [platformLockedPacks]);
  const messageText = (0,react_facet_src.useFacetMap)(platformLockedPacks => {
    var _platformLockedPacks$, _platformLockedPacks$2;

    return platformLockedPacks.length > 1 ? t('.messagePlural', [slice(platformLockedPacks, 1).map(x => x.name).join(', '), (_platformLockedPacks$ = platformLockedPacks[0]) === null || _platformLockedPacks$ === void 0 ? void 0 : _platformLockedPacks$.name]) : t('.messageSingular', [(_platformLockedPacks$2 = platformLockedPacks[0]) === null || _platformLockedPacks$2 === void 0 ? void 0 : _platformLockedPacks$2.name]);
  }, [t], [platformLockedPacks]);
  const removePackButtonText = (0,react_facet_src.useFacetMap)(platformLockedPacks => platformLockedPacks.length > 1 ? t('.removeButtonPlural') : t('.removeButtonSingular'), [t], [platformLockedPacks]);
  const removePlatformLockedPacksAndActivateMultiplayer = (0,react_facet_src.useFacetCallback)((multiplayerData, platformLockedPacks) => () => {
    hideModal();

    if (onDeactivatePack) {
      platformLockedPacks.forEach(pack => onDeactivatePack(pack.id, PackType.Resource));
    }

    multiplayerData.multiplayerGame = true;
  }, [hideModal, onDeactivatePack], [multiplayerData, platformLockedPacks]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: GO_BACK_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, titleText), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: messageText,
    gamepadIndex: 0
  }, messageText)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.removeInputLegend'),
    variant: "primary",
    onClick: removePlatformLockedPacksAndActivateMultiplayer
  }, removePackButtonText), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: GO_BACK_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.closeInputLegend'),
    variant: "secondary",
    onClick: hideModal
  }, t('.goBackButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/MultiplayerPlatformLockedModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDependenciesErrorModal/ResourcePacksDependenciesErrorModal.tsx





const ResourcePacksDependenciesErrorModal_GO_BACK_BUTTON_GAMEPAD_ALIAS = 'rpl-modal-go-back';
const ResourcePacksDependenciesErrorModal = registerModal(({
  onAccept
}) => {
  const {
    t
  } = useLocalization('CreateNewWorld.resourcePacksDependenciesErrorModal');
  const body = t('.body');
  const activatePackButton = t('.activatePackButton');
  const hideModal = useHideModal();

  const onActivatePackContinue = () => {
    hideModal();
    onAccept();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: ResourcePacksDependenciesErrorModal_GO_BACK_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: body,
    gamepadIndex: 0,
    center: true
  }, body)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: ResourcePacksDependenciesErrorModal_GO_BACK_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.closeInputLegend'),
    variant: "primary",
    onClick: hideModal
  }, t('.goBackButton')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: activatePackButton,
    onClick: onActivatePackContinue
  }, activatePackButton)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDependenciesErrorModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDownloadModal/ResourcePacksDownloadModal.tsx







const ResourcePacksDownloadModal_CLOSE_BUTTON_GAMEPAD_ALIAS = 'rpdl-modal-close';
const CONTENT_GAMEPAD_ALIAS = 'rpdl-modal-content';
const ResourcePacksDownloadModal = registerModal(({
  title,
  percentage,
  isDownloadingPack,
  isImportingPack,
  onCancel = () => {}
}) => {
  const {
    t
  } = useLocalization('CreateNewWorld.packDownloadModal');
  const body = (0,react_facet_src.useFacetMap)(isDownloadingPack => isDownloadingPack ? t('.downloadingProgressLabel') : t('.importingProgressLabel'), [t], [isDownloadingPack]);
  const narrationEnabled = useNarrationEnabled();
  const setFocusedId = src_useSetFocusedId_useSetFocusedId(); // Move focus to the modal content when close button is hidden (if it's focusable)

  (0,react_facet_src.useFacetEffect)(isImportingPack => {
    if (isImportingPack && narrationEnabled) {
      setFocusedId(CONTENT_GAMEPAD_ALIAS);
    }
  }, [setFocusedId, narrationEnabled], [isImportingPack]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: ResourcePacksDownloadModal_CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onCancel,
    closeButtonGamepadAlias: ResourcePacksDownloadModal_CLOSE_BUTTON_GAMEPAD_ALIAS,
    hideCloseButton: isImportingPack
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    gamepadAlias: CONTENT_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: body,
    center: true
  }, body), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Progress, {
    percentage: percentage
  })));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDownloadModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDownloadErrorModal/ResourcePacksDownloadErrorModal.tsx






const CANCEL_BUTTON_GAMEPAD_ALIAS = 'rpdl-modal-cancel';
const ResourcePacksDownloadErrorModal = registerModal(({
  errorCode,
  onClose
}) => {
  const {
    t
  } = useLocalization('CreateNewWorld.resourcePacks');
  const errorTitle = (0,react_facet_src.useFacetMap)(errorCode => errorCode === PackDownloadError.MissingDlcWorldTemplate ? t('.downloadWorldTemplateNoInternetTitle') : errorCode === PackDownloadError.NoInternet ? t('.downloadNoInternetTitle') : errorCode === PackDownloadError.HasPerformanceIssues ? t('.incompatibleTitle') : t('.unspecifiedErrorTitle'), [t], [errorCode]);
  const errorBody = (0,react_facet_src.useFacetMap)(errorCode => errorCode === PackDownloadError.MissingDlcWorldTemplate ? t('.downloadWorldTemplateNoInternetMsg') : errorCode === PackDownloadError.NoInternet ? t('.connectionFailedBody') : errorCode === PackDownloadError.HasPerformanceIssues ? t('.incompatibleBody') : t('.unspecifiedErrorBody'), [t], [errorCode]);
  const errorBodyExtra = (0,react_facet_src.useFacetMap)(errorCode => errorCode === PackDownloadError.MissingDlcWorldTemplate ? t('.downloadWorldTemplateMsgRemovePacks') : '', [t], [errorCode]);
  const isMissingDLC = (0,react_facet_src.useFacetUnwrap)(errorCode) !== PackDownloadError.MissingDlcWorldTemplate;
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CANCEL_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, errorTitle), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: errorBody,
    center: isMissingDLC
  }, errorBody), isMissingDLC && /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 1,
    narrationText: errorBodyExtra,
    center: true
  }, errorBodyExtra)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CANCEL_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.goBackButton'),
    onClick: onClose
  }, t('.goBackButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDownloadErrorModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDownloadConfirmationModal/ResourcePacksDownloadConfirmationModal.tsx






const ACCEPT_BUTTON_GAMEPAD_ALIAS = 'rpdl-modal-accept';
const ResourcePacksDownloadConfirmationModal = registerModal(({
  packId,
  packName,
  packSize,
  availableSize,
  onAccept
}) => {
  const {
    t
  } = useLocalization('CreateNewWorld.packDownloadModal');
  const body = (0,react_facet_src.useFacetMap)(packName => t('.confirmationBody', [packName]), [t], [packName]);
  const bodyPackSize = (0,react_facet_src.useFacetMap)(packSize => t('.confirmationBodyPackSize', [packSize]), [t], [packSize]);
  const bodyAvailableSize = (0,react_facet_src.useFacetMap)(availableSize => t('.confirmationBodyAvailableSize', [availableSize]), [t], [availableSize]);
  const hideModal = useHideModal();
  const onAcceptDownload = (0,react_facet_src.useFacetCallback)(packName => () => {
    onAccept(packId, packName);
    hideModal();
  }, [onAccept, hideModal, packId], [packName]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: ACCEPT_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.confirmationTitle')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: body
  }, body), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${bodyPackSize}. ${bodyAvailableSize}`,
    spaceBetweenParagraphs: 1,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong"
  }, bodyPackSize), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong"
  }, bodyAvailableSize))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: ACCEPT_BUTTON_GAMEPAD_ALIAS,
    gamepadIndex: 0,
    inputLegend: t('.confirmationDownloadButtonInputLegend'),
    onClick: onAcceptDownload,
    variant: "primary"
  }, t('.confirmationDownloadButton')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.confirmationCancelButton'),
    onClick: hideModal,
    gamepadIndex: 1
  }, t('.confirmationCancelButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDownloadConfirmationModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksErrorModal/ResourcePacksErrorModal.tsx





const ResourcePacksErrorModal_CANCEL_BUTTON_GAMEPAD_ALIAS = 'rpdl-modal-cancel'; // This modal handles possible errors while activating/deactivating packs.
// It should not be needed to check if it comes from activate or deactivate because
// they have different and separated error codes.

const ResourcePacksErrorModal = registerModal(({
  errorCode
}) => {
  const {
    t
  } = useLocalization('CreateNewWorld.resourcePacks');
  const hideModal = useHideModal();
  const errorTitle = errorCode === PackActionError.AddDependenciesError ? t('.requiredDependencyTitle') : errorCode === PackActionError.ContentTierIncompatible ? t('.incompatibleTitle') : errorCode === PackActionError.ContentTierIncompatibleMemory ? t('.incompatibleMemoryTitle') : errorCode === PackActionError.ContentTierIncompatibleRayTracing ? t('.incompatibleRayTracingTitle') : t('.unspecifiedErrorTitle');
  const errorBody = errorCode === PackActionError.AddDependenciesError ? t('.requiredDependencyBody') : errorCode === PackActionError.ContentTierIncompatible ? t('.incompatibleBody') : errorCode === PackActionError.ContentTierIncompatibleMemory ? t('.incompatibleMemoryBody') : errorCode === PackActionError.ContentTierIncompatibleRayTracing ? t('.incompatibleRayTracingBody') : t('.unspecifiedErrorBody');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: ResourcePacksErrorModal_CANCEL_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, errorTitle), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: errorBody
  }, errorBody)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: ResourcePacksErrorModal_CANCEL_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.goBackButton'),
    onClick: hideModal
  }, t('.goBackButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksErrorModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksPlatformLockedModal/ResourcePacksPlatformLockedModal.tsx






const ResourcePacksPlatformLockedModal_GO_BACK_BUTTON_GAMEPAD_ALIAS = 'rpl-modal-go-back';
const ResourcePacksPlatformLockedModal = registerModal(({
  multiplayerData,
  packId,
  packName,
  packSize,
  packType,
  onActivatePack
}) => {
  const {
    t
  } = useLocalization('CreateNewWorld.resourcePacksPlatformLockedModal');
  const body = (0,react_facet_src.useFacetMap)(packName => t('.body', [packName]), [t], [packName]);
  const hideModal = useHideModal();

  const turnOffMultiplayerAndActivatePack = () => {
    multiplayerData.multiplayerGame = false;
    onActivatePack(packId, packType, packName, packSize);
    hideModal();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: ResourcePacksPlatformLockedModal_GO_BACK_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: body,
    gamepadIndex: 0,
    center: true
  }, body)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.removeInputLegend'),
    variant: "primary",
    onClick: turnOffMultiplayerAndActivatePack
  }, t('.turnOffMultiplayerAndApplyPackButton')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: ResourcePacksPlatformLockedModal_GO_BACK_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.closeInputLegend'),
    variant: "secondary",
    onClick: hideModal
  }, t('.goBackButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksPlatformLockedModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/BehaviorPacksConfirmationModal/BehaviorPacksConfirmationModal.tsx





const CONFIRM_BUTTON_GAMEPAD_ALIAS = 'behavior-packs-modal-confirm';
const BehaviorPacksConfirmationModal = registerModal(({
  packId,
  type,
  packType,
  onAccept
}) => {
  const {
    t
  } = useLocalization('CreateNewWorld.behaviorPacksRemoveModal');
  const hideModal = useHideModal();
  const isDeactivateAction = type == 'deactivate';

  const confirmAction = () => {
    onAccept(packId, packType);
    hideModal();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: CONFIRM_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: isDeactivateAction ? t('.messageDeactivate') : t('.messageActivate'),
    center: true
  }, isDeactivateAction ? t('.messageDeactivate') : t('.messageActivate'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CONFIRM_BUTTON_GAMEPAD_ALIAS,
    gamepadIndex: 0,
    inputLegend: isDeactivateAction ? t('.keepLabel') : t('.dontAddPackLabel'),
    onClick: hideModal,
    variant: "primary"
  }, isDeactivateAction ? t('.keepLabel') : t('.dontAddPackLabel')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: isDeactivateAction ? t('.removeLabel') : t('.addPackLabel'),
    onClick: confirmAction
  }, isDeactivateAction ? t('.removeLabel') : t('.addPackLabel'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/BehaviorPacksConfirmationModal/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/index.ts

















;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Notifications/Notifications.tsx















function cnwTabToUpsellTab(cnwTab) {
  var _lookup$cnwTab;

  const lookup = {
    general: TabbedUpsellScreenDefaultTab.MINECRAFT,
    'resource-packs': TabbedUpsellScreenDefaultTab.PACKS,
    cheats: TabbedUpsellScreenDefaultTab.MINECRAFT,
    experimental: TabbedUpsellScreenDefaultTab.MINECRAFT,
    multiplayer: TabbedUpsellScreenDefaultTab.MULTIPLAYER,
    advanced: TabbedUpsellScreenDefaultTab.SEEDS,
    'behavior-packs': TabbedUpsellScreenDefaultTab.PACKS
  };
  return (_lookup$cnwTab = lookup[cnwTab]) !== null && _lookup$cnwTab !== void 0 ? _lookup$cnwTab : TabbedUpsellScreenDefaultTab.MINECRAFT;
}

function Notifications_Notifications({
  multiplayerWarningEnabled,
  experimentsWarningEnabled
}) {
  const {
    t
  } = useLocalization('Notifications');
  const history = RouteHistory_useRouteHistory();
  const isEditWorld = (0,react.useContext)(WorldModeContext) === 'edit';
  const editWorld = (0,react_facet_src.useSharedFacet)(editWorldFacet);
  const createNewWorld = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const createWorldMultiplayer = (0,react_facet_src.useSharedFacet)(multiplayerSelector); // Achievements disabled or not, Edu and Editor do not currently support achievements

  const achievementsWarning = (0,react_facet_src.useFacetMap)((achievementsDisabled, isEduBuild, isInEditor) => achievementsDisabled && !isEduBuild && !isInEditor, [], [(0,react_facet_src.useSharedFacet)(isEditWorld ? achievementsDisabledSelectorEditWorld : achievementsDisabledSelector), (0,react_facet_src.useSharedFacet)(isEduBuildSelector), (0,react_facet_src.useSharedFacet)(isEditorWorldSelector)]); // In trial mode or or not

  const trialModeWarning = (0,react_facet_src.useSharedFacet)(isTrialAccountSelector); // Warning for template locked settings

  const templateWarning = (0,react_facet_src.useFacetMap)(facet => isEditWorld ? facet.worldData.lockedTemplate : facet.isLockedTemplate, [isEditWorld], [isEditWorld ? editWorld : createNewWorld]); // Warning message when one or more experimental features have been enabled. If
  // the template warning is present the experimental warning should not be show.

  const showExperimentsWarning = (0,react_facet_src.useFacetMap)(template => !template && experimentsWarningEnabled, [experimentsWarningEnabled], [templateWarning]); // Warning messages for Multiplayer tab

  const platform = (0,react_facet_src.useFacetMap)(device => device.platform, [], [(0,react_facet_src.useSharedFacet)(deviceInformationFacet)]);
  const multiplayerWarningMessage = (0,react_facet_src.useFacetMap)((createWorldMultiplayer, platform) => getWarningMessage(createWorldMultiplayer.generalWarningState, platform, t), [t], [createWorldMultiplayer, platform]);
  const multiplayerWarning = (0,react_facet_src.useFacetMap)(warningMessage => warningMessage.length > 0 && multiplayerWarningEnabled, [multiplayerWarningEnabled], [multiplayerWarningMessage]);
  const showChangeSkinLink = (0,react_facet_src.useFacetMap)(createWorldMultiplayer => createWorldMultiplayer.generalWarningState === GeneralMultiplayerWarningStateEnum.NON_MULTIPLAYER_SKIN_EQUIPPED, [], [createWorldMultiplayer]); // If any notification is present, mount div with wrapping padding

  const shouldUsePadding = (0,react_facet_src.useFacetMap)((multiplayerWarning, achievementsWarning, templateWarning, trialModeWarning) => multiplayerWarning || achievementsWarning || templateWarning || experimentsWarningEnabled || trialModeWarning, [experimentsWarningEnabled], [multiplayerWarning, achievementsWarning, templateWarning, trialModeWarning]);
  const params = useRouteParams();
  const showAchievementsDisabledModal = AchievementsDisabledModal.useShowModal();
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldUsePadding
  }, /*#__PURE__*/react.createElement("div", {
    className: Notifications.notifications
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: achievementsWarning
  }, /*#__PURE__*/react.createElement(Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement("div", {
    className: Notifications.panelContent
  }, /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "neutral100",
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: Notifications.notificationBottle,
    src: achievement_bottle_namespaceObject,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Banner_Banner.Text, null, t('.achievementsDisabled')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Banner_Banner.Link, {
    onClick: () => {
      isEditWorld ? achievementsDisabledModalEditFacet.set({
        visible: true
      }) : showAchievementsDisabledModal();
    },
    gamepadIndex: 0
  }, t('.readMoreLink')))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: trialModeWarning
  }, /*#__PURE__*/react.createElement(Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement("div", {
    className: Notifications.panelContent
  }, /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "informative",
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, t('.inTrialMode')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Banner_Banner.Link, {
    onClick: () => history.push(`/tabbed-upsell?tab=${cnwTabToUpsellTab(params.tab)}`),
    gamepadIndex: 0
  }, t('.readMoreLink')))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: multiplayerWarning
  }, /*#__PURE__*/react.createElement(Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement("div", {
    className: Notifications.panelContent
  }, /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "informative",
    gamepadIndex: 2
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, multiplayerWarningMessage), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showChangeSkinLink
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Banner_Banner.Link, {
    onClick: () => history.push('/persona'),
    gamepadIndex: 3
  }, t('.changeSkinLink')))))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showExperimentsWarning
  }, /*#__PURE__*/react.createElement(Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement("div", {
    className: Notifications.panelContent
  }, /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "informative",
    gamepadIndex: 4
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, t('.experimentsWarning.informationMessage')))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: templateWarning
  }, /*#__PURE__*/react.createElement(Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement("div", {
    className: Notifications.panelContent
  }, /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "informative",
    gamepadIndex: 5
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, t('.unlockSettingsMessage')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Banner_Banner.Link, {
    gamepadIndex: 1,
    onClick: () => showUnlockSettingsModal.set(true)
  }, t('.unlockSettingsLink'))))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Notifications/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsTabContainer/WorldSettingsTabContainer.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const WorldSettingsTabContainer = ({"borderedContainer":"KdIrj"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/IsWorldTemplateLoadingProvider.ts


const IsWorldTemplateLoading = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: false
}));
const useIsWorldTemplateLoading = () => (0,react.useContext)(IsWorldTemplateLoading);
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsTabContainer/WorldSettingsTabContainer.tsx















function WorldSettingsTabContainer_WorldSettingsTabContainer({
  children,
  multiplayerWarningsEnabled,
  experimentsWarningEnabled,
  nestedRoutes,
  narrationText
}) {
  var _useIsUserDragging;

  const breakpoint = useWindowBreakpoint();
  const disableScrolling = (_useIsUserDragging = useIsUserDragging()) !== null && _useIsUserDragging !== void 0 ? _useIsUserDragging : false;
  const isActive = useRouteActive();
  const gamepadAPI = useGamepadAPI();
  const stopCheckingForScroll = (0,react_facet_src.useFacetMap)(isActive => !isActive, [], [isActive]);
  const scrollViewRef = (0,react.useRef)(null);
  const nodeIdRef = (0,react.useRef)();
  (0,react_facet_src.useFacetLayoutEffect)(active => {
    if (!active && nodeIdRef.current != null) {
      gamepadAPI === null || gamepadAPI === void 0 ? void 0 : gamepadAPI.clearRememberCache(nodeIdRef.current);
    }

    if (scrollViewRef.current) {
      scrollViewRef.current.scrollTop = 0;
    }
  }, [gamepadAPI], [isActive]);
  const paused = (0,dist.useIsPaused)();
  const isLoading = (0,react_facet_src.useFacetMap)((parentLoading, deferring) => parentLoading || deferring || paused, [paused], [useIsWorldTemplateLoading(), (0,dist.useIsDeferring)()]); // For most tabs that don't have any nested routes, we will want to fire paint
  // events as soon as the ScrollView has shown its content. However for tabs with nested routes,
  // we want to give them the control to fire the paint events; and we will instead delay those events
  // if they fire before the ScrollView has finished showing the content.

  const RenderTracker = nestedRoutes ? RenderTrackingDelay : RenderTrackingEvent;
  const animationEnabled = (0,react_facet_src.useFacetUnwrap)(useScreenAnimationEnabled());
  const {
    t
  } = useLocalization('CreateNewWorld');
  const narrationTextPrefix = t('.tabContainerNarrationSuffix');
  const narrationTextWithPrefix = `${narrationTextPrefix}. ${narrationText}`;
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: narrationTextWithPrefix
  }, /*#__PURE__*/react.createElement(RenderTracker, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 0,
    floating: breakpoint !== 'desktop',
    loading: isLoading,
    disableScrolling: disableScrolling,
    innerRef: scrollViewRef,
    defaultFocusedChildBehavior: "remember",
    stopCheckingForScroll: stopCheckingForScroll,
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTracker, {
      renderingCompleted: isContentShown,
      type: "meaningful"
    }) // If animations are disabled, we don't want the transparent background as it creates a quick fade effect.
    ,
    spinnerBackgroundColor: animationEnabled === true ? undefined : '#48494A',
    nodeIdRef: nodeIdRef
  }, /*#__PURE__*/react.createElement(Form, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", {
    className: breakpoint === 'desktop' ? WorldSettingsTabContainer.borderedContainer : ''
  }, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Column, {
    shouldSkipLandmarkInVisual: true,
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement(Notifications_Notifications, {
    multiplayerWarningEnabled: multiplayerWarningsEnabled,
    experimentsWarningEnabled: experimentsWarningEnabled
  })))), /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true
  }, children)))), /*#__PURE__*/react.createElement(InputLegend_InputLegend.Space, {
    extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 1
    })
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsTabContainer/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/VanillaTextField/checkProfanity.ts
const checkProfanity = (filter, text) => {
  return filter.isProfanityInString(text);
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/ProfanityWarningModal/ProfanityWarningModal.tsx





const defaultContextValue = () => undefined;

const ProfanityWarningModal_Context = (0,react.createContext)(defaultContextValue);
const useSetShowProfanityWarningModal = () => react.useContext(ProfanityWarningModal_Context);
const ProfanityWarningModal = () => {
  const {
    t
  } = useLocalization('ProfanityWarningModalRoute');
  const showProfanityWarningModal = useSetShowProfanityWarningModal();
  const closeModal = (0,react.useCallback)(() => {
    showProfanityWarningModal(false);
  }, [showProfanityWarningModal]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: "profanity-warning-modal-button"
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.body'),
    center: true
  }, t('.body'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.close'),
    variant: "primary",
    delayedClick: true,
    onClick: closeModal,
    gamepadAlias: "profanity-warning-modal-button"
  }, t('.close'))));
};
const ProfanityWarningModalProvider = ({
  children
}) => {
  const [showModal, setShowModal] = (0,react_facet_src.useFacetState)(false);
  return /*#__PURE__*/react.createElement(ProfanityWarningModal_Context.Provider, {
    value: setShowModal
  }, children, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showModal
  }, /*#__PURE__*/react.createElement(ProfanityWarningModal, null)));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/ProfanityWarningModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/VanillaTextField/useOnBlurDefaultHandler.ts





const useOnBlurDefaultHandler = clearOnProfanity => {
  const setShowProfanityWarningModal = useSetShowProfanityWarningModal();
  return (0,react_facet_src.useFacetCallback)(profanityFilter => (value, setValue) => {
    const hasProfanity = checkProfanity(profanityFilter, value);

    if (hasProfanity) {
      if (clearOnProfanity) {
        setValue('');
      }

      setShowProfanityWarningModal(true);
      return TextFieldValidationResult.INVALID;
    }

    return TextFieldValidationResult.VALID;
  }, [clearOnProfanity, setShowProfanityWarningModal], [(0,react_facet_src.useSharedFacet)(profanityFilterFacet)]);
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/VanillaTextField/VanillaTextFieldWithButton.tsx
function VanillaTextFieldWithButton_extends() { VanillaTextFieldWithButton_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return VanillaTextFieldWithButton_extends.apply(this, arguments); }

function VanillaTextFieldWithButton_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = VanillaTextFieldWithButton_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function VanillaTextFieldWithButton_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





const VanillaTextFieldWithButton = (_ref) => {
  let {
    onBlur,
    filterProfanity = false,
    clearOnProfanity = true
  } = _ref,
      rest = VanillaTextFieldWithButton_objectWithoutProperties(_ref, ["onBlur", "filterProfanity", "clearOnProfanity"]);

  const onBlurDefaultHandler = useOnBlurDefaultHandler(clearOnProfanity);
  const onBlurDecorated = (0,react.useCallback)((value, setValue) => {
    if (onBlur != null) {
      return onBlur(value, setValue, checkProfanity);
    } else if (filterProfanity) {
      return onBlurDefaultHandler(value, setValue);
    }
  }, [onBlur, onBlurDefaultHandler, filterProfanity]);
  return /*#__PURE__*/react.createElement(TextField.WithButton, VanillaTextFieldWithButton_extends({}, rest, {
    onBlur: onBlurDecorated
  }));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/VanillaTextField/VanillaTextField.tsx
function VanillaTextField_extends() { VanillaTextField_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return VanillaTextField_extends.apply(this, arguments); }

function VanillaTextField_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = VanillaTextField_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function VanillaTextField_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





 // This component adds a profanity filter to the TextField component, which is a functionality used only by vanilla at the moment.
// If the profanity at a later stage will be used by more games we should move this component to a common package (not @mojang/ui though).

const VanillaTextField = (_ref) => {
  let {
    onBlur,
    filterProfanity = false,
    clearOnProfanity = true
  } = _ref,
      rest = VanillaTextField_objectWithoutProperties(_ref, ["onBlur", "filterProfanity", "clearOnProfanity"]);

  const onBlurDefaultHandler = useOnBlurDefaultHandler(clearOnProfanity);
  const onBlurDecorated = (0,react.useCallback)((value, setValue) => {
    if (onBlur != null) {
      return onBlur(value, setValue, checkProfanity);
    } else if (filterProfanity) {
      return onBlurDefaultHandler(value, setValue);
    }
  }, [onBlur, onBlurDefaultHandler, filterProfanity]);
  return /*#__PURE__*/react.createElement(TextField, VanillaTextField_extends({}, rest, {
    onBlur: onBlurDecorated
  }));
};
VanillaTextField.WithButton = VanillaTextFieldWithButton;
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/VanillaTextField/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/external-link.png
const external_link_namespaceObject = __webpack_require__.p + "assets/external-link-b22bb.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/GeneralTab.tsx
function GeneralTab_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function GeneralTab_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GeneralTab_ownKeys(Object(source), true).forEach(function (key) { GeneralTab_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GeneralTab_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function GeneralTab_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


















function GeneralTab({
  isLockedTemplate,
  generalData
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.general');
  const {
    t: t2
  } = useLocalization('CreateNewWorldSideMenu');
  const isEditorWorldFacet = (0,react_facet_src.useSharedFacet)(isEditorWorldSelector);
  const isEditorWorld = (0,react_facet_src.useFacetUnwrap)(isEditorWorldFacet);
  const editorLocalizationTag = isEditorWorld === true ? '.editor' : '';
  const editingWorld = (0,react.useContext)(WorldModeContext) === 'edit';
  const webBrowserSharedFacet = (0,react_facet_src.useSharedFacet)(webBrowserFacet);
  const screenTechStackSharedFacet = (0,react_facet_src.useSharedFacet)(screenTechStackFacet);
  const historyAPI = RouteHistory_useRouteHistory();
  const showOptBackModal = OptBackModal.useShowModal();
  const worldId = useWorldID();
  const optOut = (0,react_facet_src.useFacetCallback)(screenTechStack => () => {
    screenTechStack.selectTechStackForScreen(ScreenName.EditWorldScreen, UITechStack.JsonUI);
    historyAPI.replace(ScreenName.EditWorldScreen + '/' + worldId);
  }, [historyAPI, worldId], [screenTechStackSharedFacet]);
  const openFeedbackPage = (0,react_facet_src.useFacetCallback)(webBrowser => () => {
    webBrowser.openLink(WebBrowserLink.EditWorldScreenFeedbackPage);
  }, [], [webBrowserSharedFacet]);
  const worldNameValue = (0,react_facet_src.useFacetMap)(facet => facet.worldName, [], [generalData]);
  const worldNameCallback = (0,react_facet_src.useFacetCallback)(facet => newValue => facet.worldName = newValue, [], [generalData]);
  return /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    narrationText: t2('.generalTabLabel')
  }, editingWorld && /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(PanelButton_PanelButton, {
    gamepadIndex: 0,
    defaultFocusedChildBehavior: "first",
    title: t('.designPreviewTitle'),
    description: t('.designPreviewDescription'),
    narrationText: `${t('.designPreviewTitle')} - ${t('.designPreviewDescription')}`,
    buttons: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
      inputLegend: t('.designPreviewInputLegend'),
      horizontal: true,
      onClick: openFeedbackPage,
      imgSrc: external_link_namespaceObject,
      gamepadIndex: 0
    }, t('.feedbackButton')), /*#__PURE__*/react.createElement(PanelButton_PanelButton.ButtonSpacing, null), /*#__PURE__*/react.createElement(Button_Button_Button, {
      inputLegend: t('.designPreviewInputLegend'),
      horizontal: true,
      onClick: () => showOptBackModal({
        optOutCallback: optOut
      }),
      gamepadIndex: 1
    }, t('.optOutButton')))
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isEditorWorldFacet
  }, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.projectHeader')
  }))), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(VanillaTextField, {
    label: t(`${editorLocalizationTag}.worldNameTitle`),
    gamepadIndex: 1,
    placeholder: t(`${editorLocalizationTag}.worldNamePlaceholder`) // Do not change the maxLength to a value > 1024 until bug #507491 is fixed. This to avoid issues with text input on GameCore.
    ,
    maxLength: 30,
    value: worldNameValue,
    onChange: worldNameCallback,
    filterProfanity: true,
    disabled: isLockedTemplate
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isEditorWorldFacet
  }, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.exportSettingsHeader'),
    description: t('.exportSettingsDescription')
  }))), /*#__PURE__*/react.createElement(dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(GameModeToggles, {
    isLockedTemplate: isLockedTemplate,
    generalData: generalData
  })), /*#__PURE__*/react.createElement(dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(DifficultyToggles, {
    isLockedTemplate: isLockedTemplate,
    generalData: generalData
  })), editingWorld && /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(FileManagementButtons, null))));
}

function DifficultyToggles({
  isLockedTemplate,
  generalData
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.general');
  const notifyDeferredRendererMountComplete = (0,dist.useNotifyMountComplete)();
  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    onMountComplete: notifyDeferredRendererMountComplete,
    title: t('.difficultyTitle'),
    disabled: isLockedTemplate,
    gamepad: {
      index: 3
    },
    options: [{
      label: t('.difficultyPeacefulLabel'),
      description: t('.difficultyPeacefulDescription'),
      value: DifficultyEnum.PEACEFUL
    }, {
      label: t('.difficultyEasyLabel'),
      description: t('.difficultyEasyDescription'),
      value: DifficultyEnum.EASY
    }, {
      label: t('.difficultyNormalLabel'),
      description: t('.difficultyNormalDescription'),
      value: DifficultyEnum.NORMAL
    }, {
      label: t('.difficultyHardLabel'),
      description: t('.difficultyHardDescription'),
      value: DifficultyEnum.HARD
    }],
    value: (0,react_facet_src.useFacetMap)(facet => facet.difficulty, [], [generalData]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.difficulty = newValue;
    }, [], [generalData])
  });
}

function GameModeToggles({
  isLockedTemplate,
  generalData
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.general');
  const {
    t: a
  } = useLocalization('CreateNewWorld.all');
  const editingWorld = (0,react.useContext)(WorldModeContext) === 'edit';
  const createNewWorld = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const isUsingTemplate = (0,react_facet_src.useFacetMap)(facet => editingWorld ? false : facet.isUsingTemplate, [editingWorld], [createNewWorld]);
  const isTrialAccountFacet = (0,react_facet_src.useSharedFacet)(isTrialAccountSelector);
  const togglesDisabled = (0,react_facet_src.useFacetMap)((isLockedTemplate, isTrialAccount) => isLockedTemplate || isTrialAccount, [], [isLockedTemplate, isTrialAccountFacet]);
  const achievementsDisabledMessages = useAchievementsDisabledMessages();
  const gameModes = (0,react_facet_src.useFacetMap)((isUsingTemplate, achievementsDisabledMessages) => {
    const modes = [GeneralTab_objectSpread({
      label: t('.gameModeSurvivalLabel'),
      description: t('.gameModeSurvivalDescription'),
      value: types_GameMode.SURVIVAL
    }, achievementsDisabledMessages.length === 1 // This makes the narrationSuffix optional (and not string | undefined).
    ? {
      narrationSuffix: a('.narrationSuffixEnablesAchievements')
    } : {}), {
      label: t('.gameModeCreativeLabel'),
      description: t('.gameModeCreativeDescription'),
      value: types_GameMode.CREATIVE,
      narrationSuffix: a('.narrationSuffixDisablesAchievements')
    }];

    if (isUsingTemplate || editingWorld) {
      modes.push({
        label: t('.gameModeAdventureLabel'),
        description: t('.gameModeAdventureDescription'),
        value: types_GameMode.ADVENTURE
      });
    }

    return modes;
  }, [t, a, editingWorld], [isUsingTemplate, achievementsDisabledMessages]);
  const notifyDeferredRendererMountComplete = (0,dist.useNotifyMountComplete)();
  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    title: t('.gameModeTitle'),
    gamepad: {
      index: 2
    },
    disabled: togglesDisabled,
    options: gameModes,
    onMountComplete: notifyDeferredRendererMountComplete,
    value: (0,react_facet_src.useFacetMap)(facet => facet.gameMode, [], [generalData]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.gameMode = newValue;
    }, [], [generalData])
  });
}

const FileManagementButtons = () => {
  const {
    t
  } = useLocalization('CreateNewWorld.general');
  const editWorldSharedFacet = (0,react_facet_src.useSharedFacet)(editWorldFacet);
  const worldId = useWorldID();
  const fileInfo = (0,react_facet_src.useFacetMap)(editWorldSharedFacet => {
    var _worldSummary$fileSiz, _worldSummary$lastPla;

    const worldSummary = worldId != null ? editWorldSharedFacet.worldSummary : null;
    const fileSize = (_worldSummary$fileSiz = worldSummary === null || worldSummary === void 0 ? void 0 : worldSummary.fileSize) !== null && _worldSummary$fileSiz !== void 0 ? _worldSummary$fileSiz : '-';
    const date = (_worldSummary$lastPla = worldSummary === null || worldSummary === void 0 ? void 0 : worldSummary.lastPlayed) !== null && _worldSummary$lastPla !== void 0 ? _worldSummary$lastPla : '-';
    return t('.fileDetails', [fileSize, date]);
  }, [t, worldId], [editWorldSharedFacet]);
  const fileManagementNarrationText = (0,react_facet_src.useFacetMap)(fileInfo => [t('.fileManagementTitle'), t('.fileManagement.narrationComponentTypeSectionHeader'), fileInfo].join(' . '), [t], [fileInfo]);
  const openDeleteWorldModal = DeleteWorldModal.useShowModal();
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: fileManagementNarrationText
  }, /*#__PURE__*/react.createElement(Row, {
    options: {
      index: 5
    },
    shouldSkipLandmarkInVisual: true
  }, /*#__PURE__*/react.createElement(Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, null, t('.fileManagementTitle')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement("div", {
    style: {
      flexDirection: 'row'
    }
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "secondary",
    gamepadIndex: 0,
    onClick: (0,react_facet_src.useFacetCallback)(editWorldSharedFacet => () => {
      if (worldId != null) editWorldSharedFacet.duplicateWorld.run(worldId);
    }, [worldId], [editWorldSharedFacet]),
    inputLegend: t('.fileManagementDuplicateWorldLabel'),
    autofocus: true,
    horizontal: true
  }, t('.fileManagementDuplicateWorldLabel')), /*#__PURE__*/react.createElement(PanelButton_PanelButton.ButtonSpacing, null), /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "destructive",
    gamepadIndex: 1,
    onClick: openDeleteWorldModal,
    inputLegend: t('.fileManagementDeleteWorldLabel'),
    autofocus: true,
    horizontal: true
  }, t('.fileManagementDeleteWorldLabel'))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, null, fileInfo), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }))));
};
;// CONCATENATED MODULE: ./packages/ui/src/Switch/Switch.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const src_Switch_Switch = ({"Switch":"BMKqH","context":"_8UmaI"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseSwitch/BaseSwitch.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseSwitch = ({"BaseSwitch":"A9D4z","toggle":"e7MoW","imageOn":"bgIQq","disabled":"p_TUt","imageOff":"R_YeG","toggleContainerBorder":"qxKas","toggleBase":"XjUWP","toggleBaseItem":"gMVJP","toggleTop":"RS5ul","toggleTopInner":"fr1iK","toggleTopTop":"aVlBS","toggleTopBottomBevel":"xqZlc","toggleTopOn":"KjBRi","toggleTopOff":"IxVml","toggleTopOnAnimated":"moANc","toggleTopOffAnimated":"FVcXO","switch-toggle-top-animation-on":"shenE","switch-toggle-top-animation-off":"kEW1j","offText":"pqxNj","onText":"ldgdO","toggleLabel":"SWTSF"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconOn/images/onImage.png
const onImage_namespaceObject = __webpack_require__.p + "assets/onImage-b40d0.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconOn/IconOn.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconOn = ({"iconOn":"R3e0Q"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconOn/IconOn.tsx




const IconOn_IconOn = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconOn.iconOn,
  src: onImage_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconOff/images/offImage.png
const offImage_namespaceObject = __webpack_require__.p + "assets/offImage-cc909.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconOff/IconOff.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconOff = ({"iconOff":"i0_sF"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconOff/IconOff.tsx




const IconOff_IconOff = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconOff.iconOff,
  src: offImage_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseSwitch/BaseSwitch.tsx












const getToggleTopClasses = (value, shouldAnimate) => classnames_default()(BaseSwitch.toggleTop, {
  [shouldAnimate ? BaseSwitch.toggleTopOnAnimated : BaseSwitch.toggleTopOn]: value,
  [shouldAnimate ? BaseSwitch.toggleTopOffAnimated : BaseSwitch.toggleTopOff]: !value
});

function BaseSwitch_BaseSwitch({
  onChange,
  gamepad,
  value,
  disabled = false,
  onFocusChanged,
  showOnOffText = false,
  shouldAnimateRef,
  soundEffectHovered,
  soundEffectFocused,
  soundEffectPressed,
  offNarrationText: offNarration,
  onNarrationText: onNarration,
  disabledNarrationSuffix,
  onRole = 'primary',
  offRole = 'neutral50',
  thumbRole = 'secondary'
}) {
  var _gamepad$index;

  const {
    t
  } = useLocalization('BaseSwitch');
  const {
    color: {
      [thumbRole]: semanticClassNamesThumb,
      [onRole]: semanticClassNamesOn,
      [offRole]: semanticClassNamesOff
    },
    sound: {
      inherit: semanticSounds
    }
  } = useSemanticTokens();
  const {
    narrateText
  } = useNarrateText();
  const internalShouldAnimateRef = (0,react.useRef)(false);
  const finalShouldAnimateRef = shouldAnimateRef !== null && shouldAnimateRef !== void 0 ? shouldAnimateRef : internalShouldAnimateRef;
  const toggleTopRef = (0,react.useRef)(null);
  const valueFacet = (0,react_facet_src.useFacetWrap)(value); // We use this to delay the rendering until we have a value. Otherwise, we can't know if
  // the switch should be on or off. That can potentially cause a flicker.

  const shouldRender = (0,react_facet_src.useFacetMap)(() => true, [], [valueFacet]); // We run this effect to apply the correct classes

  (0,react_facet_src.useFacetEffect)(value => {
    if (toggleTopRef.current) {
      var _finalShouldAnimateRe;

      toggleTopRef.current.className = getToggleTopClasses(value, (_finalShouldAnimateRe = finalShouldAnimateRef.current) !== null && _finalShouldAnimateRe !== void 0 ? _finalShouldAnimateRe : false);
    }
  }, [finalShouldAnimateRef], [valueFacet]); // The `onClick` handler, that is defined a couple of lines below, is going to add the
  // class that makes the transition between *on* and *off* states animate. We want to
  // remove these classes after - so that they only occur on user interaction. Otherwise,
  // they could get triggered by a parent component that switches from display:none

  const onAnimationEnd = (0,react_facet_src.useFacetCallback)((value, offNarration, onNarration) => () => {
    if (toggleTopRef.current) {
      toggleTopRef.current.className = getToggleTopClasses(value, false); // We are doing the narration here because we could have validation that is happening in the onChange handler.

      narrateText(value ? [t('.on'), onNarration !== null && onNarration !== void 0 ? onNarration : ''].join(' . ') : [t('.off'), offNarration !== null && offNarration !== void 0 ? offNarration : ''].join(' . '));
    }

    finalShouldAnimateRef.current = false;
  }, [narrateText, t, finalShouldAnimateRef], [valueFacet, (0,react_facet_src.useFacetWrap)(offNarration), (0,react_facet_src.useFacetWrap)(onNarration)]);
  const onClick = (0,react_facet_src.useFacetCallback)(value => () => {
    finalShouldAnimateRef.current = true;
    onChange === null || onChange === void 0 ? void 0 : onChange(!value);
  }, [onChange, finalShouldAnimateRef], [valueFacet]);
  const setToggleTopRef = (0,react.useCallback)(node => {
    if (!toggleTopRef.current && node) {
      const val = (0,react_facet_src.isFacet)(value) ? value.get() : value;
      node.className = getToggleTopClasses(val, finalShouldAnimateRef.current);
    } // Cleanup event listeners for the previous ref.


    if (toggleTopRef.current) {
      toggleTopRef.current.removeEventListener('animationend', onAnimationEnd);
    } // This function gets called with null when the component dismounts.


    if (node) {
      node.addEventListener('animationend', onAnimationEnd);
    }

    toggleTopRef.current = node;
  }, [onAnimationEnd, value, finalShouldAnimateRef]);
  const narrationText = (0,react_facet_src.useFacetMap)((value, disabled) => [t('.elementType'), disabled === true ? t('.narrationDisabled') : '', value ? t('.on') : t('.off'), disabled ? disabledNarrationSuffix !== null && disabledNarrationSuffix !== void 0 ? disabledNarrationSuffix : '' : ''].join(' . '), [t, disabledNarrationSuffix], [valueFacet, (0,react_facet_src.useFacetWrap)(disabled)]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldRender
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: onChange != null,
    className: BaseSwitch.BaseSwitch,
    narrationText: narrationText,
    inputLegend: t('.toggle'),
    gamepadIndex: (_gamepad$index = gamepad === null || gamepad === void 0 ? void 0 : gamepad.index) !== null && _gamepad$index !== void 0 ? _gamepad$index : 0,
    soundEffectHovered: soundEffectHovered !== null && soundEffectHovered !== void 0 ? soundEffectHovered : semanticSounds.hover,
    soundEffectFocused: soundEffectFocused !== null && soundEffectFocused !== void 0 ? soundEffectFocused : semanticSounds.focus,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.toggle,
    classNameHovered: BaseSwitch.hovered,
    classNameFocused: classnames_default()(BaseSwitch.focused, focusClass),
    classNamePressed: BaseSwitch.pressed,
    classNameDisabled: BaseSwitch.disabled,
    disabled: disabled,
    onFocusChanged: onFocusChanged,
    onClick: onClick
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: BaseSwitch.offText,
    style: {
      opacity: (0,react_facet_src.useFacetMap)(value => value ? 0.6 : 1, [], [valueFacet]),
      display: showOnOffText ? 'flex' : 'none'
    }
  }, /*#__PURE__*/react.createElement("span", {
    className: BaseSwitch.toggleLabel
  }, t('.off'))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(BaseSwitch.toggle, semanticClassNamesOff.border.base, semanticClassNamesOff.border.disable)
  }, /*#__PURE__*/react.createElement("div", {
    className: BaseSwitch.toggleContainerBorder
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: BaseSwitch.toggleBase
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(BaseSwitch.toggleBaseItem, BaseSwitch.toggleBaseItemOn, semanticClassNamesOn.background.base, semanticClassNamesOn.background.disable)
  }, /*#__PURE__*/react.createElement("div", {
    className: BaseSwitch.imageOn
  }, /*#__PURE__*/react.createElement(IconOn_IconOn, null)), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    interactive: false,
    right: false,
    role: "primary",
    disabled: disabled
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(BaseSwitch.toggleBaseItem, BaseSwitch.toggleBaseItemOff, semanticClassNamesOff.background.base, semanticClassNamesOff.background.disable)
  }, /*#__PURE__*/react.createElement("div", {
    className: BaseSwitch.imageOff
  }, /*#__PURE__*/react.createElement(IconOff_IconOff, null)), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    interactive: false,
    left: false,
    role: "neutral50",
    disabled: disabled
  }))), /*#__PURE__*/react.createElement("div", {
    ref: setToggleTopRef,
    className: BaseSwitch.toggleTop
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: classnames_default()(BaseSwitch.toggleTopInner, semanticClassNamesThumb.border.base, semanticClassNamesThumb.border.disable, semanticClassNamesThumb.background.interactive)
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    role: "secondary",
    disabled: disabled
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(BaseSwitch.toggleTopTop)
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    role: "secondary",
    disabled: disabled
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(BaseSwitch.toggleTopBottomBevel, semanticClassNamesThumb.shadow.base, semanticClassNamesThumb.shadow.disable)
  })))), /*#__PURE__*/react.createElement("fast-div", {
    className: BaseSwitch.onText,
    style: {
      opacity: (0,react_facet_src.useFacetMap)(value => value ? 1 : 0.6, [], [valueFacet]),
      display: showOnOffText ? 'flex' : 'none'
    }
  }, /*#__PURE__*/react.createElement("span", {
    className: BaseSwitch.toggleLabel
  }, t('.on')))));
}
;// CONCATENATED MODULE: ./packages/ui/src/Switch/Switch.tsx









const Switch_noop = () => {};

function Switch_Switch_Switch({
  onChange = Switch_noop,
  gamepad,
  value,
  title,
  description,
  disabled = false,
  showOnOffText = false,
  soundEffectHovered,
  soundEffectFocused,
  soundEffectPressed,
  offNarrationText,
  onNarrationText,
  disabledNarrationSuffix,
  wrapperRole = 'neutral',
  onRole,
  offRole,
  thumbRole
}) {
  var _gamepad$index;

  const {
    t
  } = useLocalization('Switch');
  const {
    sound: {
      [wrapperRole]: semanticSound
    }
  } = useSemanticTokens();
  const shouldAnimateRef = (0,react.useRef)(false);
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const titleFacet = (0,react_facet_src.useFacetWrap)(title); // We use this to delay the rendering until we have a value. Otherwise, we can't know if
  // the switch should be on or off. That can potentially cause a flicker.

  const shouldRender = (0,react_facet_src.useFacetMap)(() => true, [], [valueFacet]);
  const onClick = (0,react_facet_src.useFacetCallback)((value, disabled) => () => {
    if (!disabled) {
      shouldAnimateRef.current = true;
      onChange(!value);
    }
  }, [onChange], [valueFacet, disabledFacet]);
  const valueFacetRef = (0,react_facet_src.useFacetRef)(valueFacet);
  const disabledFacetRef = (0,react_facet_src.useFacetRef)(disabledFacet);
  const titleFacetRef = (0,react_facet_src.useFacetRef)(titleFacet);
  const getNarrationText = (0,react.useCallback)(() => {
    if (valueFacetRef.current === react_facet_src.NO_VALUE || disabledFacetRef.current === react_facet_src.NO_VALUE) return '';
    const value = valueFacetRef.current;
    const disabled = disabledFacetRef.current;
    return [title, t('.elementType'), disabled === true ? t('.narrationDisabled') : '', value ? t('.on') : t('.off'), description !== null && description !== void 0 ? description : '', disabled ? disabledNarrationSuffix !== null && disabledNarrationSuffix !== void 0 ? disabledNarrationSuffix : '' : ''].join(' . ');
  }, [valueFacetRef, disabledFacetRef, description, disabledNarrationSuffix, t, title]);
  const contextClass = (0,react_facet_src.useFacetMap)(title => {
    const hasContext = title !== '' || description != null && description !== '';
    return hasContext ? src_Switch_Switch.context : '';
  }, [description], [titleFacet]);
  const isNarrationEnabled = useNarrationEnabled();
  const hasTitle = (0,react_facet_src.useFacetMap)(title => title != null && title.length > 0, [], [titleFacet]);
  const isPanelFocusableFacet = (0,react_facet_src.useFacetMap)(disabled => disabled === true && isNarrationEnabled, [isNarrationEnabled], [disabledFacet]);
  const propInputLegendFacet = (0,react_facet_src.useFacetMap)(disabled => !disabled ? t('.toggle') : false, [t], [disabledFacet]);
  const panelSoundEffectHoveredFacet = (0,react_facet_src.useFacetMap)((isDisabled, soundEffectHovered) => !isDisabled ? soundEffectHovered !== null && soundEffectHovered !== void 0 ? soundEffectHovered : semanticSound.hover : undefined, [semanticSound.hover], [disabledFacet, (0,react_facet_src.useFacetWrap)(soundEffectHovered)]);
  const panelSoundEffectFocusedFacet = (0,react_facet_src.useFacetMap)(soundEffectFocused => soundEffectFocused !== null && soundEffectFocused !== void 0 ? soundEffectFocused : semanticSound.focus, [semanticSound.focus], [(0,react_facet_src.useFacetWrap)(soundEffectFocused)]);
  const panelSoundEffectPressedFacet = (0,react_facet_src.useFacetMap)((isDisabled, soundEffectPressed) => !isDisabled ? soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.toggle : undefined, [semanticSound.toggle], [disabledFacet, (0,react_facet_src.useFacetWrap)(soundEffectPressed)]);
  const narrationId = titleFacetRef.current !== react_facet_src.NO_VALUE ? titleFacetRef.current : '';
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldRender
  }, /*#__PURE__*/react.createElement(NarrationContext, {
    getText: getNarrationText,
    id: `narration-${narrationId}`
  }, /*#__PURE__*/react.createElement(Panel_Panel, {
    role: wrapperRole,
    disabled: disabledFacet,
    onClick: onClick,
    focusable: isPanelFocusableFacet,
    gamepadIndex: (_gamepad$index = gamepad === null || gamepad === void 0 ? void 0 : gamepad.index) !== null && _gamepad$index !== void 0 ? _gamepad$index : 0,
    shouldDisplayFocus: isPanelFocusableFacet,
    inputLegend: propInputLegendFacet,
    soundEffectHovered: panelSoundEffectHoveredFacet,
    soundEffectFocused: panelSoundEffectFocusedFacet,
    soundEffectPressed: panelSoundEffectPressedFacet,
    narrationText: ""
  }, /*#__PURE__*/react.createElement("div", {
    className: src_Switch_Switch.Switch
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: contextClass
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasTitle
  }, /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, {
    disabled: disabled
  }, titleFacet)), description != '' && description != null && /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, null, description)), /*#__PURE__*/react.createElement(BaseSwitch_BaseSwitch, {
    value: valueFacet,
    disabled: disabledFacet,
    showOnOffText: showOnOffText,
    shouldAnimateRef: shouldAnimateRef,
    disabledNarrationSuffix: disabledNarrationSuffix,
    onNarrationText: onNarrationText,
    offNarrationText: offNarrationText,
    onRole: onRole,
    offRole: offRole,
    thumbRole: thumbRole
  })))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/CheatsTab.tsx












const MAX_TICK_SPEED = 4096;
const DEFAULT_TICK_SPEED = 1;
function RandomTickSpeedSetting({
  disabled,
  gamepadIndex,
  cheatsData
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.cheats');
  const {
    t: n
  } = useLocalization('CreateNewWorld.cheats.narration');
  const tickSpeed = (0,react_facet_src.useFacetMap)(cheatsData => cheatsData.tickSpeed.toString(), [], [cheatsData]);
  const {
    narrateText
  } = useNarrateText({
    interruptible: false
  });
  const setTickSpeed = (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
    cheatsData.tickSpeed = newValue;
  }, [], [cheatsData]);
  const tickSpeedBlurHandler = (0,react.useCallback)(
  /**
   * Handler for sanitizing the input if it is less
   * than MAX_TICK_SPEED and only contains digits.
   */
  (speed, setSpeed) => {
    const numbersReg = /^[0-9]*$/g;
    const isOnlyDigits = speed.match(numbersReg);
    const isWithinRange = parseInt(speed) <= MAX_TICK_SPEED;
    const isEmpty = speed.length === 0;

    if (isEmpty || !isOnlyDigits) {
      narrateText(n('.tickSpeedInvalidValue'));
      setSpeed(DEFAULT_TICK_SPEED.toString());
      return TextField.ValidationResult.INVALID;
    } else if (!isWithinRange) {
      narrateText(n('.tickSpeedNotWithinRange'));
      setSpeed(MAX_TICK_SPEED.toString());
      return TextField.ValidationResult.INVALID;
    }

    return TextField.ValidationResult.VALID;
  }, [narrateText, n]);
  return /*#__PURE__*/react.createElement(VanillaTextField.WithButton, {
    disabledNarrationSuffix: t('.settingDisabledHint'),
    buttonInputLegend: t('.tickSpeedReset'),
    buttonText: t('.tickSpeedReset'),
    disabled: disabled,
    buttonOnClick: () => setTickSpeed(DEFAULT_TICK_SPEED.toString()),
    gamepadIndex: gamepadIndex,
    label: t('.tickSpeedLabel'),
    description: t('.tickSpeedDescription')
    /* Do not change the maxLength to a value > 1024 until bug #507491 is fixed. This to avoid issues with text input on GameCore.*/
    ,
    maxLength: 4,
    value: tickSpeed,
    onChange: setTickSpeed,
    onBlur: tickSpeedBlurHandler,
    buttonNarrationHint: t('.narrationTickSpeedButtonNarrationHint'),
    isNumber: true
  });
}
function DaylightCycleToggles({
  disabled,
  gamepadIndex,
  cheatsData
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.cheats');
  const editingWorld = (0,react.useContext)(WorldModeContext) === 'edit';
  const daylightCycleCallback = (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
    cheatsData.daylightCycle = newValue;
  }, [], [cheatsData]);
  const daylightCycleValue = (0,react_facet_src.useFacetMap)(cheatsData => cheatsData.daylightCycle, [], [cheatsData]);
  const daylightCycleOptions = [{
    label: t('.daylightCycleNormalLabel'),
    description: t('.daylightCycleNormalDescription'),
    value: DaylightCycleEnum.NORMAL
  }, {
    label: t('.daylightCycleAlwaysDayLabel'),
    description: t('.daylightCycleAlwaysDayDescription'),
    value: DaylightCycleEnum.ALWAYS_DAY
  }];

  if (editingWorld) {
    daylightCycleOptions.push({
      label: t('.daylightCycleLockTimeLabel'),
      description: t('.daylightCycleLockTimeDescription'),
      value: DaylightCycleEnum.LOCK_TIME
    });
  }

  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    disabledNarrationSuffix: t('.settingDisabledHint'),
    onMountComplete: (0,dist.useNotifyMountComplete)(),
    title: t('.daylightCycleTitle'),
    disabled: disabled,
    gamepad: {
      index: gamepadIndex
    },
    options: daylightCycleOptions,
    value: daylightCycleValue,
    onChange: daylightCycleCallback
  });
}

function CheatsEnabledSwitch({
  cheatsData
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.cheats');
  const {
    t: a
  } = useLocalization('CreateNewWorld.all');
  const achievementsDisabledMessages = useAchievementsDisabledMessages();
  const cheatTabDisabled = (0,react_facet_src.useFacetMap)((isLockedTemplate, isTrialAccount) => isLockedTemplate || isTrialAccount, [], [(0,react_facet_src.useSharedFacet)(isLockedTemplateSelector), (0,react_facet_src.useSharedFacet)(isTrialAccountSelector)]);
  const cheatsEnabledCallback = (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
    cheatsData.cheatsEnabled = newValue;
  }, [], [cheatsData]);
  const cheatsEnabledValue = (0,react_facet_src.useFacetMap)(cheatsData => cheatsData.cheatsEnabled, [], [cheatsData]);
  return /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: t('.title'),
    description: t('.description'),
    disabled: cheatTabDisabled,
    gamepad: {
      index: 0
    },
    value: cheatsEnabledValue,
    onChange: cheatsEnabledCallback,
    onNarrationText: a('.narrationSuffixDisablesAchievements') + ' . ' + a('.narrationSuffixSettingsAvailable'),
    offNarrationText: (0,react_facet_src.useFacetMap)(achievementsDisabledMessages => achievementsDisabledMessages.length === 0 ? a('.narrationSuffixEnablesAchievements') : undefined, [a], [achievementsDisabledMessages])
  });
}

function CheatsTab({
  cheatsData,
  isLockedTemplate
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.cheats');
  const {
    t: t2
  } = useLocalization('CreateNewWorldSideMenu');
  const isEduFacetUnwrapped = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(isEduBuildSelector)) === true;
  const cheatSwitches = [{
    title: t('.inventoryTitle'),
    description: t('.inventoryDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.keepInventory, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.keepInventory = newValue;
    }, [], [cheatsData])
  }, {
    title: t('.mobSpawningTitle'),
    description: t('.mobSpawningDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.mobSpawning, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.mobSpawning = newValue;
    }, [], [cheatsData])
  }, {
    title: t('.mobGriefingTitle'),
    description: t('.mobGriefingDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.mobGriefing, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.mobGriefing = newValue;
    }, [], [cheatsData])
  }, {
    title: t('.entitiesDropLootTitle'),
    description: t('.entitiesDropLootDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.entitiesDropLoot, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.entitiesDropLoot = newValue;
    }, [], [cheatsData])
  }, {
    title: t('.weatherTitle'),
    description: t('.weatherDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.weather, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.weather = newValue;
    }, [], [cheatsData])
  }, {
    title: t('.commandsTitle'),
    description: t('.commandsDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.commandsEnabled, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.commandsEnabled = newValue;
    }, [], [cheatsData])
  }, {
    title: t('.commandBlocksTitle'),
    description: t('.commandBlocksDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.commandBlocks, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.commandBlocks = newValue;
    }, [], [cheatsData])
  }, {
    title: t('.educationTitle'),
    description: t('.educationDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.educationEdition, [], [cheatsData]),
    // When you are already in Minecraft Education, hide the "education edition" toggle
    hidden: isEduFacetUnwrapped,
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.educationEdition = newValue;
    }, [], [cheatsData])
  }];
  const cheatSettingsDisabled = (0,react_facet_src.useFacetMap)((cheatsData, isLockedTemplate) => !cheatsData.cheatsEnabled || isLockedTemplate, [], [cheatsData, isLockedTemplate]);
  return /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    narrationText: t2('.cheatsTabLabel')
  }, isEduFacetUnwrapped ? null : /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(CheatsEnabledSwitch, {
    cheatsData: cheatsData
  })), /*#__PURE__*/react.createElement(NarrationContext, {
    text: isEduFacetUnwrapped ? [t('.settingsTitle.edu'), t('.settingsDescription.edu.1'), t('.settingsDescription.edu.2')].join(' . ') : [t('.settingsTitle'), t('.narrationComponentTypeSectionHeader')].join(' . ')
  }, isEduFacetUnwrapped ? /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "sectionHeader",
    color: "inherit"
  }, t('.settingsTitle')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "grey"
  }, t('.settingsDescription.edu.1')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "grey"
  }, t('.settingsDescription.edu.2')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }))) : /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.settingsTitle')
  })), /*#__PURE__*/react.createElement(dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(DaylightCycleToggles, {
    disabled: cheatSettingsDisabled,
    gamepadIndex: 1,
    cheatsData: cheatsData
  })), cheatSwitches.map((option, index) => {
    return option.hidden ? null : /*#__PURE__*/react.createElement(dist.DeferredMount, {
      key: option.title
    }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
      disabledNarrationSuffix: t('.settingDisabledHint'),
      title: option.title,
      description: option.description,
      gamepad: {
        index: index + 2
      },
      disabled: cheatSettingsDisabled,
      value: option.value,
      onChange: option.onChange
    }));
  }), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(RandomTickSpeedSetting, {
    disabled: cheatSettingsDisabled,
    gamepadIndex: cheatSwitches.length + 2,
    cheatsData: cheatsData
  })))));
}
;// CONCATENATED MODULE: ./packages/react-localization/src/useLocalizationGlobal.tsx


function useLocalizationGlobal() {
  const {
    translate,
    formatDate
  } = (0,react.useContext)(LocalizationContext);
  const localization = (0,react.useMemo)(() => {
    return {
      f: {
        formatDate
      },
      gt: (key, params) => {
        var _translate;

        return (_translate = translate(key, params)) !== null && _translate !== void 0 ? _translate : key;
      }
    };
  }, [translate, formatDate]);
  return localization;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/under-construction-art-cropped.png
const under_construction_art_cropped_namespaceObject = __webpack_require__.p + "assets/under-construction-art-cropped-2afbb.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/UnderConstructionMessage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const UnderConstructionMessage = ({"emptyStateArt":"DvNo3","emptyStateArtBig":"DlMUa","emptyStateRealmsArt":"Qhp5U","emptyStateRealmsArtBig":"xjJ6b"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/ExperimentalFeaturesTab.tsx
function ExperimentalFeaturesTab_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function ExperimentalFeaturesTab_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ExperimentalFeaturesTab_ownKeys(Object(source), true).forEach(function (key) { ExperimentalFeaturesTab_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ExperimentalFeaturesTab_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ExperimentalFeaturesTab_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function ExperimentalFeaturesTab_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ExperimentalFeaturesTab_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function ExperimentalFeaturesTab_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
















 //	Remove this constant when the functionality is complete for Edit World screen

const UNDER_CONSTRUCTION_IN_EDIT_WORLD = true;

function DynamicSwitch({
  experimentalFeature,
  gamepadIndex,
  disabled
}) {
  const {
    gt
  } = useLocalizationGlobal();
  const {
    t
  } = useLocalization('CreateNewWorld.all');
  const idFacet = (0,react_facet_src.useFacetMap)(facet => facet.id, [], [experimentalFeature]);
  const idValue = (0,react_facet_src.useFacetUnwrap)(idFacet);
  const titleFacet = (0,react_facet_src.useFacetMap)(facet => facet.title, [], [experimentalFeature]);
  const titleValue = (0,react_facet_src.useFacetUnwrap)(titleFacet);
  const descriptionFacet = (0,react_facet_src.useFacetMap)(facet => facet.description, [], [experimentalFeature]);
  const descriptionValue = (0,react_facet_src.useFacetUnwrap)(descriptionFacet);
  const valueFacet = (0,react_facet_src.useFacetMap)(facet => facet.isEnabled, [], [experimentalFeature]);
  const onChange = (0,react_facet_src.useFacetCallback)((betaFeaturesToggled, experimentalFeature) => newValue => {
    if (newValue && !betaFeaturesToggled.userHasAcceptedBetaFeatures) {
      betaFeatureToggledFacet.set({
        userTriedToActivateToggle: true,
        doSetToggleValue: () => experimentalFeature.isEnabled = newValue,
        userHasAcceptedBetaFeatures: false
      });
    } else {
      experimentalFeature.isEnabled = newValue;
    }
  }, [], [betaFeatureToggledFacet, experimentalFeature]);
  const achievementsDisabledMessages = useAchievementsDisabledMessages();
  const onNarrationText = t('.narrationSuffixDisablesAchievements');
  const offNarrationText = (0,react_facet_src.useFacetMap)(achievementsDisabledMessages => achievementsDisabledMessages.length === 0 ? t('.narrationSuffixEnablesAchievements') : undefined, [t], [achievementsDisabledMessages]);
  return idValue != null ? /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: titleValue !== react_facet_src.NO_VALUE ? gt(titleValue) : '',
    description: descriptionValue !== react_facet_src.NO_VALUE ? gt(descriptionValue) : '',
    gamepad: {
      index: gamepadIndex
    },
    value: valueFacet,
    disabled: disabled,
    onChange: onChange,
    onNarrationText: onNarrationText,
    offNarrationText: offNarrationText
  }) : null;
}

function DynamicSwitchList({
  item,
  index
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.experimentalFeatures');
  const sectionNarration = (0,react_facet_src.useFacetMap)(({
    description,
    numOfSections,
    title
  }) => {
    const enumeration = numOfSections > 1 ? t('.sectionEnumeration', [`${index}`, `${numOfSections}`]) : null;
    return [title, t('.narrationComponentTypeSectionHeader'), enumeration, description].filter(x => x).join(' . ');
  }, [t, index], [item]);
  const title = (0,react_facet_src.useFacetMap)(({
    title
  }) => title, [], [item]);
  const description = (0,react_facet_src.useFacetMap)(({
    description
  }) => description, [], [item]);
  const disabled = (0,react_facet_src.useFacetMap)(({
    disabled
  }) => disabled, [], [item]);
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: sectionNarration
  }, /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: index
  }, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: title,
    description: description
  })), /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: (0,react_facet_src.useFacetMap)(({
      features
    }) => features, [], [item])
  }, (dynamicSwitch, index) => /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(DynamicSwitch, {
    experimentalFeature: dynamicSwitch,
    gamepadIndex: index,
    disabled: disabled
  })))));
}

const sections = [{
  title: '.gameplayTitle',
  description: '.gameplayDescription',
  featuresFilter: feature => feature.category === ExperimentalFeatureCategory.GAMEPLAY
}, {
  title: '.addOnCreatorsTitle',
  description: '.addOnCreatorsDescription',
  featuresFilter: feature => feature.category === ExperimentalFeatureCategory.ADD_ON_CREATORS
}, {
  title: '.internalTestsTitle',
  description: '.internalTestsDescription',
  featuresFilter: feature => feature.category === ExperimentalFeatureCategory.INTERNAL_TESTS
}];

const ExperimentsUnderConstruction = () => {
  const {
    t
  } = useLocalization('CreateNewWorld.experimentalFeatures'); // To enable a bigger image size on bigger devices

  const breakpoint = useWindowBreakpoint(102);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 0,
    floating: true
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    title: t('.underConstruction.title'),
    imgSrc: under_construction_art_cropped_namespaceObject,
    imgClass: breakpoint === 'narrow' ? UnderConstructionMessage.emptyStateArt : UnderConstructionMessage.emptyStateArtBig
  })));
};

function ExperimentalFeaturesTab({
  isLockedTemplate,
  experimentsData
}) {
  const editingWorld = (0,react.useContext)(WorldModeContext) === 'edit';
  const {
    t
  } = useLocalization('CreateNewWorld.experimentalFeatures');
  const {
    t: t2
  } = useLocalization('CreateNewWorldSideMenu');
  const isTrialAccountFacet = (0,react_facet_src.useSharedFacet)(isTrialAccountSelector);
  const experimentsDisabled = (0,react_facet_src.useFacetMap)((isLockedTemplate, isTrialAccount) => isLockedTemplate || isTrialAccount, [], [isLockedTemplate, isTrialAccountFacet]);
  const dynamicSwitchListsFacet = (0,react_facet_src.useFacetMemo)((experimentsDisabled, experimentsData) => sections // Map the features to each section
  .map((_ref) => {
    let {
      featuresFilter
    } = _ref,
        section = ExperimentalFeaturesTab_objectWithoutProperties(_ref, ["featuresFilter"]);

    return ExperimentalFeaturesTab_objectSpread(ExperimentalFeaturesTab_objectSpread({}, section), {}, {
      features: filter(experimentsData, featuresFilter)
    });
  }) // Filter out empty sections
  .filter(({
    features
  }) => features.length > 0) // Add the number of populated sections, disabled state and localizations
  .map((_ref2, index, {
    length
  }) => {
    let {
      title,
      description
    } = _ref2,
        filteredSection = ExperimentalFeaturesTab_objectWithoutProperties(_ref2, ["title", "description"]);

    return ExperimentalFeaturesTab_objectSpread(ExperimentalFeaturesTab_objectSpread({}, filteredSection), {}, {
      description: t(description),
      disabled: experimentsDisabled,
      numOfSections: length,
      title: t(title)
    });
  }), [t], [experimentsDisabled, experimentsData]);
  return /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, UNDER_CONSTRUCTION_IN_EDIT_WORLD && editingWorld ? /*#__PURE__*/react.createElement(ExperimentsUnderConstruction, null) : /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    experimentsWarningEnabled: true,
    narrationText: t2('.experimentalFeaturesTabLabel')
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: dynamicSwitchListsFacet
  }, (item, index) => /*#__PURE__*/react.createElement(DynamicSwitchList, {
    item: item,
    index: index
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/ExperimentalFeaturesActivationWarningModal.tsx






const {
  FontWeight: ExperimentalFeaturesActivationWarningModal_FontWeight
} = Typography_Typography;
const CANCEL_BUTTON_ALIAS = 'cnw-bfw-cancel';
function ExperimentalFeaturesActivationWarningModal() {
  const {
    t
  } = useLocalization('CreateNewWorld.experimentalFeatures');
  const experimentalFeatureToggled = (0,react_facet_src.useFacetUnwrap)(betaFeatureToggledFacet);
  const userTriedToActivateToggle = experimentalFeatureToggled !== react_facet_src.NO_VALUE && experimentalFeatureToggled.userTriedToActivateToggle;
  const userHasAcceptedExperimentalFeaturesWarning = experimentalFeatureToggled !== react_facet_src.NO_VALUE && experimentalFeatureToggled.userHasAcceptedBetaFeatures;
  const showModal = userTriedToActivateToggle && !userHasAcceptedExperimentalFeaturesWarning;

  const resetBetaFeatureToggle = () => {
    betaFeatureToggledFacet.set({
      userTriedToActivateToggle: false,
      doSetToggleValue: () => {},
      userHasAcceptedBetaFeatures: false
    });
  };

  const doSetToggleValue = experimentalFeatureToggled !== react_facet_src.NO_VALUE ? experimentalFeatureToggled.doSetToggleValue : () => {};
  const descI = t('.activateExperimentsConfirmationDescriptionPart1');
  const descII = t('.activateExperimentsConfirmationDescriptionPart2');
  return /*#__PURE__*/react.createElement(react.Fragment, null, showModal && /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CANCEL_BUTTON_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: resetBetaFeatureToggle
  }, t('.activateExperimentsConfirmationTitle')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${descI}. ${descII}`,
    spaceBetweenParagraphs: 5,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong"
  }, descI), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    fontWeight: ExperimentalFeaturesActivationWarningModal_FontWeight.Bold
  }, descII))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: 'primary',
    gamepadIndex: 0,
    gamepadAlias: CANCEL_BUTTON_ALIAS,
    inputLegend: t('.activateExperimentsConfirmationCancelInputLegend'),
    onClick: resetBetaFeatureToggle
  }, t('.activateExperimentsConfirmationCancel')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.activateExperimentsConfirmationConfirmInputLegend'),
    onClick: () => {
      doSetToggleValue();
      betaFeatureToggledFacet.set({
        userTriedToActivateToggle: false,
        doSetToggleValue: () => {},
        userHasAcceptedBetaFeatures: true
      });
    }
  }, t('.activateExperimentsConfirm')))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/AdvancedTab.tsx













const CHUNK_BLOCK_SIZE = 16;
function AdvancedTab({
  advancedSettings,
  isLockedTemplate
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.advanced');
  const {
    t: t2
  } = useLocalization('CreateNewWorldSideMenu');
  const {
    t: t3
  } = useLocalization('CreateNewWorld.cheats');
  const {
    t: a
  } = useLocalization('CreateNewWorld.all');
  const mode = (0,react.useContext)(WorldModeContext);
  const isEditWorld = mode === 'edit';
  const historyAPI = RouteHistory_useRouteHistory();
  const cheatSettings = (0,react_facet_src.useSharedFacet)(cheatsSettingsSelector);
  const clipboard = (0,react_facet_src.useSharedFacet)(clipboardFacet);
  const createNewWorld = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const isRandomSeedAllowed = (0,react_facet_src.useFacetMap)(facet => facet.isRandomSeedAllowed, [], [createNewWorld]);
  const isUsingTemplate = (0,react_facet_src.useSharedFacet)(isUsingTemplateSelector);
  const isTrialAccount = (0,react_facet_src.useSharedFacet)(isTrialAccountSelector);
  const isEditorWorldFacet = (0,react_facet_src.useSharedFacet)(isEditorWorldSelector);
  const isUsingTemplateOrTrialAccount = (0,react_facet_src.useFacetMap)((isUsingTemplate, isTrialAccount) => isUsingTemplate || isTrialAccount, [], [isUsingTemplate, isTrialAccount]);
  const isSeedChangeLocked = (0,react_facet_src.useFacetMap)((isTrialAccount, isUsingTemplate, isRandomSeedAllowed) => isTrialAccount || isUsingTemplate && !isRandomSeedAllowed, [], [isTrialAccount, isUsingTemplate, isRandomSeedAllowed]);
  const isUsingTemplateOrEditWorld = (0,react_facet_src.useFacetMap)(isUsingTemplate => isUsingTemplate || isEditWorld, [isEditWorld], [isUsingTemplate]);
  const isUsingTemplateOrTrialAccountOrEditWorld = (0,react_facet_src.useFacetMap)((isUsingTemplate, isTrialAccount) => isUsingTemplate || isTrialAccount || isEditWorld, [isEditWorld], [isUsingTemplate, isTrialAccount]);
  const showSeedTemplates = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(isEduBuild => !isEduBuild, [], [(0,react_facet_src.useSharedFacet)(isEduBuildSelector)])) === true;
  const simulationDistanceDisabled = (0,react_facet_src.useFacetMap)(({
    simulationDistanceOptions
  }) => simulationDistanceOptions.length <= 1, [], [(0,react_facet_src.useSharedFacet)(simulationDistanceFacet)]);
  const achievementsDisabledMessages = useAchievementsDisabledMessages();
  const eduCheatSettingsDisabled = (0,react_facet_src.useFacetMap)((cheatSettings, isLockedTemplate) => !cheatSettings.cheatsEnabled || isLockedTemplate, [], [cheatSettings, isLockedTemplate]);
  const advancedSwitches = [{
    title: t('.useFlatWorldTitle'),
    description: t('.useFlatWorldDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.useFlatWorld, [], [advancedSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedSettings => newValue => {
      advancedSettings.useFlatWorld = newValue;
    }, [], [advancedSettings]),
    onNarrationText: a('.narrationSuffixDisablesAchievements'),
    offNarrationText: (0,react_facet_src.useFacetMap)(achievementsDisabledMessages => achievementsDisabledMessages.length === 0 ? a('.narrationSuffixEnablesAchievements') : undefined, [a], [achievementsDisabledMessages]),
    disabled: isUsingTemplateOrTrialAccountOrEditWorld
  }, {
    title: t('.startWithMapTitle'),
    description: t('.startWithMapDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.startWithMap, [], [advancedSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedSettings => newValue => {
      advancedSettings.startWithMap = newValue;
    }, [], [advancedSettings]),
    disabled: isUsingTemplateOrEditWorld
  }, {
    title: t('.bonusChestTitle'),
    description: t('.bonusChestDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.bonusChest, [], [advancedSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedSettings => newValue => {
      advancedSettings.bonusChest = newValue;
    }, [], [advancedSettings]),
    disabled: isUsingTemplateOrTrialAccountOrEditWorld
  }];
  const advancedExportSettingsSwitches = [{
    title: t('.showCoordinatesTitle'),
    description: t('.showCoordinatesDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.showCoordinates, [], [advancedSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedSettings => newValue => {
      advancedSettings.showCoordinates = newValue;
    }, [], [advancedSettings]),
    disabled: isTrialAccount,
    onNarrationText: t('.showCoordinatesDescription')
  }, {
    title: t('.firesSpreadsTitle'),
    description: t('.firesSpreadsDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.firesSpreads, [], [advancedSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedSettings => newValue => {
      advancedSettings.firesSpreads = newValue;
    }, [], [advancedSettings]),
    disabled: isTrialAccount,
    onNarrationText: t('.firesSpreadsDescription')
  }, {
    title: t('.tntExplodesTitle'),
    description: t('.tntExplodesDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.tntExplodes, [], [advancedSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedSettings => newValue => {
      advancedSettings.tntExplodes = newValue;
    }, [], [advancedSettings]),
    disabled: isTrialAccount,
    onNarrationText: t('.tntExplodesDescription')
  }, {
    title: t('.respawnBlocksExplodeTitle'),
    description: t('.respawnBlocksExplodeDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.respawnBlocksExplode, [], [advancedSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedSettings => newValue => {
      advancedSettings.respawnBlocksExplode = newValue;
    }, [], [advancedSettings]),
    disabled: isTrialAccount,
    onNarrationText: t('.respawnBlocksExplodeDescription')
  }, {
    title: t('.mobLootTitle'),
    description: t('.mobLootDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.mobLoot, [], [advancedSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedSettings => newValue => {
      advancedSettings.mobLoot = newValue;
    }, [], [advancedSettings]),
    disabled: isTrialAccount,
    onNarrationText: t('.mobLootDescription')
  }, {
    title: t('.naturalRegenerationTitle'),
    description: t('.naturalRegenerationDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.naturalRegeneration, [], [advancedSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedSettings => newValue => {
      advancedSettings.naturalRegeneration = newValue;
    }, [], [advancedSettings]),
    disabled: isTrialAccount,
    onNarrationText: t('.naturalRegenerationDescription')
  }, {
    title: t('.tileDropsTitle'),
    description: t('.tileDropsDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.tileDrops, [], [advancedSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedSettings => newValue => {
      advancedSettings.tileDrops = newValue;
    }, [], [advancedSettings]),
    disabled: isTrialAccount,
    onNarrationText: t('.tileDropsDescription')
  }, {
    title: t('.immediateRespawnTitle'),
    description: t('.immediateRespawnDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.immediateRespawn, [], [advancedSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedSettings => newValue => {
      advancedSettings.immediateRespawn = newValue;
    }, [], [advancedSettings]),
    disabled: isTrialAccount,
    onNarrationText: t('.immediateRespawnDescription')
  }];
  const eduAdvancedSwitches = [{
    title: t3('.inventoryTitle'),
    description: t3('.inventoryDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.keepInventory, [], [cheatSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(createNewWorld => newValue => {
      createNewWorld.worldCreationData.cheats.keepInventory = newValue;
    }, [], [createNewWorld])
  }, {
    title: t3('.mobSpawningTitle'),
    description: t3('.mobSpawningDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.mobSpawning, [], [cheatSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(createNewWorld => newValue => {
      createNewWorld.worldCreationData.cheats.mobSpawning = newValue;
    }, [], [createNewWorld])
  }, {
    title: t3('.mobGriefingTitle'),
    description: t3('.mobGriefingDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.mobGriefing, [], [cheatSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(createNewWorld => newValue => {
      createNewWorld.worldCreationData.cheats.mobGriefing = newValue;
    }, [], [createNewWorld])
  }, {
    title: t3('.entitiesDropLootTitle'),
    description: t3('.entitiesDropLootDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.entitiesDropLoot, [], [cheatSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(createNewWorld => newValue => {
      createNewWorld.worldCreationData.cheats.entitiesDropLoot = newValue;
    }, [], [createNewWorld])
  }, {
    title: t3('.weatherTitle'),
    description: t3('.weatherDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.weather, [], [cheatSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(createNewWorld => newValue => {
      createNewWorld.worldCreationData.cheats.weather = newValue;
    }, [], [createNewWorld])
  }];
  const simulationDistanceTogglesDisabled = (0,react_facet_src.useFacetMap)((simulationDistanceDisabled, isLockedTemplate) => simulationDistanceDisabled || isLockedTemplate, [], [simulationDistanceDisabled, isLockedTemplate]);
  const seedTemplateValue = (0,react_facet_src.useFacetMap)(value => value.worldSeed, [], [advancedSettings]);
  const onSeedValueChange = (0,react_facet_src.useFacetCallback)(createNewWorld => newValue => {
    // If a url is set to the world preview image, either a template or a seed template has been selected
    // If the seed template value changes the preview image should revert back to default
    if (createNewWorld.worldPreviewImagePath != null && createNewWorld.worldCreationData.advanced.worldSeed != newValue) {
      createNewWorld.worldPreviewImagePath = '';
    }

    createNewWorld.worldCreationData.advanced.worldSeed = newValue;
  }, [], [createNewWorld]);
  const copySeedTemplateValue = (0,react_facet_src.useFacetCallback)((seedTemplateValue, clipboard) => () => {
    clipboard.copyToClipboard(seedTemplateValue);
  }, [], [seedTemplateValue, clipboard]);

  const navigateToSeedTemplates = () => historyAPI.push(`/create-new-world/seed-templates`);

  const seedButtonText = isEditWorld ? t('.worldSeedCopyButton') : t('.worldSeedButton');
  const onSeedButtonClick = isEditWorld ? copySeedTemplateValue : navigateToSeedTemplates;
  const seedPlaceholder = isEditWorld ? '' : t('.worldSeedPlaceholder'); // Using this initialIndex we set different start when the advancedSwitches are moved to the bottom of the page.

  const initialIndex = isEditWorld ? 0 : advancedSwitches.length;
  return /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    narrationText: t2('.advancedTabLabel')
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isEditorWorldFacet
  }, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.projectHeader'),
    description: t('.projectDescription')
  }))), showSeedTemplates ? /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(VanillaTextField.WithButton, {
    buttonInputLegend: seedButtonText,
    buttonText: seedButtonText,
    buttonOnClick: onSeedButtonClick,
    gamepadIndex: 0,
    textDisabled: isEditWorld,
    disabled: isSeedChangeLocked,
    label: t('.worldSeedLabel'),
    description: t('.worldSeedDescription')
    /* Do not change the maxLength to a value > 1024 until bug #507491 is fixed. This to avoid issues with text input on GameCore.*/
    ,
    maxLength: 32,
    value: seedTemplateValue,
    onChange: onSeedValueChange,
    placeholder: seedPlaceholder,
    buttonNarrationHint: t('.narrationTemplatesButtonNarrationHint'),
    disabledNarrationSuffix: a('.narrationSuffixTemplateLocked')
  })) : /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(VanillaTextField, {
    gamepadIndex: 0,
    disabled: isLockedTemplate,
    label: t('.worldSeedLabel'),
    description: t('.worldSeedDescription')
    /* Do not change the maxLength to a value > 1024 until bug #507491 is fixed. This to avoid issues with text input on GameCore.*/
    ,
    maxLength: 32,
    value: seedTemplateValue,
    onChange: onSeedValueChange,
    placeholder: t('.worldSeedPlaceholder'),
    disabledNarrationSuffix: a('.narrationSuffixTemplateLocked')
  })), !isEditWorld ? advancedSwitches.map((option, index) => {
    var _option$disabled;

    return /*#__PURE__*/react.createElement(dist.DeferredMount, {
      key: option.title
    }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
      title: option.title,
      disabled: (_option$disabled = option.disabled) !== null && _option$disabled !== void 0 ? _option$disabled : isLockedTemplate,
      description: option.description,
      onChange: option.onChange,
      value: option.value,
      onNarrationText: option.onNarrationText,
      offNarrationText: option.offNarrationText,
      gamepad: {
        index: index + 1
      }
    }));
  }) : /*#__PURE__*/react.createElement(react.Fragment, null), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isEditorWorldFacet
  }, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.exportSettingsHeader'),
    description: t('.exportSettingsDescription')
  }))), advancedExportSettingsSwitches.map((option, index) => {
    var _option$disabled2;

    return /*#__PURE__*/react.createElement(dist.DeferredMount, {
      key: option.title
    }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
      title: option.title,
      disabled: (_option$disabled2 = option.disabled) !== null && _option$disabled2 !== void 0 ? _option$disabled2 : isLockedTemplate,
      description: option.description,
      onChange: option.onChange,
      value: option.value,
      gamepad: {
        index: initialIndex + 1 + index
      }
    }));
  }), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(RespawnRadius, {
    gamepadIndex: initialIndex + advancedExportSettingsSwitches.length + 1,
    label: t('.respawnRadiusLabel'),
    disabled: isUsingTemplateOrTrialAccount,
    description: t('.respawnRadiusDescription'),
    placeholder: t('.respawnRadiusPlaceholder'),
    advancedSettings: advancedSettings
  })), /*#__PURE__*/react.createElement(dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(SimulationDistanceToggles, {
    title: t('.simulationDistanceTitle'),
    gamepadIndex: initialIndex + advancedExportSettingsSwitches.length + 2,
    disabled: simulationDistanceTogglesDisabled,
    advancedSettings: advancedSettings
  })), isEditWorld ? advancedSwitches.map((option, index) => {
    var _option$disabled3;

    return /*#__PURE__*/react.createElement(dist.DeferredMount, {
      key: option.title
    }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
      title: option.title,
      disabled: (_option$disabled3 = option.disabled) !== null && _option$disabled3 !== void 0 ? _option$disabled3 : isLockedTemplate,
      description: option.description,
      onChange: option.onChange,
      value: option.value,
      onNarrationText: option.onNarrationText,
      offNarrationText: option.offNarrationText,
      gamepad: {
        index: advancedExportSettingsSwitches.length + index + 3
      }
    }));
  }) : /*#__PURE__*/react.createElement(react.Fragment, null), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useSharedFacet)(isEduBuildSelector)
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(DaylightCycleToggles, {
    disabled: eduCheatSettingsDisabled,
    gamepadIndex: initialIndex + advancedExportSettingsSwitches.length + advancedSwitches.length + 4,
    cheatsData: cheatSettings
  })), eduAdvancedSwitches.map((option, index) => {
    return /*#__PURE__*/react.createElement(dist.DeferredMount, {
      key: option.title
    }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
      title: option.title,
      disabled: eduCheatSettingsDisabled,
      description: option.description,
      onChange: option.onChange,
      value: option.value,
      gamepad: {
        index: initialIndex + advancedExportSettingsSwitches.length + advancedSwitches.length + index + 5
      }
    }));
  }), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(RandomTickSpeedSetting, {
    disabled: eduCheatSettingsDisabled,
    gamepadIndex: initialIndex + eduAdvancedSwitches.length + advancedExportSettingsSwitches.length + advancedSwitches.length + 6,
    cheatsData: cheatSettings
  }))))));
}

function SimulationDistanceToggles({
  title,
  gamepadIndex,
  disabled,
  advancedSettings
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.advanced');
  const mapDistanceOption = (0,react.useCallback)((distance, translation) => {
    return {
      label: t('.simulationDistanceOption', [`${distance}`]),
      value: distance,
      description: t(translation, [`${distance * CHUNK_BLOCK_SIZE}`, `${distance}`])
    };
  }, [t]);
  const mappedSimulationDistanceOptions = (0,react_facet_src.useFacetMap)(({
    simulationDistanceOptions
  }) => {
    const userHasChoices = simulationDistanceOptions.length > 1;
    const values = userHasChoices ? simulationDistanceOptions : [4, 6, 8];
    const translation = userHasChoices ? '.simulationDistanceDescription' : '.simulationDistanceDescriptionOnlyOne';
    return values.map(distance => mapDistanceOption(distance, translation));
  }, [mapDistanceOption], [(0,react_facet_src.useSharedFacet)(simulationDistanceFacet)]);
  const simulationDistanceSetter = (0,react_facet_src.useFacetCallback)(advancedSettings => newValue => {
    advancedSettings.simulationDistance = newValue;
  }, [], [advancedSettings]);
  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    onMountComplete: (0,dist.useNotifyMountComplete)(),
    title: title,
    gamepad: {
      index: gamepadIndex
    },
    options: mappedSimulationDistanceOptions,
    value: (0,react_facet_src.useFacetMap)(value => value.simulationDistance, [], [advancedSettings]),
    onChange: simulationDistanceSetter,
    disabled: disabled,
    wrapToggleText: true
  });
}

const DEFAULT_RESPAWN_RADIUS = 5;
const MAX_RESPAWN_RADIUS = 128;

function RespawnRadius({
  gamepadIndex,
  label,
  description,
  placeholder,
  disabled,
  advancedSettings
}) {
  const respawnRadius = (0,react_facet_src.useFacetMap)(value => value.respawnRadius.toString(), [], [advancedSettings]);
  const {
    t: a
  } = useLocalization('CreateNewWorld.all');
  const {
    t: n
  } = useLocalization('CreateNewWorld.advanced.narration');
  const {
    narrateText
  } = useNarrateText({
    interruptible: false
  });
  const setRespawnRadius = (0,react_facet_src.useFacetCallback)(advancedSettings => newValue => {
    advancedSettings.respawnRadius = newValue;
  }, [], [advancedSettings]);
  const respawnRadiusBlurHandler = (0,react.useCallback)(
  /**
   * Handler for sanitizing the input if it is less
   * than MAX_RESPAWN_RADIUS and only contains digits.
   */
  (radius, setRadius) => {
    const numbersReg = /^[0-9]*$/g;
    const isOnlyDigits = radius.match(numbersReg);
    const isWithinRange = parseInt(radius) <= MAX_RESPAWN_RADIUS;
    const isEmpty = radius.length === 0;

    if (isEmpty || !isOnlyDigits) {
      narrateText(n('.respawnRadiusInvalidValue'));
      const newValue = DEFAULT_RESPAWN_RADIUS.toString();
      setRadius(newValue);
      return TextField.ValidationResult.INVALID;
    } else if (!isWithinRange) {
      narrateText(n('.respawnRadiusNotWithinRange'));
      const newValue = MAX_RESPAWN_RADIUS.toString();
      setRadius(newValue);
      return TextField.ValidationResult.INVALID;
    }

    return TextField.ValidationResult.VALID;
  }, [narrateText, n]);
  return /*#__PURE__*/react.createElement(VanillaTextField, {
    gamepadIndex: gamepadIndex,
    label: label,
    description: description
    /* Do not change the maxLength to a value > 1024 until bug #507491 is fixed. This to avoid issues with text input on GameCore.*/
    ,
    maxLength: 8,
    value: respawnRadius,
    disabled: disabled,
    onChange: setRespawnRadius,
    onBlur: respawnRadiusBlurHandler,
    placeholder: placeholder,
    disabledNarrationSuffix: a('.narrationSuffixTemplateLocked'),
    isNumber: true
  });
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/consoles.ts

const consoles_isPlaystationPlatform = platform => platform === Platform.PS4 || platform === Platform.PS5;
const isXboxPlatform = platform => platform === Platform.XBOX;
const consoles_isNintendoPlatform = platform => platform === Platform.NX_HANDHELD || platform === Platform.NX_TV;
const isConsolePlatform = platform => isXboxPlatform(platform) || //
consoles_isNintendoPlatform(platform) || //
consoles_isPlaystationPlatform(platform);
const isWindowsPlatform = platform => platform === Platform.WIN32 || platform === Platform.UWP;
;// CONCATENATED MODULE: ./packages/gameface-hacks/src/some.ts
function some(array, predicate) {
  for (let i = 0; i < array.length; i++) {
    if (predicate(array[i])) {
      return true;
    }
  }

  return false;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/PlayerPermissionIcon.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PlayerPermissionIcon = ({"icon":"kFoCR","iconWrapper":"d8tfi"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/visitorGray10.png
const visitorGray10_namespaceObject = __webpack_require__.p + "assets/visitorGray10-9a6b6.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/visitorGray70.png
const visitorGray70_namespaceObject = __webpack_require__.p + "assets/visitorGray70-d4a9e.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/visitorGray90.png
const visitorGray90_namespaceObject = __webpack_require__.p + "assets/visitorGray90-9d4d1.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/memberGray10.png
const memberGray10_namespaceObject = __webpack_require__.p + "assets/memberGray10-7cc66.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/memberGray70.png
const memberGray70_namespaceObject = __webpack_require__.p + "assets/memberGray70-7b6db.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/memberGray90.png
const memberGray90_namespaceObject = __webpack_require__.p + "assets/memberGray90-a38ee.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/operatorGray10.png
const operatorGray10_namespaceObject = __webpack_require__.p + "assets/operatorGray10-1b749.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/operatorGray70.png
const operatorGray70_namespaceObject = __webpack_require__.p + "assets/operatorGray70-266ca.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/operatorGray90.png
const operatorGray90_namespaceObject = __webpack_require__.p + "assets/operatorGray90-0f8a3.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/PlayerPermissionIcon.tsx














const icons = {
  [createNewWorldFacet_PlayerPermissions.VISITOR]: {
    selected: visitorGray10_namespaceObject,
    unselected: visitorGray90_namespaceObject,
    disabled: visitorGray70_namespaceObject
  },
  [createNewWorldFacet_PlayerPermissions.MEMBER]: {
    selected: memberGray10_namespaceObject,
    unselected: memberGray90_namespaceObject,
    disabled: memberGray70_namespaceObject
  },
  [createNewWorldFacet_PlayerPermissions.OPERATOR]: {
    selected: operatorGray10_namespaceObject,
    unselected: operatorGray90_namespaceObject,
    disabled: operatorGray70_namespaceObject
  }
};
function PlayerPermissionIcon_PlayerPermissionIcon({
  type,
  status
}) {
  return /*#__PURE__*/react.createElement("div", {
    className: PlayerPermissionIcon.iconWrapper
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: icons[type][status],
    className: PlayerPermissionIcon.icon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/MultiplayerTab.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MultiplayerTab = ({"subscriptionImage":"BHnbR"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/images/steve-island.png
const steve_island_namespaceObject = __webpack_require__.p + "assets/steve-island-6fbc9.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/MultiplayerTab.tsx

















function MultiplayerTab_MultiplayerTab({
  multiplayerData,
  worldPacks,
  onDeactivatePack
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.multiplayer');
  const {
    t: t2
  } = useLocalization('CreateNewWorldSideMenu');
  const {
    t: a
  } = useLocalization('CreateNewWorld.all');
  const achievementsDisabledMessages = useAchievementsDisabledMessages();
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const multiplayerToggleDisabled = (0,react_facet_src.useFacetMap)((multiplayer, user) => !multiplayer.multiplayerSupported || user.isTrialAccount, [], [multiplayerData, userAccount]);
  const multiplayerDisabled = (0,react_facet_src.useFacetMap)(multiplayer => !multiplayer.multiplayerGame, [], [multiplayerData]);
  const platform = (0,react_facet_src.useFacetMap)(device => device.platform, [], [(0,react_facet_src.useSharedFacet)(deviceInformationFacet)]);
  const isEduBuild = (0,react_facet_src.useSharedFacet)(isEduBuildSelector);
  const showNintendoPromotion = (0,react_facet_src.useFacetMap)((userAccount, platform) => consoles_isNintendoPlatform(platform) && !userAccount.hasPremiumNetworkAccess, [], [userAccount, platform]);
  const showPlaystationPromotion = (0,react_facet_src.useFacetMap)((userAccount, platform) => consoles_isPlaystationPlatform(platform) && !userAccount.hasPremiumNetworkAccess, [], [userAccount, platform]); // If on a third party platform but missing premium internet access

  const premiumAccountInternetServicePromotion = (0,react_facet_src.useFacetMap)((showNintendoPromotion, showPlaystationPromotion) => showNintendoPromotion || showPlaystationPromotion, [], [showNintendoPromotion, showPlaystationPromotion]);
  const thirdPartyPlatform = (0,react_facet_src.useFacetMap)(platform => consoles_isPlaystationPlatform(platform) || consoles_isNintendoPlatform(platform), [], [platform]);
  const showLANInfo = (0,react_facet_src.useFacetMap)((thirdPartyPlatform, isEduBuild) => !thirdPartyPlatform && !isEduBuild, [], [thirdPartyPlatform, isEduBuild]);
  const showMSALogin = (0,react_facet_src.useFacetMap)((userAccount, thirdPartyPlatform) => thirdPartyPlatform && !userAccount.isLoggedInWithMicrosoftAccount, [], [userAccount, thirdPartyPlatform]);
  const disableMSALogin = (0,react_facet_src.useFacetMap)((multiplayer, multiplayerDisabled) => {
    return multiplayer.generalWarningState === GeneralMultiplayerWarningStateEnum.CHECK_INTERNET_CONNECTION || multiplayerDisabled;
  }, [], [multiplayerData, multiplayerDisabled]);
  const showPlayerAccessToggles = (0,react_facet_src.useFacetMap)((showMSALogin, isEduBuild) => !showMSALogin && !isEduBuild, [], [showMSALogin, isEduBuild]);
  const showPlatformPlayerAccessToggles = (0,react_facet_src.useFacetMap)(multiplayer => multiplayer.platformPlayerAccessSupported, [], [multiplayerData]);
  const activePacksFacet = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.active, [], [worldPacks]);
  const showMultiplayerPlatformLockedModal = MultiplayerPlatformLockedModal.useShowModal();
  const toggleMultiplayer = (0,react_facet_src.useFacetCallback)((multiplayer, activePacks) => newValue => {
    // We should always be able to disable multiplayer without any validation.
    if (!newValue) {
      return multiplayer.multiplayerGame = newValue;
    } // If they instead want to activate multiplayer we need to ensure none
    // of the active resource packs are locked to a specific platform.


    const hasPlatformLockedResourcePack = some(activePacks, pack => pack.isPlatformLocked);

    if (hasPlatformLockedResourcePack) {
      showMultiplayerPlatformLockedModal({
        multiplayerData: multiplayerData,
        activePacks: activePacksFacet,
        onDeactivatePack: onDeactivatePack
      });
    } else {
      multiplayer.multiplayerGame = newValue;
    }
  }, [showMultiplayerPlatformLockedModal, onDeactivatePack, multiplayerData, activePacksFacet], [multiplayerData, activePacksFacet]);
  const multiplayerOffNarrationText = (0,react_facet_src.useFacetMap)((multiplayer, achievementsDisabledMessages) => multiplayer.playerPermissions === createNewWorldFacet_PlayerPermissions.OPERATOR && achievementsDisabledMessages.length === 1 ? [t('.narrationMultiplayerAdditionalSettingsDisabled'), a('.narrationSuffixEnablesAchievements')].join(' . ') : t('.narrationMultiplayerAdditionalSettingsDisabled'), [t, a], [multiplayerData, achievementsDisabledMessages]);
  return /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    multiplayerWarningsEnabled: true,
    narrationText: t2('.multiplayerTabLabel')
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showNintendoPromotion
  }, /*#__PURE__*/react.createElement(NintendoSubscriptionPromotionPanel, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showPlaystationPromotion
  }, /*#__PURE__*/react.createElement(PlaystationPlusSubscriptionPromotionPanel, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: premiumAccountInternetServicePromotion,
    condition: false
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    key: t('.multiplayerGameTitle'),
    title: t('.multiplayerGameTitle'),
    description: t('.multiplayerGameDescription'),
    onNarrationText: t('.narrationMultiplayerAdditionalSettingsEnabled'),
    offNarrationText: multiplayerOffNarrationText,
    gamepad: {
      index: 0
    },
    value: (0,react_facet_src.useFacetMap)(value => value.multiplayerGame, [], [multiplayerData]),
    disabled: multiplayerToggleDisabled,
    onChange: toggleMultiplayer
  })), /*#__PURE__*/react.createElement(NarrationContext, {
    text: [t('.settingsTitle'), t('.narrationComponentTypeSectionHeader')].join(' . ')
  }, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.settingsTitle')
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showPlatformPlayerAccessToggles
  }, /*#__PURE__*/react.createElement(dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(PlatformPlayerAccessToggles, {
    gamepadIndex: 1,
    platform: platform,
    multiplayer: multiplayerData
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showMSALogin
  }, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(MSALogin, {
    gamepadIndex: 2,
    disabled: disableMSALogin
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showPlayerAccessToggles
  }, /*#__PURE__*/react.createElement(dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(PlayerAccessToggles, {
    gamepadIndex: 2,
    disabled: multiplayerDisabled,
    multiplayer: multiplayerData
  }))), /*#__PURE__*/react.createElement(dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(PlayerPermissionsToggles, {
    gamepadIndex: 3,
    disabled: multiplayerDisabled,
    multiplayer: multiplayerData
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showLANInfo
  }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    key: t('.visibleToLanPlayersTitle'),
    title: t('.visibleToLanPlayersTitle'),
    description: t('.visibleToLanPlayersDescription'),
    disabledNarrationSuffix: t('.multiplayerSettingsDisabledNarrationHint'),
    gamepad: {
      index: 4
    },
    disabled: multiplayerDisabled,
    value: (0,react_facet_src.useFacetMap)(value => value.visibleToLanPlayers, [], [multiplayerData]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.visibleToLanPlayers = newValue;
    }, [], [multiplayerData])
  })), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    key: t('.friendlyFireTitle'),
    title: t('.friendlyFireTitle'),
    description: t('.friendlyFireDescription'),
    disabledNarrationSuffix: t('.multiplayerSettingsDisabledNarrationHint'),
    gamepad: {
      index: 5
    },
    disabled: multiplayerDisabled,
    value: (0,react_facet_src.useFacetMap)(value => value.friendlyFire, [], [multiplayerData]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.friendlyFire = newValue;
    }, [], [multiplayerData])
  })))))));
}

function PlatformPlayerAccessToggles({
  platform,
  gamepadIndex,
  multiplayer
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.multiplayer');
  const platformPlayerAccessDisabled = (0,react_facet_src.useFacetMap)(multiplayer => !multiplayer.platformPlayerAccessEnabled || !multiplayer.multiplayerGame, [], [multiplayer]);
  const platformPlayerToggleOptions = (0,react_facet_src.useFacetMemo)((multiplayer, platform) => getPlatformPlayerAccessToggleOptions(multiplayer, platform, t), [t], [multiplayer, platform]); // TODO: Stop unwrapping when underlying components have been updated to accept facet strings

  const platformPlayerAccessTitle = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMemo)(platform => consoles_isNintendoPlatform(platform) ? t('.nintendoPlayerAccessTitle') : consoles_isPlaystationPlatform(platform) ? t('.playstationPlayerAccessTitle') : t('.playerAccessTitle'), [t], [platform]));
  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    onMountComplete: (0,dist.useNotifyMountComplete)(),
    title: platformPlayerAccessTitle === react_facet_src.NO_VALUE ? t('.playerAccessTitle') : platformPlayerAccessTitle,
    gamepad: {
      index: gamepadIndex
    },
    disabled: platformPlayerAccessDisabled,
    wrapToggleText: true,
    options: platformPlayerToggleOptions,
    value: (0,react_facet_src.useFacetMap)(value => value.platformPlayerAccess, [], [multiplayer]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.platformPlayerAccess = newValue;
    }, [], [multiplayer])
  });
}

function PlayerAccessToggles({
  disabled,
  gamepadIndex,
  multiplayer
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.multiplayer');
  const platformPlayerAccessSupported = (0,react_facet_src.useFacetMap)(multiplayer => multiplayer.platformPlayerAccessSupported, [], [multiplayer]);
  const title = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMemo)(platformPlayerAccessSupported => // If you're on a third party, prefix with "Microsoft" to make it clearer for the user
  platformPlayerAccessSupported ? t('.microsoftPlayerAccessTitle') : t('.playerAccessTitle'), [t], [platformPlayerAccessSupported]));
  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    disabledNarrationSuffix: t('.multiplayerSettingsDisabledNarrationHint'),
    onMountComplete: (0,dist.useNotifyMountComplete)(),
    title: title !== react_facet_src.NO_VALUE ? title : t('.playerAccessTitle'),
    gamepad: {
      index: gamepadIndex
    },
    disabled: disabled,
    wrapToggleText: true,
    options: [{
      label: t('.playerAccessInvitedLabel'),
      value: PlayerAccess.INVITED,
      description: t('.playerAccessInvitedDescription')
    }, {
      label: t('.playerAccessFriendsLabel'),
      value: PlayerAccess.FRIENDS,
      description: t('.playerAccessFriendsDescription')
    }, {
      label: t('.playerAccessFriendsOfFriendsLabel'),
      value: PlayerAccess.FRIENDS_OF_FRIENDS,
      description: t('.playerAccessFriendsOfFriendsDescription')
    }],
    value: (0,react_facet_src.useFacetMap)(value => value.playerAccess, [], [multiplayer]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.playerAccess = newValue;
    }, [], [multiplayer])
  });
}

function PlayerPermissionsToggles({
  gamepadIndex,
  disabled,
  multiplayer
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.multiplayer');
  const {
    t: a
  } = useLocalization('CreateNewWorld.all');
  const achievementsDisabledMessages = useAchievementsDisabledMessages();
  const options = (0,react_facet_src.useFacetMap)((multiplayer, achievementDisabledMessages) => [{
    label: t('.playerPermissionsVisitorLabel'),
    value: createNewWorldFacet_PlayerPermissions.VISITOR,
    description: t('.playerPermissionsVisitorDescription'),
    icons: {
      disabled: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: createNewWorldFacet_PlayerPermissions.VISITOR,
        status: 'disabled'
      }),
      selected: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: createNewWorldFacet_PlayerPermissions.VISITOR,
        status: 'selected'
      }),
      unselected: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: createNewWorldFacet_PlayerPermissions.VISITOR,
        status: 'unselected'
      })
    },
    narrationSuffix: multiplayer.playerPermissions === createNewWorldFacet_PlayerPermissions.OPERATOR && achievementDisabledMessages.length === 1 ? a('.narrationSuffixEnablesAchievements') : undefined
  }, {
    label: t('.playerPermissionsMemberLabel'),
    value: createNewWorldFacet_PlayerPermissions.MEMBER,
    description: t('.playerPermissionsMemberDescription'),
    icons: {
      disabled: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: createNewWorldFacet_PlayerPermissions.MEMBER,
        status: 'disabled'
      }),
      selected: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: createNewWorldFacet_PlayerPermissions.MEMBER,
        status: 'selected'
      }),
      unselected: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: createNewWorldFacet_PlayerPermissions.MEMBER,
        status: 'unselected'
      })
    },
    narrationSuffix: multiplayer.playerPermissions === createNewWorldFacet_PlayerPermissions.OPERATOR && achievementDisabledMessages.length === 1 ? a('.narrationSuffixEnablesAchievements') : undefined
  }, {
    label: t('.playerPermissionsOperatorLabel'),
    value: createNewWorldFacet_PlayerPermissions.OPERATOR,
    description: t('.playerPermissionsOperatorDescription'),
    icons: {
      disabled: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: createNewWorldFacet_PlayerPermissions.OPERATOR,
        status: 'disabled'
      }),
      selected: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: createNewWorldFacet_PlayerPermissions.OPERATOR,
        status: 'selected'
      }),
      unselected: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: createNewWorldFacet_PlayerPermissions.OPERATOR,
        status: 'unselected'
      })
    },
    narrationSuffix: a('.narrationSuffixDisablesAchievements')
  }], [t, a], [multiplayer, achievementsDisabledMessages]);
  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    disabledNarrationSuffix: t('.multiplayerSettingsDisabledNarrationHint'),
    onMountComplete: (0,dist.useNotifyMountComplete)(),
    title: t('.playerPermissionsTitle'),
    gamepad: {
      index: gamepadIndex
    },
    disabled: disabled,
    options: options,
    value: (0,react_facet_src.useFacetMap)(value => value.playerPermissions, [], [multiplayer]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.playerPermissions = newValue;
    }, [], [multiplayer])
  });
}
/**
 * Returns the Toggles options for alternative multiplayer platforms (PS & Nintendo).
 */


function getPlatformPlayerAccessToggleOptions(multiplayer, platform, t) {
  const toggles = [];

  if (multiplayer.platformPlayerInviteAccessSupported && !consoles_isNintendoPlatform(platform) && !consoles_isPlaystationPlatform(platform)) {
    toggles.push({
      label: t('.playerAccessInvitedLabel'),
      value: PlayerAccess.INVITED,
      description: consoles_isNintendoPlatform(platform) ? t('.nintendoPlayerAccessInvitedDescription') : consoles_isPlaystationPlatform(platform) ? t('.playstationPlayerAccessInvitedDescription') : t('.playerAccessInvitedDescription')
    });
  }

  toggles.push({
    label: t('.playerAccessFriendsLabel'),
    value: PlayerAccess.FRIENDS,
    description: consoles_isNintendoPlatform(platform) ? t('.nintendoPlayerAccessFriendsDescription') : consoles_isPlaystationPlatform(platform) ? t('.playstationPlayerAccessFriendsDescription') : t('.playerAccessFriendsDescription')
  });
  toggles.push({
    label: t('.playerAccessFriendsOfFriendsLabel'),
    value: PlayerAccess.FRIENDS_OF_FRIENDS,
    description: consoles_isNintendoPlatform(platform) ? t('.nintendoPlayerAccessFriendsOfFriendsDescription') : consoles_isPlaystationPlatform(platform) ? t('.playstationPlayerAccessFriendsOfFriendsDescription') : t('.playerAccessFriendsOfFriendsDescription')
  });
  return toggles;
}

function NintendoSubscriptionPromotionPanel() {
  const {
    t
  } = useLocalization('CreateNewWorld.multiplayer');
  return /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    borderless: true,
    gamepadIndex: 0,
    title: t('.nintendoSubscriptionPromotionTitle'),
    text: t('.nintendoSubscriptionPromotionBody'),
    imgSrc: steve_island_namespaceObject,
    imgClass: MultiplayerTab.subscriptionImage,
    buttons: [{
      text: t('.nintendoSubscriptionPromotionButtonLabel'),
      onClick: (0,react_facet_src.useFacetCallback)(facet => () => facet.showPremiumNetworkUpsellModal(), [], [(0,react_facet_src.useSharedFacet)(userAccountFacet)]),
      inputLegend: t('.nintendoSubscriptionPromotionButtonLabel')
    }]
  });
}

function PlaystationPlusSubscriptionPromotionPanel() {
  const {
    t
  } = useLocalization('CreateNewWorld.multiplayer');
  return /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    borderless: true,
    gamepadIndex: 0,
    title: t('.playStationPlusSubscriptionPromotionTitle'),
    text: t('.playStationPlusSubscriptionPromotionBody'),
    imgSrc: steve_island_namespaceObject,
    imgClass: MultiplayerTab.subscriptionImage
  });
}

function MSALogin({
  gamepadIndex,
  disabled
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.multiplayer');
  const showMSASignInScreen = (0,react_facet_src.useFacetCallback)(userAccount => () => userAccount.showMicrosoftAccountLogInScreen(PostSignInAction.DO_NOTHING), [], [(0,react_facet_src.useSharedFacet)(userAccountFacet)]);
  return /*#__PURE__*/react.createElement(Panel_Panel, null, /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, null, t('.microsoftSignInButtonTitle')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.microsoftSignInButtonLabel'),
    onClick: showMSASignInScreen,
    gamepadIndex: gamepadIndex,
    disabled: disabled
  }, t('.microsoftSignInButtonLabel')));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackTabs/PackTabs.tsx






const PackTabs = props => {
  const {
    gamepadAliasNamespace,
    path
  } = props;
  const {
    t
  } = useLocalization('PackTabs');
  const historyAPI = RouteHistory_useRouteHistory();
  const mode = (0,react.useContext)(WorldModeContext);
  const isEditWorld = mode === 'edit';
  const params = useRouteParams(); // worldTemplateId used as placeholder for active|available filter param

  const tabs = [{
    label: t('.activeTabButtonLabel'),
    value: 'active'
  }, {
    label: t('.availableTabButtonLabel'),
    value: 'available'
  }];
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  const prefix = isEditWorld ? `edit-world/${params.id}` : `create-new-world`;
  return /*#__PURE__*/react.createElement(TabBar_TabBar, {
    gamepadAliasNamespace: gamepadAliasNamespace,
    gamepadIndex: 1,
    value: params.worldTemplateId // active|available
    ,
    onChange: newValue => {
      setFocusedId(TabBar_TabBar.getFocusAlias(gamepadAliasNamespace, newValue));
      historyAPI.replaceKeepingFocus(`/${prefix}/${path}/${newValue}`);
    },
    tabs: tabs,
    enableGamepadShortcuts: params.tab === path
  });
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackTabs/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackTabWrapper/PackTabWrapper.tsx








/**
 * Wrapper component that uses the route status to decide if the Tab component
 * should be rendered or not.
 */
function PackTabWrapper({
  component,
  filter,
  gamepadIndex
}) {
  const params = useRouteParams();
  const visible = params.worldTemplateId === filter;
  const parentRouteActive = useRouteActive();
  const active = (0,react_facet_src.useFacetMap)(parentRouteActive => visible && parentRouteActive, [visible], [parentRouteActive]);
  return /*#__PURE__*/react.createElement(RouteActiveProvider, {
    active: active
  }, /*#__PURE__*/react.createElement(Row, {
    shouldSkipLandmarkInVisual: true,
    options: {
      index: gamepadIndex,
      disabled: !visible
    }
  }, /*#__PURE__*/react.createElement(RouteInstantTransition_RouteInstantTransition, {
    visible: visible,
    contentComponent: component,
    unmountOnExit: false,
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingDelay, {
      type: "contentful",
      renderingCompleted: isContentShown
    })
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackTabWrapper/index.ts

;// CONCATENATED MODULE: ./packages/gameface-hacks/src/map.ts
// Temporary hack until Gameface supports `map` on ChakraCore on iOS.
//
// Differs from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
// in that it does not accept a `thisArg` parameters, and the input and output arrays are of type T[] and
// T2[] respectively.
function map(array, f) {
  const result = [];

  for (let i = 0; i < array.length; i++) {
    result[i] = f(array[i], i, array);
  }

  return result;
}
;// CONCATENATED MODULE: ./packages/gameface-hacks/src/every.ts
function every(array, predicate) {
  for (let i = 0; i < array.length; i++) {
    if (!predicate(array[i], i)) {
      return false;
    }
  }

  return true;
}
;// CONCATENATED MODULE: ./packages/react-dnd/src/useDrag.ts



function useDrag({
  id,
  data,
  index,
  ref,
  pointerAxisLock,
  onDragStart,
  disabled,
  gamepadDragXOffsetPx,
  gamepadDragYOffsetPx
}) {
  const api = useDragAndDropProviderApi();
  const draggableStatesFacet = useDraggableStatesFacet();
  const dragStateFacet = (0,react_facet_src.useFacetMap)(draggableStates => draggableStates[id], [id], [(0,react_facet_src.useFacetWrap)(draggableStatesFacet !== null && draggableStatesFacet !== void 0 ? draggableStatesFacet : {})]);
  (0,react.useEffect)(() => {
    if (api == null) return;
    if (disabled == true) return; // Register draggable and get reference to state facet.

    api.addDraggable({
      id,
      index,
      data,
      ref,
      pointerAxisLock,
      onDragStart,
      gamepadDragXOffsetPx,
      gamepadDragYOffsetPx
    });
    return () => {
      api.removeDraggable(id);
    };
  }, [id, data, api, ref, index, pointerAxisLock, onDragStart, gamepadDragXOffsetPx, gamepadDragYOffsetPx, disabled]);
  const onGamepadDirectionPress = (0,react_facet_src.useFacetCallback)(state => direction => {
    if (state.dragging == 'gamepad' && api != null) {
      if (direction === 'up' || direction == 'down') {
        api.focusDragMove(direction);
      }
    }

    return state.dragging != false ? true : false;
  }, [api], [dragStateFacet]);
  const onMouseDown = (0,react.useCallback)(event => {
    if (api == null || event == null) return; // @TODO research if it can be TouchEvent

    const {
      clientX,
      clientY
    } = event.clientX != null ? event : event.touches[0];

    if (onDragStart) {
      onDragStart(() => {
        api.pointerDragStart(id, clientX, clientY);
      });
    } else {
      api.pointerDragStart(id, clientX, clientY);
    }
  }, [api, id, onDragStart]);
  const onGamepadClick = (0,react.useCallback)(() => {
    if (api == null) return;

    if (onDragStart) {
      onDragStart(() => {
        api.focusDragToggle(id);
      });
    } else {
      api.focusDragToggle(id);
    }
  }, [api, onDragStart, id]);
  const handlers = (0,react.useMemo)(() => ({
    onMouseDown,
    onGamepadClick,
    onUp: () => onGamepadDirectionPress('up') === true,
    onDown: () => onGamepadDirectionPress('down') === true,
    onLeft: () => onGamepadDirectionPress('left') === true,
    onRight: () => onGamepadDirectionPress('right') === true
  }), [onMouseDown, onGamepadClick, onGamepadDirectionPress]);
  return {
    dragStateFacet,
    handlers
  };
}
;// CONCATENATED MODULE: ./packages/react-dnd/src/useDrop.ts



function useDrop({
  id,
  index,
  ref,
  data,
  disabled,
  onDrop
}) {
  const api = useDragAndDropProviderApi();
  const droppableStatesFacet = useDroppableStatesFacet();
  const stateFacet = (0,react_facet_src.useFacetMap)(droppableStates => droppableStates[id] != null ? droppableStates[id] : {}, [id], [(0,react_facet_src.useFacetWrap)(droppableStatesFacet !== null && droppableStatesFacet !== void 0 ? droppableStatesFacet : {})]);
  (0,react.useEffect)(() => {
    if (api == null) return;
    if (disabled == true) return;
    api.addDroppable({
      id,
      index,
      ref,
      data,
      onDrop
    });
    return () => {
      api.removeDroppable(id);
    };
  }, [id, index, ref, data, onDrop, api, disabled]);
  return stateFacet;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/draggable-icon.png
const draggable_icon_namespaceObject = __webpack_require__.p + "assets/draggable-icon-bcf37.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/arrow-down.png
const arrow_down_namespaceObject = __webpack_require__.p + "assets/arrow-down-cf46b.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/remove-icon.png
const remove_icon_namespaceObject = __webpack_require__.p + "assets/remove-icon-5a112.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/settings-icon.png
const settings_icon_namespaceObject = __webpack_require__.p + "assets/settings-icon-af819.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/add-icon.png
const add_icon_namespaceObject = __webpack_require__.p + "assets/add-icon-675d0.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/mario_pack_icon_HACK.png
const mario_pack_icon_HACK_namespaceObject = __webpack_require__.p + "assets/mario_pack_icon_HACK-36558.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/missing-pack-icon.png
const missing_pack_icon_namespaceObject = __webpack_require__.p + "assets/missing-pack-icon-0a761.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/PackListItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PackListItem = ({"packListItemDragAnimationContainer":"K_ftf","packImage":"jkWPs","draggableIcon":"yh9nh","expandArrowIcon":"ZVibx","flipped":"s7QSb","settingsIcon":"RvsYq","removeIcon":"jrqnD","addIcon":"v5aeN","expandableWrapper":"KpUwY","expanded":"ZFmh4","expandableContent":"S0c54","expandableContentWrapper":"cDMTw","expandableContentDescription":"emj3l","expandableContentLinksWrapper":"H2ovu"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/hooks/useExpandable.ts

 // Can't set to exact zero due to Gameface bug with scrollHeight. Ticket here: https://coherentlabs.zendesk.com/hc/en-us/requests/19103

const GAMEFACE_ZERO = '0.0001px';
function useExpandable(expanded) {
  const contentRef = (0,react.useRef)(null);
  const expandedFacet = (0,react_facet_src.useFacetWrap)(expanded);
  const [height, setHeight] = (0,react_facet_src.useFacetState)(GAMEFACE_ZERO);
  const [overflow, setOverflow] = (0,react_facet_src.useFacetState)('hidden');
  (0,react_facet_src.useFacetEffect)(isExpanded => {
    if (!contentRef.current) return; // When we are running screenshot tests we don't want to wait for the timeout.

    if (false) {}

    setHeight(`${contentRef.current.scrollHeight}px`);

    if (isExpanded) {
      const timeOut = setTimeout(() => {
        setHeight('auto');
        setOverflow('visible');
      }, 225);
      return () => {
        clearTimeout(timeOut);
      };
    }

    if (!isExpanded) {
      requestAnimationFrame(() => {
        setHeight(GAMEFACE_ZERO);
        setOverflow('hidden');
      });
    }
  }, [setOverflow, setHeight], [expandedFacet]);
  return [{
    height,
    overflow
  }, contentRef];
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useActivateDeactivatePacks.tsx
function useActivateDeactivatePacks_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function useActivateDeactivatePacks_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { useActivateDeactivatePacks_ownKeys(Object(source), true).forEach(function (key) { useActivateDeactivatePacks_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { useActivateDeactivatePacks_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function useActivateDeactivatePacks_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








const BEHAVIOR_PACKS_TAB = 'behaviorPacks';

function packCollectionKeysWithResourcePacksAndGamepadAliasesEqualityCheck() {
  const previous = {
    active: 0,
    available: 0,
    realms: 0
  };
  return current => {
    return Object.keys(previous).reduce((acc, cur) => {
      var _current$resourcePack, _current, _current$resourcePack2;

      // Behavior packs doesn't have realms
      const currentLength = (_current$resourcePack = (_current = current[cur]) === null || _current === void 0 ? void 0 : (_current$resourcePack2 = _current.resourcePacks) === null || _current$resourcePack2 === void 0 ? void 0 : _current$resourcePack2.length) !== null && _current$resourcePack !== void 0 ? _current$resourcePack : 0;
      const isEqual = previous[cur] === currentLength;
      previous[cur] = currentLength;

      if (!acc) {
        return acc;
      }

      return isEqual;
    }, true);
  };
}

function usePackOperationNarration() {
  const firstTimeAPackIsActivated = (0,react.useRef)(true);
  const {
    narrateText
  } = useNarrateText({
    interruptible: false
  });
  const {
    t
  } = useLocalization('CreateNewWorld.resourcePacks');
  return (0,react.useCallback)(operation => {
    // Check if this is the first available pack to be activated
    if (firstTimeAPackIsActivated.current && operation === 'activate') {
      narrateText(t('.activateNarrationFirstPack'));
      firstTimeAPackIsActivated.current = false;
    } else {
      narrateText(t(`.${operation}Narration`));
    }
  }, [narrateText, t]);
}

function useActivateDeactivatePacks(packTypeKey, packsGamepadAliases, worldPacks, multiplayerData, onActivatePack, onDeactivatePack) {
  const {
    narrateText
  } = useNarrateText({
    interruptible: false
  });
  const {
    t
  } = useLocalization('CreateNewWorld.resourcePacks');
  const packType = packTypeKey === BEHAVIOR_PACKS_TAB ? PackType.Behavior : PackType.Resource;
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  const isNarrationEnabled = useNarrationEnabled();
  const resourcePackId = (0,react.useRef)(null);
  const resourcePackIndex = (0,react.useRef)(null);
  const previousPackCollectionKey = (0,react.useRef)(null);
  const previousOperation = (0,react.useRef)(null);
  const showResourcePacksPlatformLockedModal = ResourcePacksPlatformLockedModal.useShowModal();
  const narrateBehaviorPacksAction = usePackOperationNarration();
  const narrateTexturePacksAction = usePackOperationNarration();
  const deactivatePack = (0,react_facet_src.useFacetCallback)(() => (id, index, currentKey) => {
    resourcePackId.current = id;
    resourcePackIndex.current = index;
    previousPackCollectionKey.current = currentKey;
    previousOperation.current = 'remove';
    onDeactivatePack(id, packType);
  }, [packType, onDeactivatePack], []);
  const activatePack = (0,react_facet_src.useFacetCallback)(multiplayerData => (packId, packName, packSize, packIsPlatformLocked, index, currentKey) => {
    resourcePackId.current = packId;
    resourcePackIndex.current = index;
    previousPackCollectionKey.current = currentKey;
    previousOperation.current = 'activate';

    if (packIsPlatformLocked && multiplayerData.multiplayerGame) {
      showResourcePacksPlatformLockedModal({
        multiplayerData: multiplayerData,
        packId: packId,
        packType: packType,
        packName: packName,
        packSize: packSize,
        onActivatePack: onActivatePack
      });
    } else {
      onActivatePack(packId, packType, packName, packSize);
    }
  }, [packType, onActivatePack, showResourcePacksPlatformLockedModal], [multiplayerData]);
  const packCollectionKeysWithResourcePacksAndGamepadAliases = (0,react_facet_src.useFacetMemo)(worldPacks => Object.keys(packsGamepadAliases).reduce((acc, cur) => {
    const gamepadAliases = packsGamepadAliases[cur];
    const resourcePacks = worldPacks[packTypeKey][cur];
    return useActivateDeactivatePacks_objectSpread(useActivateDeactivatePacks_objectSpread({}, acc), {}, {
      [cur]: {
        gamepadAliases,
        resourcePacks
      }
    });
  }, {}), [packsGamepadAliases, packTypeKey], [worldPacks], packCollectionKeysWithResourcePacksAndGamepadAliasesEqualityCheck);
  (0,react_facet_src.useFacetEffect)(packCollectionKeysWithResourcePacksAndGamepadAliases => {
    // The first time this effect runs it won't be because of a users action.
    // Ensure that the refs have values. If not we should exit early.
    if (resourcePackId.current == null || resourcePackIndex.current == null || previousPackCollectionKey.current == null || previousOperation.current == null) {
      return;
    }

    if (packTypeKey === 'texturePacks') {
      narrateTexturePacksAction(previousOperation.current);
    }

    if (packTypeKey === 'behaviorPacks') {
      narrateBehaviorPacksAction(previousOperation.current);
    }

    const previousResourcePacksWithGamepadAliases = packCollectionKeysWithResourcePacksAndGamepadAliases[previousPackCollectionKey.current]; // We removed the last item of a list. Set the focus id to either the tab
    // or the empty state message (depends if narration is enabled or not)

    const wasLastItemInList = previousResourcePacksWithGamepadAliases.resourcePacks.length === 0;

    if (wasLastItemInList) {
      const nextFocusId = isNarrationEnabled ? previousResourcePacksWithGamepadAliases.gamepadAliases.emptyStateMessageAlias : previousResourcePacksWithGamepadAliases.gamepadAliases.tabsAlias;
      setFocusedId(nextFocusId);
      return;
    } // Not the last item. Therefore, the other items will move up one index,
    // and we want to select the one that took the previous items place (if possible).


    const itemToFocusIndex = previousResourcePacksWithGamepadAliases.resourcePacks[resourcePackIndex.current] != null ? resourcePackIndex.current : resourcePackIndex.current - 1;
    const itemToFocusId = previousResourcePacksWithGamepadAliases.resourcePacks[itemToFocusIndex].id;
    const nextFocusId = createPackActionGamepadAlias(previousOperation.current, itemToFocusId);
    setFocusedId(nextFocusId);
  }, [narrateText, t, setFocusedId, isNarrationEnabled, packTypeKey, narrateTexturePacksAction, narrateBehaviorPacksAction], [packCollectionKeysWithResourcePacksAndGamepadAliases]);
  return {
    deactivatePack,
    activatePack
  };
} // This function is to ensure that the pack list items focus alias stay in sync with what we move the focus to.

function createPackActionGamepadAlias(operation, id) {
  return `${operation}-${id}`;
} // This context is used to keep track of which list a item belonged to before it was
// activated or removed. We use that information when we choose what item we should
// focus next. This could, technically, be deduced from keeping track of all resource
// pack arrays and their length. However, this context reduces the complexity.

const PackCollectionKeyContext = (0,react.createContext)(null);
const usePackCollectionKey = () => (0,react.useContext)(PackCollectionKeyContext);
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/PackListItem.tsx
function PackListItem_extends() { PackListItem_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return PackListItem_extends.apply(this, arguments); }


























 // The Minecraft Texture Pack does not exist on the backend and is currently being
// hardcoded in the UI. We are currently having discussions about it and we are not sure
// if we'll keep it in the new Create New World screen. Therefore, we went with the
// solution of hardcoding the id like this rather than breaking the current interfaces and
// modifying existing functionality.

const MINECRAFT_TEXTURE_PACK_ID = '_GLOBAL_MINECRAFT_TEXTURE_PACK_'; // How much the draggable element is lifted off the page

const DRAG_X_LIFT_REM = -0.4;
const DRAG_Y_LIFT_REM = -0.8;
const MARIO_PACK_ID = '7f4ba1a2-43dd-45b1-aa3f-0b3ca2ebd5c8';
function PackListItem_PackListItem({
  pack: packFacet,
  gamepadIndex,
  index,
  draggable,
  removable,
  activatable,
  canShowSettingsButton = false,
  expandedPackId,
  containerListLength,
  outerRole = 'neutral',
  innerRole = 'neutral80',
  onDrop = PackListItem_noop,
  onExpand,
  onDragStart = PackListItem_noop,
  onRemove = PackListItem_noop,
  onActivate = PackListItem_noop,
  onShowSettings = PackListItem_noop,
  showTechnicalDetailsLink = false
}) {
  const {
    t
  } = useLocalization('PackListItem');
  const isLastInputPointerFacet = useIsLastInputPointer();
  const telemetry = (0,react_facet_src.useSharedFacet)(telemetryFacet);
  const newPackFacet = (0,react_facet_src.useFacetMap)(pack => {
    if (pack != null) return pack;
    return {
      id: '-1',
      contentId: '-1',
      name: '-1',
      creator: '-1',
      description: '-1',
      size: '-1',
      image: undefined,
      isMarketplaceItem: false,
      isPlatformLocked: false,
      hasSettings: false
    };
  }, [], [packFacet]);
  const packId = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(pack => pack.id, [], [newPackFacet]));
  const packName = (0,react_facet_src.useFacetMap)(pack => pack.name, [], [newPackFacet]);
  const packSize = (0,react_facet_src.useFacetMap)(pack => pack.size, [], [newPackFacet]);
  const packDescription = (0,react_facet_src.useFacetMap)(pack => pack.description, [], [newPackFacet]);
  const packIsPlatformLocked = (0,react_facet_src.useFacetMap)(pack => pack.isPlatformLocked, [], [newPackFacet]);
  const packIsPlatformLockedRef = (0,react_facet_src.useFacetRef)(packIsPlatformLocked, false);
  const isNotMarketplaceItem = (0,react_facet_src.useFacetMap)(pack => !pack.isMarketplaceItem, [], [newPackFacet]);
  const packImage = (0,react_facet_src.useFacetMap)(pack => {
    const packImage = pack.image != null && pack.image.length > 0 ? pack.image : missing_pack_icon_namespaceObject; // while waiting for bug 772743 to be resolved by Core UI, the C++ side
    // currently doesn't have the ability to expose images from an embedded
    // resource pack to JavaScript, so until the bug is resolved we have to hack
    // the image this way.
    // https://dev-mc.visualstudio.com/Minecraft/_workitems/edit/772743

    const packImageOrMarioIcon = pack.id.startsWith(MARIO_PACK_ID) ? mario_pack_icon_HACK_namespaceObject : packImage;
    return packImageOrMarioIcon;
  }, [], [newPackFacet]);
  const wrappedDraggable = (0,react_facet_src.useFacetWrap)(draggable || false);
  const droppableRef = (0,react.useRef)(null);
  const expandButtonGamepadIndex = (0,react_facet_src.useFacetMap)(draggable => draggable ? 1 : 0, [], [wrappedDraggable]);
  const expanded = (0,react_facet_src.useFacetMap)(expandedId => expandedId === packId, [packId], [expandedPackId]);
  const notExpanded = (0,react_facet_src.useFacetUnwrap)(expanded) === false;
  const disabled = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(draggable => !draggable, [], [wrappedDraggable])) === true;
  const {
    handlers,
    dragStateFacet
  } = useDrag({
    data: index,
    id: packId,
    index,
    onDragStart,
    pointerAxisLock: 'y',
    ref: droppableRef,
    disabled,
    gamepadDragXOffsetPx: useSizeInPixels(DRAG_X_LIFT_REM),
    gamepadDragYOffsetPx: useSizeInPixels(DRAG_Y_LIFT_REM)
  });
  const dropStateFacet = useDrop({
    id: packId,
    index,
    data: index,
    onDrop: (previousIndex, newIndex) => {
      // Narration: After the user re-orders
      // Keep in setTimeout to override other focus narration
      setTimeout(() => {
        narrateText(t('.narrationReorderComplete', [`${newIndex + 1}`]));
      }, 16); // Call prop onDrop handler.

      onDrop(packId, previousIndex, newIndex);
    },
    ref: droppableRef,
    disabled
  });
  const draggingFacet = (0,react_facet_src.useFacetMap)(state => state != null && state.dragging != false, [], [dragStateFacet]);
  const dragTypeFacet = (0,react_facet_src.useFacetMap)(state => state != null ? state.dragging : false, [], [dragStateFacet]);
  const displacementFacet = (0,react_facet_src.useFacetMap)(state => state != null ? state.displacement : 0, [], [dropStateFacet]);
  const dragZIndexFacet = (0,react_facet_src.useFacetMap)(state => state != null ? state.zIndex : '', [], [dragStateFacet]);
  const dragTransformFacet = (0,react_facet_src.useFacetMap)(state => state != null ? state.transform : '', [], [dragStateFacet]);
  const displacementTransformStyle = (0,react_facet_src.useFacetMap)(displacement => displacement == null ? '' : `translate(0, ${`${displacement * 100}%`})`, [], [displacementFacet]);
  const dragDropTransformLeft = (0,react_facet_src.useFacetMap)(dragging => dragging ? `${DRAG_X_LIFT_REM}rem` : '0', [], [draggingFacet]);
  const dragDropTransformTop = (0,react_facet_src.useFacetMap)(dragging => dragging ? `${DRAG_Y_LIFT_REM}rem` : '0', [], [draggingFacet]);
  const dragDropBoxShadowStyle = (0,react_facet_src.useFacetMap)(dragging => dragging ? `${DRAG_X_LIFT_REM * -1.8}rem ${DRAG_Y_LIFT_REM * -1.8}rem 0 rgba(0, 0, 0, 0.3)` : ``, [], [draggingFacet]);
  const dragButtonText = (0,react_facet_src.useFacetMap)(dragging => dragging ? t('.dropInputLegendText') : t('.dragInputLegendText'), [t], [draggingFacet]);
  const droppableTransitionStyle = (0,react_facet_src.useFacetMap)((dragging, displacement) => // We remove the transform transition when nothing is being dragged
  // to prevent it sliding into it's new position after an onDrop re-arrangement.
  // We also remove the transition for the dragged element, because it
  // isn't running smoothly in gameface (unsure why).
  displacement != null && !dragging ? 'transform 100ms linear' : '', [], [draggingFacet, displacementFacet]);
  const draggableTransitionStyle = (0,react_facet_src.useFacetMap)(dragType => dragType === 'gamepad' ? 'transform 100ms linear' : '', [], [dragTypeFacet]);
  const {
    narrateText
  } = useNarrateText();
  const onExpandCallback = (0,react_facet_src.useFacetCallback)((pack, expanded) => () => {
    // This callback is called before the expanded boolean has flipped.
    expanded = !expanded;
    narrateText([t(expanded ? '.narrationExpanded' : '.narrationCollapsed'), expanded ? t('.narrationExpandedHint') : null].join(' . '));
    onExpand(pack.id);
  }, [onExpand, narrateText, t], [packFacet, expanded]);
  const modalContext = useLeavingCNWForMarketplaceModalContext();
  const onMarketPlaceClick = (0,react_facet_src.useFacetCallback)((pack, telemetry, modalContext) => () => {
    telemetry.fireEventButtonPressed('Resource_Pack_More_Details_Button_OreUI', {});
    modalContext.show(pack.id);
  }, [], [packFacet, (0,react_facet_src.useSharedFacet)(telemetryFacet), modalContext]);
  const historyAPI = RouteHistory_useRouteHistory();
  const onTechnicalDetailsClick = (0,react_facet_src.useFacetCallback)((pack, telemetry) => () => {
    telemetry.fireEventButtonPressed('Resource_Pack_Pack_Manifest_Button_OreUI', {});
    historyAPI.push(`/manifest-validation/${pack.id}`);
  }, [historyAPI], [packFacet, telemetry]);
  const expandInputLegend = (0,react_facet_src.useFacetMap)(isExpanded => t(isExpanded ? '.collapseDescriptionInputLegend' : '.expandDescriptionInputLegend'), [t], [expanded]);
  const expandArrowClassName = (0,react_facet_src.useFacetMap)(isExpanded => `${PackListItem.expandArrowIcon} ${isExpanded ? PackListItem.flipped : ''}`, [], [expanded]);
  const activatableFacet = (0,react_facet_src.useFacetWrap)(activatable !== null && activatable !== void 0 ? activatable : false);
  const removableFacet = (0,react_facet_src.useFacetWrap)(removable !== null && removable !== void 0 ? removable : false);
  const shouldMountSettingsButton = (0,react_facet_src.useFacetMap)(pack => pack.hasSettings && canShowSettingsButton, [canShowSettingsButton], [packFacet]); // Narration: Contextual pack information, wrapping the list item and expandable content.

  const contextNarration = (0,react_facet_src.useFacetMap)((packName, containerListLength) => [packName, t('.narrationComponentType'), containerListLength > 0 ? t('.narrationListLengthContext', [`${index + 1}`, `${containerListLength}`]) : undefined].join(' . '), [t, index], [packName, (0,react_facet_src.useFacetWrap)(containerListLength !== null && containerListLength !== void 0 ? containerListLength : 0)]); // Narration: Expandable cell containing pack description

  const descriptionButtonNarration = (0,react_facet_src.useFacetMap)((expanded, removable, hasSettings) => [t('.narrationPackDescription'), t('.narrationAccordion'), t(expanded ? '.narrationExpanded' : '.narrationCollapsed'), !expanded ? removable || hasSettings ? t('.narrationExpandHint') : t('.narrationExpandHintNoButtons') : null].join(' . '), [t], [expanded, removableFacet, shouldMountSettingsButton]); // Narration: Focus narration for the re-order button

  const reorderButtonNarration = (0,react_facet_src.useFacetMap)(isPointer => [t('.narrationReorderPack'), t('.narrationPackRank', [`${index + 1}`]), t('.narrationButton'), t(isPointer ? '.narrationReorderPointerHint' : '.narrationReorderGamepadHint'), t('.narrationMultiplePacksHint')].join(' . '), [t, index], [isLastInputPointerFacet]);
  const gamepadHoverIndex = (0,react_facet_src.useFacetMap)(dragState => dragState === null || dragState === void 0 ? void 0 : dragState.gamepadHoverIndex, [], [dragStateFacet]);
  const pointerHoverIndex = (0,react_facet_src.useFacetMap)(dragState => dragState === null || dragState === void 0 ? void 0 : dragState.pointerHoverIndex, [], [dragStateFacet]);
  const hasDraggedBeyondStartArea = (0,react_facet_src.useFacetMap)(dragState => dragState === null || dragState === void 0 ? void 0 : dragState.hasDraggedPointerBeyondStartArea, [], [dragStateFacet]); // Narration: User drags pack into new rank

  (0,react_facet_src.useFacetEffect)((dragging, gamepadHoverIndex, pointerHoverIndex, isPointer, hasDraggedBeyondStartArea) => {
    if (!dragging || gamepadHoverIndex == null && pointerHoverIndex == null) {
      return;
    } // If using a pointer


    if (isPointer && pointerHoverIndex != null && hasDraggedBeyondStartArea) {
      narrateText(t('.narrationReorderPointerChangeConfirmation', [`${pointerHoverIndex + 1}`]));
    } else if (gamepadHoverIndex != null) {
      narrateText(t('.narrationReorderGamepadChangeConfirmation', [`${gamepadHoverIndex + 1}`]));
    }
  }, [narrateText, t], [draggingFacet, gamepadHoverIndex, pointerHoverIndex, isLastInputPointerFacet, hasDraggedBeyondStartArea]); // Narration: User begins re-ordering.
  // This should occur after the previous dragging narration to override it on the initial drag start.

  (0,react_facet_src.useFacetEffect)((dragging, isPointer) => {
    if (!dragging) {
      return;
    }

    if (isPointer) {
      narrateText(t('.narrationReorderPointerDraggingHint'));
    } else {
      narrateText(t('.narrationReorderGamepadDraggingHint'));
    }
  }, [narrateText, t], [draggingFacet, isLastInputPointerFacet]);
  const packCollectionKey = usePackCollectionKey();
  const {
    sound: {
      [outerRole]: semanticSound
    }
  } = useSemanticTokens();
  const mainActionSound = (0,react_facet_src.useFacetMap)(expanded => expanded ? semanticSound.contract : semanticSound.expand, [semanticSound], [expanded]); // To avoid deferred rendering being called twice inside ListItem when NarrationContext
  // changes prop key from fallback to packId --> only render when packId is available

  if (packId == react_facet_src.NO_VALUE) return null;
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: contextNarration,
    key: packId
  }, /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: outerRole
  }, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: gamepadIndex
  }, /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("fast-div", {
    style: {
      top: dragDropTransformTop,
      left: dragDropTransformLeft,
      zIndex: dragZIndexFacet
    }
  }, /*#__PURE__*/react.createElement("fast-div", {
    ref: droppableRef,
    style: {
      transform: dragTransformFacet,
      transition: draggableTransitionStyle
    },
    className: PackListItem.packListItemContent
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: PackListItem.packListItemDragAnimationContainer,
    style: {
      transform: displacementTransformStyle,
      boxShadow: dragDropBoxShadowStyle,
      transition: droppableTransitionStyle
    }
  }, /*#__PURE__*/react.createElement(ListItem_ListItem, {
    gamepadIndex: 0,
    defaultFocusedChildBehavior: "grid"
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: wrappedDraggable
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, PackListItem_extends({
    fitContent: true,
    onClick: PackListItem_noop,
    inputLegend: dragButtonText,
    narrationText: reorderButtonNarration,
    gamepadIndex: 0,
    touchDetectionDelay: 0,
    soundEffectPressed: semanticSound.lift
  }, handlers), /*#__PURE__*/react.createElement(ListItem_ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: draggable_icon_namespaceObject,
    className: PackListItem.draggableIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, index + 1), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  })))), /*#__PURE__*/react.createElement(ListItem_ListItem.Action, {
    inputLegend: expandInputLegend,
    gamepadIndex: expandButtonGamepadIndex,
    narrationText: descriptionButtonNarration,
    onClick: onExpandCallback,
    soundEffectPressed: mainActionSound
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.Cell, null, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: packImage,
    className: PackListItem.packImage
  })), /*#__PURE__*/react.createElement(ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, packName))), /*#__PURE__*/react.createElement(ListItem_ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: arrow_down_namespaceObject,
    className: expandArrowClassName,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }))),
  /*#__PURE__*/
  // Settings Button
  react.createElement(react_facet_src.Mount, {
    when: shouldMountSettingsButton
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, {
    inputLegend: t('.settingsButtonText'),
    onClick: () => onShowSettings(packId),
    narrationText: t('.narrationSettingsButton'),
    gamepadIndex: 2
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.Cell, {
    align: "center"
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: settings_icon_namespaceObject,
    className: PackListItem.settingsIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    align: "center",
    color: "inherit",
    variant: "captionTiny"
  }, t('.settingsButtonText'))))),
  /*#__PURE__*/
  // Remove Button
  react.createElement(react_facet_src.Mount, {
    when: removableFacet
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, {
    inputLegend: t('.removeButtonText'),
    onClick: () => onRemove(packId, index, packCollectionKey),
    narrationText: t('.narrationRemoveButton'),
    gamepadIndex: 3,
    gamepadAlias: createPackActionGamepadAlias('remove', packId)
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.Cell, {
    align: "center"
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: remove_icon_namespaceObject,
    className: PackListItem.removeIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    align: "center",
    variant: "captionTiny",
    color: "inherit"
  }, t('.removeButtonText'))))),
  /*#__PURE__*/
  // Activate Button
  react.createElement(react_facet_src.Mount, {
    when: activatableFacet
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, {
    inputLegend: t('.activateButtonText'),
    onClick: () => onActivate(packId, packName, packSize, packIsPlatformLockedRef.current, index, packCollectionKey),
    narrationText: t('.narrationActivateButton'),
    gamepadIndex: 2,
    gamepadAlias: createPackActionGamepadAlias('activate', packId)
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.Cell, {
    align: "center"
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: add_icon_namespaceObject,
    className: PackListItem.addIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    align: "center",
    color: "inherit",
    variant: "captionTiny"
  }, t('.activateButtonText'))))))))), /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    disabled: notExpanded,
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(ExpandableContent, {
    size: packSize,
    description: packDescription,
    onMarketPlaceClick: onMarketPlaceClick,
    onTechnicalDetailsClick: onTechnicalDetailsClick,
    expanded: expanded,
    hideMarketplaceLink: isNotMarketplaceItem,
    hideSize: isNotMarketplaceItem,
    outerRole: outerRole,
    innerRole: innerRole // We don't show the technical details link for the 'fake' global
    // texture pack (but we do show it for other global packs)
    ,
    showTechnicalDetailsLink: showTechnicalDetailsLink && packId != MINECRAFT_TEXTURE_PACK_ID
  }))))));
}

function ExpandableContent({
  expanded,
  description,
  size,
  onMarketPlaceClick,
  onTechnicalDetailsClick,
  hideMarketplaceLink,
  hideSize,
  outerRole,
  innerRole,
  showTechnicalDetailsLink = false
}) {
  const {
    t
  } = useLocalization('PackListItem');
  const [expandableStyles, contentRef] = useExpandable(expanded);
  const linkDisabled = (0,react_facet_src.useFacetMap)(isExpanded => !isExpanded, [], [expanded]);
  const {
    color: {
      [outerRole]: semanticClassNames,
      [innerRole]: semanticClassNamesInner
    },
    variant
  } = useSemanticTokens();
  const narrationContext = (0,react_facet_src.useFacetMap)((size, description, hideSize) => [hideSize ? null : size, description].join(' . '), [], [size, description, hideSize]);
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: narrationContext
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(isExpanded => classnames_default()(PackListItem.expandableWrapper, semanticClassNames.background.base, {
      [PackListItem.expanded]: isExpanded
    }), [semanticClassNames], [expanded]),
    style: expandableStyles
  }, /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: innerRole
  }, /*#__PURE__*/react.createElement("div", {
    ref: contentRef
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    narrationText: false,
    gamepadIndex: 0,
    isInteractive: hideMarketplaceLink,
    className: classnames_default()(PackListItem.expandableContent, semanticClassNamesInner.background.base, semanticClassNamesInner.border.base),
    classNameFocused: focusClass
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(PackListItem.expandableContentWrapper, semanticClassNamesInner.text.base, variant.dimmer)
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(PackListItem.expandableContentDescription, semanticClassNamesInner.text.base)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    color: "inherit"
  }, description), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hideMarketplaceLink,
    condition: false
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    color: "inherit"
  }, /*#__PURE__*/react.createElement(Link_Link, {
    disabled: linkDisabled,
    gamepadIndex: 0,
    onClick: onMarketPlaceClick,
    withUnderlinePolyfill: true
  }, t(`.descriptionMarketplaceLink`))))), /*#__PURE__*/react.createElement("div", {
    className: PackListItem.expandableContentLinksWrapper
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hideSize,
    condition: false
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, size)), showTechnicalDetailsLink && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", null), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    color: "inherit"
  }, /*#__PURE__*/react.createElement(Link_Link, {
    gamepadIndex: 1,
    onClick: onTechnicalDetailsClick,
    withUnderlinePolyfill: true
  }, t(`.descriptionTechnicalDetailsLink`)))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hideSize,
    condition: false
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  })))));
}

function PackListItem_noop() {}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItemWrapper/PackListItemWrapper.tsx





const PackListItemWrapper = props => {
  const pack = (0,react_facet_src.useFacetMemo)(facet => {
    const result = find_find(facet, pack => pack.id === props.packId);
    return result !== null && result !== void 0 ? result : facet[props.index];
  }, [props.packId, props.index], [props.packs]);
  const listLength = (0,react_facet_src.useFacetMap)(packs => packs.length, [], [props.packs]);
  return /*#__PURE__*/react.createElement(PackListItem_PackListItem, {
    showTechnicalDetailsLink: props.showTechnicalDetailsLink,
    gamepadIndex: props.index,
    pack: pack,
    index: props.index,
    draggable: props.draggable,
    expandedPackId: props.expandedId,
    removable: props.isNotLockedTemplate,
    containerListLength: listLength,
    onDragStart: props.onDragStart,
    onDrop: props.onDrop,
    onExpand: props.onExpand,
    onRemove: props.onRemove,
    canShowSettingsButton: props.canShowSettingsButton,
    onShowSettings: props.onShowSettings
  });
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItemWrapper/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackMap/PackMap.tsx





function resourcePackEqualityCheck() {
  let previousResourcePackIds = [];
  return function (current) {
    if (previousResourcePackIds.length !== current.length) {
      previousResourcePackIds = map(current, pack => pack.id);
      return false;
    }

    const isEqual = every(current, (pack, i) => previousResourcePackIds[i] === pack.id);

    if (!isEqual) {
      previousResourcePackIds = map(current, pack => pack.id);
    }

    return isEqual;
  };
}

function PackMap(props) {
  const packs = (0,react_facet_src.useFacetMemo)(facet => facet, [], [props.packsFacet], resourcePackEqualityCheck);
  const packIds = (0,react_facet_src.useFacetMap)(packs => packs.map(p => p.id), [], [packs]);
  const ids = (0,react_facet_src.useFacetUnwrap)(packIds);
  return ids !== react_facet_src.NO_VALUE ? /*#__PURE__*/react.createElement(react.Fragment, null, ids === null || ids === void 0 ? void 0 : ids.map((packId, index) => /*#__PURE__*/react.createElement(PackListItemWrapper, {
    showTechnicalDetailsLink: props.showTechnicalDetailsLink,
    packs: packs,
    key: ids[index],
    packId: packId,
    index: index,
    draggable: props.draggable,
    expandedId: props.expandedId,
    onDragStart: props.onDragStart,
    onDrop: props.onDrop,
    onExpand: props.onExpand,
    onRemove: props.onRemove,
    canShowSettingsButton: props.canShowSettingsButton,
    onShowSettings: props.onShowSettings,
    isNotLockedTemplate: props.isNotLockedTemplate
  }))) : null;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackMap/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListInfoMessage/PackListInfoMessage.tsx





function PackListInfoMessage({
  text,
  role = 'neutral'
}) {
  const {
    color: {
      [role]: semanticClassNames
    },
    variant
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(semanticClassNames.text.base, variant.dimmer)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, text)));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListInfoMessage/index.ts

;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowUpWhite/images/arrowUpWhite.png
const arrowUpWhite_namespaceObject = __webpack_require__.p + "assets/arrowUpWhite-2c2b7.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowUpWhite/IconArrowUpWhite.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowUpWhite = ({"iconArrowUpWhite":"wXcBf"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowUpWhite/IconArrowUpWhite.tsx




const IconArrowUpWhite_IconArrowUpWhite = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconArrowUpWhite.iconArrowUpWhite,
  src: arrowUpWhite_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowDownWhite/images/arrowDownWhite.png
const arrowDownWhite_namespaceObject = __webpack_require__.p + "assets/arrowDownWhite-55034.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowDownWhite/IconArrowDownWhite.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowDownWhite = ({"iconArrowDownWhite":"ayLXu"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowDownWhite/IconArrowDownWhite.tsx




const IconArrowDownWhite_IconArrowDownWhite = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconArrowDownWhite.iconArrowDownWhite,
  src: arrowDownWhite_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Accordion/Accordion.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Accordion = ({"bevelWrapper":"xy0uV","content":"koWU0","left":"aMZtH","count":"NejtX","expandableWrapper":"cydJJ","expanded":"izYgc"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Accordion/Accordion.tsx









function Accordion_Accordion(props) {
  const {
    label,
    count,
    children,
    gamepadIndex,
    narrationHint,
    onExpandNarrationHint,
    expandedDefaultState = false
  } = props;
  const {
    t
  } = useLocalization('Accordion');
  const {
    narrateText
  } = useNarrateText();
  const [expanded, setExpanded] = (0,react_facet_src.useFacetState)(expandedDefaultState);
  const [expandableStyles, contentRef] = useExpandable(expanded);
  const countLabel = (0,react_facet_src.useFacetMap)(count => `(${count})`, [], [count !== null && count !== void 0 ? count : Accordion_zeroFacet]);
  const inputLegend = (0,react_facet_src.useFacetMap)(expanded => expanded ? t('.closeInputLegend') : t('.openInputLegend'), [t], [expanded]);
  const narrationText = (0,react_facet_src.useFacetMap)((expanded, count) => {
    const text = count != null ? count > 100 ? `${label} (100+)` : `${label} - ${count}` : label;
    const componentType = t('.narrationComponentType');
    const state = expanded ? t('.stateExpanded') : t('.stateCollapsed');
    const hint = expanded ? null : narrationHint;
    return [text, componentType, state, hint].join(' . ');
  }, [t, label, narrationHint], [expanded, count !== null && count !== void 0 ? count : nullFacet]);
  const onClick = (0,react_facet_src.useFacetCallback)(expanded => () => {
    const text = expanded ? t('.stateCollapsed') : [t('.stateExpanded'), onExpandNarrationHint].join(' . ');
    narrateText(text);
    setExpanded(!expanded);
  }, [narrateText, t, onExpandNarrationHint, setExpanded], [expanded]);
  const rowOptions = (0,react_facet_src.useFacetMap)(expanded => ({
    index: 1,
    disabled: !expanded
  }), [], [expanded]);
  const expandableWrapperStyles = (0,react_facet_src.useFacetMap)(expanded => `${Accordion.expandableWrapper} ${expanded ? Accordion.expanded : ''}`, [], [expanded]);
  return /*#__PURE__*/react.createElement(Row, {
    shouldSkipLandmarkInVisual: true,
    options: {
      index: gamepadIndex
    }
  }, /*#__PURE__*/react.createElement(Column, {
    shouldSkipLandmarkInVisual: true,
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement(Row, {
    shouldSkipLandmarkInVisual: true,
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: Accordion.bevelWrapper
  }, /*#__PURE__*/react.createElement(Pressable_Pressable, {
    gamepadIndex: gamepadIndex,
    inputLegend: inputLegend,
    narrationText: narrationText,
    onClick: onClick,
    height: 4.4,
    variant: "neutral80",
    reflection: "bevel"
  }, /*#__PURE__*/react.createElement("div", {
    className: Accordion.content
  }, /*#__PURE__*/react.createElement("div", {
    className: Accordion.left
  }, label, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), count != null && /*#__PURE__*/react.createElement("div", {
    className: Accordion.count
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: countLabel
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: expanded,
    condition: true
  }, /*#__PURE__*/react.createElement(IconArrowUpWhite_IconArrowUpWhite, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: expanded,
    condition: false
  }, /*#__PURE__*/react.createElement(IconArrowDownWhite_IconArrowDownWhite, null)))))), /*#__PURE__*/react.createElement(Row, {
    shouldSkipLandmarkInVisual: true,
    options: rowOptions
  }, /*#__PURE__*/react.createElement(Column, {
    shouldSkipLandmarkInVisual: true,
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: expandableWrapperStyles,
    style: expandableStyles
  }, /*#__PURE__*/react.createElement("div", {
    ref: contentRef
  }, /*#__PURE__*/react.createElement("div", {
    className: Accordion.expandableContent
  }, children)))))));
}
const Accordion_zeroFacet = (0,react_facet_src.createFacet)({
  initialValue: 0
});
const nullFacet = (0,react_facet_src.createFacet)({
  initialValue: null
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useExpandableIndex.ts


function useExpandableIndex() {
  return (0,react.useMemo)(() => {
    const expandedId = (0,react_facet_src.createFacet)({
      initialValue: false
    });
    return {
      closeExpanded: () => expandedId.set(false),
      toggleExpanded: id => expandedId.setWithCallback(prev => prev != id ? id : false),
      expandedId
    };
  }, []);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useReorderPacks.ts

const useReorderPacks = (activePacks, packType, expandedId, closeExpanded, isLockedTemplate, onChangePackPriority) => {
  const moreThanOneActivePack = (0,react_facet_src.useFacetMap)(facet => facet.length > 1, [], [activePacks]);
  const isDraggable = (0,react_facet_src.useFacetMap)((multiplePacks, isLockedTemplate) => multiplePacks && !isLockedTemplate, [], [moreThanOneActivePack, isLockedTemplate]);
  const changePackPriority = (0,react_facet_src.useFacetCallback)(() => (packId, dragIndex, dropIndex) => {
    if (onChangePackPriority) {
      onChangePackPriority(packId, packType, dragIndex, dropIndex);
    }
  }, [packType, onChangePackPriority], []); // If the packs are expanded, we wait for the collapse
  // to finish before we start the dragging animation.

  const dragStartHandler = (0,react_facet_src.useFacetCallback)(expandedId => {
    const dragStart = callback => {
      if (expandedId === false) {
        callback();
      } else {
        closeExpanded();
        setTimeout(() => {
          callback();
        }, 200);
      }
    };

    return dragStart;
  }, [closeExpanded], [expandedId]);
  return {
    isDraggable,
    changePackPriority,
    dragStartHandler
  };
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/images/realms-plus-promotion.png
const realms_plus_promotion_namespaceObject = __webpack_require__.p + "assets/realms-plus-promotion-f1ffa.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/images/marketplace-icon.png
const marketplace_icon_namespaceObject = __webpack_require__.p + "assets/marketplace-icon-bca68.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/images/minecraft-texture-pack.png
const minecraft_texture_pack_namespaceObject = __webpack_require__.p + "assets/minecraft-texture-pack-070c0.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/ResourcePacksTab.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ResourcePacksTab = ({"container":"g9sbm","draggableDashedBackground":"ufNa6","draggableDashedBackgroundGreyCover":"mojsE","marketplaceButtonContent":"Jk4Oc","marketplaceButtonTextWrap":"Iabmi","marketplaceIcon":"xkjpr","realmsPlusPromotionImage":"uBhPx"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/ResourcePacksTab.tsx































const ACTIVE_RP_TAB_ALIAS = 'tab-bar-cnw-rp-active';
const AVAILABLE_RP_TAB_ALIAS = 'tab-bar-cnw-rp-available';
const EMPTY_LOCAL_ACTIVE_PACKS_ALIAS = 'empty-local-active-rp';
const EMPTY_AVAILABLE_PACKS_ALIAS = 'empty-available-rp';
const EMPTY_REALMS_PLUS_PACKS_ALIAS = 'empty-realms-plus-rp';

function ActiveTab({
  isLockedTemplate,
  worldPacks,
  onChangePackPriority
}) {
  // This is used to disable the column on this route. We shouldn't need to,
  // but there is currently a bug with focus navigation which is causing the below
  // tree to be focusable despite the parent Tab focusable being disabled
  const parentRouteActive = useRouteActive();
  const options = (0,react_facet_src.useFacetMap)(parentRouteActive => ({
    index: 0,
    disabled: !parentRouteActive
  }), [], [parentRouteActive]);
  return /*#__PURE__*/react.createElement(Column, {
    shouldSkipLandmarkInVisual: true,
    options: options
  }, (0,react.useMemo)(() => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(ActiveLocalPacks, {
    isLockedTemplate: isLockedTemplate,
    worldPacks: worldPacks,
    onChangePackPriority: onChangePackPriority
  })), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(ActiveGlobalPacks, {
    worldPacks: worldPacks
  })), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  })), [isLockedTemplate, worldPacks, onChangePackPriority]));
}

const createGlobalMinecraftTexturePack = t => ({
  id: MINECRAFT_TEXTURE_PACK_ID,
  contentId: MINECRAFT_TEXTURE_PACK_ID,
  name: t('.globalMinecraftPackTitle'),
  creator: 'Minecraft',
  description: t('.globalMinecraftPackDescription'),
  size: 'n/a',
  image: minecraft_texture_pack_namespaceObject,
  isMarketplaceItem: false,
  isPlatformLocked: false,
  hasSettings: false
});

function ActiveGlobalPacks({
  worldPacks
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.resourcePacks');
  const activeGlobal = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.activeGlobal, [], [worldPacks]);
  const activePacks = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.active, [], [worldPacks]);
  const activeGlobalPacks = (0,react_facet_src.useFacetMemo)(facet => {
    const packs = slice(facet, 0);
    packs.push(createGlobalMinecraftTexturePack(t));
    return packs;
  }, [t], [activeGlobal], react_facet_src.shallowObjectArrayEqualityCheck);
  const localPacksLength = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(facet => facet.length, [], [activePacks])); // Start the index offset as 1 to account for a focusable empty state message on the local packs

  const gamepadIndexOffset = localPacksLength == react_facet_src.NO_VALUE || localPacksLength === 0 ? 1 : localPacksLength;
  const {
    toggleExpanded,
    expandedId
  } = useExpandableIndex();
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: t('.narrationActiveGlobalPacksHeader')
  }, /*#__PURE__*/react.createElement(ListHeader_ListHeader, {
    role: "neutral",
    label: t('.globalPacksListHeader')
  }), /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: activeGlobalPacks
  }, (packFacet, index) => /*#__PURE__*/react.createElement(PackListItem_PackListItem, {
    showTechnicalDetailsLink: true,
    pack: packFacet,
    index: index,
    gamepadIndex: index + gamepadIndexOffset,
    expandedPackId: expandedId,
    onExpand: toggleExpanded,
    canShowSettingsButton: false
  })), /*#__PURE__*/react.createElement(PackListInfoMessage, {
    text: t('.globalPacksInfoMessage')
  }));
}

function ActiveLocalPacks({
  role = 'neutral',
  isLockedTemplate,
  worldPacks,
  onChangePackPriority
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.resourcePacks');
  const activePacks = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.active, [], [worldPacks]);
  const {
    expandedId,
    toggleExpanded,
    closeExpanded
  } = useExpandableIndex();
  const {
    isDraggable,
    changePackPriority,
    dragStartHandler
  } = useReorderPacks(activePacks, PackType.Resource, expandedId, closeExpanded, isLockedTemplate, onChangePackPriority);
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  const activePacksEmpty = (0,react_facet_src.useFacetMap)(activePacks => activePacks.length < 1, [], [activePacks]);
  const moreThanOneActivePack = (0,react_facet_src.useFacetMap)(activePacks => activePacks.length > 1, [], [activePacks]);
  const {
    deactivatePack
  } = usePackActions();
  const onShowSettings = (0,react_facet_src.useFacetCallback)(f => id => f.showSettings(id), [], [(0,react_facet_src.useSharedFacet)(resourcePacksFacet)]);
  const isNotLockedTemplate = (0,react_facet_src.useFacetMap)(isLockedTemplate => !isLockedTemplate, [], [isLockedTemplate]);
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: t('.narrationActiveLocalPacksHeader')
  }, /*#__PURE__*/react.createElement(ListHeader_ListHeader, {
    role: "neutral",
    label: t('.localPacksListHeader')
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: activePacksEmpty
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadAlias: EMPTY_LOCAL_ACTIVE_PACKS_ALIAS,
    title: t('.emptyLocalActivePacksMessageTitle'),
    text: t('.emptyLocalActivePacksMessageDescription'),
    gamepadIndex: 0
  })), /*#__PURE__*/react.createElement("div", {
    className: ResourcePacksTab.draggableDashedBackground
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ResourcePacksTab.draggableDashedBackgroundGreyCover, semanticClassNames.background.base)
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: activePacksEmpty,
    condition: false
  }, /*#__PURE__*/react.createElement(PackCollectionKeyContext.Provider, {
    value: "active"
  }, /*#__PURE__*/react.createElement(PackMap, {
    showTechnicalDetailsLink: true,
    packsFacet: activePacks,
    draggable: isDraggable,
    expandedId: expandedId,
    onDragStart: dragStartHandler,
    onDrop: changePackPriority,
    onExpand: toggleExpanded,
    onRemove: deactivatePack,
    onShowSettings: onShowSettings,
    canShowSettingsButton: true,
    isNotLockedTemplate: isNotLockedTemplate
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLockedTemplate,
    condition: false
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: moreThanOneActivePack
  }, /*#__PURE__*/react.createElement(PackListInfoMessage, {
    text: t('.packPriorityInfoMessage')
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLockedTemplate
  }, /*#__PURE__*/react.createElement(PackListInfoMessage, {
    text: t('.changesDisabledMessage')
  })));
}

function AvailableTab({
  isLockedTemplate,
  worldPacks
}) {
  // This is used to disable the column on this route. We shouldn't need to,
  // but there seems to be a bug with focus navigation which is causing the below
  // tree to be focusable despite the parent Tab focusable being disabled
  const parentRouteActive = useRouteActive();
  const options = (0,react_facet_src.useFacetMap)(parentRouteActive => ({
    index: 0,
    disabled: !parentRouteActive
  }), [], [parentRouteActive]);
  const {
    t
  } = useLocalization('CreateNewWorld.resourcePacks');
  const {
    toggleExpanded,
    expandedId
  } = useExpandableIndex();
  const inactivePacks = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.available, [], [worldPacks]);
  const activePacks = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.active, [], [worldPacks]);
  const isTrialAccountFacet = (0,react_facet_src.useSharedFacet)(isTrialAccountSelector);
  const inactivePacksEmpty = (0,react_facet_src.useFacetMap)(facet => facet.length <= 0, [], [inactivePacks]);
  const inactivePacksLength = (0,react_facet_src.useFacetMap)(facet => facet.length, [], [inactivePacks]);
  const isMarketplaceSupported = (0,react_facet_src.useFacetMap)((isEduBuild, isEditorWorld) => !isEduBuild && !isEditorWorld, [], [(0,react_facet_src.useSharedFacet)(isEduBuildSelector), (0,react_facet_src.useSharedFacet)(isEditorWorldSelector)]); // If the player has active packs but no inactive, all packs have been activated and the empty state message should say so
  // If the player doesn't have any active packs or available packs, they don't own any and the empty state message should inform them where they can buy packs

  const userOwnsAtLeastOnePack = (0,react_facet_src.useFacetMap)(activePacks => activePacks.length > 0, [], [activePacks]);
  const emptyStateTitle = (0,react_facet_src.useFacetMap)(userOwnsAtLeastOnePack => userOwnsAtLeastOnePack ? t('.activatedAllPacksMessageTitle') : t('.userOwnsNoPacksMessageTitle'), [t], [userOwnsAtLeastOnePack]);
  const emptyStateText = (0,react_facet_src.useFacetMap)(userOwnsAtLeastOnePack => userOwnsAtLeastOnePack ? t('.activatedAllPacksMessageDescription') : t('.userOwnsNoMessageDescription'), [t], [userOwnsAtLeastOnePack]);
  const packsActivateable = (0,react_facet_src.useFacetMap)((isLockedTemplate, isTrialAccount) => !isLockedTemplate && !isTrialAccount, [], [isLockedTemplate, isTrialAccountFacet]);
  const {
    activatePack
  } = usePackActions();
  return /*#__PURE__*/react.createElement(Column, {
    shouldSkipLandmarkInVisual: true,
    options: options
  }, (0,react.useMemo)(() => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Accordion_Accordion, {
    gamepadIndex: 0,
    label: t('.inactivePacksAccordionHeader'),
    count: inactivePacksLength,
    narrationHint: t('.inactivePacksAccordionHint'),
    onExpandNarrationHint: t('.inactivePacksOnExpandAccordionHint'),
    expandedDefaultState: "production" === 'test'
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: inactivePacksEmpty
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadAlias: EMPTY_AVAILABLE_PACKS_ALIAS,
    title: emptyStateTitle,
    text: emptyStateText,
    gamepadIndex: 0
  })), /*#__PURE__*/react.createElement(PackCollectionKeyContext.Provider, {
    value: "available"
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: inactivePacks
  }, (packFacet, index) => /*#__PURE__*/react.createElement(PackListItem_PackListItem, {
    containerListLength: inactivePacksLength,
    activatable: packsActivateable,
    onActivate: activatePack,
    pack: packFacet,
    index: index,
    gamepadIndex: index,
    expandedPackId: expandedId,
    onExpand: toggleExpanded
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  })), /*#__PURE__*/react.createElement(RealmsPlusPackList, {
    toggleExpanded: toggleExpanded,
    expandedId: expandedId,
    worldPacks: worldPacks,
    isLockedTemplate: isLockedTemplate
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isMarketplaceSupported
  }, /*#__PURE__*/react.createElement(GetMorePacksButton, {
    gamepadIndex: 2
  })), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  })), [t, toggleExpanded, expandedId, inactivePacksEmpty, inactivePacksLength, inactivePacks, isMarketplaceSupported, emptyStateText, emptyStateTitle, packsActivateable, activatePack, worldPacks, isLockedTemplate]));
}

function RealmsPlusPackList({
  toggleExpanded,
  expandedId,
  isLockedTemplate,
  worldPacks
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.resourcePacks');
  const isRealmsPlusSupported = (0,react_facet_src.useFacetMap)((facet, isEduBuild, isEditorWorld) => facet.realmsPlusSupported && !isEduBuild && !isEditorWorld, [], [worldPacks, (0,react_facet_src.useSharedFacet)(isEduBuildSelector), (0,react_facet_src.useSharedFacet)(isEditorWorldSelector)]);
  const realmsSubscriber = (0,react_facet_src.useFacetMap)(facet => facet.realmsSubscriber, [], [worldPacks]);
  const notRealmsSubscriber = (0,react_facet_src.useFacetMap)(facet => !facet.realmsSubscriber, [], [worldPacks]);
  const realmsPacks = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.realms, [], [worldPacks]);
  const realmsPacksEmpty = (0,react_facet_src.useFacetMap)(facet => facet.length <= 0, [], [realmsPacks]);
  const realmsPacksLength = (0,react_facet_src.useFacetMap)((facet, subscriber) => subscriber ? facet.length : '100+', [], [realmsPacks, realmsSubscriber]);
  const isNotLockedTemplate = (0,react_facet_src.useFacetMap)(isLockedTemplate => !isLockedTemplate, [], [isLockedTemplate]);
  const {
    activatePack
  } = usePackActions();
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isRealmsPlusSupported
  }, /*#__PURE__*/react.createElement(Accordion_Accordion, {
    gamepadIndex: 1,
    label: t('.realmsPlusPacksAccordionHeader'),
    count: realmsPacksLength,
    narrationHint: t('.realmsPlusPacksAccordionHint'),
    onExpandNarrationHint: t('.realmsPlusPacksOnExpandAccordionHint'),
    expandedDefaultState: "production" === 'test'
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: realmsSubscriber
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: realmsPacksEmpty
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadAlias: EMPTY_REALMS_PLUS_PACKS_ALIAS,
    gamepadIndex: 0,
    title: t('.realmsPlusPacksEmptyTitle'),
    text: t('.realmsPlusPacksEmptyBody')
  })), /*#__PURE__*/react.createElement(PackCollectionKeyContext.Provider, {
    value: "realms"
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: realmsPacks
  }, (packFacet, index) => /*#__PURE__*/react.createElement(PackListItem_PackListItem, {
    activatable: isNotLockedTemplate,
    onActivate: activatePack,
    pack: packFacet,
    index: index,
    gamepadIndex: index,
    expandedPackId: expandedId,
    onExpand: toggleExpanded
  }))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: notRealmsSubscriber
  }, /*#__PURE__*/react.createElement(RealmsPlusPromotionPanel, null)), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }))));
}

function RealmsPlusPromotionPanel() {
  const {
    t
  } = useLocalization('CreateNewWorld.resourcePacks');
  const historyAPI = RouteHistory_useRouteHistory();
  return /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    title: t('.realmsPlusPromotionTitle'),
    text: t('.realmsPlusPromotionBody'),
    imgSrc: realms_plus_promotion_namespaceObject,
    imgClass: ResourcePacksTab.realmsPlusPromotionImage,
    buttons: [{
      text: t('.realmsPlusPromotionButtonLabel'),
      inputLegend: t('.realmsPlusPromotionButtonInputLegend'),
      onClick: () => historyAPI.push('/realms-plus-pdp?tab=default')
    }],
    gamepadIndex: 0
  });
}

function GetMorePacksButton({
  gamepadIndex,
  role = 'neutral'
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.resourcePacks');
  const historyAPI = RouteHistory_useRouteHistory();
  const {
    color: {
      [role]: semanticClassNames
    },
    variant
  } = useSemanticTokens();
  const onClick = (0,react_facet_src.useFacetCallback)((marketplaceFacet, telemetryFacet) => () => {
    telemetryFacet.fireEventButtonPressed('Get_More_Packs_Button_OreUI', {});
    const queryParams = marketplaceFacet.getMorePacks ? `?title=${marketplaceFacet.getMorePacks.title}&pageId=${marketplaceFacet.getMorePacks.pageId}` : '';
    historyAPI.push(`/marketplace/get-more-packs${queryParams}`);
  }, [historyAPI], [(0,react_facet_src.useSharedFacet)(marketplaceSuggestionsFacet), (0,react_facet_src.useSharedFacet)(telemetryFacet)]);
  const narrationText = `${t('.getMorePacksButtonTitle')} . ${t('.narrationComponentTypeMarketplaceButton')} , ${t('.getMorePacksButtonBody')}`;
  return /*#__PURE__*/react.createElement(Pressable_Pressable, {
    delayedClick: true,
    gamepadIndex: gamepadIndex,
    inputLegend: t('.getMorePacksButtonInputLegend'),
    narrationText: narrationText,
    onClick: onClick,
    variant: "neutral",
    reflection: "bevel"
  }, /*#__PURE__*/react.createElement("div", {
    className: ResourcePacksTab.marketplaceButtonContent
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: marketplace_icon_namespaceObject,
    className: ResourcePacksTab.marketplaceIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ResourcePacksTab.marketplaceButtonTextWrap, semanticClassNames.text.base)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    color: "inherit",
    variant: "body"
  }, t('.getMorePacksButtonTitle')), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(semanticClassNames.text.base, variant.dimmer)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, t('.getMorePacksButtonBody'))))));
}

const ResourcePackActionsContext = (0,react.createContext)({});

const usePackActions = () => (0,react.useContext)(ResourcePackActionsContext);

function ResourcePacksTab_ResourcePacksTab({
  multiplayerData,
  worldPacks,
  isLockedTemplate,
  onActivatePack,
  onDeactivatePack,
  onChangePackPriority
}) {
  const {
    activatePack,
    deactivatePack
  } = useActivateDeactivatePacks('texturePacks', {
    active: {
      tabsAlias: ACTIVE_RP_TAB_ALIAS,
      emptyStateMessageAlias: EMPTY_LOCAL_ACTIVE_PACKS_ALIAS
    },
    available: {
      tabsAlias: AVAILABLE_RP_TAB_ALIAS,
      emptyStateMessageAlias: EMPTY_AVAILABLE_PACKS_ALIAS
    },
    realms: {
      tabsAlias: AVAILABLE_RP_TAB_ALIAS,
      emptyStateMessageAlias: EMPTY_REALMS_PLUS_PACKS_ALIAS
    }
  }, worldPacks, multiplayerData, onActivatePack, onDeactivatePack);
  const sharedPacks = (0,react_facet_src.useFacetMap)(facet => facet.sharedPacks, [], [worldPacks]);
  const resourcePacksDisabled = (0,react_facet_src.useFacetMap)((isLockedTemplate, user) => isLockedTemplate || user.isTrialAccount, [], [isLockedTemplate, (0,react_facet_src.useSharedFacet)(userAccountFacet)]);
  const {
    t
  } = useLocalization('CreateNewWorld.resourcePacks');
  const {
    t: t2
  } = useLocalization('CreateNewWorldSideMenu');
  const value = (0,react.useMemo)(() => ({
    activatePack,
    deactivatePack
  }), [activatePack, deactivatePack]);
  return /*#__PURE__*/react.createElement(ResourcePackActionsContext.Provider, {
    value: value
  }, /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(DragAndDropProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    nestedRoutes: true,
    narrationText: t2('.resourcePacksTabLabel')
  }, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    disabled: resourcePacksDisabled,
    gamepad: {
      index: 0
    },
    title: t('.sharedPacksTitle'),
    description: t('.sharedPacksDescription'),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => facet.sharedPacks = newValue, [], [worldPacks]),
    value: sharedPacks
  })), /*#__PURE__*/react.createElement("div", {
    className: ResourcePacksTab.container
  }, /*#__PURE__*/react.createElement(PackTabs, {
    gamepadAliasNamespace: "cnw-rp",
    path: "resource-packs"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(PackTabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(ActiveTab, {
      isLockedTemplate: isLockedTemplate,
      worldPacks: worldPacks,
      onChangePackPriority: onChangePackPriority
    }), [isLockedTemplate, worldPacks, onChangePackPriority]),
    gamepadIndex: 3,
    filter: "active"
  }), /*#__PURE__*/react.createElement(PackTabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(AvailableTab, {
      isLockedTemplate: isLockedTemplate,
      worldPacks: worldPacks
    }), [isLockedTemplate, worldPacks]),
    gamepadIndex: 3,
    filter: "available"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/UnlockSettingsModal.tsx








function UnlockSettingsMessageModal() {
  const {
    t
  } = useLocalization('CreateNewWorld');
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  const unlockTemplateSettings = (0,react_facet_src.useFacetCallback)(facet => () => {
    facet.unlockTemplateSettings();
    setFocusedId(CREATE_BUTTON_ALIAS);
  }, [setFocusedId], [(0,react_facet_src.useSharedFacet)(createNewWorldFacet)]);

  const confirmUnlockSettings = () => {
    showUnlockSettingsModal.set(false);
    unlockTemplateSettings();
  };

  const cancelUnlockSettings = () => {
    showUnlockSettingsModal.set(false);
  };

  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-keepSettings';
  const visible = (0,react_facet_src.useFacetMap)(showUnlockSettingsModal => showUnlockSettingsModal, [], [showUnlockSettingsModal]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: visible
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: cancelUnlockSettings
  }, t('.unlockSettingsModal.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.unlockSettingsModal.message'),
    gamepadIndex: 0,
    center: true
  }, t('.unlockSettingsModal.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.unlockSettingsModal.keepSettings'),
    variant: "primary",
    onClick: cancelUnlockSettings
  }, t('.unlockSettingsModal.keepSettings')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.unlockSettingsModal.unlock'),
    onClick: confirmUnlockSettings,
    gamepadAlias: "pop-up-modal-unlockSettings"
  }, t('.unlockSettingsModal.unlock'))))), /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: {
      button: types_ButtonType.B,
      inputLegend: t('.unlockSettingsModal.keepSettings')
    },
    onClick: cancelUnlockSettings
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/images/empty-state-art.png
const empty_state_art_namespaceObject = __webpack_require__.p + "assets/empty-state-art-461d2.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/BehaviorPacksTab.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BehaviorPacksTab = ({"emptyStateArt":"XnOc_","container":"TPaUw","draggableDashedBackground":"PWSBv","draggableDashedBackgroundGreyCover":"pTqB3"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/BehaviorPacksTab.tsx























const ACTIVE_BP_TAB_ALIAS = 'tab-bar-cnw-bp-active';
const EMPTY_ACTIVE_PACKS_ALIAS = 'empty-active-bp';
const AVAILABLE_BP_TAB_ALIAS = 'tab-bar-cnw-bp-available';
const BehaviorPacksTab_EMPTY_AVAILABLE_PACKS_ALIAS = 'empty-available-bp';

function BehaviorPacksTab_ActiveTab({
  isLockedTemplate,
  worldPacks,
  onChangePackPriority
}) {
  // This is used to disable the column on this route. We shouldn't need to,
  // but there is currently a bug with focus navigation which is causing the below
  // tree to be focusable despite the parent Tab focusable being disabled
  const parentRouteActive = useRouteActive();
  const options = (0,react_facet_src.useFacetMap)(parentRouteActive => ({
    index: 0,
    disabled: !parentRouteActive
  }), [], [parentRouteActive]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Column, {
    shouldSkipLandmarkInVisual: true,
    options: options
  }, (0,react.useMemo)(() => /*#__PURE__*/react.createElement(ActivePacks, {
    isLockedTemplate: isLockedTemplate,
    worldPacks: worldPacks,
    onChangePackPriority: onChangePackPriority
  }), [isLockedTemplate, onChangePackPriority, worldPacks])), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  }));
}

function ActivePacks({
  role = 'neutral',
  isLockedTemplate,
  worldPacks,
  onChangePackPriority
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.behaviorPacks');
  const {
    toggleExpanded,
    expandedId,
    closeExpanded
  } = useExpandableIndex();
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  const {
    deactivatePack
  } = BehaviorPacksTab_usePackActions();
  const activePacks = (0,react_facet_src.useFacetMap)(facet => facet.behaviorPacks.active, [], [worldPacks]);
  const {
    isDraggable,
    changePackPriority,
    dragStartHandler
  } = useReorderPacks(activePacks, PackType.Behavior, expandedId, closeExpanded, isLockedTemplate, onChangePackPriority);
  const activePacksEmpty = (0,react_facet_src.useFacetMap)(activePacks => activePacks.length < 1, [], [activePacks]);
  const moreThanOneActivePack = (0,react_facet_src.useFacetMap)(activePacks => activePacks.length > 1, [], [activePacks]);
  const isNotLockedTemplate = (0,react_facet_src.useFacetMap)(isLockedTemplate => !isLockedTemplate, [], [isLockedTemplate]);
  const onShowSettings = (0,react_facet_src.useFacetCallback)(f => id => f.showSettings(id), [], [(0,react_facet_src.useSharedFacet)(resourcePacksFacet)]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: activePacksEmpty
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadAlias: EMPTY_ACTIVE_PACKS_ALIAS,
    title: t('.emptyLocalActivePacksMessageTitle'),
    text: t('.emptyLocalActivePacksMessageDescription'),
    gamepadIndex: 0
  })), /*#__PURE__*/react.createElement("div", {
    className: BehaviorPacksTab.draggableDashedBackground
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(BehaviorPacksTab.draggableDashedBackgroundGreyCover, semanticClassNames.background.base)
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: activePacksEmpty,
    condition: false
  }, /*#__PURE__*/react.createElement(PackCollectionKeyContext.Provider, {
    value: "active"
  }, /*#__PURE__*/react.createElement(PackMap, {
    showTechnicalDetailsLink: true,
    packsFacet: activePacks,
    draggable: isDraggable,
    expandedId: expandedId,
    onDragStart: dragStartHandler,
    onDrop: changePackPriority,
    onExpand: toggleExpanded,
    onRemove: deactivatePack,
    onShowSettings: onShowSettings,
    canShowSettingsButton: true,
    isNotLockedTemplate: isNotLockedTemplate
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLockedTemplate,
    condition: false
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: moreThanOneActivePack
  }, /*#__PURE__*/react.createElement(PackListInfoMessage, {
    text: t('.packPriorityInfoMessage')
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLockedTemplate
  }, /*#__PURE__*/react.createElement(PackListInfoMessage, {
    text: t('.changesDisabledMessage')
  })));
}

function BehaviorPacksTab_AvailableTab({
  isLockedTemplate,
  worldPacks
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.behaviorPacks');
  const {
    toggleExpanded,
    expandedId
  } = useExpandableIndex();
  const {
    activatePack
  } = BehaviorPacksTab_usePackActions(); // This is used to disable the column on this route. We shouldn't need to,
  // but there seems to be a bug with focus navigation which is causing the below
  // tree to be focusable despite the parent Tab focusable being disabled

  const parentRouteActive = useRouteActive();
  const options = (0,react_facet_src.useFacetMap)(parentRouteActive => ({
    index: 0,
    disabled: !parentRouteActive
  }), [], [parentRouteActive]);
  const inactivePacks = (0,react_facet_src.useFacetMap)(facet => facet.behaviorPacks.available, [], [worldPacks]);
  const inactivePacksEmpty = (0,react_facet_src.useFacetMap)(facet => facet.length < 1, [], [inactivePacks]);
  const isNotLockedTemplate = (0,react_facet_src.useFacetMap)(isLockedTemplate => !isLockedTemplate, [], [isLockedTemplate]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Column, {
    shouldSkipLandmarkInVisual: true,
    options: options
  }, (0,react.useMemo)(() => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: inactivePacksEmpty
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadAlias: BehaviorPacksTab_EMPTY_AVAILABLE_PACKS_ALIAS,
    title: t('.activatedAllPacksMessageTitle'),
    text: t('.activatedAllPacksMessageDescription'),
    gamepadIndex: 0
  })), /*#__PURE__*/react.createElement(PackCollectionKeyContext.Provider, {
    value: "available"
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: inactivePacks
  }, (packFacet, index) => /*#__PURE__*/react.createElement(PackListItem_PackListItem, {
    activatable: isNotLockedTemplate,
    onActivate: activatePack,
    pack: packFacet,
    index: index,
    gamepadIndex: index,
    expandedPackId: expandedId,
    onExpand: toggleExpanded
  })))), [inactivePacksEmpty, t, inactivePacks, isNotLockedTemplate, activatePack, expandedId, toggleExpanded])), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  }));
}

const BehaviorPacksTab_ResourcePackActionsContext = (0,react.createContext)({});

const BehaviorPacksTab_usePackActions = () => (0,react.useContext)(BehaviorPacksTab_ResourcePackActionsContext);

function BehaviorPacksTab_BehaviorPacksTab({
  multiplayerData,
  worldPacks,
  isLockedTemplate,
  onActivatePack,
  onDeactivatePack,
  onChangePackPriority
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.behaviorPacks');
  const {
    t: t2
  } = useLocalization('CreateNewWorldSideMenu');
  const hasBehaviorPacks = (0,react_facet_src.useFacetMap)(facet => facet.behaviorPacks.active.length > 0 || facet.behaviorPacks.available.length > 0, [], [worldPacks]);
  const togglePack = useActivateDeactivatePacks('behaviorPacks', {
    active: {
      tabsAlias: ACTIVE_BP_TAB_ALIAS,
      emptyStateMessageAlias: EMPTY_ACTIVE_PACKS_ALIAS
    },
    available: {
      tabsAlias: AVAILABLE_BP_TAB_ALIAS,
      emptyStateMessageAlias: BehaviorPacksTab_EMPTY_AVAILABLE_PACKS_ALIAS
    }
  }, worldPacks, multiplayerData, onActivatePack, onDeactivatePack);
  return /*#__PURE__*/react.createElement(BehaviorPacksTab_ResourcePackActionsContext.Provider, {
    value: togglePack
  }, /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(DragAndDropProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    nestedRoutes: true,
    narrationText: t2('.behaviorPacksTabLabel')
  }, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasBehaviorPacks,
    condition: true
  }, /*#__PURE__*/react.createElement("div", {
    className: BehaviorPacksTab.container
  }, /*#__PURE__*/react.createElement(PackTabs, {
    gamepadAliasNamespace: "cnw-bp",
    path: "behavior-packs"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(PackTabWrapper, {
    component: () => /*#__PURE__*/react.createElement(BehaviorPacksTab_ActiveTab, {
      isLockedTemplate: isLockedTemplate,
      worldPacks: worldPacks,
      onChangePackPriority: onChangePackPriority
    }),
    gamepadIndex: 3,
    filter: "active"
  }), /*#__PURE__*/react.createElement(PackTabWrapper, {
    component: () => /*#__PURE__*/react.createElement(BehaviorPacksTab_AvailableTab, {
      isLockedTemplate: isLockedTemplate,
      worldPacks: worldPacks,
      onChangePackPriority: onChangePackPriority
    }),
    gamepadIndex: 3,
    filter: "available"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  })))), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasBehaviorPacks,
    condition: false
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadAlias: EMPTY_ACTIVE_PACKS_ALIAS,
    title: t('.noPacksAvailableTitle'),
    text: t('.noPacksAvailableBody'),
    gamepadIndex: 0,
    imgSrc: empty_state_art_namespaceObject,
    borderless: true,
    imgClass: BehaviorPacksTab.emptyStateArt
  })))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/DebugTab.tsx









function DebugTab() {
  const debugSettings = (0,react_facet_src.useSharedFacet)(debugSettingsFacet);
  const allBiomesRaw = (0,react_facet_src.useFacetMap)(({
    allBiomes
  }) => allBiomes, [], [debugSettings]);
  const spawnDimension = (0,react_facet_src.useFacetMap)(({
    spawnDimensionId
  }) => spawnDimensionId, [], [debugSettings]);
  const allBiomes = (0,react_facet_src.useFacetMap)(allBiomesRaw => map(allBiomesRaw, biome => ({
    label: biome.label,
    dimension: biome.dimension,
    value: biome.id
  })), [], [allBiomesRaw]);
  const biomeOptions = (0,react_facet_src.useFacetMap)((allBiomes, selectedBiomeType) => filter(allBiomes, biome => biome.dimension === selectedBiomeType), [], [allBiomes, spawnDimension]);
  const spawnBiomeId = (0,react_facet_src.useFacetMap)(facet => facet.spawnBiomeId, [], [debugSettings]);
  const disableSpawnBiomeOptions = (0,react_facet_src.useFacetMap)(facet => facet.defaultSpawnBiome || facet.isBiomeOverrideActive, [], [debugSettings]);
  return /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    narrationText: "Debug"
  }, /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: 'Flat nether',
    gamepad: {
      index: 0
    },
    value: (0,react_facet_src.useFacetMap)(value => value.flatNether, [], [debugSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => {
      debugSettings.flatNether = newValue;
    }, [], [debugSettings])
  })), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: 'Enable game version override',
    gamepad: {
      index: 1
    },
    value: (0,react_facet_src.useFacetMap)(value => value.enableGameVersionOverride, [], [debugSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => {
      debugSettings.enableGameVersionOverride = newValue;
    }, [], [debugSettings])
  })), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(VanillaTextField, {
    label: 'Game version override',
    gamepadIndex: 2,
    placeholder: '0.0.0' // Do not change the maxLength to a value > 1024 until bug #507491 is fixed. This to avoid issues with text input on GameCore.
    ,
    maxLength: 30,
    disabled: (0,react_facet_src.useFacetMap)(value => !value.enableGameVersionOverride, [], [debugSettings]),
    value: (0,react_facet_src.useFacetMap)(value => value.gameVersionOverride, [], [debugSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.gameVersionOverride = newValue;
    }, [], [debugSettings])
  })), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: 'World biome settings'
  })), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: 'Default spawn biome',
    description: 'Using the default spawn biome will mean a random overworld spawn is selected',
    gamepad: {
      index: 3
    },
    disabled: (0,react_facet_src.useFacetMap)(facet => facet.isBiomeOverrideActive, [], [debugSettings]),
    value: (0,react_facet_src.useFacetMap)(facet => facet.defaultSpawnBiome, [], [debugSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => {
      debugSettings.defaultSpawnBiome = newValue;
    }, [], [debugSettings])
  }), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(Toggles_Toggles, {
    onMountComplete: (0,dist.useNotifyMountComplete)(),
    title: 'Spawn dimension filter',
    gamepad: {
      index: 4
    },
    disabled: disableSpawnBiomeOptions,
    wrapToggleText: true,
    options: [{
      label: 'Overworld',
      value: 0
    }, {
      label: 'Nether',
      value: 1
    }],
    value: spawnDimension,
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => {
      debugSettings.spawnDimensionId = newValue;
    }, [], [debugSettings])
  })), /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(Dropdown, {
    label: "Spawn biome",
    options: biomeOptions,
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => debugSettings.spawnBiomeId = newValue, [], [debugSettings]),
    disabled: disableSpawnBiomeOptions,
    gamepadIndex: 5,
    value: (0,react_facet_src.useFacetMap)((spawnBiomeId, biomeOptions) => // If the spawnBiomeSelector is returned as 0 but the select biome subset doesn't contain that
    // value, it should fall back to the first biome option for the subset
    biomeOptions.filter(biome => biome.value === spawnBiomeId).length > 0 ? spawnBiomeId : biomeOptions[0].value, [], [spawnBiomeId, biomeOptions])
  })), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: 'Biome override',
    description: "Set the world to a selected biome. This will override the Spawn biome!",
    gamepad: {
      index: 6
    },
    value: (0,react_facet_src.useFacetMap)(value => value.isBiomeOverrideActive, [], [debugSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => {
      debugSettings.isBiomeOverrideActive = newValue;
    }, [], [debugSettings])
  }), /*#__PURE__*/react.createElement(Dropdown, {
    label: "Biome override",
    description: "Select biome to be used in the entire world",
    options: allBiomes,
    disabled: (0,react_facet_src.useFacetMap)(value => !value.isBiomeOverrideActive, [], [debugSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => {
      debugSettings.biomeOverrideId = newValue;
    }, [], [debugSettings]),
    gamepadIndex: 7,
    value: (0,react_facet_src.useFacetMap)(value => value.biomeOverrideId, [], [debugSettings])
  }));
}

function DebugTabWrapper() {
  return /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(DebugTab, null));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/ScriptingCodingTab.tsx









function ScriptingCodingTab() {
  const {
    t
  } = useLocalization('CreateNewWorld.scriptingCoding');
  const {
    t: t2
  } = useLocalization('CreateNewWorldSideMenu');
  const {
    t: t3
  } = useLocalization('CreateNewWorld.cheats');
  const isLockedTemplate = (0,react_facet_src.useSharedFacet)(isLockedTemplateSelector);
  const cheatSettings = (0,react_facet_src.useSharedFacet)(cheatsSettingsSelector);
  const createNewWorld = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const cheatSettingsDisabled = (0,react_facet_src.useFacetMap)((cheatSettings, isLockedTemplate) => !cheatSettings.cheatsEnabled || isLockedTemplate, [], [cheatSettings, isLockedTemplate]);
  return /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    narrationText: t2('.scriptingCodingTabLabel')
  }, /*#__PURE__*/react.createElement(NarrationContext, {
    text: [t('.settingsTitle'), t('.narrationComponentTypeSectionHeader')].join(' . ')
  }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    key: t('.codeBuilderTitle'),
    title: t('.codeBuilderTitle'),
    description: t('.codeBuilderDescription'),
    gamepad: {
      index: 0
    },
    value: (0,react_facet_src.useFacetMap)(scriptingCoding => scriptingCoding.codeBuilderEnabled, [], [(0,react_facet_src.useSharedFacet)(scriptingCodingSettingsSelector)]),
    onChange: (0,react_facet_src.useFacetCallback)(createNewWorld => newValue => {
      createNewWorld.worldCreationData.scriptingCoding.codeBuilderEnabled = newValue;
    }, [], [createNewWorld])
  }), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    key: t3('.commandsTitle'),
    title: t3('.commandsTitle'),
    description: t3('.commandsDescription'),
    disabledNarrationSuffix: t3('.settingDisabledHint'),
    gamepad: {
      index: 1
    },
    disabled: cheatSettingsDisabled,
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.commandsEnabled, [], [cheatSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(createNewWorld => newValue => {
      createNewWorld.worldCreationData.cheats.commandsEnabled = newValue;
    }, [], [createNewWorld])
  }), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    key: t3('.commandBlocksTitle'),
    title: t3('.commandBlocksTitle'),
    description: t3('.commandBlocksDescription'),
    disabledNarrationSuffix: t3('.settingDisabledHint'),
    gamepad: {
      index: 2
    },
    disabled: cheatSettingsDisabled,
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.commandBlocks, [], [cheatSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(createNewWorld => newValue => {
      createNewWorld.worldCreationData.cheats.commandBlocks = newValue;
    }, [], [createNewWorld])
  })));
}

function ScriptingCodingTabWrapper() {
  return /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(ScriptingCodingTab, null));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/index.tsx











;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/Prompt.tsx







function Prompt_noop() {}

function Prompt_Prompt() {
  const resourcePacks = (0,react_facet_src.useSharedFacet)(resourcePacksFacet);
  const show = (0,react_facet_src.useFacetMap)(facet => facet.prompt.active, [], [resourcePacks]); // TODO: Check/optimise the equality fn

  const title = (0,react_facet_src.useFacetMap)(facet => facet.prompt.title, [], [resourcePacks]);
  const body = (0,react_facet_src.useFacetMap)(facet => facet.prompt.body, [], [resourcePacks]);
  const buttons = (0,react_facet_src.useFacetMap)(facet => facet.prompt.actions, [], [resourcePacks]);
  const handleOption = (0,react_facet_src.useFacetCallback)(facet => id => {
    facet.prompt.handleAction(id);
  }, [], [resourcePacks]); // Hide the close button if there is only one button

  const hideCloseButton = (0,react_facet_src.useFacetMap)(buttons => buttons.length <= 1, [], [buttons]); // If there is more than one button, we use the first 'secondary' button variant as the close handler

  const closeHandler = (0,react_facet_src.useFacetCallback)(buttons => buttons.length > 1 ? () => {
    var _buttons$find;

    const buttonId = (_buttons$find = buttons.find(({
      variant
    }) => variant === types_PromptActionVariant.Secondary)) === null || _buttons$find === void 0 ? void 0 : _buttons$find.id;

    if (buttonId != null) {
      handleOption(buttonId);
    }
  } : Prompt_noop, [handleOption], [buttons]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: show
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: MODAL_DEFAULT_BUTTON_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeHandler,
    hideCloseButton: hideCloseButton
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: body,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: body
  }))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: false
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: buttons
  }, (button, index) => /*#__PURE__*/react.createElement(react.Fragment, null, index > 0 && /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(ModalButton, {
    button: button,
    index: index,
    onClick: handleOption
  }))))));
}
const MODAL_DEFAULT_BUTTON_ALIAS = 'prompt-default-btn';

function ModalButton({
  button,
  onClick,
  index
}) {
  const {
    t
  } = useLocalization('CreateNewWorld.dlcCheckErrorModal');
  const onClickWithId = (0,react_facet_src.useFacetCallback)(button => () => onClick(button.id), [onClick], [button]);
  const variant = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(button => button.variant === types_PromptActionVariant.Primary ? 'primary' : 'secondary', [], [button]));
  return /*#__PURE__*/react.createElement(Button_Button_Button, {
    onClick: onClickWithId,
    gamepadIndex: index,
    inputLegend: t('.buttonSelectInputLegend'),
    gamepadAlias: index === 0 ? MODAL_DEFAULT_BUTTON_ALIAS : undefined,
    variant: variant === react_facet_src.NO_VALUE ? 'secondary' : variant
  }, (0,react_facet_src.useFacetMap)(button => button.label, [], [button]));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/WorldSettings.tsx

















function WorldSettings({
  generalData,
  multiplayerData,
  cheatsData,
  isLockedTemplate,
  worldPacks,
  advancedSettings,
  experimentsData,
  showDownloadPackModal,
  downloadPackName,
  downloadPackPercentage,
  isDownloadingPack,
  isImportingPack,
  worldPreviewImage,
  isUsingTemplate,
  onActivatePack,
  onDeactivatePack,
  onDownloadPackCancel,
  onChangePackPriority,
  backButtonCallback,
  mainActionCallback,
  realmsActionCallback
}) {
  const mode = (0,react.useContext)(WorldModeContext);
  const {
    t
  } = useLocalization('CreateNewWorld');
  const breakpoint = useWindowBreakpoint();
  const buildSettings = (0,react_facet_src.useSharedFacet)(buildSettingsFacet);
  const isEditorWorldFacet = (0,react_facet_src.useSharedFacet)(isEditorWorldSelector);
  const isTrialAccountFacet = (0,react_facet_src.useSharedFacet)(isTrialAccountSelector);
  const isEduBuildFacet = (0,react_facet_src.useSharedFacet)(isEduBuildSelector);
  const showRealmsButton = (0,react_facet_src.useFacetMap)((isEditor, isEduBuild, isTrialAccount, buildSettings) => !(isEditor || isEduBuild || isTrialAccount || buildSettings.isPreviewBuild || mode === 'edit'), [mode], [isEditorWorldFacet, isEduBuildFacet, isTrialAccountFacet, buildSettings]);
  const titleLabelFacet = (0,react_facet_src.useFacetMap)(isEditor => t(`${isEditor ? '.editor' : ''}.title`), [t], [isEditorWorldFacet]);
  const editWorldTitle = t('.editTitle');
  const hasAppliedWorldTemplate = useApplyWorldTemplate();
  const showSpinner = (0,react_facet_src.useFacetMap)((requestedWorldTemplate, appliedWorldTemplate) => requestedWorldTemplate && !appliedWorldTemplate, [], [hasAppliedWorldTemplate, isUsingTemplate]);
  return /*#__PURE__*/react.createElement(PointerBlocker_PointerBlocker, null, /*#__PURE__*/react.createElement(LeavingCNWForMarketplaceModalProvider, null, /*#__PURE__*/react.createElement(IsWorldTemplateLoading.Provider, {
    value: showSpinner
  }, /*#__PURE__*/react.createElement(GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout, {
    narrationText: mode === 'edit' ? t('.editTitleNarration') : t('.titleNarration'),
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: backButtonCallback
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography, {
      variant: "header5A",
      color: "black"
    }, mode === 'edit' ? editWorldTitle : titleLabelFacet)
  }, /*#__PURE__*/react.createElement(Grid_Grid, {
    noGutters: true
  }, breakpoint === 'desktop' && /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 4,
    narrowSize: 3
  }, /*#__PURE__*/react.createElement(DeferredMountContainer, {
    showRealmsButton: showRealmsButton,
    showSpinner: showSpinner,
    worldPreviewImage: worldPreviewImage,
    onMainActionClick: mainActionCallback,
    onMainRealmsActionClick: realmsActionCallback,
    worldPacks: worldPacks,
    generalData: generalData
  })), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 8,
    narrowSize: 5
  }, /*#__PURE__*/react.createElement(TabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(GeneralTab, {
      isLockedTemplate: isLockedTemplate,
      generalData: generalData
    }), [isLockedTemplate, generalData]),
    tab: "general"
  }), /*#__PURE__*/react.createElement(TabWrapper, {
    tab: "experimental",
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(ExperimentalFeaturesTab, {
      isLockedTemplate: isLockedTemplate,
      experimentsData: experimentsData
    }), [isLockedTemplate, experimentsData])
  }), /*#__PURE__*/react.createElement(TabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(ResourcePacksTab_ResourcePacksTab, {
      multiplayerData: multiplayerData,
      worldPacks: worldPacks,
      isLockedTemplate: isLockedTemplate,
      onActivatePack: onActivatePack,
      onDeactivatePack: onDeactivatePack,
      onChangePackPriority: onChangePackPriority
    }), [multiplayerData, worldPacks, isLockedTemplate, onActivatePack, onDeactivatePack, onChangePackPriority]),
    tab: "resource-packs"
  }), /*#__PURE__*/react.createElement(TabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(CheatsTab, {
      cheatsData: cheatsData,
      isLockedTemplate: isLockedTemplate
    }), [cheatsData, isLockedTemplate]),
    tab: "cheats"
  }), /*#__PURE__*/react.createElement(TabWrapper, {
    tab: "advanced",
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(AdvancedTab, {
      advancedSettings: advancedSettings,
      isLockedTemplate: isLockedTemplate
    }), [advancedSettings, isLockedTemplate])
  }), /*#__PURE__*/react.createElement(TabWrapper, {
    tab: "multiplayer",
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(MultiplayerTab_MultiplayerTab, {
      multiplayerData: multiplayerData,
      worldPacks: worldPacks,
      onDeactivatePack: onDeactivatePack
    }), [multiplayerData, worldPacks, onDeactivatePack])
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(isEduBuild => isEduBuild, [], [isEduBuildFacet])
  }, /*#__PURE__*/react.createElement(TabWrapper, {
    tab: "scripting-coding",
    component: ScriptingCodingTabWrapper
  })), /*#__PURE__*/react.createElement(TabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(BehaviorPacksTab_BehaviorPacksTab, {
      multiplayerData: multiplayerData,
      worldPacks: worldPacks,
      isLockedTemplate: isLockedTemplate,
      onActivatePack: onActivatePack,
      onDeactivatePack: onDeactivatePack,
      onChangePackPriority: onChangePackPriority
    }), [multiplayerData, worldPacks, isLockedTemplate, onActivatePack, onDeactivatePack, onChangePackPriority]),
    tab: "behavior-packs"
  }), /*#__PURE__*/react.createElement(TabWrapper, {
    tab: "debug",
    component: DebugTabWrapper
  }))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showDownloadPackModal
  }, /*#__PURE__*/react.createElement(ResourcePacksDownloadModal.Component, {
    title: downloadPackName,
    percentage: downloadPackPercentage,
    isDownloadingPack: isDownloadingPack,
    isImportingPack: isImportingPack,
    onCancel: onDownloadPackCancel
  })), /*#__PURE__*/react.createElement(UnlockSettingsMessageModal, null), /*#__PURE__*/react.createElement(ExperimentalFeaturesActivationWarningModal, null), /*#__PURE__*/react.createElement(LeavingCNWForMarketplaceModal, null), /*#__PURE__*/react.createElement(Prompt_Prompt, null)))));
}

const WorldSettingsWrapper = props => {
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: props.renderPage
  }, /*#__PURE__*/react.createElement(WorldSettings, props));
};

const useApplyWorldTemplate = () => {
  const historyAPI = RouteHistory_useRouteHistory();
  const applyTemplateSharedFacet = (0,react_facet_src.useSharedFacet)(applyTemplateSelector);
  const [applyingWorldTemplate, setApplyingWorldTemplate] = (0,react_facet_src.useFacetState)(false);
  const {
    worldTemplateId
  } = useRouteParams();
  const hasCalledFacetApplyTemplate = (0,react.useRef)(false);
  const applyTemplate = (0,react_facet_src.useFacetCallback)(appTemp => worldTemplateId => appTemp(worldTemplateId), [], [applyTemplateSharedFacet]);
  (0,react_facet_src.useFacetEffect)(() => {
    // This "available" & "active" check is a temp fix to work with the resource packs filter tab route
    // TODO: Find more elegant solution
    if (worldTemplateId == null || ['available', 'active'].includes(worldTemplateId) || hasCalledFacetApplyTemplate.current === true) {
      return;
    }

    hasCalledFacetApplyTemplate.current = true;
    setApplyingWorldTemplate(true);
    applyTemplate(worldTemplateId);
    historyAPI.replaceKeepingFocus('/create-new-world/general');
  }, [worldTemplateId, setApplyingWorldTemplate, applyTemplate, historyAPI], [applyTemplateSharedFacet]);
  return applyingWorldTemplate;
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/images/world-preview-default.jpg
const world_preview_default_namespaceObject = __webpack_require__.p + "assets/world-preview-default-03016.jpg";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/CreateNewWorldRoute/CreateNewWorldRoute.tsx










const CreateNewWorldRoute = () => {
  const createNewWorld = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const resourcePacks = (0,react_facet_src.useSharedFacet)(resourcePacksFacet);
  const multiplayerSelectorFacet = (0,react_facet_src.useSharedFacet)(multiplayerSelector);
  const advancedSelectorFacet = (0,react_facet_src.useSharedFacet)(advancedSettingsSelector);
  const optionsFacetLocal = (0,react_facet_src.useSharedFacet)(optionsFacet);
  const inputFacetLocal = (0,react_facet_src.useSharedFacet)(inputFacet);
  const telemetry = (0,react_facet_src.useSharedFacet)(telemetryFacet);
  const isLockedTemplate = (0,react_facet_src.useFacetMap)(facet => facet.isLockedTemplate, [], [createNewWorld]);
  const worldData = (0,react_facet_src.useFacetMap)(facet => facet.worldCreationData, [], [createNewWorld]);
  const generalData = (0,react_facet_src.useFacetMap)(facet => facet.general, [], [worldData]);
  const betaFeatures = (0,react_facet_src.useFacetMap)(facet => facet.betaFeatures, [], [worldData]);
  const historyAPI = RouteHistory_useRouteHistory();
  const isUsingTemplate = (0,react_facet_src.useFacetMap)(facet => facet.isUsingTemplate, [], [createNewWorld]);
  const createNewWorldCheatsSelectorShared = (0,react_facet_src.useSharedFacet)(cheatsSettingsSelector); // Download pack modal.

  const showDownloadPackModal = (0,react_facet_src.useFacetMap)(facet => facet.resourcePackToDownload != null && (facet.status === resourcePacksFacet_ResourcePacksFacetStatus.DownloadingResourcePacks || facet.status === resourcePacksFacet_ResourcePacksFacetStatus.StartDownload), [], [resourcePacks]);
  const downloadPackModalTitle = (0,react_facet_src.useFacetMap)(facet => facet.resourcePackToDownload.title, [], [resourcePacks]);
  const downloadPackModalPercentage = (0,react_facet_src.useFacetMap)(facet => (facet.downloadProgress + facet.importProgress) * 0.5, [], [resourcePacks]);
  const isDownloadingPack = (0,react_facet_src.useFacetMap)(facet => facet.downloadProgress < 1, [], [resourcePacks]);
  const isImportingPack = (0,react_facet_src.useFacetMap)(facet => facet.downloadProgress >= 1 && facet.importProgress < 1, [], [resourcePacks]); // Pack actions.

  const onActivatePack = (0,react_facet_src.useFacetCallback)((resourcePacks, createNewWorld) => packId => {
    resourcePacks.activate(packId, createNewWorld.showedAchievementWarning, true, true);
  }, [], [resourcePacks, createNewWorld]);
  const onDeactivatePack = (0,react_facet_src.useFacetCallback)(facet => packId => {
    facet.deactivate(packId);
  }, [], [resourcePacks]);
  const onChangePackPriority = (0,react_facet_src.useFacetCallback)(facet => (packId, packType, dragIndex, dropIndex) => {
    facet.changePackPriority(packId, dragIndex, dropIndex);
  }, [], [resourcePacks]);
  const createWorldError = (0,react_facet_src.useFacetMap)(({
    createWorld: {
      error
    }
  }) => error != null, [], [createNewWorld]);
  const onDownloadPackCancel = (0,react_facet_src.useFacetCallback)((isDownloadingPack, facet) => () => {
    if (isDownloadingPack) facet.cancelDownload();
  }, [], [isDownloadingPack, resourcePacks]);
  const worldPreviewImagePath = (0,react_facet_src.useFacetMap)(facet => facet.worldPreviewImagePath != null && facet.worldPreviewImagePath.length > 0 ? facet.worldPreviewImagePath : world_preview_default_namespaceObject, [], [createNewWorld]);
  const showLoseYourChangesModal = LoseYourChangesModal.useShowModal();
  const backButtonCallback = (0,react_facet_src.useFacetCallback)(facet => () => {
    const userHasChangedSettings = facet.checkIfUserHasChangedSettings();

    if (userHasChangedSettings) {
      showLoseYourChangesModal({
        onLeave: () => {
          historyAPI.goBack();
        }
      });
    } else {
      historyAPI.goBack();
    }
  }, [historyAPI, showLoseYourChangesModal], [createNewWorld]);
  const createWorldCallback = (0,react_facet_src.useFacetCallback)((options, input, world, telemetry) => () => {
    if (options.showTouchControlSelectionScreen && input.currentInputType == types_InputMethod.TOUCH) {
      world.inWorldCreation = true;
      historyAPI.push('/touch-control-selection');
    } else {
      telemetry.fireEventButtonPressed('Create_World_Button_OreUI', {});
      world.createWorld.call();
    }
  }, [historyAPI], [optionsFacetLocal, inputFacetLocal, createNewWorld, telemetry]);
  const createOnRealmsCallback = (0,react_facet_src.useFacetCallback)((world, telemetry) => () => {
    telemetry.fireEventButtonPressed('Create_On_Realms_OreUI', {});
    world.createOnRealms.call();
  }, [], [createNewWorld, telemetry]); // This is a temporary hack for a scenario where the user can load a new CNW screen while
  // the CNW screen is already on the scene stack (by going through marketplace from Resource Packs).
  // In this scenario, the backend will flip this consumeResetFlag to true for a frame so we reset
  // the React states.

  const renderPage = (0,react_facet_src.useFacetMap)(facet => !facet.consumeResetFlag, [], [createNewWorld]);
  const showCreateOnRealmsErrorModal = (0,react_facet_src.useFacetMap)(world => world.createOnRealms.error != null, [], [createNewWorld]);
  return /*#__PURE__*/react.createElement(WorldModeContext.Provider, {
    value: "create"
  }, /*#__PURE__*/react.createElement(WorldSettingsWrapper, {
    generalData: generalData,
    multiplayerData: multiplayerSelectorFacet,
    cheatsData: createNewWorldCheatsSelectorShared,
    isLockedTemplate: isLockedTemplate,
    worldPacks: resourcePacks,
    showDownloadPackModal: showDownloadPackModal,
    downloadPackName: downloadPackModalTitle,
    downloadPackPercentage: downloadPackModalPercentage,
    isDownloadingPack: isDownloadingPack,
    isImportingPack: isImportingPack,
    worldPreviewImage: worldPreviewImagePath,
    isUsingTemplate: isUsingTemplate,
    renderPage: renderPage,
    onActivatePack: onActivatePack,
    onDeactivatePack: onDeactivatePack,
    onDownloadPackCancel: onDownloadPackCancel,
    onChangePackPriority: onChangePackPriority,
    advancedSettings: advancedSelectorFacet,
    experimentsData: betaFeatures,
    backButtonCallback: backButtonCallback,
    mainActionCallback: createWorldCallback,
    realmsActionCallback: createOnRealmsCallback
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: createWorldError
  }, /*#__PURE__*/react.createElement(CreateWorldErrorModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showCreateOnRealmsErrorModal
  }, /*#__PURE__*/react.createElement(CreateOnRealmsErrorModal.Component, null)));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/CreateNewWorldRoute/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/MobileDataBlockedModalRoute/MobileDataBlockedModalRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MobileDataBlockedModalRoute = ({"centeredLink":"Hrjsd"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/MobileDataBlockedModalRoute/MobileDataBlockedModalRoute.tsx









const MobileDataBlockedModalRoute_MobileDataBlockedModalRoute = () => {
  const historyAPI = RouteHistory_useRouteHistory();
  const optionsWrapped = (0,react_facet_src.useSharedFacet)(optionsFacet);
  const telemetryWrapped = (0,react_facet_src.useSharedFacet)(telemetryFacet);
  const fireTelemetry = (0,react_facet_src.useFacetCallback)(telemetry => buttonName => {
    telemetry.fireEventButtonPressed('MobileDataBlockedModal_'.concat(buttonName), {});
  }, [], [telemetryWrapped]);
  const setUseDataOnce = (0,react_facet_src.useFacetCallback)(options => () => {
    options.useMobileDataOnce = true;
  }, [], [optionsWrapped]);
  const DEFAULT_FOCUS_ALIAS = 'backButton';
  const {
    t
  } = useLocalization('MobileDataBlockedModalRoute');
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: `${t('.title')}. ${t('.onlyWifi')}. ${t('.costWarning')}`
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: () => {
      fireTelemetry('Close_Button_Or_Unfocus');
      historyAPI.goBack();
    }
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${t('.onlyWifi')}. ${t('.costWarning')}`,
    spaceBetweenParagraphs: 5,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong"
  }, t('.onlyWifi')), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    fontWeight: Typography_Typography.FontWeight.Bold
  }, t('.costWarning'))), /*#__PURE__*/react.createElement(NarrationContext, {
    text: `${t('.changeSettings')}`
  }, /*#__PURE__*/react.createElement("div", {
    className: MobileDataBlockedModalRoute.centeredLink
  }, /*#__PURE__*/react.createElement(Link_Link, {
    gamepadIndex: 0,
    onClick: () => {
      fireTelemetry('Settings_Page_Link');
      historyAPI.replace(`/mobile-data-blocked-modal/links/settings-page`);
    },
    withUnderlinePolyfill: true
  }, t('.changeSettings'))))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    delayedClick: true,
    onClick: () => {
      fireTelemetry('Go_Back_Button');
      historyAPI.goBack();
    },
    autofocus: true,
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.goBack'),
    variant: "primary"
  }, t('.goBack')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    delayedClick: true,
    onClick: () => {
      fireTelemetry('Use_Data_Once_Button');
      setUseDataOnce();
      historyAPI.goBack();
    },
    inputLegend: t('.playOnceWithData'),
    variant: "secondary"
  }, t('.playOnceWithData')))));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/MobileDataBlockedModalRoute/index.ts

// EXTERNAL MODULE: ./node_modules/ramda/src/times.js
var times = __webpack_require__(32250);
var times_default = /*#__PURE__*/__webpack_require__.n(times);
// EXTERNAL MODULE: ./node_modules/ramda/src/splitEvery.js
var splitEvery = __webpack_require__(59241);
var splitEvery_default = /*#__PURE__*/__webpack_require__.n(splitEvery);
;// CONCATENATED MODULE: ./packages/ui/src/GridList/GridList.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const GridList = ({"row":"jc_nV","cell":"aTnV0"});
;// CONCATENATED MODULE: ./packages/ui/src/GridList/GridList.tsx








const FILLER = Symbol('filler');

const GridListItem = ({
  horizontalIndex,
  verticalIndex,
  index,
  itemSeparatorHorizontal,
  renderItem,
  item,
  listLengthFacet
}) => {
  return /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(react.Fragment, null, horizontalIndex > 0 && itemSeparatorHorizontal, /*#__PURE__*/react.createElement("div", {
    className: GridList.cell
  }, /*#__PURE__*/react.createElement(react_facet_src.With, {
    data: (0,react_facet_src.useFacetMemo)(item => item !== FILLER ? item : undefined, [], [item])
  }, item => renderItem({
    itemFacet: item,
    index,
    rowIndex: verticalIndex,
    columnIndex: horizontalIndex,
    listLengthFacet
  })))));
};

function GridList_GridList({
  loading,
  emptyMessage,
  renderItem,
  data,
  gamepadIndex,
  scrollIntoViewAlign,
  scrollIntoViewSpeedFactor,
  itemSeparatorHorizontal,
  itemSeparatorVertical,
  firstRowSeparatorVertical,
  footer,
  renderTracker,
  columns,
  autofocus
}) {
  const isRenderingPaused = (0,dist.useIsPaused)();
  const dataFacet = (0,react_facet_src.useFacetWrap)(data);
  const countFacet = (0,react_facet_src.useFacetMap)(data => data.length, [], [dataFacet]);
  const countValue = (0,react_facet_src.useFacetUnwrap)(countFacet);
  const dataMatrix = (0,react_facet_src.useFacetMemo)(data => {
    // If there is no data the matrix should contain an empty array
    if (data.length > 0) {
      const rows = splitEvery_default()(columns, data);

      const lastRow = rows[rows.length - 1];

      times_default()(() => lastRow.push(FILLER), columns - lastRow.length);

      return rows;
    } else {
      return [];
    }
  }, [columns], [dataFacet]);
  return /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(GridList_ScrollViewContainer, {
    autofocus: autofocus,
    loading: (0,react_facet_src.useFacetWrap)(loading !== null && loading !== void 0 ? loading : false),
    gamepadIndex: gamepadIndex,
    scrollIntoViewAlign: scrollIntoViewAlign,
    scrollIntoViewSpeedFactor: scrollIntoViewSpeedFactor,
    renderTracker: renderTracker
  }, !isRenderingPaused && /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: dataMatrix
  }, (row, verticalIndex) => /*#__PURE__*/react.createElement(react.Fragment, null, verticalIndex === 0 && firstRowSeparatorVertical, verticalIndex > 0 && itemSeparatorVertical, /*#__PURE__*/react.createElement("div", {
    className: GridList.row
  }, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: verticalIndex,
    defaultFocusedChildBehavior: "grid"
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: row
  }, (item, horizontalIndex) => /*#__PURE__*/react.createElement(GridListItem, {
    horizontalIndex: horizontalIndex,
    verticalIndex: verticalIndex,
    index: verticalIndex * columns + horizontalIndex,
    itemSeparatorHorizontal: itemSeparatorHorizontal,
    renderItem: renderItem,
    item: item,
    listLengthFacet: countFacet
  })))))),
  /**
   * We need to deffer the empty message, since the DeferredMountProvider will be waiting
   * for something to be mounted using DeferredMount so that it will run its process and complete
   * any deferred rendering
   *
   * Removing this would cause an spinner to be shown for all eternity.
   */
  countValue != null && countValue === 0 && /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(react.Fragment, null, emptyMessage)), footer));
}
function GridList_ScrollViewContainer({
  loading,
  gamepadIndex,
  children,
  scrollIntoViewAlign,
  scrollIntoViewSpeedFactor,
  renderTracker,
  horizontal,
  autofocus
}) {
  const isPaused = (0,dist.useIsPaused)();
  const isLoading = (0,react_facet_src.useFacetMap)((isDeferring, loading) => isDeferring || isPaused || loading, [isPaused], [(0,dist.useIsDeferring)(), loading]);
  return /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    autofocus: autofocus,
    loading: isLoading,
    gamepadIndex: gamepadIndex,
    scrollIntoViewAlign: scrollIntoViewAlign,
    scrollIntoViewSpeedFactor: scrollIntoViewSpeedFactor,
    renderTracker: renderTracker,
    horizontal: horizontal
  }, children);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useImagePreloading.tsx
function useImagePreloading_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function useImagePreloading_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { useImagePreloading_ownKeys(Object(source), true).forEach(function (key) { useImagePreloading_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { useImagePreloading_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function useImagePreloading_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



function useImagePreloading(imageUrls, timeoutMS) {
  const urls = (0,react_facet_src.useFacetWrap)(imageUrls);
  const callbackState = (0,react.useRef)({});
  const [isPreloading, setIsPreloading] = (0,react_facet_src.useFacetState)(true); // Store a reference to the container that contains all of the image nodes

  const containerRef = (0,react.useRef)(null); // This effect will start running the check as soon as we've got some urls.

  (0,react_facet_src.useFacetLayoutEffect)(urls => {
    // If the urls changes we'll remove the previous container and reset the refs.
    containerRef.current && document.body.removeChild(containerRef.current);
    containerRef.current = null;
    callbackState.current = urls.reduce((acc, cur) => useImagePreloading_objectSpread(useImagePreloading_objectSpread({}, acc), {}, {
      [cur]: false
    }), {});

    const imageHasLoaded = url => () => {
      // Update the hashmap so we know that this url has been loaded
      callbackState.current[url] = true; // Check if this was the last image to load

      const callbackValues = Object.values(callbackState.current);

      if (callbackValues.length === urls.length && callbackValues.every(x => x)) {
        setIsPreloading(false);
      }
    };

    if (urls.filter(url => url.length > 0).length) {
      const container = document.createElement('div');
      container.style.visibility = 'hidden';
      container.style.position = 'absolute';
      containerRef.current = container;
      urls.forEach(url => {
        const image = new Image();
        image.src = url;
        image.addEventListener('load', imageHasLoaded(url));
        container.appendChild(image);
      });
      document.body.appendChild(container);
    }

    return () => {
      containerRef.current && document.body.removeChild(containerRef.current);
      containerRef.current = null;
    };
  }, [setIsPreloading], [urls]); // Make it possible to short-ciruit the preloading

  (0,react.useEffect)(() => {
    let timeout;

    if (timeoutMS != null) {
      timeout = setTimeout(() => setIsPreloading(false), timeoutMS);
    }

    return () => {
      if (timeout != null) {
        clearTimeout(timeout);
      }
    };
  }, [timeoutMS, setIsPreloading]);
  return isPreloading;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/SeedTemplateCard/images/placeholder.png
const SeedTemplateCard_images_placeholder_namespaceObject = __webpack_require__.p + "assets/placeholder-9e208.png";
;// CONCATENATED MODULE: ./packages/react-narrator/src/hooks/useSetParentNarrationText.tsx

 // To enable compositional components that cna have both text, buttons and images as children
// to internally handle the narration, The text content is provided using context

const ChildTextNarrationApi = (0,react.createContext)({
  getId: () => 0,
  set: () => {}
});

const useChildTextNarrationApi = () => (0,react.useContext)(ChildTextNarrationApi);
/**
 * This hook should be used in compositional components to help configure the narration tex, since there might be multiple of them.
 * It receives a unique id from the parent component and uses this as an key to set the narration text at a higher level.
 */


const useSetParentNarrationText = text => {
  const childNarrationApi = useChildTextNarrationApi();
  const [id, setId] = (0,react_facet_src.useFacetState)(react_facet_src.NO_VALUE); // Get a unique id for this child

  (0,react.useEffect)(() => {
    // Exit early if we don't have an id (shouldn't happen)
    if (id.get() != react_facet_src.NO_VALUE) return;
    setId(childNarrationApi.getId());
  }, [id, setId, childNarrationApi]); // Set the narration text against our unique id

  (0,react_facet_src.useFacetEffect)((id, text) => {
    childNarrationApi.set(id, text);
  }, [childNarrationApi], [id, (0,react_facet_src.useFacetWrap)(text)]);
};
function ChildTextNarrationApiProvider({
  children,
  setNarrationTextState
}) {
  const childId = (0,react.useRef)(0);
  return /*#__PURE__*/react.createElement(ChildTextNarrationApi.Provider, {
    value: (0,react.useMemo)(() => ({
      getId: () => childId.current++,
      set: (childId, text) => setNarrationTextState(prev => {
        if (prev === react_facet_src.NO_VALUE) return []; // Shouldn't ever happen as we default to an array

        prev[childId] = text === false ? '' : text;
        return prev;
      })
    }), [setNarrationTextState])
  }, children);
}
;// CONCATENATED MODULE: ./packages/ui/src/Card/Card.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Card = ({"cardWrapper":"MLe4y","card":"Dsmzk","cardDropShadow":"xeqcX","hovered":"IseJx","pressed":"JAVQA","information":"XiGeZ","bottomEdge":"Ikw_7"});
;// CONCATENATED MODULE: ./packages/ui/src/Card/Card.tsx








function Card_Card({
  autofocus,
  gamepadIndex,
  children,
  onClick,
  inputLegend,
  gamepadAlias,
  onFocusChanged,
  onHoverChanged,
  narrationSuffix,
  narrationTextOverride,
  role = 'neutral'
}) {
  const {
    sound: {
      neutral: semanticSound
    }
  } = useSemanticTokens();
  const [titleNarrationTextState, setTitleNarrationTextState] = (0,react_facet_src.useFacetState)([]);
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  const narrationTextOverrideWrapped = (0,react_facet_src.useFacetWrap)(narrationTextOverride !== null && narrationTextOverride !== void 0 ? narrationTextOverride : '');
  const {
    t
  } = useLocalization('Card');
  const contextNarration = (0,react_facet_src.useFacetMap)((titleNarrationTextState, narrationTextOverrideWrapped, narrationSuffix) => {
    // If the narration is overridden, it should only use the provided string
    if (narrationTextOverrideWrapped) return narrationTextOverrideWrapped;
    return `${titleNarrationTextState.join(' . ')} . ${t('.narrationComponentTypeButton')} . ${narrationSuffix}`;
  }, [t], [titleNarrationTextState, narrationTextOverrideWrapped, (0,react_facet_src.useFacetWrap)(narrationSuffix !== null && narrationSuffix !== void 0 ? narrationSuffix : '')]);
  return /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement("div", {
    className: Card.cardWrapper
  }, /*#__PURE__*/react.createElement(BoxBorder, {
    autofocus: autofocus,
    gamepadAlias: gamepadAlias,
    className: classnames_default()(Card.card, semanticClassNames.border.interactive, semanticClassNames.text.base),
    classNameHovered: Card.hovered,
    classNamePressed: Card.pressed,
    gamepadIndex: gamepadIndex,
    inputLegend: inputLegend,
    narrationText: contextNarration,
    onClick: onClick,
    onFocusChanged: onFocusChanged,
    onHoverChanged: onHoverChanged,
    soundEffectPressed: semanticSound.press
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(ChildTextNarrationApiProvider, {
    setNarrationTextState: setTitleNarrationTextState
  }, children), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Card.bottomEdge, semanticClassNames.shadow.base)
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Card.cardDropShadow, semanticClassNames.dropShadow.base)
  })));
}

function Information({
  children,
  innerRef,
  narrationText
}) {
  const {
    color: {
      inherit: semanticClassNames
    }
  } = useSemanticTokens(); // Set child string value as narration string

  useSetParentNarrationText(narrationText);
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Card.information, semanticClassNames.border.base, semanticClassNames.background.base, semanticClassNames.background.hover),
    ref: innerRef
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), children, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }));
}

Card_Card.Information = Information;
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/SeedTemplateCard/SeedTemplateCard.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SeedTemplateCard = ({"illustrationStandard":"EpyXS","illustrationPlaceholder":"CPwL0"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/SeedTemplateCard/SeedTemplateCard.tsx








const hasImage = template => template.image != null && template.image != '';

function SeedTemplateCard_SeedTemplateCard({
  template,
  onSelect,
  gamepadIndex,
  inputLegend,
  autofocus
}) {
  const handleClickOnCard = (0,react_facet_src.useFacetCallback)(facetTemplate => () => {
    onSelect(facetTemplate.seedValue, facetTemplate.image);
  }, [onSelect], [template]);
  const title = (0,react_facet_src.useFacetMap)(facet => facet.title, [], [template]);
  const className = (0,react_facet_src.useFacetMap)(template => hasImage(template) ? SeedTemplateCard.illustrationStandard : SeedTemplateCard.illustrationPlaceholder, [], [template]);
  const src = (0,react_facet_src.useFacetMap)(template => hasImage(template) ? template.image : SeedTemplateCard_images_placeholder_namespaceObject, [], [template]);
  const imageRendering = (0,react_facet_src.useFacetMap)(template => hasImage(template) ? undefined : 'pixelated', [], [template]);
  const {
    t
  } = useLocalization('SeedTemplateCard');
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Card_Card, {
    gamepadIndex: gamepadIndex,
    inputLegend: inputLegend,
    narrationSuffix: t('.narrationSuffix'),
    onClick: handleClickOnCard,
    autofocus: autofocus
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: className,
    src: src,
    imageRendering: imageRendering,
    cover: true
  }), /*#__PURE__*/react.createElement(Card_Card.Information, {
    narrationText: title
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit",
    verticalAlign: "center"
  }, title))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/SeedTemplateCard/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SeedTemplatesRoute/images/creeper-cropped.png
const creeper_cropped_namespaceObject = __webpack_require__.p + "assets/creeper-cropped-1ee9c.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SeedTemplatesRoute/SeedTemplatesRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SeedTemplatesRoute = ({"errorImage":"UzH8W","errorImageBig":"wdc99"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SeedTemplatesRoute/SeedTemplatesRoute.tsx


















const WAIT_FOR_SEED_TEMPLATE_IMAGES_MS = 1250;
const IMAGE_PRELOADING_TIMEOUT_MS = 8000;
const SeedTemplatesRoute_LOADING_TIMEOUT = 10000;
const SeedTemplatesRoute_LOADING_WARNING = 1500;
const emptySeedsFacet = (0,react_facet_src.createFacet)({
  initialValue: {
    templates: []
  }
});

const templateHasImage = template => template.image != null && template.image.length > 0;

function SeedTemplateRoute() {
  const {
    t
  } = useLocalization('SeedTemplatesRoute');
  const isPaused = (0,dist.useIsPaused)();
  const historyAPI = RouteHistory_useRouteHistory();
  const breakpoint = useWindowBreakpoint(); // To enable a bigger image size on bigger devices

  const imageBreakpoint = useWindowBreakpoint(102);
  const sharedFacet = (0,react_facet_src.useSharedFacet)(seedTemplatesFacet);
  const seedsFacet = isPaused ? emptySeedsFacet : sharedFacet; // The backend will give us a list of seed templates. However, the objects in that
  // array might not have an image to start with. They could be assigned later. Therefore,
  // we'll try to wait until we have enough images to cover a full grid.

  const hasEnoughImages = (0,react_facet_src.useFacetMap)(facet => {
    // If we haven't received any templates yet we cant have enough images to fill a grid.
    if (!facet.templates.length) {
      return false;
    } // Check to see if the first fold of templates has images


    if (facet.templates.length >= 9) {
      for (let i = 0; i < facet.templates.length; i++) {
        const template = facet.templates[i];

        if (template.image == null || !template.image.length) {
          return false;
        }
      }

      return true;
    } // If we don't have enough images for a full fold we'll try to wait for all of them.


    return every(facet.templates, template => template.image != null && template.image.length > 0);
  }, [], [seedsFacet]); // This is used to short-circuit the hasEnoughImages facet above. We
  // want all of the templates to have images, but we cant wait forever.

  const [hasExceededImageWaitTime, setHasExceededImageWaitTime] = (0,react_facet_src.useFacetState)(false);
  (0,react.useEffect)(() => {
    const timeout = setTimeout(() => setHasExceededImageWaitTime(true), WAIT_FOR_SEED_TEMPLATE_IMAGES_MS);
    return () => clearTimeout(timeout);
  }, [setHasExceededImageWaitTime]); // If the status is set to failed, the error message should be immediately shown

  const fetchFailed = (0,react_facet_src.useFacetMap)(seedTemplatesFacet => seedTemplatesFacet.failedToFetch, [], [sharedFacet]);
  const seedTemplates = (0,react_facet_src.useFacetMap)((seedsFacet, hasExceededImageWaitTime, hasEnoughImages, fetchFailed) => {
    if (fetchFailed) return [];
    const templates = []; // We will wait until we have either enough images, or we've exceeded the wait time.
    // As soon as we push items into the templates array we'll start the image preloader

    if (hasEnoughImages || hasExceededImageWaitTime) {
      for (let i = 0; i < seedsFacet.templates.length; i++) {
        const template = seedsFacet.templates[i]; // Don't add any duplicates.

        if (!templates.find(x => x.seedValue === template.seedValue)) {
          templates.push(template);
        }
      }
    }

    return templates;
  }, [], [seedsFacet, hasExceededImageWaitTime, hasEnoughImages, fetchFailed], () => () => false); // We'll prefetch the images so that they are cached when we render the
  // grid. That should, hopefully, make the rendering a lot smoother.

  const urlsFacet = (0,react_facet_src.useFacetMap)(templates => {
    // If an image receives an empty string in Gameface it will break
    const imageUrls = templates.filter(templateHasImage).map(template => template.image);

    if (templates.length) {
      // We also want to have the placeholder image preloaded.
      imageUrls.push(SeedTemplateCard_images_placeholder_namespaceObject);
    }

    return imageUrls;
  }, [], [seedTemplates]);
  const isPreloadingImages = useImagePreloading(urlsFacet, IMAGE_PRELOADING_TIMEOUT_MS);
  const imagesHaveLoaded = (0,react_facet_src.useFacetMap)((isPreloading, seedsFacet, fetchFailed) => {
    // If the fetch has failed, the timeout should exit early
    if (fetchFailed) return true;else return !isPreloading && seedsFacet.templates.length > 0 && !fetchFailed;
  }, [], [isPreloadingImages, seedsFacet, fetchFailed]);
  const loadingTimedOut = useTimeout(imagesHaveLoaded, SeedTemplatesRoute_LOADING_TIMEOUT);
  const showErrorMessage = (0,react_facet_src.useFacetMap)( // The loading timeout exits early if fetch has failed
  // In that case the error message should be shown
  (fetchFailed, loadingTimedOut) => fetchFailed || loadingTimedOut, [], [fetchFailed, loadingTimedOut]);
  const loadingTakingTime = useTimeout(imagesHaveLoaded, SeedTemplatesRoute_LOADING_WARNING);
  const narrateLoading = (0,react_facet_src.useFacetMap)((takingTime, isPreloadingImages) => takingTime && isPreloadingImages, [], [loadingTakingTime, isPreloadingImages]);
  const handleClick = (0,react_facet_src.useFacetCallback)(value => (newSeedValue, newImageValue) => {
    value.worldCreationData.advanced.worldSeed = newSeedValue;
    value.worldPreviewImagePath = newImageValue;
    historyAPI.goBack();
  }, [historyAPI], [(0,react_facet_src.useSharedFacet)(createNewWorldFacet)]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: narrateLoading
  }, /*#__PURE__*/react.createElement(Narration, {
    text: t('.narration.loadingMessage')
  })), /*#__PURE__*/react.createElement(GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout, {
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: () => historyAPI.goBack()
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography, {
      variant: "header5A",
      color: "black"
    }, t('.title'))
  }, /*#__PURE__*/react.createElement(Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showErrorMessage
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: 2,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 8,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    autofocus: true,
    imgSrc: creeper_cropped_namespaceObject,
    imgClass: imageBreakpoint === 'narrow' ? SeedTemplatesRoute.errorImage : SeedTemplatesRoute.errorImageBig,
    gamepadIndex: 0,
    title: t('.errorMessageTitle'),
    text: t('.errorMessageBody'),
    buttons: [{
      text: t('.errorBackButtonText'),
      inputLegend: t('.errorBackButtonInputLegend'),
      gamepadAlias: 'seed-temp-empty-state',
      onClick: () => historyAPI.goBack()
    }]
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: loadingTimedOut,
    condition: false
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(GridList_GridList, {
    autofocus: true,
    loading: (0,react_facet_src.useFacetMap)(imagesHaveLoaded => !imagesHaveLoaded, [], [imagesHaveLoaded]),
    gamepadIndex: 0,
    data: seedTemplates,
    columns: breakpoint === 'narrow' ? 2 : 3,
    firstRowSeparatorVertical: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 1
    }) // Used to stop the focus outline being hidden by the overflow
    ,
    itemSeparatorHorizontal: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: breakpoint === 'narrow' ? 1 : 3
    }),
    itemSeparatorVertical: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: breakpoint === 'narrow' ? 2 : 4
    }),
    footer: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputLegend_InputLegend.Space, null), /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 1
    })),
    renderItem: ({
      itemFacet,
      columnIndex,
      rowIndex
    }) => /*#__PURE__*/react.createElement(SeedTemplateCard_SeedTemplateCard, {
      autofocus: columnIndex === 0 && rowIndex === 0,
      template: itemFacet,
      gamepadIndex: columnIndex,
      inputLegend: t('.selectTemplateInputLegend'),
      onSelect: handleClick
    }),
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingEvent, {
      type: "meaningful",
      renderingCompleted: isContentShown
    })
  }))))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SeedTemplatesRoute/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/RowWrapper.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RowWrapper = ({"hidden":"N9BNb"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/RowWrapper.tsx






function RowWrapper_RowWrapper({
  Component,
  route,
  gamepadIndex,
  wideSize,
  narrowSize
}) {
  const params = useRouteParams();
  const visible = params.tab === route;
  const active = (0,react_facet_src.useFacetWrap)(visible);
  const hiddenClass = visible ? '' : RowWrapper.hidden;
  const mountedRef = (0,react.useRef)(visible);
  mountedRef.current = mountedRef.current || visible;
  const widePaddingSize = (12 - wideSize) / 2;
  const narrowPaddingSize = (8 - narrowSize) / 2; // TODO: We'll have to change the render tracking in the future. We'll probably have to make the meaningful
  // one a be a RenderTrackingDelay and send another RenderTrackingEvent in each tab. It's easier to do this
  // once we know more about how each tab is loading.

  return mountedRef.current ? /*#__PURE__*/react.createElement(RouteActiveProvider, {
    active: active
  }, /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    fullHeight: true,
    gamepadIndex: gamepadIndex,
    className: hiddenClass,
    disabled: !visible
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: widePaddingSize,
    narrowSize: narrowPaddingSize,
    gamepadIndex: -1,
    disabled: true
  }), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: wideSize,
    narrowSize: narrowSize,
    gamepadIndex: 0,
    disabled: !visible
  }, /*#__PURE__*/react.createElement(Component, null)), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: widePaddingSize,
    narrowSize: narrowPaddingSize,
    gamepadIndex: 1,
    disabled: true
  })), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: visible
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: visible
  })) : null;
}
;// CONCATENATED MODULE: ./packages/ui/src/PlayerStatusBadge/Images/online-badge.png
const online_badge_namespaceObject = __webpack_require__.p + "assets/online-badge-73dd0.png";
;// CONCATENATED MODULE: ./packages/ui/src/PlayerStatusBadge/PlayerStatusBadge.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PlayerStatusBadge = ({"onlineBadge":"KDWBk"});
;// CONCATENATED MODULE: ./packages/ui/src/PlayerStatusBadge/PlayerStatusBadge.tsx




function PlayerStatusBadge_PlayerStatusBadge() {
  return /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: online_badge_namespaceObject,
    className: PlayerStatusBadge.onlineBadge,
    imageRendering: "pixelated"
  });
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/PlayerAvatar/PlayerAvatar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PlayerAvatar = ({"playerAvatar":"VAC__","largePlayerAvatar":"FHWvG","wrapper":"h4MBg","largeWrapper":"yjDTL","badge":"oFxJL","online":"PIxlV","offline":"Biaix"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/PlayerAvatar/PlayerAvatar.tsx







const staticStatuses = {
  online: (0,react_facet_src.createStaticFacet)('online'),
  offline: (0,react_facet_src.createStaticFacet)('offline')
};
function PlayerAvatar_PlayerAvatar({
  status = 'online',
  src,
  variant = 'small'
}) {
  const statusFacet = (0,react_facet_src.isFacet)(status) ? status : staticStatuses[status];
  const badgeStyles = (0,react_facet_src.useFacetMap)(status => classnames_default()(PlayerAvatar.badge, PlayerAvatar[status]), [], [statusFacet]);
  const avatarStyles = variant === 'small' ? PlayerAvatar.playerAvatar : PlayerAvatar.largePlayerAvatar;
  const {
    color
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(PlayerAvatar.wrapper, {
      [PlayerAvatar.largeWrapper]: variant === 'large'
    }, color['neutral'].border.base)
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: badgeStyles
  }, /*#__PURE__*/react.createElement(PlayerStatusBadge_PlayerStatusBadge, null)), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: src,
    className: avatarStyles
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/Tag/Tag.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Tag = ({"tag":"c3aSY","tagWrapper":"j_y1K"});
;// CONCATENATED MODULE: ./packages/ui/src/Tag/Tag.tsx






function Tag_Tag({
  children,
  role
}) {
  const {
    color
  } = useSemanticTokens();
  const tagClasses = (0,react_facet_src.useFacetMap)(role => classnames_default()(Tag.tag, color[role].background.base, color[role].text.base), [color], [(0,react_facet_src.useFacetWrap)(role)]);
  return /*#__PURE__*/react.createElement("div", {
    className: Tag.tagWrapper
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: tagClasses
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit"
  }, children)), /*#__PURE__*/react.createElement("fast-div", {
    className: Tag.shadowBottom
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: Tag.shadowRight
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/PlayerAvatarWrapper/PlayerAvatarWrapper.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PlayerAvatarWrapper = ({"wrapper":"gj3Lw","additionalPlayers":"sVory","tagWrapper":"NN7aY","panel":"MRa9N"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/PlayerAvatarWrapper/PlayerAvatarWrapper.tsx









function PlayerAvatarWrapper_PlayerAvatarWrapper({
  players,
  full,
  totalAmountOfPlayers
}) {
  const {
    t
  } = useLocalization('PlayerAvatarWrapper'); // Up to four players that are displayed in the wrapper

  const selectedPlayersLength = (0,react_facet_src.useFacetMap)(players => players.length, [], [players]);
  const selectedPlayersLengthRef = (0,react_facet_src.useFacetRef)(selectedPlayersLength); // Only the images of up to 4 players should be shown

  const playerImages = (0,react_facet_src.useFacetMap)(players => players.map(({
    img
  }) => img), [], [players]); // The total amount of players should be shown as a number if more than 4 are active in the world

  const showTotalAmountOfPlayers = (0,react_facet_src.useFacetMap)(totalAmountOfPlayers => totalAmountOfPlayers > 4, [], [totalAmountOfPlayers]); // The total amount of players should be shown as a number if more than 4 are active in the world
  // appended with a '+'

  const amountOfPlayersVisual = (0,react_facet_src.useFacetMap)(totalAmountOfPlayers => totalAmountOfPlayers + '+', [], [totalAmountOfPlayers]);
  const {
    color,
    variant
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("div", {
    className: PlayerAvatarWrapper.wrapper
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: playerImages
  }, (img, index) => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(PlayerAvatar_PlayerAvatar, {
    src: img,
    status: 'online'
  }), selectedPlayersLengthRef.current != react_facet_src.NO_VALUE && index < selectedPlayersLengthRef.current - 1 && /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showTotalAmountOfPlayers
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(color['neutral'].text.base, variant.dimmer, PlayerAvatarWrapper.additionalPlayers)
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, amountOfPlayersVisual))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: full
  }, /*#__PURE__*/react.createElement("div", {
    className: PlayerAvatarWrapper.tagWrapper
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Tag_Tag, {
    role: 'informativeTint'
  }, t('.full')))));
}

function PlayerAvatarWrapper_Panel({
  children
}) {
  const {
    color
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(PlayerAvatarWrapper.panel, color['neutral80'].background.base)
  }, children);
}

PlayerAvatarWrapper_PlayerAvatarWrapper.Panel = PlayerAvatarWrapper_Panel;
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/WorldListItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const WorldListItem = ({"worldImageWrapper":"o_yQY","editIcon":"Fcaz7"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/images/edit-icon.png
const edit_icon_namespaceObject = __webpack_require__.p + "assets/edit-icon-56235.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/WorldTag.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const WorldTag = ({"wrapper":"YFWnH"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/WorldTag.tsx






function WorldTag_WorldTag({
  tag
}) {
  const {
    t
  } = useLocalization('PlayScreen');
  return (
    /*#__PURE__*/
    // When additional tags are added to worlds, more cases need to be handled for the tag roles and copy
    react.createElement(Tag_Tag, {
      role: 'neutral100'
    }, (0,react_facet_src.useFacetMap)(tag => {
      if (tag === types_GameMode.CREATIVE) return t('.creative');
      if (tag === types_GameMode.SURVIVAL) return t('.survival');
      return t('.adventure');
    }, [t], [tag]))
  );
}

function WorldTag_Wrapper({
  children
}) {
  return /*#__PURE__*/react.createElement("div", {
    className: WorldTag.wrapper
  }, children);
}

WorldTag_WorldTag.Wrapper = WorldTag_Wrapper;
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/images/world-preview-default.jpg
const WorldItem_images_world_preview_default_namespaceObject = __webpack_require__.p + "assets/world-preview-default-a8cf0.jpg";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/WorldListItem.tsx














 // Return translation key for corresponding GameMode type

const gameModeNarrationKeys = {
  [types_GameMode.ADVENTURE]: '.adventure',
  [types_GameMode.SURVIVAL]: '.survival',
  [types_GameMode.CREATIVE]: '.creative'
};
function WorldListItem_WorldListItem({
  autofocus,
  item,
  onWorldClick,
  index,
  onEdit = () => {},
  containerListLength,
  totalAmountOfPlayers,
  worldFull,
  playersOnline
}) {
  const {
    t
  } = useLocalization('WorldListItem');
  const {
    t: narration
  } = useLocalization('WorldListItem.narration');
  const tags = (0,react_facet_src.useFacetMap)(item => [item.gameMode], [], [item]);
  const tagsLength = (0,react_facet_src.useFacetMap)(tags => tags.length, [], [tags]);
  const tagsLengthRef = (0,react_facet_src.useFacetRef)(tagsLength);
  const highlightedPlayers = (0,react_facet_src.useFacetWrap)(playersOnline !== null && playersOnline !== void 0 ? playersOnline : []);
  const worldFullWrapped = (0,react_facet_src.useFacetWrap)(worldFull !== null && worldFull !== void 0 ? worldFull : false);
  const showPlayersOnline = (0,react_facet_src.useFacetMap)(playersOnline => playersOnline != null && playersOnline.length > 0, [], [highlightedPlayers]);
  const numberOfPlayersOnline = (0,react_facet_src.useFacetMap)(totalAmountOfPlayers => totalAmountOfPlayers - 4, [], [(0,react_facet_src.useFacetWrap)(totalAmountOfPlayers !== null && totalAmountOfPlayers !== void 0 ? totalAmountOfPlayers : 0)]); // We currently only show local worlds, that always show the edit button
  // The logic for when to show the button will need facet criteria or other logic for non local worlds

  const editAvailable = (0,react_facet_src.useFacetWrap)(true);
  const worldId = (0,react_facet_src.useFacetMap)(item => item.id, [], [item]);
  const unwrappedId = (0,react_facet_src.useFacetUnwrap)(worldId);
  const worldIdRef = (0,react_facet_src.useFacetRef)(worldId);
  const worldName = (0,react_facet_src.useFacetMap)(item => item.name, [], [item]);
  const worldImageSrc = (0,react_facet_src.useFacetMap)(item => item.previewImgPath != null && item.previewImgPath.length > 0 ? item.previewImgPath : WorldItem_images_world_preview_default_namespaceObject, [], [item]); // These are enums, needs to be translated to tag

  const tagsNarrationText = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(tags => {
    const tagsNarrationStrings = tags.map(tag => gameModeNarrationKeys[tag]);
    return tagsNarrationStrings.join(' . ');
  }, [], [tags])); // Narration: Contextual pack information, wrapping the list item

  const contextNarration = (0,react_facet_src.useFacetMap)((worldName, containerListLength) => [worldName, narration('.componentRole'), containerListLength > 0 ? narration('.listLengthContext', [`${index + 1}`, `${containerListLength}`]) : undefined, tagsNarrationText != react_facet_src.NO_VALUE ? narration(tagsNarrationText) : ''].join(' . '), [narration, index, tagsNarrationText], [worldName, containerListLength]); // To avoid deferred rendering being called twice inside ListItem when NarrationContext
  // changes prop key from fallback to worldId --> only render when worldId is available

  if (unwrappedId == react_facet_src.NO_VALUE) return null;
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: contextNarration,
    key: unwrappedId
  }, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    shouldSkipLandmarkInVisual: true,
    defaultFocusedChildBehavior: "first",
    gamepadIndex: index
  }, /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(ListItem_ListItem, {
    gamepadIndex: 0,
    defaultFocusedChildBehavior: "grid",
    tall: true
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.Action, {
    autofocus: autofocus,
    inputLegend: t('.play'),
    narrationText: [narration('.play'), narration('.buttonSiblings', ['1', '2'])].join(' . '),
    onClick: onWorldClick,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", {
    className: WorldListItem.worldImageWrapper
  }, /*#__PURE__*/react.createElement(WorldImage_WorldImage, {
    imgSrc: worldImageSrc
  })), /*#__PURE__*/react.createElement(ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, worldName)), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(WorldTag_WorldTag.Wrapper, null, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: tags
  }, tag => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(WorldTag_WorldTag, {
    tag: tag
  }), tagsLengthRef.current != react_facet_src.NO_VALUE && index < tagsLengthRef.current - 1 && /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showPlayersOnline
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(PlayerAvatarWrapper_PlayerAvatarWrapper, {
    totalAmountOfPlayers: numberOfPlayersOnline,
    full: worldFullWrapped,
    players: highlightedPlayers
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: editAvailable
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, {
    narrationText: [narration('.edit'), narration('.buttonSiblings', ['2', '2'])].join(' . '),
    inputLegend: t('.edit'),
    onClick: () => worldIdRef.current !== react_facet_src.NO_VALUE && onEdit(worldIdRef.current),
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: edit_icon_namespaceObject,
    className: WorldListItem.editIcon
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, t('.edit')))))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/OutOfStorageModal.tsx




const OutOfStorageModal = registerModal(() => {
  const {
    t
  } = useLocalization('PlayScreen.outOfStorageModal');
  const CLOSE_BUTTON_GAMEPAD_ALIAS = 'pop-up-modal-outOfStorageModal';
  const hideModal = useHideModal();
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.body'),
    gamepadIndex: 0
  }, t('.body'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CLOSE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.closeInputLegend'),
    variant: "secondary",
    onClick: hideModal
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/hooks/shouldShowControlSelection.tsx




function useShouldShowTouchControlScreen() {
  return (0,react_facet_src.useFacetMap)((input, options, deviceInformation) => {
    // note: due to an ESLint bug we have to have explicit type annotations here
    const isUsingTouch = input.currentInputType === types_InputMethod.TOUCH;
    const shouldShowScreen = options.showTouchControlSelectionScreen;
    const isNintendoSwitch = deviceInformation.platform === Platform.NX_HANDHELD; // only uses touch for hotbar

    return isUsingTouch && shouldShowScreen && !isNintendoSwitch;
  }, [], [(0,react_facet_src.useSharedFacet)(inputFacet), (0,react_facet_src.useSharedFacet)(optionsFacet), (0,react_facet_src.useSharedFacet)(deviceInformationFacet)]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/NonMultiplayerSkinModal.tsx




const NonMultiplayerSkinModal = registerModal(({
  onContinue,
  onChangeSkin
}) => {
  const {
    t
  } = useLocalization('PlayScreen.nonMultiplayerSkinModal');
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-nonMultiplayerSkinModal';
  const hideModal = useHideModal();
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.body'),
    gamepadIndex: 0,
    center: true
  }, t('.body'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    gamepadIndex: 0,
    inputLegend: t('.continueAction'),
    variant: "primary",
    onClick: () => {
      hideModal();
      onContinue();
    }
  }, t('.continueAction')), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.changeAction'),
    variant: "secondary",
    onClick: () => {
      hideModal();
      onChangeSkin();
    }
  }, t('.changeAction'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/ExperimentalWorldLoadingModal.tsx





const ExperimentalWorldLoadingModal = registerModal(({
  onLoadWorld
}) => {
  const {
    t
  } = useLocalization('PlayScreen.experimentalWorldLoadingModal');
  const hideModal = useHideModal();
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-experimentalWorldLoadingModal';
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${t('.bodyFirstParagraph')}. ${t('.bodySecondParagraph')}`,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong"
  }, t('.bodyFirstParagraph')), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong"
  }, t('.bodySecondParagraph')))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.back'),
    variant: "primary",
    onClick: hideModal
  }, t('.goBackButtonText')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.action'),
    gamepadIndex: 1,
    variant: "secondary",
    onClick: () => {
      hideModal();
      onLoadWorld();
    }
  }, t('.loadWorld'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/hooks/worldStartup.tsx







function useWorldStartup(world) {
  const historyAPI = RouteHistory_useRouteHistory();
  const worldStartupFacet = (0,react_facet_src.useSharedFacet)(worldStartupFacet_worldStartupFacet);
  const buildSettings = (0,react_facet_src.useSharedFacet)(buildSettingsFacet);
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const showNonMultiplayerSkinModal = NonMultiplayerSkinModal.useShowModal();
  const startWorld = (0,react_facet_src.useFacetCallback)((worldStartup, world) => () => {
    worldStartup.startLocalWorld.run(world.id);
  }, [], [worldStartupFacet, world]);
  const showOutOfStorageModal = OutOfStorageModal.useShowModal();
  const shouldShowControlSelection = useShouldShowTouchControlScreen();
  const shouldShowExperimentalModal = (0,react_facet_src.useFacetMap)((world, buildSettings) => {
    const worldIsOld = compareGameVersions(world.gameVersion, buildSettings.currentGameVersion) < 0;
    return world.isExperimental && worldIsOld;
  }, [], [world, buildSettings]);
  const showExperimentalWorldLoadingModal = ExperimentalWorldLoadingModal.useShowModal();
  return (0,react_facet_src.useFacetCallback)((world, userAccount, deviceInformation, shouldShowControlSelection, shouldShowExperimentalModal) => () => {
    if (deviceInformation.isStorageLow) {
      showOutOfStorageModal();
    } else if (!userAccount.hasValidCrossPlatformSkin) {
      showNonMultiplayerSkinModal({
        onContinue: startWorld,
        onChangeSkin: () => {
          historyAPI.push('/persona');
        }
      });
    } else if (shouldShowControlSelection) {
      historyAPI.push(`/play/touch-control-selection/${encodeURIComponent(world.id)}`);
    } else if (shouldShowExperimentalModal) {
      showExperimentalWorldLoadingModal({
        onLoadWorld: startWorld
      });
    } else {
      startWorld();
    }
  }, [historyAPI, startWorld, showOutOfStorageModal, showNonMultiplayerSkinModal, showExperimentalWorldLoadingModal], [world, userAccount, deviceInformation, shouldShowControlSelection, shouldShowExperimentalModal]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/WorldList.tsx









function WorldItem({
  world,
  index,
  numberOfWorlds
}) {
  const historyAPI = RouteHistory_useRouteHistory();
  return /*#__PURE__*/react.createElement(WorldListItem_WorldListItem, {
    onEdit: worldId =>  false ? 0 : historyAPI.push(`/edit-world/${encodeURIComponent(worldId)}`),
    item: world,
    index: index,
    onWorldClick: useWorldStartup(world),
    containerListLength: numberOfWorlds
  });
}

function WorldList({
  worlds,
  gamepadIndex,
  Header,
  Footer,
  scrollViewRef
}) {
  const amountOfWorlds = (0,react_facet_src.useFacetMap)(facet => {
    var _facet$length;

    return (_facet$length = facet.length) !== null && _facet$length !== void 0 ? _facet$length : 0;
  }, [], [worlds]); // The + 2 is to offset for the header. We could build this into the FlatList component
  // but given that the visual navigation should be finished soon we might not want to add more
  // gamepad logic to core components.

  const footerIndex = (0,react_facet_src.useFacetMap)(amountOfWorlds => amountOfWorlds + 2, [], [amountOfWorlds]);
  return /*#__PURE__*/react.createElement(Row, {
    options: {
      index: gamepadIndex
    },
    shouldSkipLandmarkInVisual: true
  }, /*#__PURE__*/react.createElement(FlatList, {
    loading: (0,react_facet_src.useFacetWrap)(false),
    gamepadIndex: 0,
    header: Header && /*#__PURE__*/react.createElement(Header, null),
    emptyMessage: /*#__PURE__*/react.createElement(react.Fragment, null, "Empty"),
    data: worlds,
    scrollViewRef: scrollViewRef,
    footer: Footer && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 1
    }), /*#__PURE__*/react.createElement(Footer, {
      gamepadIndex: footerIndex
    })),
    renderItem: ({
      itemFacet,
      index
    }) => /*#__PURE__*/react.createElement(WorldItem, {
      world: itemFacet,
      index: index,
      numberOfWorlds: amountOfWorlds
    }),
    itemSeparator: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 2
    }),
    padSpinnerVertically: true
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/DetailedCard/DetailedCard.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const DetailedCard = ({"detailedCard":"Jc8Rm","information":"nDjUk","pressed":"H9mwe","additionalAction":"oxWWD","elevated":"DDpsY","elevatedAdditionalAction":"wESDB","pressedAction":"Iz5CA","pressedAdditionalAction":"pTz3U"});
;// CONCATENATED MODULE: ./packages/ui/src/DetailedCard/DetailedCard.tsx







function DetailedCard_DetailedCard({
  children,
  role = 'neutral'
}) {
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  const classes = classnames_default()(DetailedCard.main, semanticClassNames.text.base, semanticClassNames.border.base);
  return /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement("div", {
    className: classes
  }, children));
}

function DetailedCardAction({
  autofocus,
  gamepadIndex,
  children,
  onClick,
  inputLegend,
  onFocusChanged,
  onHoverChanged,
  narrationText,
  gamepadAlias
}) {
  const {
    sound: {
      neutral: semanticSound
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(Pressable_Pressable, {
    focusStateOnElevatedFace: true,
    variant: "neutral",
    isElevated: true,
    reflectionConfig: {
      top: false,
      bottom: false,
      left: false,
      right: false
    },
    autofocus: autofocus,
    gamepadIndex: gamepadIndex,
    gamepadAlias: gamepadAlias,
    inputLegend: inputLegend,
    classNameElevated: DetailedCard.elevated,
    classNameElevatedAndPressed: DetailedCard.pressedAction,
    narrationText: narrationText,
    onClick: onClick,
    onFocusChanged: onFocusChanged,
    onHoverChanged: onHoverChanged,
    soundEffectPressed: semanticSound.press
  }, /*#__PURE__*/react.createElement("div", {
    className: DetailedCard.detailedCard
  }, children));
}

function DetailedCard_Information({
  children,
  innerRef,
  narrationText,
  role = 'inherit'
}) {
  // Set child string value as narration string
  useSetParentNarrationText(narrationText);
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  const classes = classnames_default()(DetailedCard.information, semanticClassNames.text.base, semanticClassNames.border.base);
  return /*#__PURE__*/react.createElement("div", {
    className: classes,
    ref: innerRef
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), children, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }));
}

function AdditionalAction({
  children,
  onClick,
  onMouseDown,
  inputLegend,
  narrationText,
  gamepadAlias,
  hidden = false,
  gamepadIndex = 0,
  innerRef,
  touchDetectionDelay,
  soundEffectPressed
}) {
  {
    const hiddenFacet = (0,react_facet_src.useFacetWrap)(hidden);
    return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
      when: (0,react_facet_src.useFacetMap)(hidden => !hidden, [], [hiddenFacet])
    }, /*#__PURE__*/react.createElement(Pressable_Pressable, {
      innerRef: innerRef,
      variant: "neutral",
      isElevated: true,
      reflectionConfig: {
        top: true,
        bottom: false,
        left: false,
        right: false
      },
      classNameElevated: DetailedCard.elevatedAdditionalAction,
      classNameElevatedAndPressed: DetailedCard.pressedAdditionalAction,
      gamepadIndex: gamepadIndex,
      gamepadAlias: gamepadAlias,
      inputLegend: inputLegend,
      onClick: onClick,
      onMouseDown: onMouseDown,
      narrationText: narrationText,
      touchDetectionDelay: touchDetectionDelay,
      soundEffectPressed: soundEffectPressed
    }, /*#__PURE__*/react.createElement("div", {
      className: DetailedCard.detailedCard
    }, children)));
  }
}

DetailedCard_DetailedCard.Information = DetailedCard_Information;
DetailedCard_DetailedCard.AdditionalAction = AdditionalAction;
DetailedCard_DetailedCard.Action = DetailedCardAction;
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/WorldCard.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const WorldCard = ({"editIcon":"lE4AL","editButton":"UzBDX","editButtonFiller":"MltQY","players":"ngorA"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/WorldCard.tsx













 // Return translation key for corresponding GameMode type

function GameModeToNarrationKey(key) {
  if (key === types_GameMode.ADVENTURE) return '.adventure';
  if (key === types_GameMode.SURVIVAL) return '.survival';
  if (key === types_GameMode.CREATIVE) return '.creative';
}
function WorldCard_WorldCard({
  item,
  onWorldClick,
  index,
  narrationIndex,
  onEdit = () => {},
  containerListLength,
  totalAmountOfPlayers,
  worldFull,
  playersOnline
}) {
  const {
    t
  } = useLocalization('WorldCard');
  const {
    t: narration
  } = useLocalization('WorldCard.narration');
  const tags = (0,react_facet_src.useFacetMap)(item => [item.gameMode], [], [item]);
  const tagsLength = (0,react_facet_src.useFacetMap)(tags => tags.length, [], [tags]);
  const tagsLengthRef = (0,react_facet_src.useFacetRef)(tagsLength);
  const highlightedPlayers = (0,react_facet_src.useFacetWrap)(playersOnline !== null && playersOnline !== void 0 ? playersOnline : []);
  const worldFullWrapped = (0,react_facet_src.useFacetWrap)(worldFull !== null && worldFull !== void 0 ? worldFull : false);
  const showPlayersOnline = (0,react_facet_src.useFacetMap)(playersOnline => playersOnline != null && playersOnline.length > 0, [], [highlightedPlayers]);
  const numberOfPlayersOnline = (0,react_facet_src.useFacetMap)(totalAmountOfPlayers => totalAmountOfPlayers - 4, [], [(0,react_facet_src.useFacetWrap)(totalAmountOfPlayers !== null && totalAmountOfPlayers !== void 0 ? totalAmountOfPlayers : 0)]); // All of these cards are rendered in the same gamepad column. Each card adds
  // two focusables to the column that they reside in. Therefore, we have to
  // multiply the index by 2 to get the correct offset.

  const first = index * 2;
  const second = first + 1; // We currently only show local worlds, that always show the edit button
  // The logic for when to show the button will need facet criteria or other logic for non local worlds

  const editAvailableWrapped = (0,react_facet_src.useFacetWrap)(true);
  const worldId = (0,react_facet_src.useFacetMap)(item => item.id, [], [item]);
  const worldIdRef = (0,react_facet_src.useFacetRef)(worldId);
  const worldName = (0,react_facet_src.useFacetMap)(item => item.name, [], [item]); // These are enums, needs to be translated to tag

  const tagsNarrationText = (0,react_facet_src.useFacetMap)(tags => {
    const tagsNarrationStrings = tags.map(tag => GameModeToNarrationKey(tag));
    return tagsNarrationStrings.join(' . ');
  }, [], [tags]);
  const contextNarration = (0,react_facet_src.useFacetMap)((worldName, containerListLength, tagsNarrationText) => [worldName, narration('.componentRole'), containerListLength > 0 ? narration('.gridAmountContext', [`${narrationIndex}`, `${containerListLength}`]) : undefined, narration(tagsNarrationText)].join(' . '), [narration, narrationIndex], [worldName, containerListLength, tagsNarrationText]);
  const worldImageSrc = (0,react_facet_src.useFacetMap)(item => item.previewImgPath != null && item.previewImgPath.length > 0 ? item.previewImgPath : WorldItem_images_world_preview_default_namespaceObject, [], [item]);
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: contextNarration
  }, /*#__PURE__*/react.createElement(DetailedCard_DetailedCard, null, /*#__PURE__*/react.createElement(DetailedCard_DetailedCard.Action, {
    variant: "standard",
    gamepadIndex: first,
    inputLegend: t('.play'),
    narrationText: [narration('.play'), narration('.buttonSiblings', ['1', '2'])].join(' . '),
    onClick: onWorldClick
  }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(WorldImage_WorldImage, {
    border: false,
    imgSrc: worldImageSrc
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showPlayersOnline
  }, /*#__PURE__*/react.createElement("div", {
    className: WorldCard.players
  }, /*#__PURE__*/react.createElement(PlayerAvatarWrapper_PlayerAvatarWrapper.Panel, null, /*#__PURE__*/react.createElement(PlayerAvatarWrapper_PlayerAvatarWrapper, {
    totalAmountOfPlayers: numberOfPlayersOnline,
    full: worldFullWrapped,
    players: highlightedPlayers
  }))))), /*#__PURE__*/react.createElement(DetailedCard_DetailedCard.Information, {
    narrationText: 'placeholder'
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, worldName)), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(WorldTag_WorldTag.Wrapper, null, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: tags
  }, (tag, index) => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(WorldTag_WorldTag, {
    tag: tag
  }), tagsLengthRef.current != react_facet_src.NO_VALUE && index < tagsLengthRef.current - 1 && /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  })))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: editAvailableWrapped,
    condition: false
  }, /*#__PURE__*/react.createElement("div", {
    className: WorldCard.editButtonFiller
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: editAvailableWrapped
  }, /*#__PURE__*/react.createElement(DetailedCard_DetailedCard.AdditionalAction, {
    gamepadIndex: second,
    narrationText: [narration('.edit'), narration('.buttonSiblings', ['2', '2'])].join(' . '),
    inputLegend: t('.edit'),
    onClick: () => worldIdRef.current !== react_facet_src.NO_VALUE && onEdit(worldIdRef.current)
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement("div", {
    className: WorldCard.editButton
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: edit_icon_namespaceObject,
    className: WorldCard.editIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit",
    verticalAlign: "center"
  }, t('.edit'))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  })))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/WorldGrid.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const WorldGrid = ({"row":"OufbE","column":"NMzdz","cell":"QDf02"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/WorldGrid.tsx









const NUMBER_OF_COLUMNS = 4;
const COLUMN_WIDTH = `${100 / NUMBER_OF_COLUMNS}%`;

function WorldCardItem({
  world,
  index,
  columnIndex,
  containerListLength
}) {
  const historyAPI = RouteHistory_useRouteHistory();
  const startWorld = useWorldStartup(world);
  return /*#__PURE__*/react.createElement(react.Fragment, null, index > 0 && /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: WorldGrid.cell
  }, /*#__PURE__*/react.createElement(WorldCard_WorldCard // The card's placement in the grid needs to be calculated using its index and column index
  , {
    narrationIndex: index * 4 + columnIndex + 1,
    onEdit: worldId =>  false ? 0 : historyAPI.push(`/edit-world/${encodeURIComponent(worldId)}`),
    item: world,
    index: index,
    onWorldClick: startWorld,
    containerListLength: containerListLength
  })));
}

function WorldCardColumn({
  worlds,
  index: columnIndex,
  containerListLength
}) {
  return /*#__PURE__*/react.createElement(react.Fragment, null, columnIndex > 0 && /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: WorldGrid.column,
    style: {
      width: COLUMN_WIDTH
    }
  }, /*#__PURE__*/react.createElement(Column, {
    shouldSkipLandmarkInVisual: true,
    options: {
      defaultFocusedChildBehavior: 'grid',
      index: columnIndex
    }
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: worlds
  }, (world, index) => /*#__PURE__*/react.createElement(WorldCardItem, {
    world: world,
    index: index,
    columnIndex: columnIndex,
    containerListLength: containerListLength
  })))));
}

function WorldGrid_WorldGrid({
  worlds: allWorlds,
  gamepadIndex,
  Header,
  Footer,
  scrollViewRef
}) {
  const isRenderingPaused = (0,dist.useIsPaused)();
  const containerListLength = (0,react_facet_src.useFacetMap)(allWorlds => {
    var _allWorlds$length;

    return (_allWorlds$length = allWorlds.length) !== null && _allWorlds$length !== void 0 ? _allWorlds$length : 0;
  }, [], [allWorlds]);
  const dataMatrix = (0,react_facet_src.useFacetMemo)(data => {
    const matrix = [...new Array(NUMBER_OF_COLUMNS)].map(() => []);
    data.forEach((item, index) => {
      const matrixIndex = index % NUMBER_OF_COLUMNS;
      matrix[matrixIndex].push(item);
    });
    return matrix;
  }, [], [allWorlds]);
  const scrollRef = (0,react.useRef)(null);
  const isLoading = (0,react_facet_src.useFacetMap)(isDeferring => isDeferring || isRenderingPaused, [isRenderingPaused], [(0,dist.useIsDeferring)()]);
  return /*#__PURE__*/react.createElement(Row, {
    options: {
      index: gamepadIndex
    },
    shouldSkipLandmarkInVisual: true
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    loading: isLoading,
    innerRef: scrollViewRef,
    gamepadIndex: 0
  }, Header && /*#__PURE__*/react.createElement(Header, null), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }), !isRenderingPaused && /*#__PURE__*/react.createElement(Row, {
    scrollRef: scrollRef,
    options: {
      index: 1,
      defaultFocusedChildBehavior: 'remember'
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: WorldGrid.row
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: dataMatrix
  }, (columnWorlds, index) => /*#__PURE__*/react.createElement(WorldCardColumn, {
    worlds: columnWorlds,
    containerListLength: containerListLength,
    index: index
  })))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }), Footer && /*#__PURE__*/react.createElement(Footer, {
    gamepadIndex: 2
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/no-worlds-yet-art.png
const no_worlds_yet_art_namespaceObject = __webpack_require__.p + "assets/no-worlds-yet-art-38524.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/EmptyStateMessage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AllWorlds_EmptyStateMessage = ({"emptyStateArt":"zvmmk","emptyStateArtBig":"kcpRz"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/EmptyState.tsx






function EmptyState({
  gamepadIndex,
  navigationButtons
}) {
  const {
    t
  } = useLocalization('PlayScreen.allWorlds'); // To enable a bigger image size on bigger devices

  const breakpoint = useWindowBreakpoint(102);
  const imageClass = breakpoint === 'narrow' ? AllWorlds_EmptyStateMessage.emptyStateArt : AllWorlds_EmptyStateMessage.emptyStateArtBig;
  return /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: gamepadIndex,
    title: t('.emptyStateTitle'),
    text: t('.emptyStateText'),
    imgSrc: no_worlds_yet_art_namespaceObject,
    imgClass: imageClass,
    buttons: navigationButtons
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/error.png
const error_namespaceObject = __webpack_require__.p + "assets/error-1ee9c.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/AlternativeStorageState.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AlternativeStorageState = ({"alternativeStorageArt":"oXowS","alternativeStorageArtBig":"xFEJD"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/AlternativeStorageState.tsx







function AlternativeStorageState_AlternativeStorageState({
  gamepadIndex
}) {
  const {
    t
  } = useLocalization('PlayScreen.allWorlds');
  const historyAPI = RouteHistory_useRouteHistory(); // To enable a bigger image size on bigger devices

  const breakpoint = useWindowBreakpoint(102);
  const imageClass = breakpoint === 'narrow' ? AlternativeStorageState.alternativeStorageArt : AlternativeStorageState.alternativeStorageArtBig;
  return /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: gamepadIndex,
    title: t('.alternativeStorageTitle'),
    text: t('.alternativeStorageText'),
    imgSrc: error_namespaceObject,
    imgClass: imageClass,
    buttons: [{
      variant: 'secondary',
      text: t('.alternativeStorageButton'),
      onClick: () => historyAPI.push('/settings')
    }]
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/TemplateScreenNoInternetModal.tsx




const TemplateScreenNoInternetModal = registerModal(() => {
  const {
    t
  } = useLocalization('PlayScreen.templateScreenNoInternetModal');
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-templateScreenNoInternetModal';
  const onClose = useHideModal();
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.body'),
    gamepadIndex: 0
  }, t('.body'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.close'),
    variant: "secondary",
    onClick: onClose
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/hooks/navigate.tsx




function useNavigateToCreateNewWorld(buttonName) {
  const historyAPI = RouteHistory_useRouteHistory();
  const telemetrySharedFacet = (0,react_facet_src.useSharedFacet)(telemetryFacet);
  return (0,react_facet_src.useFacetCallback)(telemetry => () => {
    telemetry.fireEventButtonPressed(buttonName, {});
    historyAPI.push('/create-new-world');
  }, [historyAPI, buttonName], [telemetrySharedFacet]);
}
function useNavigateToCreateFromTemplate(buttonName) {
  const historyAPI = RouteHistory_useRouteHistory();
  const worldTemplateList = (0,react_facet_src.useSharedFacet)(worldTemplateListFacet);
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const telemetrySharedFacet = (0,react_facet_src.useSharedFacet)(telemetryFacet);
  const showNoInternetModal = TemplateScreenNoInternetModal.useShowModal();
  return (0,react_facet_src.useFacetCallback)((worldTemplateList, deviceInformation, telemetry) => () => {
    telemetry.fireEventButtonPressed(buttonName, {});
    const noLocalTemplates = worldTemplateList.premiumTemplates.length + worldTemplateList.customTemplates.length == 0;
    const noInternetConnection = !deviceInformation.isOnline;

    if (noLocalTemplates && noInternetConnection) {
      showNoInternetModal();
    } else {
      historyAPI.push('/create-new-world-from-template');
    }
  }, [buttonName, showNoInternetModal, historyAPI], [worldTemplateList, deviceInformation, telemetrySharedFacet]);
}
function useOpenFeedbackPage() {
  const webBrowserSharedFacet = (0,react_facet_src.useSharedFacet)(webBrowserFacet);
  const telemetrySharedFacet = (0,react_facet_src.useSharedFacet)(telemetryFacet);
  const openFeedbackPage = (0,react_facet_src.useFacetCallback)((telemetry, webBrowser) => () => {
    telemetry.fireEventButtonPressed('Play_Screen_Feedback_Button_OreUI', {});
    webBrowser.openLink(WebBrowserLink.PlayScreenFeedbackPage);
  }, [], [telemetrySharedFacet, webBrowserSharedFacet]);
  return openFeedbackPage;
}
function useOptOut(tab) {
  const historyAPI = RouteHistory_useRouteHistory();
  const screenTechStackSharedFacet = (0,react_facet_src.useSharedFacet)(screenTechStackFacet);
  const telemetrySharedFacet = (0,react_facet_src.useSharedFacet)(telemetryFacet);
  const optOut = (0,react_facet_src.useFacetCallback)((telemetry, screenTechStack) => () => {
    telemetry.fireEventButtonPressed('Play_Screen_Opt_Out_Button_OreUI', {});
    screenTechStack.selectTechStackForScreen(ScreenName.PlayScreen, UITechStack.JsonUI);
    historyAPI.replace('/play/' + tab);
  }, [historyAPI, tab], [telemetrySharedFacet, screenTechStackSharedFacet]);
  return optOut;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/DesignPreview.tsx





function DesignPreview({
  tab,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization('PlayScreen');
  const openFeedbackPage = useOpenFeedbackPage();
  const optOut = useOptOut(tab);
  return /*#__PURE__*/react.createElement(PanelButton_PanelButton, {
    gamepadIndex: gamepadIndex,
    defaultFocusedChildBehavior: "first",
    title: t('.designPreviewTitle'),
    description: t('.designPreviewDescription'),
    narrationText: `${t('.designPreviewTitle')} - ${t('.designPreviewDescription')}`,
    buttons: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
      inputLegend: `${t('.designPreviewInputLegend')}`,
      horizontal: true,
      onClick: openFeedbackPage,
      imgSrc: external_link_namespaceObject,
      gamepadIndex: 0
    }, t('.feedbackButton')), /*#__PURE__*/react.createElement(PanelButton_PanelButton.ButtonSpacing, null), /*#__PURE__*/react.createElement(Button_Button_Button, {
      inputLegend: `${t('.designPreviewInputLegend')}`,
      horizontal: true,
      onClick: optOut,
      gamepadIndex: 1
    }, t('.optOutButton')))
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/ButtonHeader.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ButtonHeader = ({"buttonsCenter":"IAVEv","buttonsEnd":"UjHH5","button":"mVSiw"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/ButtonHeader.tsx









function ButtonHeader_noop() {}

function HeaderButton({
  item,
  index,
  numberOfButtons,
  t: narration,
  breakpoint
}) {
  const narrationSuffix = (0,react_facet_src.useFacetMap)(({
    narrationSuffix
  }, numberOfButtons) => [narration('.buttonSiblings', [`${index + 1}`, `${numberOfButtons}`]), narrationSuffix].join(' . '), [narration, index], [item, numberOfButtons]);
  const text = (0,react_facet_src.useFacetMap)(({
    text
  }) => text, [], [item]);
  const imgSrc = (0,react_facet_src.useFacetMap)(({
    imgSrc
  }) => imgSrc, [], [item]);
  const inputLegend = (0,react_facet_src.useFacetMap)(({
    inputLegend,
    text
  }) => inputLegend !== null && inputLegend !== void 0 ? inputLegend : text, [], [item]);
  const isLastItem = (0,react_facet_src.useFacetMap)(numberOfButtons => index < numberOfButtons - 1, [index], [numberOfButtons]);
  const onClick = (0,react_facet_src.useFacetCallback)(({
    onClick
  }) => onClick !== null && onClick !== void 0 ? onClick : ButtonHeader_noop, [], [item]); // Would be nice to not unwrap this variant, but looks like a deeper piece of work
  // to make the Pressable accept Facets for this prop and measure the performance impact of that.

  const variant = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(({
    variant
  }) => variant, [], [item]));
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: ButtonHeader.button
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: inputLegend,
    gamepadIndex: index,
    narrationSuffix: narrationSuffix,
    variant: variant == react_facet_src.NO_VALUE ? 'secondary' : variant,
    onClick: onClick,
    imgSrc: imgSrc
  }, text)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLastItem
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: breakpoint === 'narrow' ? 2 : 4
  })));
}

function ButtonHeader_ButtonHeader({
  buttons,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization('PlayScreen.narration');
  const breakpoint = useWindowBreakpoint();
  const numberOfButtons = (0,react_facet_src.useFacetMap)(buttons => buttons.length, [], [buttons]);
  const centerAlignButtons = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(buttons => buttons.length > 2, [], [buttons])) === true;
  const horizontalPadding = /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: breakpoint === 'narrow' && centerAlignButtons ? 7 : 0
  });
  return /*#__PURE__*/react.createElement(Row, {
    options: {
      index: gamepadIndex,
      defaultFocusedChildBehavior: 'first'
    },
    shouldSkipLandmarkInVisual: true
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    className: centerAlignButtons ? ButtonHeader.buttonsCenter : ButtonHeader.buttonsEnd
  }, horizontalPadding, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: buttons
  }, (button, index) => /*#__PURE__*/react.createElement(HeaderButton, {
    t: t,
    breakpoint: breakpoint,
    item: button,
    index: index,
    numberOfButtons: numberOfButtons
  })), horizontalPadding));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/StorageIndicator/images/settings-icon.png
const StorageIndicator_images_settings_icon_namespaceObject = __webpack_require__.p + "assets/settings-icon-af819.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/StorageIndicator/StorageIndicator.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const StorageIndicator = ({"container":"LtuVe","flexBetween":"M6QIX","leftContentWrapper":"Mm3Zd","settingsButton":"XUQjt","settingsIcon":"jf7d7"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/StorageIndicator/hooks/useFormatBytes.ts


const SIZES = ['.bytes', '.kilobytes', '.megabytes', '.gigabytes', '.terabytes', '.petabytes'];
const BYTES_DECIMALS = 2;
const K = 1024;

function formatBytes(bytes, t) {
  if (bytes <= 0) return t(SIZES[0], ['0']);
  const dm = BYTES_DECIMALS < 0 ? 0 : BYTES_DECIMALS;
  const i = Math.floor(Math.log(bytes) / Math.log(K));
  const value = parseFloat((bytes / Math.pow(K, i)).toFixed(dm)).toString();
  const iClamped = Math.max(0, Math.min(i, SIZES.length - 1));
  return t(SIZES[iClamped], [value]);
} // grabs and decodes the world ID from the route URL


function useFormatBytes() {
  const {
    t
  } = useLocalization('StorageIndicator');
  return (0,react.useCallback)(bytes => formatBytes(bytes, t), [t]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/StorageIndicator/StorageIndicator.tsx













function StorageIndicator_StorageIndicator({
  gamepadIndex,
  role = 'inherit'
}) {
  const {
    t
  } = useLocalization('StorageIndicator');
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const historyAPI = RouteHistory_useRouteHistory();
  const percentage = (0,react_facet_src.useFacetMap)(({
    storageUsed,
    storageSize
  }) => storageSize <= 0 ? 1 : storageUsed / storageSize, // Prevent division by zero
  [], [deviceInformation]);
  const formatBytes = useFormatBytes();
  const storageLabel = (0,react_facet_src.useFacetMap)(({
    storageSize,
    storageUsed
  }) => t('.storageSpace', [formatBytes(Math.max(0, storageUsed)), formatBytes(Math.max(0, storageSize))]), [t, formatBytes], [deviceInformation]);
  const isStorageFull = (0,react_facet_src.useFacetMap)(({
    isStorageFull,
    storageSize,
    storageUsed
  }) => isStorageFull || storageSize <= 0 || storageUsed >= storageSize, [], [deviceInformation]);
  const {
    color: {
      [role]: semanticClassNames
    },
    rawColors: {
      success,
      notice,
      destructive
    }
  } = useSemanticTokens();
  const progressBarColor = (0,react_facet_src.useFacetMap)(({
    isStorageLow
  }, isStorageFull) => {
    var _destructive$backgrou, _destructive$backgrou2, _notice$background$de, _notice$background, _success$background$d, _success$background;

    return isStorageFull ? (_destructive$backgrou = destructive === null || destructive === void 0 ? void 0 : (_destructive$backgrou2 = destructive.background) === null || _destructive$backgrou2 === void 0 ? void 0 : _destructive$backgrou2.default) !== null && _destructive$backgrou !== void 0 ? _destructive$backgrou : 'var(--red50)' : isStorageLow ? (_notice$background$de = notice === null || notice === void 0 ? void 0 : (_notice$background = notice.background) === null || _notice$background === void 0 ? void 0 : _notice$background.default) !== null && _notice$background$de !== void 0 ? _notice$background$de : 'var(--orange20)' : (_success$background$d = success === null || success === void 0 ? void 0 : (_success$background = success.background) === null || _success$background === void 0 ? void 0 : _success$background.default) !== null && _success$background$d !== void 0 ? _success$background$d : 'var(--green50)';
  }, [success, notice, destructive], [deviceInformation, isStorageFull]);
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(StorageIndicator.container, semanticClassNames.border.base, semanticClassNames.text.base, semanticClassNames.background.base)
  }, /*#__PURE__*/react.createElement("div", {
    className: StorageIndicator.flexBetween
  }, /*#__PURE__*/react.createElement("div", {
    className: StorageIndicator.leftContentWrapper
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    color: "inherit",
    variant: "secondaryButton"
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: storageLabel
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isStorageFull
  }, /*#__PURE__*/react.createElement(Tag_Tag, {
    role: "destructiveTint"
  }, t('.fullStorageTag')))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(ProgressBar_ProgressBar, {
    percentage: percentage,
    fillColor: progressBarColor
  })), /*#__PURE__*/react.createElement(NavigationButton_NavigationButton, {
    className: StorageIndicator.settingsButton,
    gamepadIndex: gamepadIndex,
    inputLegend: t('.settings'),
    narrationText: t('.settings'),
    onClick: () => {
      historyAPI.push('/settings/storage');
    },
    role: role
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: StorageIndicator_images_settings_icon_namespaceObject,
    className: StorageIndicator.settingsIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionTiny"
  }, t('.settings')))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/StorageIndicator/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/UnexpectedLaunchErrorModal.tsx






const UnexpectedLaunchErrorModal = registerModal(() => {
  const {
    t
  } = useLocalization('PlayScreen.unexpectedLaunchErrorModal');
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-unexpectedLaunchErrorModal';
  const worldStartup = (0,react_facet_src.useSharedFacet)(worldStartupFacet_worldStartupFacet);
  const onClose = (0,react_facet_src.useFacetCallback)(worldStartup => () => {
    worldStartup.startLocalWorld.clear();
  }, [], [worldStartup]);
  const errorCodeMsg = (0,react_facet_src.useFacetMap)(worldStartup => {
    const errorCode = worldStartup.startLocalWorld.result ? worldStartup.startLocalWorld.result.toString() : 'n/a';
    return t('.body2', [errorCode]);
  }, [t], [worldStartup]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: 'example',
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "center"
  }, t('.body')), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "center"
  }, errorCodeMsg))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.close'),
    variant: "secondary",
    onClick: onClose
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/WorldMissingEntitlementModal.tsx







const WorldMissingEntitlementModal = registerModal(() => {
  const {
    t
  } = useLocalization('PlayScreen.worldMissingEntitlementModal');
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-worldMissingEntitlementModal';
  const worldList = (0,react_facet_src.useSharedFacet)(worldListFacet);
  const hideModal = useHideModal();
  const [doNotShowAgain, setDoNotShowAgain] = (0,react_facet_src.useFacetState)(false);
  const worldsWithoutEntitlement = (0,react_facet_src.useFacetMap)(worldStartup => {
    var _worldStartup$localWo;

    return (_worldStartup$localWo = worldStartup.localWorldsWithoutEntitlement) !== null && _worldStartup$localWo !== void 0 ? _worldStartup$localWo : [];
  }, [], [worldList]);
  const amountOfWorldsWithoutEntitlement = (0,react_facet_src.useFacetMap)(worldsWithoutEntitlement => worldsWithoutEntitlement.length, [], [worldsWithoutEntitlement]);
  const worldNamesWithoutEntitlement = (0,react_facet_src.useFacetMemo)(worldsWithoutEntitlement => worldsWithoutEntitlement.map(({
    name
  }) => name), [], [worldsWithoutEntitlement]);
  const modalText = (0,react_facet_src.useFacetMap)(amountOfWorldsWithoutEntitlement => t('.body', [`${amountOfWorldsWithoutEntitlement}`]), [t], [amountOfWorldsWithoutEntitlement]);
  const closeAndConfirmChoiceModal = (0,react_facet_src.useFacetCallback)((notificationOptions, doNotShowAgain) => () => {
    notificationOptions.doNotShowEntitlementsWarning = doNotShowAgain;
    hideModal();
  }, [hideModal], [(0,react_facet_src.useSharedFacet)(notificationOptionsFacet), doNotShowAgain]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, (0,react_facet_src.useFacetMap)(amountOfWorldsWithoutEntitlement => t('.title', [`${amountOfWorldsWithoutEntitlement}`]), [t], [amountOfWorldsWithoutEntitlement])), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: modalText
  }, modalText), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: worldNamesWithoutEntitlement,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    header: /*#__PURE__*/react.createElement(Modal_Modal_Modal.Checkbox, {
      value: doNotShowAgain,
      onChange: value => setDoNotShowAgain(!!value),
      title: t('.doNotShowAgain')
    })
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.close'),
    variant: "secondary",
    onClick: closeAndConfirmChoiceModal
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/ImportWorldProgressModal.tsx








function ImportWorldProgressModal_noop() {}

const ImportWorldProgressModal = registerModal(() => {
  const {
    t
  } = useLocalization('PlayScreen.importWorldProgressModal');
  const worldTransfer = (0,react_facet_src.useSharedFacet)(worldTransferFacet);
  const isNarrationEnabled = useNarrationEnabled();
  const FOCUS_ALIAS_CONTENT = 'import-world-progress-content-focus';
  const FOCUS_ALIAS_CLOSE = 'import-world-progress-close-focus';
  const progress = (0,react_facet_src.useFacetMap)(worldTransfer => {
    var _worldTransfer$import;

    return (_worldTransfer$import = worldTransfer.importWorld.progress) !== null && _worldTransfer$import !== void 0 ? _worldTransfer$import : 0;
  }, [], [worldTransfer]);
  const importingLabel = t('.body'); // We only want the close button to exist as an invisible button
  // to move focus to _if_ narration is disabled. If narration is enabled,
  // then we just put focus on the progress content and narrate that.

  const onClose = isNarrationEnabled ? undefined : ImportWorldProgressModal_noop;
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: isNarrationEnabled ? FOCUS_ALIAS_CONTENT : FOCUS_ALIAS_CLOSE
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    closeButtonGamepadAlias: FOCUS_ALIAS_CLOSE,
    hideCloseButton: true,
    onClose: onClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    gamepadAlias: FOCUS_ALIAS_CONTENT
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: importingLabel,
    center: true
  }, importingLabel), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Progress, {
    percentage: progress
  })));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/ImportWorldErrorModal.tsx






/**
 * Currently the worldTransferFacet can only throw the WorldTransferResult.FailureUnknown
 * error, which is a fairly ambiguous error.
 */

const ImportWorldErrorModal = registerModal(() => {
  const {
    t
  } = useLocalization('PlayScreen.importWorldErrorModal');
  const worldTransfer = (0,react_facet_src.useSharedFacet)(worldTransferFacet);
  const FOCUS_ALIAS_BUTTON = 'import-world-error-button-focus';
  const onClose = (0,react_facet_src.useFacetCallback)(worldTransfer => () => {
    worldTransfer.importWorld.clear();
  }, [], [worldTransfer]);
  const closeLabel = t('.close');
  const bodyLabel = t('.unknownError.body');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: FOCUS_ALIAS_BUTTON
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.unknownError.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: bodyLabel,
    center: true
  }, bodyLabel)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "secondary",
    inputLegend: closeLabel,
    onClick: onClose,
    gamepadAlias: FOCUS_ALIAS_BUTTON
  }, closeLabel)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/images/import-world-icon.png
const import_world_icon_namespaceObject = __webpack_require__.p + "assets/import-world-icon-4e8aa.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/AllWorldsTab.tsx
























// We send these to telemetry to track button clicks
const CREATE_NEW_WORLD_BUTTON_NAME = 'Play_Screen_Create_New_World_Button_OreUI';
const CREATE_FROM_TEMPLATE_BUTTON_NAME = 'Play_Screen_Create_From_Template_Button_OreUI';
const NEW_PLAY_SCREEN_WITHOUT_TEMPLATE_BUTTON = 'vanilla.ab.newPlayScreenWithoutTemplateButton';

function useNavigationButtons() {
  const {
    t
  } = useLocalization('PlayScreen');
  const {
    t: narration
  } = useLocalization('PlayScreen.narration');
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const worldTransfer = (0,react_facet_src.useSharedFacet)(worldTransferFacet); // The copy for the button leading to templates says "Worlds by Creators"
  // These worlds are templates and referred to as such in the code
  // Phrasing is to make it easier for players to understand what the templates are

  const hideTemplateButton = useFeatureFlag(NEW_PLAY_SCREEN_WITHOUT_TEMPLATE_BUTTON);
  const navigateToCreateNewWorld = useNavigateToCreateNewWorld(CREATE_NEW_WORLD_BUTTON_NAME);
  const navigateToCreateFromTemplate = useNavigateToCreateFromTemplate(CREATE_FROM_TEMPLATE_BUTTON_NAME);
  const importWorld = (0,react_facet_src.useFacetCallback)(({
    importWorld
  }) => () => {
    importWorld.run();
  }, [], [worldTransfer]);
  const isDesktopPlatform = (0,react_facet_src.useFacetMap)(facet => isWindowsPlatform(facet.platform), [], [deviceInformation]);
  const navigationButtons = (0,react_facet_src.useFacetMap)(isDesktopPlatform => {
    const buttons = hideTemplateButton ? [{
      variant: 'primary',
      text: t('.createNewWorld'),
      narrationSuffix: narration('.createNewWorld'),
      onClick: navigateToCreateFromTemplate
    }] : [{
      variant: 'primary',
      text: t('.createNewWorld'),
      narrationSuffix: narration('.createNewWorld'),
      onClick: navigateToCreateNewWorld
    }, {
      variant: 'secondary',
      text: t('.createWorldByCreator'),
      narrationSuffix: narration('.createWorldByCreator'),
      onClick: navigateToCreateFromTemplate
    }];

    if (isDesktopPlatform) {
      const importWorldButton = {
        text: t('.importWorld'),
        variant: 'secondary',
        narrationSuffix: narration('.importWorld'),
        onClick: importWorld,
        imgSrc: import_world_icon_namespaceObject
      };
      buttons.push(importWorldButton);
    }

    return buttons;
  }, [hideTemplateButton, narration, navigateToCreateFromTemplate, navigateToCreateNewWorld, t, importWorld], [isDesktopPlatform]);
  return navigationButtons;
}
/**
 * If there is a successful world import then we clear the Action.
 */


function useOnWorldImportSuccess() {
  const worldTransfer = (0,react_facet_src.useSharedFacet)(worldTransferFacet);
  const clearImportWorldAction = (0,react_facet_src.useFacetCallback)(facet => () => {
    facet.importWorld.clear();
  }, [], [worldTransfer]);
  const importWorldResult = (0,react_facet_src.useFacetMap)(facet => facet.importWorld.result, [], [worldTransfer]);
  (0,react_facet_src.useFacetEffect)(result => {
    if (result === WorldTransferResult.Success) {
      clearImportWorldAction();
    }
  }, [clearImportWorldAction], [importWorldResult]);
}

function AllWorldsButtonHeader({
  navigationButtons
}) {
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const showStorageIndicator = (0,react_facet_src.useFacetMap)( // Only show the storage indicator on consoles when the storage is low or full
  ({
    platform,
    isStorageFull,
    isStorageLow
  }) => isConsolePlatform(platform) && (isStorageFull || isStorageLow), [], [deviceInformation]);
  return /*#__PURE__*/react.createElement(Row, {
    options: {
      index: 0
    },
    shouldSkipLandmarkInVisual: true
  }, /*#__PURE__*/react.createElement(Column, {
    options: {
      index: 0
    },
    shouldSkipLandmarkInVisual: true
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showStorageIndicator
  }, /*#__PURE__*/react.createElement(StorageIndicator_StorageIndicator, {
    gamepadIndex: 0
  })), /*#__PURE__*/react.createElement(ButtonHeader_ButtonHeader, {
    gamepadIndex: 1,
    buttons: navigationButtons
  })));
}

function AllWorldsTab() {
  const worldList = (0,react_facet_src.useSharedFacet)(worldListFacet);
  const allWorlds = (0,react_facet_src.useFacetMap)(f => f.localWorlds, [], [worldList]); // This is when there are no local worlds to show, but the user _possibly_
  // have stored worlds on the devices' normal storage

  const isUsingAlternativeStorage = (0,react_facet_src.useFacetMap)(device => device.isUsingAlternativeStorage, [], [(0,react_facet_src.useSharedFacet)(deviceInformationFacet)]); // TODO: This also has to take loading into consideration because the array might be empty to start with.

  const isEmptyListOfWorlds = (0,react_facet_src.useFacetMap)((allWorlds, isUsingAlternativeStorage) => allWorlds.length < 1 && !isUsingAlternativeStorage, [], [allWorlds, isUsingAlternativeStorage]);
  const isNotEmptyListOfWorldsAndNotUsingAlternativeStorage = (0,react_facet_src.useFacetMap)((isEmptyListOfWorlds, isUsingAlternativeStorage) => !isEmptyListOfWorlds && !isUsingAlternativeStorage, [], [isEmptyListOfWorlds, isUsingAlternativeStorage]); // If one or more worlds are missing entitlement, show the entitlement warning modal

  const worldMissingEntitlement = (0,react_facet_src.useFacetMap)(({
    localWorldsWithoutEntitlement
  }, {
    doNotShowEntitlementsWarning
  }) => // If the player has decided to hide this warning modal it should not be shown
  !doNotShowEntitlementsWarning && localWorldsWithoutEntitlement != null && localWorldsWithoutEntitlement.length > 0, [], [(0,react_facet_src.useSharedFacet)(worldListFacet), (0,react_facet_src.useSharedFacet)(notificationOptionsFacet)]);
  const breakpoint = useWindowBreakpoint(102);
  const AllWorlds = breakpoint === 'narrow' ? WorldList : WorldGrid_WorldGrid;
  const isActive = useRouteActive();
  const scrollViewRef = (0,react.useRef)(null);
  (0,react_facet_src.useFacetLayoutEffect)(active => {
    // When we switch to another tab we'll reset the scroll position.
    if (!active && scrollViewRef.current) {
      scrollViewRef.current.scrollTop = 0;
    }
  }, [], [isActive]);
  const worldStartFailed = (0,react_facet_src.useFacetMap)(worldStartup => {
    const result = worldStartup.startLocalWorld.result;
    return result != null && result != StartLocalWorldResult.Ok;
  }, [], [(0,react_facet_src.useSharedFacet)(worldStartupFacet_worldStartupFacet)]);
  const worldTransfer = (0,react_facet_src.useSharedFacet)(worldTransferFacet);
  const showWorldImportProgressModal = (0,react_facet_src.useFacetMap)(worldTransfer => {
    var _worldTransfer$import;

    return worldTransfer.importWorld.state === AsyncStatefulFunctionState.InProgress && ((_worldTransfer$import = worldTransfer.importWorld.progress) !== null && _worldTransfer$import !== void 0 ? _worldTransfer$import : 0) > 0;
  }, [], [worldTransfer]);
  const showImportWorldErrorModal = (0,react_facet_src.useFacetMap)(worldTransfer => worldTransfer.importWorld.result != null && worldTransfer.importWorld.result !== WorldTransferResult.Success && worldTransfer.importWorld.result !== WorldTransferResult.InterruptedByUser, [], [worldTransfer]);
  useOnWorldImportSuccess();
  const navigationButtons = useNavigationButtons();
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isUsingAlternativeStorage
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 0,
    floating: true
  }, /*#__PURE__*/react.createElement(AlternativeStorageState_AlternativeStorageState, {
    gamepadIndex: 0
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isEmptyListOfWorlds
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 0,
    floating: true
  }, /*#__PURE__*/react.createElement(EmptyState, {
    gamepadIndex: 0,
    navigationButtons: navigationButtons
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(DesignPreview, {
    tab: "all",
    gamepadIndex: 1
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isNotEmptyListOfWorldsAndNotUsingAlternativeStorage
  }, /*#__PURE__*/react.createElement(AllWorlds, {
    worlds: allWorlds,
    gamepadIndex: 0,
    Header: () => /*#__PURE__*/react.createElement(AllWorldsButtonHeader, {
      navigationButtons: navigationButtons
    }),
    Footer: ({
      gamepadIndex
    }) => /*#__PURE__*/react.createElement(DesignPreview, {
      tab: "all",
      gamepadIndex: gamepadIndex
    }),
    scrollViewRef: scrollViewRef
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: worldStartFailed
  }, /*#__PURE__*/react.createElement(UnexpectedLaunchErrorModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: worldMissingEntitlement
  }, /*#__PURE__*/react.createElement(WorldMissingEntitlementModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showWorldImportProgressModal
  }, /*#__PURE__*/react.createElement(ImportWorldProgressModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showImportWorldErrorModal
  }, /*#__PURE__*/react.createElement(ImportWorldErrorModal.Component, null)));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/under-construction-art-realms-cropped.png
const under_construction_art_realms_cropped_namespaceObject = __webpack_require__.p + "assets/under-construction-art-realms-cropped-6c23e.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/UnderConstructionMessage.tsx









function UnderConstructionMessage_UnderConstructionMessage({
  tab
}) {
  const {
    t
  } = useLocalization('PlayScreen');
  const openFeedbackPage = useOpenFeedbackPage();
  const optOut = useOptOut(tab); // To enable a bigger image size on bigger devices

  const breakpoint = useWindowBreakpoint(102);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 0,
    floating: true
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    title: t('.underConstructionTitle'),
    text: t('.underConstructionMessage'),
    imgSrc: under_construction_art_cropped_namespaceObject,
    imgClass: breakpoint === 'narrow' ? UnderConstructionMessage.emptyStateArt : UnderConstructionMessage.emptyStateArtBig,
    buttons: [{
      text: t('.feedbackButton'),
      onClick: openFeedbackPage
    }, {
      text: t('.optOutButton'),
      onClick: optOut
    }]
  })));
}
function UnderConstructionMessageRealms() {
  const {
    t
  } = useLocalization('PlayScreen');
  const optOut = useOptOut('all'); // To enable a bigger image size on bigger devices

  const breakpoint = useWindowBreakpoint(102);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 0,
    floating: true
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    title: t('.underConstructionTitleRealms'),
    imgSrc: under_construction_art_realms_cropped_namespaceObject,
    imgClass: breakpoint === 'narrow' ? UnderConstructionMessage.emptyStateRealmsArt : UnderConstructionMessage.emptyStateRealmsArtBig,
    buttons: [{
      text: t('.optOutButton'),
      onClick: optOut
    }]
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Realms/RealmsTab.tsx


function RealmsTab() {
  return /*#__PURE__*/react.createElement(UnderConstructionMessageRealms, null);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/ServersTab.tsx


function ServersTab() {
  return /*#__PURE__*/react.createElement(UnderConstructionMessage_UnderConstructionMessage, {
    tab: "servers"
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/index.ts



;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/PlayScreenRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PlayScreenRoute = ({"noShrinkRow":"bSBrL"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/UI_Menu_ServerTab.png
const UI_Menu_ServerTab_namespaceObject = __webpack_require__.p + "assets/UI_Menu_ServerTab-657bb.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/UI_Menu_RealmsTab.png
const UI_Menu_RealmsTab_namespaceObject = __webpack_require__.p + "assets/UI_Menu_RealmsTab-93444.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/UI_Menu_WorldsTab.png
const UI_Menu_WorldsTab_namespaceObject = __webpack_require__.p + "assets/UI_Menu_WorldsTab-8d953.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/UI_Menu_WorldsTab_Alt01.png
const UI_Menu_WorldsTab_Alt01_namespaceObject = __webpack_require__.p + "assets/UI_Menu_WorldsTab_Alt01-bb1fa.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/UI_Menu_WorldsTab_Alt02.png
const UI_Menu_WorldsTab_Alt02_namespaceObject = __webpack_require__.p + "assets/UI_Menu_WorldsTab_Alt02-8a362.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/PlayScreenRoute.tsx
















const PlayScreenRoute_CREATE_BUTTON_ALIAS = 'play-create-button';
const CREATE_TEMPLATE_BUTTON_ALIAS = 'play-template-create-button';
const PlayScreenRoute_PlayScreenRoute = () => {
  const {
    t
  } = useLocalization('PlayScreen');
  const historyAPI = RouteHistory_useRouteHistory();
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(NarrationContext, {
    text: t('.narration.title')
  }, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout, {
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: () => historyAPI.goBack()
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography, {
      variant: "header5A",
      color: "black"
    }, t('.title'))
  }, /*#__PURE__*/react.createElement(Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0,
    className: PlayScreenRoute.noShrinkRow
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(PlayScreenRoute_Tabs, null))), /*#__PURE__*/react.createElement(RowWrapper_RowWrapper, {
    route: 'all',
    Component: AllWorldsTab,
    gamepadIndex: 1,
    wideSize: 12,
    narrowSize: 8
  }), /*#__PURE__*/react.createElement(RowWrapper_RowWrapper, {
    route: 'realms',
    Component: RealmsTab,
    gamepadIndex: 1,
    wideSize: 12,
    narrowSize: 8
  }), /*#__PURE__*/react.createElement(RowWrapper_RowWrapper, {
    route: 'servers',
    Component: ServersTab,
    gamepadIndex: 1,
    wideSize: 12,
    narrowSize: 8
  }), /*#__PURE__*/react.createElement(InputLegend_InputLegend.Space, null)))));
}; // 1/100 chance of showing the sunset icon for all worlds

const RANDOM_SUNSET_WORLD = Math.ceil(Math.random() * 100); // 1/9600 chance of showing the retro icon for all worlds

const RANDOM_RETRO_WORLD = Math.ceil(Math.random() * 9600);

function getWorldIcon() {
  if (RANDOM_RETRO_WORLD === 9600) return UI_Menu_WorldsTab_Alt02_namespaceObject;
  if (RANDOM_SUNSET_WORLD === 10) return UI_Menu_WorldsTab_Alt01_namespaceObject;else return UI_Menu_WorldsTab_namespaceObject;
}

const WORLD_ICON = getWorldIcon();

const PlayScreenRoute_Tabs = () => {
  const {
    t
  } = useLocalization('PlayScreen');
  const historyAPI = RouteHistory_useRouteHistory();
  const params = useRouteParams();
  const tabs = [{
    label: t('.allWorlds'),
    value: 'all',
    icons: {
      selected: /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
        iconSrc: WORLD_ICON,
        selected: true
      }),
      unselected: /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
        iconSrc: WORLD_ICON,
        selected: false
      })
    }
  }, {
    label: t('.realms'),
    value: 'realms',
    icons: {
      selected: /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
        iconSrc: UI_Menu_RealmsTab_namespaceObject,
        selected: true
      }),
      unselected: /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
        iconSrc: UI_Menu_RealmsTab_namespaceObject,
        selected: false
      })
    }
  }, {
    label: t('.servers'),
    value: 'servers',
    icons: {
      selected: /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
        iconSrc: UI_Menu_ServerTab_namespaceObject,
        selected: true
      }),
      unselected: /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
        iconSrc: UI_Menu_ServerTab_namespaceObject,
        selected: false
      })
    }
  }];
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  const tabBarNamespaceAlias = 'play-screen';
  return /*#__PURE__*/react.createElement(TabBar_TabBar, {
    autofocus: true,
    gamepadAliasNamespace: tabBarNamespaceAlias,
    gamepadIndex: 0,
    value: params.tab ? params.tab : 'all',
    onChange: newValue => {
      historyAPI.replaceKeepingFocus(`/play/${newValue}`);
      setFocusedId(TabBar_TabBar.getFocusAlias(tabBarNamespaceAlias, newValue));
    },
    tabs: tabs,
    enableGamepadShortcuts: true
  });
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmMemberCard/RealmMemberCard.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmMemberCard = ({"container":"ivQgF","realmButton":"w6xBK","gamerIconImage":"Whz2w","paperdollImage":"UhprB","hidden":"rORSO"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmMemberCard/images/paperdoll.png
const paperdoll_namespaceObject = __webpack_require__.p + "assets/paperdoll-b86d7.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmMemberCard/images/member.png
const member_namespaceObject = __webpack_require__.p + "assets/member-7cc66.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmMemberCard/images/operator.png
const operator_namespaceObject = __webpack_require__.p + "assets/operator-919bc.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmMemberCard/images/visitor.png
const visitor_namespaceObject = __webpack_require__.p + "assets/visitor-da442.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmMemberCard/RealmMemberCard.tsx













function RealmMemberCard_RealmMemberCard({
  member
}) {
  const {
    t
  } = useLocalization('RealmsStories.timeline');
  const gamerTag = (0,react_facet_src.useFacetMap)(m => m.gamerTag, [], [member]);
  const gamerIcon = (0,react_facet_src.useFacetMap)(m => {
    var _m$gamerIcon;

    return (_m$gamerIcon = m.gamerIcon) !== null && _m$gamerIcon !== void 0 ? _m$gamerIcon : paperdoll_namespaceObject;
  }, [], [member]);
  const imageStyle = (0,react_facet_src.useFacetMap)(m => m.gamerIcon != null ? RealmMemberCard.gamerIconImage : RealmMemberCard.paperdollImage, [], [member]);
  const loginInformation = (0,react_facet_src.useFacetMap)(m => t('.signIn', [`${convertSecondsToTime(getLatestRealmPlayerSessionLogin(m))}`]), [t], [member]);
  const playerRoleIcon = (0,react_facet_src.useFacetMap)(m => {
    if (m.role === RealmPlayerRoleEnum.MEMBER) {
      return member_namespaceObject;
    } else if (m.role === RealmPlayerRoleEnum.VISITOR) {
      return visitor_namespaceObject;
    } else {
      return operator_namespaceObject;
    }
  }, [], [member]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: RealmMemberCard.container
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: gamerIcon,
    className: imageStyle
  }), /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "neutral100"
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: playerRoleIcon
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Banner_Banner.Text, null, gamerTag)), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    align: "center"
  }, loginInformation)));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmMemberCard/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmVerticalAddButton/RealmVerticalAddButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmVerticalAddButton = ({"realmsStoriesHomePostButton":"_x3gN","icon":"Uoz80"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmVerticalAddButton/images/gray-plus-sign.png
const gray_plus_sign_namespaceObject = __webpack_require__.p + "assets/gray-plus-sign-658a3.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmVerticalAddButton/RealmVerticalAddButton.tsx








function RealmVerticalAddButton_RealmVerticalAddButton({
  onClick,
  gamepadIndex,
  narrationText,
  variant
}) {
  const {
    t
  } = useLocalization('RealmsStories');
  return /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensCollectionProvider, {
    collection: realmsTokens
  }, /*#__PURE__*/react.createElement(Pressable_Pressable, {
    onClick: onClick,
    gamepadIndex: gamepadIndex,
    isElevated: true,
    inputLegend: t('.add'),
    variant: variant,
    narrationText: narrationText,
    className: RealmVerticalAddButton.realmsStoriesHomePostButton
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    imageRendering: "pixelated",
    className: RealmVerticalAddButton.icon,
    src: gray_plus_sign_namespaceObject
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Tabs/MembersTab.tsx









function MemberTab() {
  const {
    t
  } = useLocalization('RealmsStories.members');
  const {
    t: pt
  } = useLocalization('RealmsStories');
  const breakpoint = useWindowBreakpoint();
  const [searchValue, setSearchValue] = (0,react_facet_src.useFacetState)('');
  const [filterValue, setFilterValue] = (0,react_facet_src.useFacetState)(RealmMemberFilterOption.All);
  const [sortValue, setSortValue] = (0,react_facet_src.useFacetState)(RealmMemberSortOption.MostRecent);
  const realmsFacet = (0,react_facet_src.useSharedFacet)(realmsStoriesFacet);
  const groupedPlayers = (0,react_facet_src.useFacetMap)(facet => groupRealmPlayersByRole(facet.data.members), [], [realmsFacet]);
  const sortedRealmPlayers = (0,react_facet_src.useFacetMemo)((players, searchValue, filterValue, sortValue) => {
    let unsortedMembers = [];

    switch (filterValue) {
      case RealmMemberFilterOption.Online:
        unsortedMembers = players.online;
        break;

      case RealmMemberFilterOption.Operators:
        unsortedMembers = players.operators;
        break;

      case RealmMemberFilterOption.Members:
        unsortedMembers = players.members;
        break;

      case RealmMemberFilterOption.Visitors:
        unsortedMembers = players.visitors;
        break;

      case RealmMemberFilterOption.Friends:
      case RealmMemberFilterOption.All:
      default:
        unsortedMembers = players.allPlayers;
        break;
    }

    let sortedMembers = [];

    switch (sortValue) {
      case RealmMemberSortOption.AlphabeticalAscending:
        sortedMembers = sortRealmPlayerGamerTagAlphabeticallyAscending(unsortedMembers);
        break;

      case RealmMemberSortOption.AlphabeticalDescending:
        sortedMembers = sortRealmPlayerGamerTagAlphabeticallyDescending(unsortedMembers);
        break;

      case RealmMemberSortOption.LeastRecent:
        sortedMembers = sortRealmPlayerByLeastActive(unsortedMembers);
        break;

      case RealmMemberSortOption.MostRecent:
      default:
        sortedMembers = sortRealmPlayerByMostRecent(unsortedMembers);
        break;
    }

    if (searchValue !== '') {
      sortedMembers = filterRealmPlayersByGamerTagSearch(sortedMembers, searchValue);
    } // TODO: Add check to see if current player has access to add new players before calling method


    sortedMembers = addButtonReplacementPlayer(sortedMembers);
    return sortedMembers;
  }, [], [groupedPlayers, searchValue, filterValue, sortValue], () => () => false);
  return /*#__PURE__*/react.createElement(Grid_Grid, {
    noGutters: true
  }, /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: 4,
    narrowSize: 2,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(BaseTextField_BaseTextField, {
    placeholder: t('.search'),
    narrationText: '',
    value: searchValue,
    onChange: setSearchValue
  })), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: 4,
    narrowSize: 3,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(BaseDropdown_BaseDropdown, {
    options: [{
      label: t('.showAll'),
      value: RealmMemberFilterOption.All
    }, {
      label: t('.friends'),
      value: RealmMemberFilterOption.Friends
    }, {
      label: t('.online'),
      value: RealmMemberFilterOption.Online
    }, {
      label: t('.operators'),
      value: RealmMemberFilterOption.Operators
    }, {
      label: t(''),
      value: RealmMemberFilterOption.Members
    }, {
      label: t('.visitors'),
      value: RealmMemberFilterOption.Visitors
    }],
    value: filterValue,
    onChange: setFilterValue
  })), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: 4,
    narrowSize: 3,
    gamepadIndex: 2
  }, /*#__PURE__*/react.createElement(BaseDropdown_BaseDropdown, {
    options: [{
      label: t('.byMostRecent'),
      value: RealmMemberSortOption.MostRecent
    }, {
      label: t('.byAlphabeticalAscending'),
      value: RealmMemberSortOption.AlphabeticalAscending
    }, {
      label: t('.byAlphabeticalDescending'),
      value: RealmMemberSortOption.AlphabeticalDescending
    }, {
      label: t('.byLeastRecent'),
      value: RealmMemberSortOption.LeastRecent
    }],
    value: sortValue,
    onChange: setSortValue
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 1,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: 12,
    narrowSize: 8,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(GridList_GridList, {
    gamepadIndex: 0,
    columns: breakpoint === 'narrow' ? 4 : 5,
    firstRowSeparatorVertical: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 1
    }),
    itemSeparatorHorizontal: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: breakpoint === 'narrow' ? 1 : 3
    }),
    itemSeparatorVertical: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: breakpoint === 'narrow' ? 2 : 4
    }),
    renderItem: ({
      itemFacet
    }) => /*#__PURE__*/react.createElement(MemberTabGridItem, {
      realmPlayer: itemFacet,
      t: pt
    }),
    data: sortedRealmPlayers
  }))));
}

function MemberTabGridItem({
  realmPlayer,
  t
}) {
  const shouldDisplayAddPlayerButtonFacet = (0,react_facet_src.useFacetMap)(player => player.gamerTag === REPLACEMENT_REALM_PLAYER_GAMER_TAG, [], [realmPlayer]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldDisplayAddPlayerButtonFacet
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      display: 'flex',
      width: '8.4rem',
      marginLeft: '8rem',
      alignItems: 'center'
    }
  }, /*#__PURE__*/react.createElement(RealmVerticalAddButton_RealmVerticalAddButton, {
    onClick: () => console.log('to do'),
    gamepadIndex: 7,
    narrationText: t('.invitePlayerToRealm'),
    variant: "secondary"
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldDisplayAddPlayerButtonFacet,
    condition: false
  }, /*#__PURE__*/react.createElement(react_facet_src.With, {
    data: realmPlayer
  }, realmPlayer => /*#__PURE__*/react.createElement(RealmMemberCard_RealmMemberCard, {
    member: realmPlayer
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryPost/RealmStoryPost.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmStoryPost = ({"storyPostSection":"ReC4q","storyPostContainer":"j_Y2I","border":"ONMYw","detailsSection":"ukEYi","totalLikesContainer":"dTU_B","inlineIcon":"bQTT4"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryPost/images/comments_light.png
const comments_light_namespaceObject = __webpack_require__.p + "assets/comments_light-88de7.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryPost/images/heart_sprite.png
const heart_sprite_namespaceObject = __webpack_require__.p + "assets/heart_sprite-88957.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryPost/images/heart_outline.png
const heart_outline_namespaceObject = __webpack_require__.p + "assets/heart_outline-84139.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryPost/images/options.png
const options_namespaceObject = __webpack_require__.p + "assets/options-9456a.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/gamer-icons/gamer-icon-villager.png
const gamer_icon_villager_namespaceObject = __webpack_require__.p + "assets/gamer-icon-villager-856f0.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryPost/RealmStoryPost.tsx




















const RealmStoryPost_hasImage = realmStory => realmStory.image !== '' || realmStory.fetchImage.state === AsyncStatefulFunctionState.InProgress;

function RealmStoryPost_RealmStoryPost({
  realmStory,
  index
}) {
  const historyAPI = RouteHistory_useRouteHistory();
  const {
    t
  } = useLocalization('RealmsStories.feedPost');
  const breakpoint = useWindowBreakpoint();
  const isNarrationEnabled = useNarrationEnabled();
  const totalComments = (0,react_facet_src.useFacetMap)(facet => t('.totalComments', [facet.totalComments.toLocaleString()]), [t], [realmStory]);
  const totalLikes = (0,react_facet_src.useFacetMap)(facet => t('.totalLikes', [facet.totalLikes.toLocaleString()]), [t], [realmStory]);
  const hasStoryImage = (0,react_facet_src.useFacetMap)(realmStory => RealmStoryPost_hasImage(realmStory), [], [realmStory]);
  const storyImage = (0,react_facet_src.useFacetMap)(realmStory => realmStory.image, [], [realmStory]);
  const storyBody = (0,react_facet_src.useFacetMap)(facet => facet.body, [], [realmStory]);
  const storyTimePosted = (0,react_facet_src.useFacetMap)(facet => facet.timePosted, [], [realmStory]);
  const authorGamerTag = (0,react_facet_src.useFacetMap)(facet => facet.author.gamerTag, [], [realmStory]);
  const authorGamerIcon = (0,react_facet_src.useFacetMap)(facet => {
    var _facet$author$gamerIc;

    return (_facet$author$gamerIc = facet.author.gamerIcon) !== null && _facet$author$gamerIc !== void 0 ? _facet$author$gamerIc : gamer_icon_villager_namespaceObject;
  }, [], [realmStory]);
  const authorOnlineStatus = (0,react_facet_src.useFacetMap)(facet => facet.author.isOnline ? 'online' : 'offline', [], [realmStory]);
  const likedStoryNarration = (0,react_facet_src.useFacetMap)(facet => facet.hasLiked ? t('.unlikeStoryPost') : t('.likeStoryPost'), [t], [realmStory]);
  const likeButtonText = (0,react_facet_src.useFacetMap)(facet => facet.hasLiked ? t('.liked') : t('.like'), [t], [realmStory]);
  const likeButtonIcon = (0,react_facet_src.useFacetMap)(facet => facet.hasLiked ? heart_sprite_namespaceObject : heart_outline_namespaceObject, [], [realmStory]);
  const likeButtonRole = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(facet => facet.hasLiked ? 'primary' : 'neutral', [], [realmStory]));
  const postNarrationText = (0,react_facet_src.useFacetMap)(story => `${story.author.gamerTag} . ${story.author.isOnline ? t('.online') : t('.offline')} . ${story.body}`, [t], [realmStory]);
  const openStoryCommentsHandler = (0,react_facet_src.useFacetCallback)(story => () => {
    historyAPI.push(`/realms-story-comments/${encodeURIComponent(story.id)}`);
  }, [historyAPI], [realmStory]);
  const toggleStoryLike = (0,react_facet_src.useFacetCallback)(story => () => {
    story.toggleLike.run();
  }, [], [realmStory]);
  const {
    color: {
      ['neutral']: neutralColors,
      ['neutral80']: darkColors
    },
    variant
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: isNarrationEnabled,
    narrationText: postNarrationText,
    gamepadIndex: index,
    className: neutralColors.border.base,
    classNameFocused: neutralColors.outline.base
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(RealmStoryPost.storyPostContainer, darkColors.background.base)
  }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(PlayerAvatar_PlayerAvatar, {
    src: authorGamerIcon,
    status: authorOnlineStatus,
    variant: "large"
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(neutralColors.text.base, RealmStoryPost.storyPostSection)
  }, /*#__PURE__*/react.createElement(Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 8,
    narrowSize: 6
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit",
    align: "left"
  }, authorGamerTag)), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 4,
    narrowSize: 2
  }, /*#__PURE__*/react.createElement("span", {
    className: classnames_default()(variant.dimmer, neutralColors.text.base)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit",
    align: "right"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, storyTimePosted))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasStoryImage
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(WorldImage_WorldImage, {
    imgSrc: storyImage,
    role: "neutral"
  }))))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 2
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "paragraphs",
    color: "inherit"
  }, storyBody)))))), /*#__PURE__*/react.createElement(ListItem_ListItem, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(RealmStoryPost.border, RealmStoryPost.detailsSection, neutralColors.background.base, neutralColors.bevel.base)
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.Main, {
    role: "neutral"
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmStoryPost.totalLikesContainer
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: heart_sprite_namespaceObject,
    className: RealmStoryPost.inlineIcon
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit",
    align: "left"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, totalLikes)))), breakpoint !== 'narrow' && /*#__PURE__*/react.createElement(ListItem_ListItem.Cell, null, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit",
    align: "right"
  }, totalComments))), /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 0,
    narrationText: likedStoryNarration,
    inputLegend: likedStoryNarration,
    onClick: toggleStoryLike,
    role: likeButtonRole === react_facet_src.NO_VALUE ? 'neutral' : likeButtonRole
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: likeButtonIcon
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionTiny",
    color: "inherit"
  }, likeButtonText)), /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 1,
    narrationText: t('.viewComments'),
    inputLegend: t('.viewComments'),
    onClick: openStoryCommentsHandler
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: comments_light_namespaceObject
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionTiny",
    color: "inherit"
  }, t('.comments'))), /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 2,
    narrationText: t('.options'),
    inputLegend: t('.options'),
    onClick: () => {}
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: options_namespaceObject
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionTiny",
    color: "inherit"
  }, t('.options')))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryPost/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/RealmsStoriesRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmsStoriesRoute = ({"tabsContainer":"lLbmU","border":"N7qJ3","activityFeedItem":"ytC0s"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Tabs/StoryFeedTab.tsx

















function StoryFeedTab() {
  const historyAPI = RouteHistory_useRouteHistory();
  const breakpoint = useWindowBreakpoint();
  const isNarrationEnabled = useNarrationEnabled();
  const realmsFacet = (0,react_facet_src.useSharedFacet)(realmsStoriesFacet);
  const {
    t
  } = useLocalization('RealmsStories.feed');
  const RECENT_PLAYERS_TO_DISPLAY = breakpoint === 'desktop' ? 4 : 3;
  const isStoriesLoading = (0,react_facet_src.useFacetMap)(facet => facet.data.fetchStories.state === AsyncStatefulFunctionState.InProgress, [], [realmsFacet]);
  const loadedRealmStories = (0,react_facet_src.useFacetMap)(facet => {
    const stories = [];

    for (let i = 0; i < facet.data.stories.length; i++) {
      stories.push(facet.data.stories[i]);
    }

    return stories;
  }, [], [realmsFacet], () => () => false);
  const isMembersLoading = (0,react_facet_src.useFacetMap)(facet => facet.data.fetchMembers.state === AsyncStatefulFunctionState.InProgress, [], [realmsFacet]);
  const recentRealmPlayers = (0,react_facet_src.useFacetMap)(facet => {
    const players = [];
    const sortedPlayers = selectMostRecentRealmPlayers(slice(facet.data.members, 0));
    const max = Math.min(RECENT_PLAYERS_TO_DISPLAY, sortedPlayers.length);

    for (let i = 0; i < max; i++) {
      players.push(sortedPlayers[i]);
    }

    return players;
  }, [RECENT_PLAYERS_TO_DISPLAY], [realmsFacet]);

  const onAddNewStoryClick = () => historyAPI.push('/realms-new-story');

  return /*#__PURE__*/react.createElement(Grid_Grid, {
    noGutters: true
  }, /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: 4,
    narrowSize: 3,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.createPost'),
    variant: "hero",
    onClick: onAddNewStoryClick,
    gamepadIndex: 1
  }, t('.createPost')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.addMember'),
    variant: "secondary",
    onClick: () => {},
    gamepadIndex: 2
  }, t('.addMember')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 3,
    loading: isMembersLoading
  }, /*#__PURE__*/react.createElement(ListHeader_ListHeader, {
    role: "primary",
    label: t('.activityFeed')
  }), /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: recentRealmPlayers
  }, (item, index) => /*#__PURE__*/react.createElement(RecentMemberListItem, {
    realmPlayer: item,
    isNarrationEnabled: isNarrationEnabled,
    index: index
  })))), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: 8,
    narrowSize: 5,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(GridList_GridList, {
    loading: isStoriesLoading,
    data: loadedRealmStories,
    gamepadIndex: 0,
    columns: 1,
    itemSeparatorVertical: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: breakpoint === 'narrow' ? 2 : 4
    }),
    renderItem: ({
      itemFacet,
      index
    }) => /*#__PURE__*/react.createElement(RealmStoryPost_RealmStoryPost, {
      realmStory: itemFacet,
      index: index
    }),
    footer: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 4
    }),
    emptyMessage: /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
      autofocus: true,
      gamepadIndex: 0,
      title: t('.emptyStoryFeedTitle'),
      text: t('.emptyStoryFeedText')
    })
  }))));
}

function RecentMemberListItem({
  realmPlayer,
  isNarrationEnabled,
  index
}) {
  const {
    t
  } = useLocalization('RealmsStories.feed');
  const gamerTag = (0,react_facet_src.useFacetMap)(player => player.gamerTag, [], [realmPlayer]);
  const gamerIcon = (0,react_facet_src.useFacetMap)(player => {
    var _player$gamerIcon;

    return (_player$gamerIcon = player.gamerIcon) !== null && _player$gamerIcon !== void 0 ? _player$gamerIcon : gamer_icon_villager_namespaceObject;
  }, [], [realmPlayer]);
  const onlineStatus = (0,react_facet_src.useFacetMap)(player => player.isOnline ? 'online' : 'offline', [], [realmPlayer]);
  const narrationText = (0,react_facet_src.useFacetMap)(player => {
    return `${player.gamerTag} . ${player.isOnline ? t('.online') : t('.offline')}`;
  }, [t], [realmPlayer]);
  const {
    color: {
      ['neutral']: neutralColors,
      ['neutral80']: darkColors
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: isNarrationEnabled,
    narrationText: narrationText,
    gamepadIndex: index,
    className: classnames_default()(RealmsStoriesRoute.activityFeedItem, RealmsStoriesRoute.border, darkColors.background.base),
    classNameFocused: classnames_default()(RealmsStoriesRoute.activityFeedItem, darkColors.background.hover, neutralColors.outline.base)
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(neutralColors.border.base)
  }, /*#__PURE__*/react.createElement(PlayerAvatar_PlayerAvatar, {
    src: gamerIcon,
    variant: "large",
    status: onlineStatus
  })), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "white"
  }, gamerTag));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Tabs/TimelineTab.tsx



function TimelineTab() {
  const {
    t
  } = useLocalization('RealmsStories');
  return /*#__PURE__*/react.createElement(Grid_Grid, {
    noGutters: true
  }, /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 3,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    wideSize: 12,
    narrowSize: 8,
    gamepadIndex: 4
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "header3",
    align: "center"
  }, t('.timeline')))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Tabs/index.tsx



;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/RealmsStoriesRoute.tsx










function RealmsStoriesRoute_RealmsStoriesRoute() {
  var _params$tab;

  const historyAPI = RouteHistory_useRouteHistory();
  const {
    t
  } = useLocalization('RealmsStories');
  const params = useRouteParams();
  const [selectedTab, setSelectedTab] = (0,react.useState)((_params$tab = params.tab) !== null && _params$tab !== void 0 ? _params$tab : 'home');
  const realmsStoriesTabs = [{
    label: t('.home'),
    value: 'home'
  }, {
    label: t('.members'),
    value: 'members'
  }, {
    label: t('.timeline'),
    value: 'timeline'
  }];
  return /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensCollectionProvider, {
    collection: realmsTokens
  }, /*#__PURE__*/react.createElement(GlassPane_GlassPane, {
    role: "primary"
  }, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout, {
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: historyAPI.goBack
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography, {
      variant: "header5A",
      color: "black"
    }, t('.header'))
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmsStoriesRoute.tabsContainer
  }, /*#__PURE__*/react.createElement(Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(TabBar_TabBar, {
    gamepadAliasNamespace: "realms-stories",
    gamepadIndex: 0,
    tabs: realmsStoriesTabs,
    value: selectedTab,
    enableGamepadShortcuts: true,
    onChange: newValue => {
      setSelectedTab(newValue);
      historyAPI.replaceWithPreviousFocus(`/realms-stories/${newValue}`);
    }
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(TabWrapper, {
    component: StoryFeedTab,
    tab: "home"
  }), /*#__PURE__*/react.createElement(TabWrapper, {
    component: MemberTab,
    tab: "members"
  }), /*#__PURE__*/react.createElement(TabWrapper, {
    component: TimelineTab,
    tab: "timeline"
  }))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/TemplateCommon.tsx





function hasAdditionalProperty(message, key) {
  if (message.additionalProperties == null) return false;

  for (let i = 0; i < message.additionalProperties.length; i++) {
    const prop = message.additionalProperties[i];
    if (prop != null && prop.key == key) return true;
  }

  return false;
}
function TemplateCommon_getAdditionalProperty(message, key) {
  if (message.additionalProperties == null) return '';
  if (message.additionalProperties.length < 1) return '';

  for (let i = 0; i < message.additionalProperties.length; i++) {
    const prop = message.additionalProperties[i];
    if (prop.key == key) return prop.value;
  }

  return null;
}
function getMessageImage(message, imageID) {
  for (let i = 0; i < message.images.length; i++) {
    const image = message.images[i];
    if (image == null || image.id != imageID) continue;
    if (image.isLoaded) return image;
    return null;
  }

  return null;
}
function getMessageImageUrl(message, imageID) {
  const image = getMessageImage(message, imageID);
  if (image && image.url.length > 0) return image.url;
  return null;
}
function getMessageButton(message, buttonID) {
  for (let i = 0; i < message.buttons.length; i++) {
    const button = message.buttons[i];
    if (button != null && button.id == buttonID) return button;
  }

  return null;
}
function getButtonText(message, buttonID, fallback = '') {
  const button = getMessageButton(message, buttonID);
  if (button != null && button.text.length > 0) return button.text;
  return fallback;
}
function ErrorModal({
  errorMessage,
  messageID
}) {
  const {
    t
  } = useLocalization('AnnouncementModalRoute');
  const historyAPI = RouteHistory_useRouteHistory();
  let title = String(t('.errorTitle'));
  const bodyText = String(errorMessage);

  if (messageID != null) {
    title += ' ID: ' + messageID;
  }

  const continueClick = function () {
    historyAPI.goBack();
  };

  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: title + bodyText
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    focusableIfScrollable: true
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: bodyText
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "left"
  }, bodyText))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.confirmInputLegend'),
    variant: "secondary",
    onClick: () => continueClick()
  }, t('.continue')))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/ImageThumbnailCTA.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ImageThumbnailCTA = ({"headerDiv":"mbdeF","image1Div":"q5uyU","image2Div":"hkTtP","imageFill":"CZukv","rightDiv":"Fhcnq","buttonDiv":"kiYsW","boarderStyle":"U_nrH"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/ImageThumbnailCTA.tsx











const CONTINUE_BUTTON_ID = 'Dismiss';
const UNLOCK_BUTTON_ID = 'CallToAction';
const LARGE_IMAGE_ID = 'Primary';
const SMALL_IMAGE_ID = 'Secondary'; //check if all non-default message properties are present

function hasRequiredProperties(announcement) {
  if (announcement.surface === 'LoginAnnouncement' && announcement.template === 'ImageThumbnailCTA' && hasAdditionalProperty(announcement, 'header') && hasAdditionalProperty(announcement, 'body') && announcement.images.length >= 2 && getMessageButton(announcement, UNLOCK_BUTTON_ID) != null) return true;
  return false;
}

function joinClasses(head, tail) {
  return head + ' ' + tail;
}

function ImageThumbnailCTA_ImageThumbnailCTA({
  announcement
}) {
  const {
    t
  } = useLocalization('AnnouncementModalRoute');
  const historyAPI = RouteHistory_useRouteHistory();
  const message = (0,react_facet_src.useFacetUnwrap)(announcement);
  const reportClick = (0,react_facet_src.useFacetCallback)(report => (messageID, button) => {
    report(messageID, button.id);
    button.reportClick();
  }, [], [(0,react_facet_src.useSharedFacet)(applyReportClick)]);
  const reportDismiss = (0,react_facet_src.useFacetCallback)(reportDismiss => messageID => {
    reportDismiss(messageID);
  }, [], [(0,react_facet_src.useSharedFacet)(applyReportDismiss)]);

  if (message === react_facet_src.NO_VALUE || message == null) {
    return /*#__PURE__*/react.createElement(ErrorModal, {
      errorMessage: t('.errorNoMessage')
    });
  }

  if (!hasRequiredProperties(message)) return /*#__PURE__*/react.createElement(ErrorModal, {
    errorMessage: t('.errorInvalidTemplate')
  });
  const title = String(TemplateCommon_getAdditionalProperty(message, 'header'));
  const bodyText = String(TemplateCommon_getAdditionalProperty(message, 'body'));
  const continueButtonText = getButtonText(message, CONTINUE_BUTTON_ID, t('.continue'));
  const unlockButton = getMessageButton(message, UNLOCK_BUTTON_ID);
  const unlockButtonText = getButtonText(message, UNLOCK_BUTTON_ID, t('.unlock'));
  const image1 = getMessageImageUrl(message, LARGE_IMAGE_ID);
  const image2 = getMessageImageUrl(message, SMALL_IMAGE_ID);

  const dismissModal = () => {
    reportDismiss(message.id);
    historyAPI.goBack();
  };

  const fillWidth = {
    width: '100%'
  };
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: `${title}. ${bodyText}`
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: dismissModal
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    focusableIfScrollable: true
  }, /*#__PURE__*/react.createElement("div", {
    className: ImageThumbnailCTA.headerDiv
  }, /*#__PURE__*/react.createElement("div", {
    className: joinClasses(ImageThumbnailCTA.image1Div, ImageThumbnailCTA.boarderStyle)
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: `${image1}`,
    className: ImageThumbnailCTA.imageFill
  })), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    className: ImageThumbnailCTA.rightDiv
  }, /*#__PURE__*/react.createElement("div", {
    className: joinClasses(ImageThumbnailCTA.image2Div, ImageThumbnailCTA.boarderStyle)
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: `${image2}`,
    className: ImageThumbnailCTA.imageFill
  })), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    className: ImageThumbnailCTA.buttonDiv
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 2,
    inputLegend: t('.confirmInputLegend'),
    variant: "primary",
    onClick: () => {
      if (unlockButton != null) {
        reportClick(message.id, unlockButton);
        reportDismiss(message.id);
      }
    }
  }, unlockButtonText)))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: bodyText
  }, /*#__PURE__*/react.createElement("div", {
    style: fillWidth
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "left",
    whiteSpace: "preWrap"
  }, bodyText)))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.confirmInputLegend'),
    variant: "secondary",
    onClick: dismissModal
  }, continueButtonText))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/ImageText.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ImageText = ({"mainImage":"NQe8O","textBox":"L5DW3","imageFill":"WuFak","boarderStyle":"f9XJI"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/ImageText.tsx










const ImageText_CONTINUE_BUTTON_ID = 'Dismiss';
const MAIN_IMAGE_ID = 'Primary'; //check if all non-default message properties are present

function ImageText_hasRequiredProperties(announcement) {
  if (announcement.surface === 'LoginAnnouncement' && announcement.template === 'ImageText' && hasAdditionalProperty(announcement, 'header') && hasAdditionalProperty(announcement, 'body') && announcement.images.length >= 1) return true;
  return false;
}

let imgWidth;

function calculateWidth() {
  const rem = parseFloat(window.getComputedStyle(document.documentElement).fontSize);
  const vh = window.innerHeight / 100;
  const imgHeight = 16;
  const imgMaxHeight = 26.8;
  imgWidth = imgMaxHeight * vh < 16 * rem ? 'calc(' + imgMaxHeight.toString() + 'vh * 16 / 9)' : 'calc(' + imgHeight.toString() + 'rem * 16 / 9)';
}

function ImageText_ImageText({
  announcement
}) {
  const {
    t
  } = useLocalization('AnnouncementModalRoute');
  const historyAPI = RouteHistory_useRouteHistory();
  const message = (0,react_facet_src.useFacetUnwrap)(announcement);
  const reportDismiss = (0,react_facet_src.useFacetCallback)(reportDismiss => messageID => {
    reportDismiss(messageID);
  }, [], [(0,react_facet_src.useSharedFacet)(applyReportDismiss)]);

  if (message === react_facet_src.NO_VALUE || message == null) {
    return /*#__PURE__*/react.createElement(ErrorModal, {
      errorMessage: t('.errorNoMessage')
    });
  }

  if (!ImageText_hasRequiredProperties(message)) return /*#__PURE__*/react.createElement(ErrorModal, {
    errorMessage: t('.errorInvalidTemplate')
  });
  const title = String(TemplateCommon_getAdditionalProperty(message, 'header'));
  const bodyText = String(TemplateCommon_getAdditionalProperty(message, 'body'));
  const image = getMessageImageUrl(message, MAIN_IMAGE_ID);
  const continueButtonText = getButtonText(message, ImageText_CONTINUE_BUTTON_ID, t('.continue'));

  const dismissModal = () => {
    reportDismiss(message.id);
    historyAPI.goBack();
  };

  calculateWidth();
  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: `${title}. ${bodyText}`
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: dismissModal
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    focusableIfScrollable: true
  }, /*#__PURE__*/react.createElement("div", {
    className: ImageText.mainImage
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: `${image}`,
    className: ImageText.imageFill + ' ' + ImageText.boarderStyle,
    width: imgWidth
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: bodyText
  }, /*#__PURE__*/react.createElement("div", {
    className: ImageText.textBox
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "left",
    whiteSpace: "preWrap"
  }, bodyText)))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.confirmInputLegend'),
    variant: "secondary",
    onClick: dismissModal
  }, continueButtonText))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/HeroImageCTA.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const HeroImageCTA = ({"outerDiv":"oQouW","imageContainer":"ncO_r","textBox":"FDtOo","imageFill":"zahMv","boarderStyle":"CL2fS"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/HeroImageCTA.tsx











const HeroImageCTA_CONTINUE_BUTTON_ID = 'Dismiss';
const HeroImageCTA_UNLOCK_BUTTON_ID = 'CallToAction';
const HeroImageCTA_MAIN_IMAGE_ID = 'Primary'; //check if all non-default message properties are present

function HeroImageCTA_hasRequiredProperties(announcement) {
  if (announcement.surface === 'LoginAnnouncement' && announcement.template === 'HeroImageCTA' && hasAdditionalProperty(announcement, 'header') && hasAdditionalProperty(announcement, 'body') && announcement.images.length >= 1) return true;
  return false;
}

function HeroImageCTA_joinClasses(head, tail) {
  return head + ' ' + tail;
}

function HeroImageCTA_HeroImageCTA({
  announcement
}) {
  const {
    t
  } = useLocalization('AnnouncementModalRoute');
  const historyAPI = RouteHistory_useRouteHistory();
  const message = (0,react_facet_src.useFacetUnwrap)(announcement);
  const reportClick = (0,react_facet_src.useFacetCallback)(report => (messageID, button) => {
    report(messageID, button.id);
    button.reportClick();
  }, [], [(0,react_facet_src.useSharedFacet)(applyReportClick)]);
  const reportDismiss = (0,react_facet_src.useFacetCallback)(reportDismiss => messageID => {
    reportDismiss(messageID);
  }, [], [(0,react_facet_src.useSharedFacet)(applyReportDismiss)]);

  if (message === react_facet_src.NO_VALUE || message == null) {
    return /*#__PURE__*/react.createElement(ErrorModal, {
      errorMessage: t('.errorNoMessage')
    });
  }

  if (!HeroImageCTA_hasRequiredProperties(message)) return /*#__PURE__*/react.createElement(ErrorModal, {
    errorMessage: t('.errorInvalidTemplate')
  });
  const title = String(TemplateCommon_getAdditionalProperty(message, 'header'));
  const bodyText = String(TemplateCommon_getAdditionalProperty(message, 'body'));
  const continueButtonText = getButtonText(message, HeroImageCTA_CONTINUE_BUTTON_ID, t('.continue'));
  const unlockButton = getMessageButton(message, HeroImageCTA_UNLOCK_BUTTON_ID);
  const unlockButtonText = getButtonText(message, HeroImageCTA_UNLOCK_BUTTON_ID, t('.unlock'));
  const image = getMessageImageUrl(message, HeroImageCTA_MAIN_IMAGE_ID);

  const dismissModal = () => {
    reportDismiss(message.id);
    historyAPI.goBack();
  };

  function includeUnlock(id) {
    return /*#__PURE__*/react.createElement(Button_Button_Button, {
      gamepadIndex: 2,
      inputLegend: t('.confirmInputLegend'),
      variant: "primary",
      onClick: () => {
        if (unlockButton != null) {
          reportClick(id, unlockButton);
          reportDismiss(id);
        }
      },
      horizontal: true
    }, unlockButtonText);
  }

  return /*#__PURE__*/react.createElement(NarrationContext, {
    text: `${title}. ${bodyText}`
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: dismissModal
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    focusableIfScrollable: true
  }, /*#__PURE__*/react.createElement("div", {
    className: HeroImageCTA.outerDiv
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: HeroImageCTA_joinClasses(HeroImageCTA.imageContainer, HeroImageCTA.boarderStyle)
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: `${image}`,
    className: HeroImageCTA.imageFill
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: bodyText
  }, /*#__PURE__*/react.createElement("div", {
    className: HeroImageCTA.textBox
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    verticalAlign: "center",
    align: "left",
    color: "inherit",
    whiteSpace: "preWrap"
  }, bodyText))))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.confirmInputLegend'),
    variant: "secondary",
    onClick: dismissModal,
    horizontal: true
  }, continueButtonText), unlockButton != null && /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), unlockButton != null && includeUnlock(message.id))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates.tsx




;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/AnnouncementModalRoute.tsx






function AnnouncementModalRoute() {
  const {
    t
  } = useLocalization('AnnouncementModalRoute');
  const params = useRouteParams();
  const data = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(messageDetailSelector(params.id)));
  const loadStatus = data === react_facet_src.NO_VALUE ? undefined : data.isLoaded;
  const announcement = data === react_facet_src.NO_VALUE ? undefined : data.message;
  const isLoaded = loadStatus != null ? loadStatus : false;

  if (isLoaded == true) {
    if (announcement != null) {
      switch (announcement.template) {
        case 'ImageText':
          return /*#__PURE__*/react.createElement(ImageText_ImageText, {
            announcement: announcement
          });

        case 'ImageThumbnailCTA':
          return /*#__PURE__*/react.createElement(ImageThumbnailCTA_ImageThumbnailCTA, {
            announcement: announcement
          });

        case 'HeroImageCTA':
          return /*#__PURE__*/react.createElement(HeroImageCTA_HeroImageCTA, {
            announcement: announcement
          });

        default:
          return /*#__PURE__*/react.createElement(ErrorModal, {
            errorMessage: t('.errorUnsupportedTemplate')
          });
      }
    } else {
      return /*#__PURE__*/react.createElement(ErrorModal, {
        errorMessage: t('.errorNoMessage')
      });
    }
  }

  return null;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/engine/src/playerBannedFacet.ts

const PLAYER_BANNED_FACET = 'vanilla.playerBanned';
const playerBannedFacet = (0,react_facet_src.sharedFacet)(PLAYER_BANNED_FACET);
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayerBannedModalRoute/PlayerBannedModalRoute.tsx







function getBanTimeRemainingBody(timeRemaining, isPermanent, isHours, t) {
  if (isPermanent) {
    return t('.body.forever');
  } else if (timeRemaining == null || timeRemaining == '0') {
    return '';
  } else if (timeRemaining == '1') {
    return isHours ? t('.body.hour') : t('.body.day');
  } else {
    return isHours ? t('.body.hours', [timeRemaining]) : t('.body.days', [timeRemaining]);
  }
}

const PlayerBannedModalRoute = () => {
  var _params$get;

  const historyAPI = RouteHistory_useRouteHistory();
  const {
    t
  } = useLocalization('PlayerBannedModalRoute');
  const openBannedInfoPage = (0,react_facet_src.useFacetCallback)(facet => () => facet.openBannedInfoPage(), [], [(0,react_facet_src.useSharedFacet)(playerBannedFacet)]);
  const params = useRouteQuery();
  const banReason = t('.' + ((_params$get = params.get('banReason')) !== null && _params$get !== void 0 ? _params$get : 'unknownReportArea'));
  const timeRemaining = params.get('timeRemaining');
  const isHours = params.get('isHours') == '1';
  const isPermanent = params.get('isPermanent') == '1';
  const banType = isPermanent ? t('.permanent') : t('.temporary');
  const bannedBody = t('.body', [banType, banReason]);
  const closeButtonText = t('.close');
  const bannedBody2 = t('.body2', [closeButtonText, banType]);
  const modalTitle = t('.title', [banType]);
  const banTimeRemainingBody = getBanTimeRemainingBody(timeRemaining, isPermanent, isHours, t);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: () => historyAPI.goBack()
  }, modalTitle), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${bannedBody}. ${bannedBody2} . ${banTimeRemainingBody}`,
    spaceBetweenParagraphs: 4,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong"
  }, bannedBody), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong"
  }, bannedBody2), banTimeRemainingBody != '' && /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong"
  }, banTimeRemainingBody))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    autofocus: true,
    inputLegend: closeButtonText,
    variant: "primary",
    delayedClick: true,
    onClick: openBannedInfoPage
  }, closeButtonText)));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayerBannedModalRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ReportPlayerRoute/AreaInput.tsx





function AreaInput({
  reportArea,
  onConfirm,
  onChangeReportArea,
  isSubmitDisabled
}) {
  const {
    t
  } = useLocalization('ReportPlayerRoute');
  const reportableAreas = (0,react_facet_src.sharedSelector)(reportFacet => reportFacet.reportAreaOptions, [playerReportFacet]);
  const options = (0,react_facet_src.useFacetMap)(areas => areas.map(a => ({
    label: t('.' + a.label),
    value: a.value
  })), [t], [(0,react_facet_src.useSharedFacet)(reportableAreas)]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    scrollable: false
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.whereReportDescription')
  }, t('.whereReportDescription')), /*#__PURE__*/react.createElement(Dropdown, {
    label: "",
    placeholder: t('.whereReport'),
    description: "",
    options: options,
    gamepadIndex: 1,
    onChange: onChangeReportArea,
    value: reportArea
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    autofocus: true,
    inputLegend: t('.next'),
    variant: "primary",
    delayedClick: true,
    onClick: onConfirm,
    disabled: isSubmitDisabled
  }, t('.next'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ReportPlayerRoute/ReasonInputAndSubmission.tsx




var ReportReason;

(function (ReportReason) {
  ReportReason[ReportReason["Cheating"] = 1] = "Cheating";
  ReportReason[ReportReason["NameOrGamertag"] = 2] = "NameOrGamertag";
  ReportReason[ReportReason["UnsportingBehavior"] = 4] = "UnsportingBehavior";
  ReportReason[ReportReason["ChildSexualExploitationOrAbuse"] = 6] = "ChildSexualExploitationOrAbuse";
  ReportReason[ReportReason["TerrorismOrViolentExtremism"] = 7] = "TerrorismOrViolentExtremism";
  ReportReason[ReportReason["HateSpeech"] = 8] = "HateSpeech";
  ReportReason[ReportReason["ImminentHarm"] = 9] = "ImminentHarm";
  ReportReason[ReportReason["NonConsensualIntimateImagery"] = 10] = "NonConsensualIntimateImagery";
})(ReportReason || (ReportReason = {}));

function ReasonInputAndSubmission({
  gamertag,
  reportReason,
  onClickSendReport,
  onChangeReportReason,
  onChangeReportMessage,
  isSubmitDisabled
}) {
  const {
    t
  } = useLocalization('ReportPlayerRoute');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Dropdown, {
    label: "",
    placeholder: t('.whyReport', [gamertag]),
    description: "",
    options: [{
      label: t('.cheating'),
      value: ReportReason.Cheating
    }, {
      label: t('.nameOrGamertag'),
      value: ReportReason.NameOrGamertag
    }, {
      label: t('.unsportingBehavior'),
      value: ReportReason.UnsportingBehavior
    }, {
      label: t('.childSexualExploitationOrAbuse'),
      value: ReportReason.ChildSexualExploitationOrAbuse
    }, {
      label: t('.terrorismOrViolentExtremism'),
      value: ReportReason.TerrorismOrViolentExtremism
    }, {
      label: t('.hateSpeech'),
      value: ReportReason.HateSpeech
    }, {
      label: t('.imminentHarm'),
      value: ReportReason.ImminentHarm
    }, {
      label: t('.nonConsensualIntimateImagery'),
      value: ReportReason.NonConsensualIntimateImagery
    }],
    gamepadIndex: 0,
    onChange: onChangeReportReason,
    value: reportReason
  }), /*#__PURE__*/react.createElement(VanillaTextField, {
    gamepadIndex: 1,
    rows: 8,
    label: "",
    description: t('.optionalText'),
    value: "",
    onChange: onChangeReportMessage,
    maxLength: 500
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 2,
    autofocus: true,
    inputLegend: t('.report'),
    variant: "primary",
    delayedClick: true,
    onClick: onClickSendReport,
    disabled: isSubmitDisabled
  }, t('.report'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ReportPlayerRoute/ChatSelection.tsx





const MAX_SELECTED_CHAT_MESSAGES = 4;

function MessageCheckbox({
  index,
  gamepad,
  data,
  onChange,
  checkingDisabled
}) {
  const [isCheckboxEnabled, setIsCheckboxEnabled] = (0,react_facet_src.useFacetState)(false);
  const changeHandler = (0,react_facet_src.useFacetCallback)(checkingDisabled => value => {
    if (value && checkingDisabled) {
      return;
    }

    onChange(index, value);
    setIsCheckboxEnabled(value);
  }, [onChange, index, setIsCheckboxEnabled], [checkingDisabled]);
  return /*#__PURE__*/react.createElement(Checkbox_Checkbox, {
    title: (0,react_facet_src.useFacetMap)(data => data.message, [], [data]),
    description: (0,react_facet_src.useFacetMap)(data => data.author, [], [data]),
    gamepad: gamepad,
    value: isCheckboxEnabled,
    onChange: changeHandler,
    disabled: (0,react_facet_src.useFacetMap)(data => !data.isAuthorBeingReported, [], [data])
  });
}

const useOnChangeChatMessageCheckbox = (selectedMessagesFacet, setSelectedMessagesFacet) => {
  return (0,react_facet_src.useFacetCallback)(facet => (index, value) => {
    setSelectedMessagesFacet(() => {
      const updated = [...facet];

      if (value) {
        if (updated.length < MAX_SELECTED_CHAT_MESSAGES) {
          updated.push(index);
        }
      } else {
        const idx = updated.findIndex(value => value == index);

        if (idx > -1) {
          updated.splice(idx, 1);
        }
      }

      return updated;
    });
  }, [setSelectedMessagesFacet], [selectedMessagesFacet]);
};
function ChatSelection({
  chatMessages,
  selectedMessages,
  onConfirm,
  setSelectedMessagesFacet
}) {
  const {
    t
  } = useLocalization('ReportPlayerRoute');
  const dataFacet = (0,react_facet_src.useFacetWrap)(chatMessages);
  const selectedMessagesFacet = (0,react_facet_src.useFacetWrap)(selectedMessages);
  const onChange = useOnChangeChatMessageCheckbox(selectedMessagesFacet, setSelectedMessagesFacet);
  const isSelectedChatMessagesFull = (0,react_facet_src.useFacetMap)(selectedChatMessages => selectedChatMessages.length >= MAX_SELECTED_CHAT_MESSAGES, [], [selectedMessagesFacet]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isSelectedChatMessagesFull
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.chatSelectionLimitReached')
  }, t('.chatSelectionLimitReached'))), /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 1,
    darkTheme: true
  }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: dataFacet
  }, (chatMessage, index) => /*#__PURE__*/react.createElement(MessageCheckbox, {
    index: index,
    gamepad: {
      index: index
    },
    data: chatMessage,
    onChange: onChange,
    checkingDisabled: isSelectedChatMessagesFull
  })))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 2,
    autofocus: true,
    inputLegend: t('.confirmSelection'),
    variant: "primary",
    delayedClick: true,
    onClick: onConfirm
  }, t('.confirmSelection'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ReportPlayerRoute/ReportConfirmation.tsx



function ReportConfirmation({
  onConfirm
}) {
  const {
    t
  } = useLocalization('ReportPlayerRoute');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    scrollable: false
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.reportConfirmation')
  }, t('.reportConfirmation')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    autofocus: true,
    inputLegend: t('.next'),
    variant: "primary",
    delayedClick: true,
    onClick: onConfirm
  }, t('.next'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ReportPlayerRoute/ReportPlayerRoute.tsx










var ReportPlayerModalState;

(function (ReportPlayerModalState) {
  ReportPlayerModalState[ReportPlayerModalState["ReportAreaInput"] = 0] = "ReportAreaInput";
  ReportPlayerModalState[ReportPlayerModalState["ChatSelection"] = 1] = "ChatSelection";
  ReportPlayerModalState[ReportPlayerModalState["ReportReasonInputAndSubmission"] = 2] = "ReportReasonInputAndSubmission";
  ReportPlayerModalState[ReportPlayerModalState["WaitingForReportResponse"] = 3] = "WaitingForReportResponse";
  ReportPlayerModalState[ReportPlayerModalState["ReportComplete"] = 4] = "ReportComplete";
})(ReportPlayerModalState || (ReportPlayerModalState = {}));

const ReportPlayerRoute = () => {
  var _params$get, _params$get2, _params$get3;

  const {
    t
  } = useLocalization('ReportPlayerRoute');
  const historyAPI = RouteHistory_useRouteHistory(); // Query parameters

  const params = useRouteQuery();
  const gamertag = (_params$get = params.get('gamertag')) !== null && _params$get !== void 0 ? _params$get : t('.unknownGamertag');
  const xuid = (_params$get2 = params.get('xuid')) !== null && _params$get2 !== void 0 ? _params$get2 : '0';
  const uuid = (_params$get3 = params.get('uuid')) !== null && _params$get3 !== void 0 ? _params$get3 : '0'; // State

  const [reportStateFacet, setReportStateFacet] = (0,react_facet_src.useFacetState)(ReportPlayerModalState.ReportAreaInput);
  const [reportAreaFacet, setReportAreaFacet] = (0,react_facet_src.useFacetState)(-1);
  const [reportReasonFacet, setReportReasonFacet] = (0,react_facet_src.useFacetState)(-1);
  const [reportMessageFacet, setReportMessageFacet] = (0,react_facet_src.useFacetState)('');
  const selectedMessages = [];
  const [selectedMessagesFacet, setSelectedMessagesFacet] = (0,react_facet_src.useFacetState)(selectedMessages);
  const reportableChatMessagesFacet = (0,react_facet_src.sharedSelector)(reportFacet => reportFacet.reportableChatMessages, [playerReportFacet]);
  const isChatSelectionAvailableFacet = (0,react_facet_src.sharedSelector)(reportFacet => reportFacet.isChatAvailable(), [playerReportFacet]);
  const isReportAreaInputVisibleFacet = (0,react_facet_src.useFacetMap)(reportState => reportState === ReportPlayerModalState.ReportAreaInput, [], [reportStateFacet]);
  const isReportAreaInvalidFacet = (0,react_facet_src.useFacetMap)(reportArea => reportArea == -1, [], [reportAreaFacet]);
  const isReportReasonInputVisibleFacet = (0,react_facet_src.useFacetMap)(reportState => reportState === ReportPlayerModalState.ReportReasonInputAndSubmission, [], [reportStateFacet]);
  const isReportReasonInvalidFacet = (0,react_facet_src.useFacetMap)(reportReason => reportReason == -1, [], [reportReasonFacet]);
  const isChatSelectionVisibleFacet = (0,react_facet_src.useFacetMap)(reportState => reportState === ReportPlayerModalState.ChatSelection, [], [reportStateFacet]);
  const isReportConfirmationVisibleFacet = (0,react_facet_src.useFacetMap)(reportState => reportState === ReportPlayerModalState.ReportComplete, [], [reportStateFacet]); // Callbacks

  const reportPlayer = (0,react_facet_src.useFacetCallback)((facet, reportArea, reportReason, reportMessage, selectedChatMessages) => () => {
    facet.reportArea = reportArea;
    facet.reportReason = reportReason;
    facet.reportMessage = reportMessage;
    facet.selectedChatMessages = selectedChatMessages;
    facet.xuid = xuid;
    facet.uuid = uuid;
    facet.reportPlayer();
  }, [xuid, uuid], [(0,react_facet_src.useSharedFacet)(playerReportFacet), reportAreaFacet, reportReasonFacet, reportMessageFacet, selectedMessagesFacet]);
  const onConfirmReportArea = (0,react_facet_src.useFacetCallback)((isChatSelectionAvailable, reportArea) => () => {
    if (isChatSelectionAvailable && reportArea == 0) {
      setReportStateFacet(ReportPlayerModalState.ChatSelection);
    } else {
      setReportStateFacet(ReportPlayerModalState.ReportReasonInputAndSubmission);
    }
  }, [setReportStateFacet], [(0,react_facet_src.useSharedFacet)(isChatSelectionAvailableFacet), reportAreaFacet]);

  const onConfirmChatSelection = () => {
    setReportStateFacet(ReportPlayerModalState.ReportReasonInputAndSubmission);
  };

  const onClose = () => {
    historyAPI.goBack();
  };

  const sendReportAndGoToConfirmation = () => {
    reportPlayer();
    setReportStateFacet(ReportPlayerModalState.ReportComplete);
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.title', [gamertag])), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isReportAreaInputVisibleFacet
  }, /*#__PURE__*/react.createElement(AreaInput, {
    reportArea: reportAreaFacet,
    onChangeReportArea: setReportAreaFacet,
    onConfirm: onConfirmReportArea,
    isSubmitDisabled: isReportAreaInvalidFacet
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isChatSelectionVisibleFacet
  }, /*#__PURE__*/react.createElement(ChatSelection, {
    chatMessages: (0,react_facet_src.useSharedFacet)(reportableChatMessagesFacet),
    selectedMessages: selectedMessagesFacet,
    onConfirm: onConfirmChatSelection,
    setSelectedMessagesFacet: setSelectedMessagesFacet
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isReportReasonInputVisibleFacet
  }, /*#__PURE__*/react.createElement(ReasonInputAndSubmission, {
    gamertag: gamertag,
    reportReason: reportReasonFacet,
    onChangeReportReason: setReportReasonFacet,
    onClickSendReport: sendReportAndGoToConfirmation,
    onChangeReportMessage: setReportMessageFacet,
    isSubmitDisabled: isReportReasonInvalidFacet
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isReportConfirmationVisibleFacet
  }, /*#__PURE__*/react.createElement(ReportConfirmation, {
    onConfirm: onClose
  })));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ReportPlayerRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAchievementsRoute/SignInAchievementsRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SignInAchievementsRoute = ({"mainImage":"Ux__y"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAchievementsRoute/images/Sign-in_Prompts_Achievements.png
const Sign_in_Prompts_Achievements_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Achievements-f878d.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAchievementsRoute/images/Sign-in_Prompts_Achievements Animated.gif
const Sign_in_Prompts_Achievements_Animated_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Achievements Animated-06cb0.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAchievementsRoute/SignInAchievementsRoute.tsx













function SignInAchievementsRoute_SignInAchievementsRoute() {
  const historyAPI = RouteHistory_useRouteHistory();
  const {
    t
  } = useLocalization('SignInAchievementsRoute');
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const signInList = (0,react_facet_src.useFacetWrap)([t('.signInList1'), t('.signInList2'), t('.signInList3')]); //decide whether to show the animated version of the art

  const disableAchievementsAnimatedFlag = useFeatureFlag(DISABLE_ANIMATED_SIGN_IN_SCREENS);
  const isScreenAnimationEnabled = useScreenAnimationEnabled(); //to display the animated version, the user must have animation enabled and the feature flag must be active

  const isAnimationEnabled = (0,react_facet_src.useFacetMap)(isScreenAnimationEnabled => isScreenAnimationEnabled && !disableAchievementsAnimatedFlag, [disableAchievementsAnimatedFlag], [isScreenAnimationEnabled]); //set the image based on the above

  const MainImage = (0,react_facet_src.useFacetMap)(isAnimationEnabled => isAnimationEnabled ? Sign_in_Prompts_Achievements_Animated_namespaceObject : Sign_in_Prompts_Achievements_namespaceObject, [], [isAnimationEnabled]);
  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    historyAPI.replace('/achievements');
    user.showMicrosoftAccountLogInScreen(PostSignInAction.DO_NOTHING);
  }, [historyAPI], [userAccount]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'signInAchievementsButton'
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: historyAPI.goBack
  }, t('.signInHeader')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: MainImage,
    className: SignInAchievementsRoute.mainImage,
    imageRendering: 'pixelated'
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.signInPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "left"
  }, t('.signInPrompt'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: signInList,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.laterButton'),
    variant: "secondary",
    onClick: historyAPI.goBack,
    horizontal: true
  }, t('.laterButton')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: 'signInAchievementsButton',
    autofocus: true,
    inputLegend: t('.signInButton'),
    variant: "primary",
    onClick: signIn,
    horizontal: true
  }, t('.signInButton'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAchievementsRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAddFriendRoute/SignInAddFriendRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SignInAddFriendRoute = ({"mainImage":"MedW5"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAddFriendRoute/images/Sign-in_Prompts_Friends.png
const Sign_in_Prompts_Friends_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Friends-24f5f.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAddFriendRoute/images/Sign-in_Prompts_Friends Animated.gif
const Sign_in_Prompts_Friends_Animated_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Friends Animated-0c355.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAddFriendRoute/SignInAddFriendRoute.tsx














function SignInAddFriendRoute_SignInAddFriendRoute() {
  const historyAPI = RouteHistory_useRouteHistory();
  const {
    t
  } = useLocalization('SignInAddFriendRoute'); //set up all facets

  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const deviceInfo = (0,react_facet_src.useSharedFacet)(deviceInformationFacet); //decide whether to show the animated version of the art

  const disableFriendsAnimatedFlag = useFeatureFlag(DISABLE_ANIMATED_SIGN_IN_SCREENS);
  const isScreenAnimationEnabled = useScreenAnimationEnabled(); //to display the animated version, the user must have animation enabled and the feature flag must be active

  const isAnimationEnabled = (0,react_facet_src.useFacetMap)(isScreenAnimationEnabled => isScreenAnimationEnabled && !disableFriendsAnimatedFlag, [disableFriendsAnimatedFlag], [isScreenAnimationEnabled]); //set the image based on the above

  const MainImage = (0,react_facet_src.useFacetMap)(isAnimationEnabled => isAnimationEnabled ? Sign_in_Prompts_Friends_Animated_namespaceObject : Sign_in_Prompts_Friends_namespaceObject, [], [isAnimationEnabled]); //return the correct version of the list based on platform

  const signInList = (0,react_facet_src.useFacetMap)(device => {
    if (device.platform == Platform.PS4 || device.platform == Platform.PS5 || device.platform == Platform.NX_HANDHELD || device.platform == Platform.NX_TV) {
      return [t('.signInList1NXPS'), t('.signInList3')];
    } else {
      //all platforms other than PS and Switch should use this
      return [t('.signInList1'), t('.signInList2'), t('.signInList3')];
    }
  }, [t], [deviceInfo]); //call the sign in screen when the button is pressed

  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    historyAPI.goBack();
    user.showMicrosoftAccountLogInScreen(PostSignInAction.DO_NOTHING);
  }, [historyAPI], [userAccount]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'signInAddFriendButton'
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: historyAPI.goBack
  }, t('.signInHeader')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: MainImage,
    className: SignInAddFriendRoute.mainImage,
    imageRendering: 'pixelated'
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.signInPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "left"
  }, t('.signInPrompt'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: signInList,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.laterButton'),
    variant: "secondary",
    onClick: historyAPI.goBack,
    horizontal: true
  }, t('.laterButton')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: 'signInAddFriendButton',
    autofocus: true,
    inputLegend: t('.signInButton'),
    variant: "primary",
    onClick: signIn,
    horizontal: true
  }, t('.signInButton'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAddFriendRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInPlayOnServerRoute/SignInPlayOnServerRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SignInPlayOnServerRoute = ({"mainImage":"nKl10"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInPlayOnServerRoute/images/Sign-in_Prompts_Servers.png
const Sign_in_Prompts_Servers_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Servers-327ad.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInPlayOnServerRoute/images/Sign-in_Prompts_Servers Animated.gif
const Sign_in_Prompts_Servers_Animated_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Servers Animated-ab246.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInPlayOnServerRoute/SignInPlayOnServerRoute.tsx













function SignInPlayOnServerRoute_SignInPlayOnServerRoute() {
  const historyAPI = RouteHistory_useRouteHistory();
  const {
    t
  } = useLocalization('SignInPlayOnServerRoute');
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const signInList = (0,react_facet_src.useFacetWrap)([t('.signInList1'), t('.signInList2'), t('.signInList3')]); //decide whether to show the animated version of the art

  const disableServerAnimatedFlag = useFeatureFlag(DISABLE_ANIMATED_SIGN_IN_SCREENS);
  const isScreenAnimationEnabled = useScreenAnimationEnabled(); //to display the animated version, the user must have animation enabled and the feature flag must be active

  const isAnimationEnabled = (0,react_facet_src.useFacetMap)(isScreenAnimationEnabled => isScreenAnimationEnabled && !disableServerAnimatedFlag, [disableServerAnimatedFlag], [isScreenAnimationEnabled]); //set the image based on the above

  const MainImage = (0,react_facet_src.useFacetMap)(isAnimationEnabled => isAnimationEnabled ? Sign_in_Prompts_Servers_Animated_namespaceObject : Sign_in_Prompts_Servers_namespaceObject, [], [isAnimationEnabled]);
  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    historyAPI.goBack();
    user.showMicrosoftAccountLogInScreen(PostSignInAction.DO_NOTHING);
  }, [historyAPI], [userAccount]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'signInPlayOnServerButton'
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: historyAPI.goBack
  }, t('.signInHeader')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: MainImage,
    className: SignInPlayOnServerRoute.mainImage,
    imageRendering: 'pixelated'
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.signInPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "left"
  }, t('.signInPrompt'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: signInList,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.laterButton'),
    variant: "secondary",
    onClick: historyAPI.goBack,
    horizontal: true
  }, t('.laterButton')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: 'signInPlayOnServerButton',
    autofocus: true,
    inputLegend: t('.signInButton'),
    variant: "primary",
    onClick: signIn,
    horizontal: true
  }, t('.signInButton'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInPlayOnServerRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInSavePurchasesRoute/SignInSavePurchasesRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SignInSavePurchasesRoute = ({"mainImage":"WNtel"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInSavePurchasesRoute/images/Sign-in_Prompts_Save_Purchases.png
const Sign_in_Prompts_Save_Purchases_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Save_Purchases-c428e.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInSavePurchasesRoute/images/Sign-in_Prompts_Save_Purchases Animated.gif
const Sign_in_Prompts_Save_Purchases_Animated_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Save_Purchases Animated-cfb0b.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInSavePurchasesRoute/SignInSavePurchasesRoute.tsx













function SignInSavePurchasesRoute_SignInSavePurchasesRoute() {
  const historyAPI = RouteHistory_useRouteHistory();
  const {
    t
  } = useLocalization('SignInSavePurchasesRoute');
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const signInList = (0,react_facet_src.useFacetWrap)([t('.signInList1'), t('.signInList2'), t('.signInList3')]); //decide whether to show the animated version of the art

  const disablePurchasesAnimatedFlag = useFeatureFlag(DISABLE_ANIMATED_SIGN_IN_SCREENS);
  const isScreenAnimationEnabled = useScreenAnimationEnabled(); //to display the animated version, the user must have animation enabled and the feature flag must be active

  const isAnimationEnabled = (0,react_facet_src.useFacetMap)(isScreenAnimationEnabled => isScreenAnimationEnabled && !disablePurchasesAnimatedFlag, [disablePurchasesAnimatedFlag], [isScreenAnimationEnabled]); //set the image based on the above

  const MainImage = (0,react_facet_src.useFacetMap)(isAnimationEnabled => isAnimationEnabled ? Sign_in_Prompts_Save_Purchases_Animated_namespaceObject : Sign_in_Prompts_Save_Purchases_namespaceObject, [], [isAnimationEnabled]);
  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    historyAPI.goBack();
    user.showMicrosoftAccountLogInScreen(PostSignInAction.SAVE_ENTITLEMENTS);
  }, [historyAPI], [userAccount]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'signInSavePurchasesButton'
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: historyAPI.goBack
  }, t('.signInHeader')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: MainImage,
    className: SignInSavePurchasesRoute.mainImage,
    imageRendering: 'pixelated'
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.signInPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "left"
  }, t('.signInPrompt'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: signInList,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 2,
    narrationText: t('.createAccountPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "left"
  }, t('.createAccountPrompt')))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.laterButton'),
    variant: "secondary",
    onClick: historyAPI.goBack,
    horizontal: true
  }, t('.laterButton')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: 'signInSavePurchasesButton',
    autofocus: true,
    inputLegend: t('.signInButton'),
    variant: "primary",
    onClick: signIn,
    horizontal: true
  }, t('.signInButton'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInSavePurchasesRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/FirstTimeSignInRoute/FirstTimeSignInRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const FirstTimeSignInRoute = ({"mainImage":"ulzxH"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/FirstTimeSignInRoute/images/Sign-in_Prompts_Launch.png
const Sign_in_Prompts_Launch_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Launch-be303.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/FirstTimeSignInRoute/images/Sign-in_Prompts_Launch Animated.gif
const Sign_in_Prompts_Launch_Animated_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Launch Animated-d5ba8.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/FirstTimeSignInRoute/FirstTimeSignInRoute.tsx














function FirstTimeSignInRoute_FirstTimeSignInRoute() {
  const historyAPI = RouteHistory_useRouteHistory();
  const {
    t
  } = useLocalization('FirstTimeSignInRoute'); //set up all facets

  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const deviceInfo = (0,react_facet_src.useSharedFacet)(deviceInformationFacet); //decide whether to show the animated version of the art

  const disableSignInAnimatedFlag = useFeatureFlag(DISABLE_ANIMATED_SIGN_IN_SCREENS);
  const isScreenAnimationEnabled = useScreenAnimationEnabled(); //to display the animated version, the user must have animation enabled and the feature flag must be active

  const isAnimationEnabled = (0,react_facet_src.useFacetMap)(isScreenAnimationEnabled => isScreenAnimationEnabled && !disableSignInAnimatedFlag, [disableSignInAnimatedFlag], [isScreenAnimationEnabled]); //set the image based on the above

  const MainImage = (0,react_facet_src.useFacetMap)(isAnimationEnabled => isAnimationEnabled ? Sign_in_Prompts_Launch_Animated_namespaceObject : Sign_in_Prompts_Launch_namespaceObject, [], [isAnimationEnabled]); //return the correct version of the list based on platform

  const signInList = (0,react_facet_src.useFacetMap)(device => {
    if (consoles_isPlaystationPlatform(device.platform)) {
      return [t('.signInList4'), t('.signInList2PS'), t('.signInList3PS')];
    } else {
      //all platforms other than PS should use this
      return [t('.signInList1'), t('.signInList2'), t('.signInList3'), t('.signInList4')];
    }
  }, [t], [deviceInfo]); //call the sign in screen when the button is pressed

  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    historyAPI.goBack();
    user.showMicrosoftAccountLogInScreen(PostSignInAction.DO_NOTHING);
  }, [historyAPI], [userAccount]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'firstTimeSignInButton'
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: historyAPI.goBack
  }, t('.signInHeader')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: MainImage,
    className: FirstTimeSignInRoute.mainImage,
    imageRendering: 'pixelated'
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.signInPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "left"
  }, t('.signInPrompt'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: signInList,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 2,
    narrationText: t('.createAccountPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionLong",
    align: "left"
  }, t('.createAccountPrompt')))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.laterButton'),
    variant: "secondary",
    onClick: historyAPI.goBack,
    horizontal: true
  }, t('.laterButton')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: 'firstTimeSignInButton',
    autofocus: true,
    inputLegend: t('.signInButton'),
    variant: "primary",
    onClick: signIn,
    horizontal: true
  }, t('.signInButton'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/FirstTimeSignInRoute/index.ts

;// CONCATENATED MODULE: ./packages/ui/src/Modal/ErrorModal.tsx





/**
 * This is a generic error modal that be passed as the errorComponent in the root <Application />
 */
function ErrorModal_ErrorModal({
  errorMessage,
  onDismiss
}) {
  const {
    t
  } = useLocalization('ErrorModal');
  const title = t('.title');
  const goBack = t('.goBack');
  const goingBack = t('.goingBack');
  const content = errorMessage != null && errorMessage !== '' ? errorMessage : goingBack;
  const narration = `${title} . ${content}`;
  const showButtons = content !== goingBack;
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: narration
  }, content)), showButtons && /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "primary",
    onClick: onDismiss,
    gamepadIndex: 0,
    autofocus: true,
    inputLegend: goBack
  }, goBack)));
}
;// CONCATENATED MODULE: ./packages/ui/src/RouteSlideTransition/RouteSlideTransition.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RouteSlideTransition = ({"base":"C84xm","exited":"_rSgg","entered":"JDSRH","left":"kEh2T","entering":"DSGNH","slide-left-in":"EMBuQ","exiting":"uv_vE","slide-left-out":"h0rGc","right":"k0msz","slide-right-in":"DFwIo","slide-right-out":"NE3Mc"});
;// CONCATENATED MODULE: ./packages/ui/src/RouteSlideTransition/RouteSlideTransition.tsx








function RouteSlideTransition_RouteSlideTransition({
  visible,
  unmountOnExit,
  contentComponent,
  inverse,
  renderTracker,
  defaultFocusedChildAlias,
  defaultFocusedChildBehavior
}) {
  const Content = (0,react.useMemo)(() => react.memo(contentComponent), [contentComponent]);
  const recalculateSizes = useOnComponentResizeForceRecalculate();
  const ref = (0,react.useRef)(null);
  const hiddenFacet = (0,react_facet_src.useFacetWrap)(!visible);
  return /*#__PURE__*/react.createElement(TransitionPrimitive, {
    visible: visible,
    inverse: inverse,
    appear: true,
    unmountOnExit: unmountOnExit,
    timeout: 400
  }, (status, inverse) => {
    const paused = status !== 'entered';
    recalculateSizes();
    return /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
      scrollRef: ref,
      gamepadIndex: 0,
      disabled: !visible,
      defaultFocusedChildAlias: defaultFocusedChildAlias,
      defaultFocusedChildBehavior: defaultFocusedChildBehavior
    }, /*#__PURE__*/react.createElement("div", {
      ref: ref,
      className: classnames_default()(RouteSlideTransition.base, {
        [RouteSlideTransition.left]: !inverse,
        [RouteSlideTransition.right]: inverse,
        [RouteSlideTransition.entered]: status === 'entered',
        [RouteSlideTransition.entering]: status === 'entering',
        [RouteSlideTransition.exiting]: status === 'exiting',
        [RouteSlideTransition.exited]: status === 'exited'
      })
    }, /*#__PURE__*/react.createElement(dist.PauseMountProvider, {
      paused: paused
    }, renderTracker && renderTracker(status === 'entered'), /*#__PURE__*/react.createElement(Content, {
      hidden: hiddenFacet
    }))));
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/videos/video_crosshair.webm
const video_crosshair_namespaceObject = __webpack_require__.p + "assets/video_crosshair-c6f01.webm";
;// CONCATENATED MODULE: ./games/vanilla/main/src/videos/video_touch.webm
const video_touch_namespaceObject = __webpack_require__.p + "assets/video_touch-181aa.webm";
;// CONCATENATED MODULE: ./games/vanilla/main/src/videos/video_classic.webm
const video_classic_namespaceObject = __webpack_require__.p + "assets/video_classic-164db.webm";
;// CONCATENATED MODULE: ./packages/ui/src/RadioGroup/RadioBox.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RadioBox = ({"wrapper":"C9Ox8","wrapperDisabled":"chklf","RadioBox":"UYLxr","innerBox":"mNihg","innerBoxTileLeft":"Rugdi","innerBoxTileRight":"TG2vJ","RadioBoxCheckedDisabled":"OGJXs","label":"aS_mB","labelInner":"T4t4A"});
// EXTERNAL MODULE: ./node_modules/@react-facet/core/dist/index.js
var core_dist = __webpack_require__(88572);
;// CONCATENATED MODULE: ./packages/ui/src/RadioGroup/RadioBox.tsx









function RadioBox_RadioBox({
  onClick,
  gamepad,
  checked,
  label,
  description,
  disabled,
  extraSpeechProps: {
    index,
    groupSize
  } = {
    index: 1,
    groupSize: 1
  },
  onFocusChanged,
  omitDescription = false,
  readDescription = false,
  checkedRole = 'primary',
  uncheckedRole = 'neutral50',
  textRole = 'neutral',
  soundEffectPressed
}) {
  const {
    t
  } = useLocalization('RadioBox');
  const checkedFacet = (0,core_dist.useFacetWrap)(checked);
  const {
    color: {
      [textRole]: semanticClassNamesText,
      [checkedRole]: semanticClassNamesChecked,
      [uncheckedRole]: semanticClassNamesUnchecked
    },
    sound,
    variant
  } = useSemanticTokens();
  const narrationText = (0,core_dist.useFacetMap)(checked => [...(label != null ? [label] : []), checked ? t('.selected') : '', checked && readDescription && description != null ? description + '. ' : '', disabled ? t('.disabled') : '', t('.count', [`${index + 1}`, `${groupSize}`])].join(' . '), [readDescription, description, label, index, groupSize, disabled, t], [checkedFacet]);
  const box = (0,core_dist.useFacetMap)(checked => {
    var _semanticClassNamesCh, _semanticClassNamesCh2, _semanticClassNamesUn, _semanticClassNamesUn2;

    return classnames_default()(RadioBox.RadioBox, {
      [(_semanticClassNamesCh = semanticClassNamesChecked.background.interactive) !== null && _semanticClassNamesCh !== void 0 ? _semanticClassNamesCh : '']: checked,
      [(_semanticClassNamesCh2 = semanticClassNamesChecked.border.interactive) !== null && _semanticClassNamesCh2 !== void 0 ? _semanticClassNamesCh2 : '']: checked,
      [(_semanticClassNamesUn = semanticClassNamesUnchecked.background.interactive) !== null && _semanticClassNamesUn !== void 0 ? _semanticClassNamesUn : '']: !checked,
      [(_semanticClassNamesUn2 = semanticClassNamesUnchecked.border.interactive) !== null && _semanticClassNamesUn2 !== void 0 ? _semanticClassNamesUn2 : '']: !checked
    });
  }, [semanticClassNamesChecked, semanticClassNamesUnchecked], [checkedFacet]);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    className: RadioBox.wrapper,
    classNameFocused: classnames_default()(RadioBox.focused, focusClass),
    classNameDisabled: RadioBox.wrapperDisabled,
    narrationText: narrationText,
    onClick: onClick,
    onFocusChanged: onFocusChanged,
    inputLegend: false,
    disabled: disabled,
    gamepadIndex: gamepad.index,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : sound.inherit.toggle
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: box
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular"
  }), /*#__PURE__*/react.createElement(core_dist.Mount, {
    when: checkedFacet
  }, /*#__PURE__*/react.createElement("div", {
    className: RadioBox.innerBox
  }, /*#__PURE__*/react.createElement("div", {
    className: RadioBox.innerBoxTileLeft
  }), /*#__PURE__*/react.createElement("div", {
    className: RadioBox.innerBoxTileRight
  })))), Boolean(label) && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(RadioBox.label, semanticClassNamesText.text.base)
  }, Boolean(!omitDescription) && Boolean(description) && /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: 'inherit'
  }, label), Boolean(!omitDescription) && Boolean(description) && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(semanticClassNamesText.text.base, variant.dimmer)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: 'inherit'
  }, /*#__PURE__*/react.createElement("div", {
    className: RadioBox.labelInner
  }, description)), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }))));
}
;// CONCATENATED MODULE: ./packages/ui/src/RadioGroup/RadioGroup.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RadioGroup = ({"wrapper":"d41i7","header":"dTZYj"});
;// CONCATENATED MODULE: ./packages/ui/src/RadioGroup/RadioGroup.tsx
function RadioGroup_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function RadioGroup_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { RadioGroup_ownKeys(Object(source), true).forEach(function (key) { RadioGroup_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { RadioGroup_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function RadioGroup_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









let RadioGroup_id = 0;

const RadioGroup_noop = () => {};

function RadioGroup_RadioGroup({
  gamepad,
  options,
  title,
  onChange = RadioGroup_noop,
  value: selectedValue,
  disabled = false,
  disabledValues,
  onFocusChanged,
  checkedRole,
  uncheckedRole,
  wrapperRole = 'neutral',
  soundEffectPressed
}) {
  const wrappingRef = (0,react.useRef)(null);
  const {
    color: {
      [wrapperRole]: semanticClassNames
    },
    sound: {
      [wrapperRole]: semanticSound
    }
  } = useSemanticTokens();
  const index = options.findIndex(option => {
    return option.value === selectedValue;
  });

  if (index === -1) {
    console.warn('The provided default value does not match any of the provided options. This means that no option is selected, which is a broken state for RadioGroup.');
  }

  const focusAlias = (0,react.useRef)(`MCT-${RadioGroup_id++}`);
  return /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: wrapperRole
  }, /*#__PURE__*/react.createElement(Column, {
    options: RadioGroup_objectSpread(RadioGroup_objectSpread({
      index: 0
    }, gamepad), {}, {
      defaultFocusedChildBehavior: 'remember',
      disabled: disabled,
      defaultFocusedChildAlias: focusAlias.current
    }),
    scrollRef: wrappingRef
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(RadioGroup.wrapper, semanticClassNames.background.base)
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular",
    thin: true,
    left: false,
    right: false,
    bottom: false
  }), title != null && title != '' && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: `${RadioGroup.header} ${semanticClassNames.text.base}`
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: 'inherit'
  }, title))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), options.map((option, index) => {
    return /*#__PURE__*/react.createElement(RadioBox_RadioBox, {
      disabled: disabled || disabledValues && disabledValues.indexOf(option.value) > -1 ? true : false,
      key: index,
      label: option.label,
      description: option.description,
      omitDescription: option.omitDescription,
      readDescription: option.readDescription,
      gamepad: {
        index: index
      },
      checked: option.value === selectedValue,
      onClick: () => {
        if (selectedValue !== option.value) onChange(option.value);
      },
      extraSpeechProps: {
        index,
        groupSize: options.length
      },
      onFocusChanged: onFocusChanged,
      checkedRole: checkedRole,
      uncheckedRole: uncheckedRole,
      textRole: wrapperRole,
      soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSound.toggle
    });
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/TouchControlSelectionRoute/TouchControlSelection.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const TouchControlSelection = ({"borderedContainer":"vzhv1","information":"c_o_5","spinnerContainer":"hmYnU","loadingImageSpinnerOuter":"SmsRy","loadingImageSpinnerInner":"RBMB_"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/TouchControlSelectionRoute/TouchControlSelection.tsx















function TouchControlSelection_TouchControlSelection({
  startWorld
}) {
  const VIDEO_ASPECT_RATIO = 0.48;
  const [videoContainerHeight, setVideoContainerHeight] = (0,react_facet_src.useFacetState)('0px');
  const videoContainerRef = (0,react.useRef)(null);
  const history = RouteHistory_useRouteHistory();
  const {
    t
  } = useLocalization('TouchControlSelectionRoute');
  const options = (0,react_facet_src.useSharedFacet)(optionsFacet);
  const [selected, setSelected] = (0,react.useState)(TouchControlSchemeEnum.CLASSIC);
  const createNewWorldFacetLocal = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const goBack = (0,react_facet_src.useFacetCallback)(world => () => {
    world.inWorldCreation = false;
    history.goBack();
  }, [history], [createNewWorldFacetLocal]);
  const onSelectControlScheme = (0,react_facet_src.useFacetCallback)(options => () => {
    options.touchControlScheme = selected;
    options.showTouchControlSelectionScreen = false;
    startWorld();
  }, [selected, startWorld], [options]);
  const {
    color
  } = useSemanticTokens();
  const touchId = 'touch';
  const classicId = 'classic';
  const crosshairId = 'crosshair';
  const videoRefTouch = (0,react.useRef)(null);
  const videoRefClassic = (0,react.useRef)(null);
  const videoRefCrosshair = (0,react.useRef)(null);
  const videoRefs = (0,react.useMemo)(() => [videoRefTouch, videoRefCrosshair, videoRefClassic], []);
  const playVideoWithString = (0,react_facet_src.useFacetCallback)(options => stringId => {
    let id = TouchControlSchemeEnum.TOUCH;

    if (stringId == classicId) {
      id = TouchControlSchemeEnum.CLASSIC;
    } else if (stringId == crosshairId) {
      id = TouchControlSchemeEnum.CROSSHAIR;
    }

    if (options.playVideoInTouchControlSelectionScreen) {
      for (let i = TouchControlSchemeEnum.TOUCH; i <= TouchControlSchemeEnum.CLASSIC; ++i) {
        const videoRef = videoRefs[i].current;

        if (i == id) {
          if (videoRef != null) {
            videoRef.currentTime = 0;
            videoRef.play();
          }
        } else {
          videoRef === null || videoRef === void 0 ? void 0 : videoRef.pause();
        }
      }
    }

    setSelected(id);
  }, [videoRefs], [options]);
  (0,react_facet_src.useFacetEffect)(options => {
    switch (options.touchControlScheme) {
      case TouchControlSchemeEnum.CLASSIC:
        {
          playVideoWithString(classicId);
          break;
        }

      case TouchControlSchemeEnum.TOUCH:
        {
          playVideoWithString(touchId);
          break;
        }

      case TouchControlSchemeEnum.CROSSHAIR:
        {
          playVideoWithString(crosshairId);
          break;
        }

      default:
    }
  }, [playVideoWithString], [options]);
  const resize = (0,react.useCallback)(() => {
    if (videoContainerRef.current) {
      const {
        width
      } = videoContainerRef.current.getBoundingClientRect();

      if (width > 0) {
        setVideoContainerHeight(width * VIDEO_ASPECT_RATIO + 'px');
      } else {
        requestAnimationFrame(resize);
      }
    }
  }, [setVideoContainerHeight]);
  (0,react.useEffect)(() => {
    resize();
    window.addEventListener('resize', resize);
    return () => window.removeEventListener('resize', resize);
  }, [resize]);

  function videoWidth(id) {
    return selected == id ? '100%' : '0px';
  }

  function videoHeight(id) {
    return selected == id ? '100%' : '0px';
  }

  const introNarration = [t('.header') + '. ', t('.title') + '. ', (selected == TouchControlSchemeEnum.CLASSIC ? t('.classicLabel') : selected == TouchControlSchemeEnum.TOUCH ? t('.touchLabel') : t('.crosshairLabel')) + '. ', t('.selected') + '. ', selected == TouchControlSchemeEnum.CLASSIC ? t('.classicInfo') : selected == TouchControlSchemeEnum.TOUCH ? t('.touchInfo') : t('.crosshairInfo')].join(' . ');
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(Narration, {
    text: introNarration
  }), /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout, {
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: goBack
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography, {
      variant: "header5A",
      color: "black"
    }, t('.header'))
  }, /*#__PURE__*/react.createElement(Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 8,
    narrowSize: 4
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: TouchControlSelection.borderedContainer
  }, /*#__PURE__*/react.createElement("fast-div", {
    ref: videoContainerRef,
    style: {
      height: videoContainerHeight
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(TouchControlSelection.spinnerContainer, color['neutral80'].background.base)
  }, /*#__PURE__*/react.createElement("div", {
    className: TouchControlSelection.loadingImageSpinnerOuter
  }, /*#__PURE__*/react.createElement("div", {
    className: TouchControlSelection.loadingImageSpinnerInner
  }, /*#__PURE__*/react.createElement(Spinner_Spinner, null)))), /*#__PURE__*/react.createElement("video", {
    ref: videoRefs[TouchControlSchemeEnum.CLASSIC],
    style: {
      width: videoWidth(TouchControlSchemeEnum.CLASSIC),
      height: videoHeight(TouchControlSchemeEnum.CLASSIC),
      position: 'absolute'
    },
    src: video_classic_namespaceObject,
    loop: true
  }), /*#__PURE__*/react.createElement("video", {
    ref: videoRefs[TouchControlSchemeEnum.CROSSHAIR],
    style: {
      width: videoWidth(TouchControlSchemeEnum.CROSSHAIR),
      height: videoHeight(TouchControlSchemeEnum.CROSSHAIR),
      position: 'absolute'
    },
    src: video_crosshair_namespaceObject,
    loop: true
  }), /*#__PURE__*/react.createElement("video", {
    ref: videoRefs[TouchControlSchemeEnum.TOUCH],
    style: {
      width: videoWidth(TouchControlSchemeEnum.TOUCH),
      height: videoHeight(TouchControlSchemeEnum.TOUCH),
      position: 'absolute'
    },
    src: video_touch_namespaceObject,
    loop: true
  })), /*#__PURE__*/react.createElement("div", {
    className: TouchControlSelection.information
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "white"
  }, selected == TouchControlSchemeEnum.CLASSIC ? t('.classicInfo') : selected == TouchControlSchemeEnum.TOUCH ? t('.touchInfo') : t('.crosshairInfo')))))), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 4,
    narrowSize: 4
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView, {
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: TouchControlSelection.borderedContainer
  }, /*#__PURE__*/react.createElement(RadioGroup_RadioGroup, {
    title: t('.title'),
    gamepad: {
      index: 0
    },
    options: [{
      label: t('.touchLabel'),
      value: touchId,
      description: t('.touchInfo'),
      omitDescription: true,
      readDescription: true
    }, {
      label: t('.classicLabel'),
      value: classicId,
      description: t('.classicInfo'),
      omitDescription: true,
      readDescription: true
    }, {
      label: t('.crosshairLabel'),
      value: crosshairId,
      description: t('.crosshairInfo'),
      omitDescription: true,
      readDescription: true
    }],
    onChange: test => playVideoWithString(test),
    value: selected == TouchControlSchemeEnum.CLASSIC ? classicId : selected == TouchControlSchemeEnum.TOUCH ? touchId : crosshairId
  })), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "hero",
    gamepadIndex: 1,
    onClick: onSelectControlScheme,
    inputLegend: t('.select'),
    autofocus: true,
    narrationSuffix: selected == TouchControlSchemeEnum.CLASSIC ? t('.classicLabel') : selected == TouchControlSchemeEnum.TOUCH ? t('.touchLabel') : t('.crosshairLabel')
  }, t('.select'))))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/TouchControlSelectionRoute/TouchControlSelectionRoute.tsx




 // this is the original implementation of /touch-control-selection that relies
// on a hack for world startup

function TouchControlSelectionRoute() {
  const history = RouteHistory_useRouteHistory();
  const startWorld = (0,react_facet_src.useFacetCallback)((world, telemetry) => () => {
    if (world.inWorldCreation) {
      world.inWorldCreation = false;
      telemetry.fireEventButtonPressed('Create_World_Button_OreUI', {});
      world.createWorld.call();
    } else {
      // this relies on the previous screen (edit world screen or play screen)
      // to check flags in its screen controller to handle the world startup
      history.goBack();
    }
  }, [history], [(0,react_facet_src.useSharedFacet)(createNewWorldFacet), (0,react_facet_src.useSharedFacet)(telemetryFacet)]);
  return /*#__PURE__*/react.createElement(TouchControlSelection_TouchControlSelection, {
    startWorld: startWorld
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/TouchControlSelectionRoute/WorldStartupTouchControlSelectionRoute.tsx




 // this a second version of /touch-control-selection that will start the world
// via the WorldStartupFacet when the player presses the "select" button

function WorldStartupTouchControlSelectionRoute() {
  const params = useRouteParams();
  const startWorld = (0,react_facet_src.useFacetCallback)(worldStartup => () => {
    worldStartup.startLocalWorld.run(decodeURIComponent(params.id));
  }, [params], [(0,react_facet_src.useSharedFacet)(worldStartupFacet_worldStartupFacet)]);
  return /*#__PURE__*/react.createElement(TouchControlSelection_TouchControlSelection, {
    startWorld: startWorld
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/TouchControlSelectionRoute/index.ts


;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/TabType.tsx
const realmsStoriesTabValues = ['home', 'members', 'timeline'];
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/TabWrapper/TabTypes.tsx
const createNewWorldTabValues = ['general', 'resource-packs', 'cheats', 'experimental', 'multiplayer', 'advanced', 'behavior-packs', 'debug'];
const EditWorldTabValues = (/* unused pure expression or super */ null && (['general', 'advanced', 'multiplayer', 'cheats', 'resource-packs', 'behavior-packs', 'experiments']));
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoryCommentsRoute/RealmsStoryCommentsRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmsStoryCommentsRoute = ({"realmsBackground":"DXmdf"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoryCommentsRoute/images/enderman-holding-dirt.png
const enderman_holding_dirt_namespaceObject = __webpack_require__.p + "assets/enderman-holding-dirt-21d77.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsStoriesErrorModal/RealmsStoriesErrorModal.tsx




const DEFAULT_FOCUS_ALIAS = 'realms-error-modal-cont-btn';
function RealmsStoriesErrorModal({
  isVisible,
  onClose,
  variant = 'default'
}) {
  const {
    t
  } = useLocalization('RealmsStories.errorModal');
  let messageBody = '';

  switch (variant) {
    case 'comment-post':
      messageBody = t('.commentPostFailedMessage');
      break;

    case 'story-post':
      messageBody = t('.storyPostFailedMessage');
      break;

    case 'default':
    default:
      messageBody = t('.defaultErrorMessage');
      break;
  }

  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isVisible
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.header')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: false
  }, messageBody)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.continue'),
    onClick: onClose,
    horizontal: true
  }, t('.continue')))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmSideStoryPost/RealmSideStoryPost.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmSideStoryPost = ({"newBadge":"nOjn9","image":"Ha3NE"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmSideStoryPost/RealmSideStoryPost.tsx










const RealmSideStoryPost_hasImage = realmStory => realmStory.image !== '' || realmStory.fetchImage.state === AsyncStatefulFunctionState.InProgress;

function RealmSideStoryPost_RealmSideStoryPost({
  onWriteStoryClick,
  realmStory
}) {
  const {
    t
  } = useLocalization('RealmsStories');
  const {
    t: tc
  } = useLocalization('RealmsStoryCommentsRoute');
  const hasStoryImage = (0,react_facet_src.useFacetMap)(realmStory => RealmSideStoryPost_hasImage(realmStory), [], [realmStory]);
  const storyImageURLstring = (0,react_facet_src.useFacetMap)(realmStory => RealmSideStoryPost_hasImage(realmStory) ? `url(${realmStory.image})` : '', [], [realmStory]);
  const storyBody = (0,react_facet_src.useFacetMap)(facet => facet.body, [], [realmStory]);
  const postedDate = (0,react_facet_src.useFacetMap)(facet => facet.timePosted, [], [realmStory]);
  const postAuthor = (0,react_facet_src.useFacetMap)(facet => t('.byline', [facet.author.gamerTag]), [t], [realmStory]);
  const isNewStoryPost = (0,react_facet_src.useFacetMap)(facet => !facet.hasViewed, [], [realmStory]);
  const {
    color: {
      ['neutral']: neutralColors,
      ['primary']: primaryColors
    },
    variant
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(SideMenu_SideMenu, {
    gamepadIndex: 1,
    role: "neutral80"
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasStoryImage
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement("fast-div", {
    className: classnames_default()(RealmSideStoryPost.image, neutralColors.border.base),
    style: {
      backgroundImage: storyImageURLstring
    }
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isNewStoryPost
  }, /*#__PURE__*/react.createElement("span", {
    className: classnames_default()(RealmSideStoryPost.newBadge, primaryColors.background.base, primaryColors.text.base)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "black"
  }, t('.new'))))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }))), /*#__PURE__*/react.createElement(SideMenu_SideMenu.Item, {
    role: "neutral80"
  }, /*#__PURE__*/react.createElement("span", {
    className: neutralColors.text.base
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit"
  }, postAuthor)), /*#__PURE__*/react.createElement("span", {
    className: classnames_default()(variant.dimmer, neutralColors.text.base)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, postedDate))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement("span", {
    className: neutralColors.text.base
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "paragraphs",
    color: "inherit"
  }, storyBody))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "primary",
    onClick: onWriteStoryClick,
    inputLegend: tc('.writeComment'),
    gamepadIndex: 0
  }, tc('.writeComment'))));
}
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/rewardImages/index.ts
/* global require */


const rewardImages_context = __webpack_require__(14925);

const rewardImages = rewardImages_context.keys().sort(localeCompare).map(fileName => {
  const path = rewardImages_context(fileName);
  return path;
});
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/achievementImages/index.ts
/* global require */


const achievementImages_context = __webpack_require__(65079);

const achievementImages = achievementImages_context.keys().sort(localeCompare).map(fileName => {
  const path = achievementImages_context(fileName);
  return path;
});
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/achievements.ts


 // new Date('December 17, 2018 03:24:00').getTime() / 1000

const date = 1545013440; //2019-02-04T20:34:12.000Z

const dateII = 1549312452; //2018-10-31T19:17:20.000Z

const dateIII = 1545013440; //2018-07-08T01:30:40.000Z

const dateIV = 1531013440; // Not unlocked

const dateV = 0;
const dateSelection = [date, dateII, dateIII, dateIV];
const shouldUseRealisticNames = undefined === 'true';
const realisticAchievements = [{
  title: 'Into the Nether',
  description: 'Build a portal to the Nether.'
}, {
  title: 'MOAR Tools',
  description: 'Construct one type of each tool (one pickaxe, one shovel, one ax, one hoe).'
}, {
  title: 'Dispense with this',
  description: 'Construct a dispenser.'
}, {
  title: 'Leader of the Pack',
  description: 'Befriend five wolves.'
}, {
  title: 'Awarded all Trophies',
  description: 'All trophies have been awarded.'
}, {
  title: 'Pork Chop',
  description: 'Cook and eat a Porkchop'
}, {
  title: 'Passing The Time',
  description: 'Play for 100 days.'
}, {
  title: 'The Haggler',
  description: 'Obtain 30 Emeralds.'
}, {
  title: 'Pot Planter',
  description: 'Craft and place a Flower Pot.'
}, {
  title: "It's A Sign",
  description: 'Craft and place a Sign.'
}, {
  title: 'Iron Belly',
  description: 'Stop starvation by eating Rotten Flesh.'
}, {
  title: 'Have A Shearful Day',
  description: 'Use Shears to obtain Wool from a sheep.'
}, {
  title: 'Rainbow Collection',
  description: 'Gather 16 colors of Wool.'
}, {
  title: "Stayin' Frosty",
  description: 'Swim in lava while affected by a Fire Resistance effect.'
}, {
  title: 'Chestful Of Cobblestone',
  description: 'Mine and place 1728 Cobblestone in a Chest.'
}, {
  title: 'Renewable Energy',
  description: 'Smelt Wood logs in a Furnace, using Charcoal as the fuel source.'
}, {
  title: 'Music To My Ears',
  description: 'Play a Music Disc in a Jukebox.'
}, {
  title: 'BodyGuard',
  description: 'Create an Iron Golem.'
}, {
  title: 'Iron Man',
  description: 'Equip a full set of Iron Armor.'
}, {
  title: 'Zombie Doctor',
  description: 'Cure a Zombie Villager.'
}, {
  title: 'Lion Tamer',
  description: 'Tame an Ocelot.'
}, {
  title: 'Archer',
  description: 'Kill a Creeper with Arrows.'
}, {
  title: 'Tie-Dye Outfit',
  description: 'Dye a full 4-piece set of Leather Armor.'
}, {
  title: 'Trampoline',
  description: 'Bounce 30 blocks high off a Slime Block.'
}, {
  title: 'Camouflage',
  description: 'Kill a mob while wearing the head of that type of mob.'
}, {
  title: 'Map Room',
  description: 'Place 9 fully explored, adjacent maps into item frames in the shape of a 3x3 square.'
}, {
  title: 'Freight Station',
  description: 'Move an item from a Minecart chest, into a regular Chest using a Hopper.'
}, {
  title: 'Smelt Everything!',
  description: 'Connect 3 Chests to a single Furnace using Hoppers.'
}, {
  title: 'Taste Of Your Own Medicine',
  description: 'Poison a Witch with a Splash Potion.'
}, {
  title: 'Beam Me Up',
  description: 'Teleport over 100 meters from a single throw of an Ender Pearl.'
}, {
  title: 'Super Sonic',
  description: 'Use Elytra to fly through a 1 by 1 gap while moving faster than 40 m/s,'
}, {
  title: 'Great View From Up Here',
  description: 'Levitate up 50 blocks from the attacks of a Shulker.'
}, {
  title: 'The End... Again...',
  description: 'Respawn the Ender Dragon.'
}, {
  title: 'You Need a Mint',
  description: 'Collect dragons breath in a glass bottle.'
}, {
  title: 'The Deep End',
  description: 'Defeat an Elder Guardian.'
}, {
  title: 'Artificial Selection',
  description: 'Breed a mule from a horse and donkey.'
}, {
  title: 'Bee our guest',
  description: 'Use a Campfire to collect Honey from a Beehive using a Bottle without aggravating the bees.'
}]; // The fixture data has 100 achievements, where 59 are unlocked, 31 in progress and 10 are locked. There are 90 rewards in total, and out of those 53 are unlocked, 38 are locked.

const achievementsSharedFacetDefaultState = {
  status: AchievementFacetStatus.LOADED,
  data: {
    achievementsUnlocked: 59,
    maxAchievements: 100,
    hoursPlayed: 400,
    currentGamerScore: 1170,
    maxGamerScore: 2038,
    achievements: Array.from(Array(100).keys()).map(key => {
      const progress = key < 10 ? 0 : key > 40 ? 100 : key;
      const isLocked = progress !== 100;
      const noReward = key % 11 === 0;
      const normalisedIndex = key % realisticAchievements.length;
      const descriptionLong = shouldUseRealisticNames ? realisticAchievements[normalisedIndex].description : 'Description';
      const descriptionMedium = shouldUseRealisticNames ? realisticAchievements[normalisedIndex].description : 'Description';
      const descriptionShort = shouldUseRealisticNames ? realisticAchievements[normalisedIndex].description : 'Description';
      const rewardNameShort = 'Reward name';
      const rewardNameMedium = 'Reward';
      const rewardNameLong = 'Reward';
      return {
        id: `${key}`,
        name: shouldUseRealisticNames ? realisticAchievements[normalisedIndex].title : 'About',
        description: key % 10 === 0 ? descriptionLong : key % 3 === 0 ? descriptionMedium : descriptionShort,
        gamerScore: 30,
        progress: progress / 100,
        progressTarget: 3,
        isLocked: isLocked,
        isSecret: false,
        dateUnlocked: isLocked ? 0 : dateSelection[key % dateSelection.length],
        hasReward: !noReward,
        rewardImage: noReward ? undefined : rewardImages[key % rewardImages.length],
        rewardName: noReward ? undefined : key % 2 === 0 ? rewardNameShort : key % 3 === 0 ? rewardNameLong : rewardNameMedium,
        isRewardOwned: !noReward && !isLocked,
        rewardId: !noReward ? 'afef6035-74c3-4c32-9c31-33853cad886e' : undefined,
        image: achievementImages[key % achievementImages.length]
      };
    })
  }
}; // The fixture data has 10 achievements, where 0 are unlocked, 0 in progress and 10 are locked. No rewards.

const achievementsFacetNoCompleted = {
  status: AchievementFacetStatus.LOADED,
  data: {
    achievementsUnlocked: 0,
    maxAchievements: 10,
    hoursPlayed: 400,
    currentGamerScore: 0,
    maxGamerScore: 300,
    achievements: Array.from(Array(10).keys()).map(key => {
      const description = 'Spend a day under water';
      return {
        id: `${key}`,
        name: 'Sleeping with the fishes',
        description: description,
        gamerScore: 30,
        progress: 0,
        progressTarget: 1,
        isLocked: true,
        isSecret: false,
        dateUnlocked: dateV,
        hasReward: false,
        rewardImage: '',
        rewardName: '',
        isRewardOwned: false,
        image: achievementImages[key % achievementImages.length]
      };
    })
  }
}; // The fixture data has 10 achievements, where 10 are unlocked, 0 in progress and 0 are locked. No rewards.

const achievementsFacetAllCompleted = {
  status: AchievementFacetStatus.LOADED,
  data: {
    achievementsUnlocked: 10,
    maxAchievements: 10,
    hoursPlayed: 400,
    currentGamerScore: 300,
    maxGamerScore: 300,
    achievements: Array.from(Array(10).keys()).map(key => {
      const description = 'Spend a day under water';
      return {
        id: `${key}`,
        name: 'Sleeping with the fishes',
        description: description,
        gamerScore: 30,
        progress: 1,
        progressTarget: 1,
        isLocked: false,
        isSecret: false,
        dateUnlocked: date,
        hasReward: false,
        rewardImage: '',
        rewardName: '',
        isRewardOwned: false,
        image: achievementImages[key % achievementImages.length]
      };
    })
  }
};
const achievementsFacetLoading = {
  status: AchievementFacetStatus.LOADING,
  data: {
    achievementsUnlocked: 0,
    maxAchievements: 0,
    hoursPlayed: 0,
    currentGamerScore: 0,
    maxGamerScore: 0,
    achievements: []
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/buildSettings.ts
const currentGameVersion = {
  major: 1,
  minor: 19,
  patch: 0,
  revision: 0,
  isBeta: false
};
const buildSettingsSharedFacetDefaultState = {
  isDevBuild: false,
  isEduBuild: false,
  isPreviewBuild: false,
  currentGameVersion: currentGameVersion
};
const buildSettingsFacetIsDevBuild = {
  isDevBuild: true,
  isEduBuild: false,
  isPreviewBuild: false,
  currentGameVersion: currentGameVersion
};
const buildSettingsFacetIsEduBuild = {
  isDevBuild: false,
  isEduBuild: true,
  isPreviewBuild: false,
  currentGameVersion: currentGameVersion
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/clipboard.ts
const clipboardSharedFacetDefaultState = {
  copyToClipboard: () => {}
};
// EXTERNAL MODULE: ./node_modules/ramda/src/mergeDeepRight.js
var mergeDeepRight = __webpack_require__(57046);
var mergeDeepRight_default = /*#__PURE__*/__webpack_require__.n(mergeDeepRight);
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/createNewWorld.ts

 // Internal helper functions

const initialGeneralData = {
  worldName: '',
  gameMode: types_GameMode.SURVIVAL,
  difficulty: DifficultyEnum.EASY
};
const initialBetaFeaturesData = [{
  id: '0',
  title: 'Caves and cliffs blocks',
  description: 'Goats, snowier snow and what else might lurk behind the next block?',
  isEnabled: false,
  category: ExperimentalFeatureCategory.GAMEPLAY
}, {
  id: '1',
  title: 'Cave generation',
  description: 'Explore the new varied cave generation',
  isEnabled: false,
  category: ExperimentalFeatureCategory.GAMEPLAY
}, {
  id: '2',
  title: 'Custom Biomes',
  description: 'Create custom biomes and change world generation in your add-ons',
  isEnabled: false,
  category: ExperimentalFeatureCategory.ADD_ON_CREATORS
}, {
  id: '3',
  title: 'Additional modding capabilities',
  description: 'Doing a lot of repetitive things? This might help creating your add-on',
  isEnabled: false,
  category: ExperimentalFeatureCategory.ADD_ON_CREATORS
}, {
  id: '4',
  title: 'GameTest Framework',
  description: 'What is this?',
  isEnabled: false,
  category: ExperimentalFeatureCategory.ADD_ON_CREATORS
}, {
  id: '5',
  title: 'Holiday Creator Features',
  description: 'Includes actor properties and data-driven fog volumes for add-ons',
  isEnabled: false,
  category: ExperimentalFeatureCategory.ADD_ON_CREATORS
}];
const initialAdvancedData = {
  useFlatWorld: false,
  // simulationDistance depends on a facet value from SimulationDistanceFacet
  simulationDistance: 8,
  startWithMap: false,
  bonusChest: false,
  showCoordinates: false,
  firesSpreads: true,
  tntExplodes: true,
  respawnBlocksExplode: true,
  mobLoot: true,
  naturalRegeneration: true,
  tileDrops: true,
  immediateRespawn: false,
  respawnRadius: '5',
  worldSeed: ''
};
const initialCreateNewWorldFacet = {
  createWorld: {
    call: () => {},
    error: null
  },
  createOnRealms: {
    call: () => {},
    error: null
  },
  unlockTemplateSettings: () => {},
  consumeResetFlag: false,
  isLockedTemplate: false,
  isUsingTemplate: false,
  isRandomSeedAllowed: false,
  isAchievementsDisabled: false,
  isEditorWorld: false,
  applyTemplate: templateId => {
    return templateId;
  },
  checkIfUserHasChangedSettings: () => true,
  levelId: '',
  showedAchievementWarning: false,
  inWorldCreation: false,
  worldPreviewImagePath: '',
  worldCreationData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerSupported: true,
      playerPermissions: createNewWorldFacet_PlayerPermissions.MEMBER,
      multiplayerGame: true,
      playerAccess: PlayerAccess.FRIENDS,
      visibleToLanPlayers: true,
      friendlyFire: true,
      platformPlayerAccess: PlayerAccess.FRIENDS,
      platformPlayerAccessSupported: false,
      platformPlayerAccessEnabled: true,
      platformPlayerInviteAccessSupported: true
    },
    general: initialGeneralData,
    betaFeatures: initialBetaFeaturesData,
    cheats: {
      cheatsEnabled: false,
      commandsEnabled: true,
      daylightCycle: DaylightCycleEnum.NORMAL,
      keepInventory: false,
      mobSpawning: false,
      mobGriefing: false,
      entitiesDropLoot: false,
      weather: false,
      commandBlocks: false,
      educationEdition: false,
      tickSpeed: '1'
    },
    scriptingCoding: {
      codeBuilderEnabled: false
    },
    advanced: initialAdvancedData
  }
};

function createNewWorldData(overrides) {
  return mergeDeepRight_default()(initialCreateNewWorldFacet, overrides);
}

const createNewWorldSharedFacetDefaultState = createNewWorldData({
  worldCreationData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerGame: true,
      platformPlayerAccessSupported: true
    },
    cheats: {
      cheatsEnabled: false
    }
  }
});
const createNewWorldFacetMultiplayerTabMultiplayerEnabled = createNewWorldData({
  worldCreationData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerGame: true
    }
  }
});
const createNewWorldFacetMultiplayerTabMultiplayerDisabled = createNewWorldData({
  worldCreationData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerGame: false
    }
  }
});
function createNewWorldFacetMultiplayerTabWarning(warning) {
  return createNewWorldData({
    worldCreationData: {
      multiplayer: {
        generalWarningState: warning,
        multiplayerGame: true
      }
    }
  });
}
const createNewWorldFacetCheatsTabCheatsEnabled = createNewWorldData({
  worldCreationData: {
    cheats: {
      cheatsEnabled: true
    }
  },
  isAchievementsDisabled: true
});
const createNewWorldFacetCheatsTabCheatsDisabled = createNewWorldData({
  worldCreationData: {
    cheats: {
      cheatsEnabled: false
    }
  }
});
const createNewWorldFacetNotificationsBanner = createNewWorldData({
  isAchievementsDisabled: true,
  worldCreationData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.CHECK_INTERNET_CONNECTION,
      multiplayerGame: true
    }
  }
});
const experimentalFeature = {
  id: 'id',
  title: 'title',
  description: 'desc',
  isEnabled: true,
  category: ExperimentalFeatureCategory.GAMEPLAY
}; // Achievements disabled modal - All possible disabling features enabled

function createNewWorldFacetAchievementsDisabled() {
  return createNewWorldData({
    isAchievementsDisabled: true,
    worldCreationData: {
      advanced: {
        useFlatWorld: true
      },
      general: {
        gameMode: GameMode.CREATIVE
      },
      cheats: {
        cheatsEnabled: true
      },
      multiplayer: {
        playerPermissions: PlayerPermissions.OPERATOR
      },
      betaFeatures: [experimentalFeature]
    }
  });
} // Create on realms: Fixtures for error modal specific variants

function createNewWorldFacetWithRealmsError(error) {
  return createNewWorldData({
    createOnRealms: {
      call: () => {},
      error: error
    }
  });
} // Create new world: Fixtures for error modal specific variants

function createNewWorldFacetWithCreateWorldError(error) {
  return createNewWorldData({
    createWorld: {
      call: () => {},
      error: error
    }
  });
}
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/debugSettings.ts

const allBiomes = [{
  label: 'Nether 1',
  id: 0,
  dimension: BiomeDimension.NETHER
}, {
  label: 'Nether 2',
  id: 1,
  dimension: BiomeDimension.NETHER
}, {
  label: 'Nether 3',
  id: 2,
  dimension: BiomeDimension.NETHER
}, {
  label: 'Nether 4',
  id: 3,
  dimension: BiomeDimension.NETHER
}, {
  label: 'Random overworld biome',
  id: 4,
  dimension: BiomeDimension.OVERWORLD
}, {
  label: 'Overworld 2',
  id: 5,
  dimension: BiomeDimension.OVERWORLD
}, {
  label: 'Overworld 3',
  id: 6,
  dimension: BiomeDimension.OVERWORLD
}, {
  label: 'Overworld 4',
  id: 7,
  dimension: BiomeDimension.OVERWORLD
}, {
  label: 'Overworld 5',
  id: 8,
  dimension: BiomeDimension.OVERWORLD
}, {
  label: 'Overworld 6',
  id: 9,
  dimension: BiomeDimension.OVERWORLD
}];
const debugSettingsSharedFacetDefaultState = {
  flatNether: false,
  enableGameVersionOverride: false,
  gameVersionOverride: '',
  spawnDimensionId: 0,
  spawnBiomeId: 0,
  biomeOverrideId: 0,
  allBiomes: allBiomes,
  defaultSpawnBiome: true,
  isBiomeOverrideActive: false
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/resource-pack-images/pack-image.png
const pack_image_namespaceObject = __webpack_require__.p + "assets/pack-image-6ba6e.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/resourcePacks.ts



const platFormLockedPackIds = ['resource-pack-6'];
const packsWithSettings = ['resource-pack-5'];
const createMockPack = packId => {
  return {
    id: packId,
    contentId: packId,
    name: `Mock Pack ${packId}`,
    creator: 'Creator',
    description: `This is a pack description for ${packId}.`,
    size: '3.5MB',
    image: pack_image_namespaceObject,
    isMarketplaceItem: true,
    isPlatformLocked: platFormLockedPackIds.includes(packId),
    hasSettings: packsWithSettings.includes(packId)
  };
};
const resourcePacks_MOCK_DOWNLOAD_SPEED = 100;
const resourcePacksSharedFacetDefaultState = {
  texturePacks: {
    activeGlobal: [],
    active: [...new Array(3)].map((_, i) => createMockPack(`${i}`)),
    available: [...new Array(3)].map((_, i) => createMockPack(`${i + 3}`)),
    realms: [...new Array(3)].map((_, i) => createMockPack(`${i + 6}`)),
    unowned: []
  },
  behaviorPacks: {
    active: [...new Array(3)].map((_, i) => createMockPack(`${i}`)),
    available: [...new Array(3)].map((_, i) => createMockPack(`${i + 3}`))
  },
  realmsPlusSupported: true,
  realmsSubscriber: true,
  sharedPacks: false,
  resourcePackToDownload: {
    title: '',
    body: ''
  },
  status: resourcePacksFacet_ResourcePacksFacetStatus.Idle,
  downloadProgress: 0,
  importProgress: 0,
  marketplacePackId: '1',
  prompt: {
    actions: [],
    active: false,
    body: '',
    handleAction: () => {},
    id: 'prompt',
    title: ''
  },
  activate: () => {},
  deactivate: () => {},
  cancelDownload: () => false,
  confirmDownload: () => false,
  changePackPriority: () => {},
  showSettings: () => {}
};
const resourcePacksSharedFacetDownloadPackState = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  status: resourcePacksFacet_ResourcePacksFacetStatus.DownloadingResourcePacks,
  resourcePackToDownload: {
    title: 'Example pack',
    body: 'This pack will do things to your game.'
  },
  downloadProgress: 0.4
});
const resourcePacksSharedFacetActivePacksEmptyState = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  texturePacks: {
    activeGlobal: [],
    active: [],
    available: [...new Array(3)].map((_, i) => createMockPack(`${i}`)),
    realms: [],
    unowned: []
  }
});
const resourcePacksSharedFacetAvailablePacksEmptyState = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  texturePacks: {
    activeGlobal: [],
    active: [...new Array(3)].map((_, i) => createMockPack(`${i}`)),
    available: [],
    realms: [...new Array(3)].map((_, i) => createMockPack(`${i + 3}`)),
    unowned: []
  }
});
const resourcePacksSharedFacetRealmsPacksEmptyState = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  texturePacks: {
    activeGlobal: [],
    active: [...new Array(3)].map((_, i) => createMockPack(`${i}`)),
    available: [...new Array(3)].map((_, i) => createMockPack(`${i + 3}`)),
    realms: [],
    unowned: []
  }
});
const resourcePacksSharedFacetRealmsPacksNotSubscriber = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  texturePacks: {
    activeGlobal: [],
    active: [...new Array(3)].map((_, i) => createMockPack(`${i}`)),
    available: [...new Array(3)].map((_, i) => createMockPack(`${i + 3}`)),
    realms: [],
    unowned: []
  },
  realmsPlusSupported: true,
  realmsSubscriber: false
});
const resourcePacksSharedFacetDownloadConfirmation = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  prompt: {
    id: 'prompt',
    active: true,
    title: 'Ready to download?',
    body: `${createMockPack('1').name} needs to be downloaded before it can be activated.`,
    actions: [{
      id: 0,
      label: 'Download and activate pack',
      variant: types_PromptActionVariant.Primary
    }, {
      id: 1,
      label: 'Cancel',
      variant: types_PromptActionVariant.Secondary
    }],
    handleAction: () => {}
  },
  resourcePackToDownload: {
    title: createMockPack('1').name,
    body: ''
  },
  status: resourcePacksFacet_ResourcePacksFacetStatus.CheckingResourcePacks
});
const resourcePacksSharedFacetDownloading = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  resourcePackToDownload: {
    title: createMockPack('1').name,
    body: ''
  },
  status: resourcePacksFacet_ResourcePacksFacetStatus.StartDownload,
  downloadProgress: 0.4
});
const resourcePacksSharedFacetImporting = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  resourcePackToDownload: {
    title: createMockPack('1').name,
    body: ''
  },
  status: resourcePacksFacet_ResourcePacksFacetStatus.DownloadingResourcePacks,
  downloadProgress: 1.0,
  importProgress: 0.7
});
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/factories/resourcePacks.ts
function resourcePacks_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function resourcePacks_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { resourcePacks_ownKeys(Object(source), true).forEach(function (key) { resourcePacks_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { resourcePacks_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function resourcePacks_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




let ResourcePackDlcCheckResult;

(function (ResourcePackDlcCheckResult) {
  ResourcePackDlcCheckResult[ResourcePackDlcCheckResult["Valid"] = 0] = "Valid";
  ResourcePackDlcCheckResult[ResourcePackDlcCheckResult["MissingWorldTemplate"] = 1] = "MissingWorldTemplate";
  ResourcePackDlcCheckResult[ResourcePackDlcCheckResult["MissingDependencies"] = 2] = "MissingDependencies";
  ResourcePackDlcCheckResult[ResourcePackDlcCheckResult["NoStorage"] = 3] = "NoStorage";
  ResourcePackDlcCheckResult[ResourcePackDlcCheckResult["NoInternet"] = 4] = "NoInternet";
  ResourcePackDlcCheckResult[ResourcePackDlcCheckResult["DevicePerformanceTooLow"] = 5] = "DevicePerformanceTooLow";
})(ResourcePackDlcCheckResult || (ResourcePackDlcCheckResult = {}));

/**
 * These debug constants can be changed to help test various scenarios
 */
const Debug = {
  NUM_ACTIVE_PACKS: 3,
  EMPTY_GLOBAL_RESOURCE_PACKS: false,
  REALMS_PLUS_SUPPORTED: true,
  REALMS_PLUS_SUBSCRIBER: false,
  DLC_CHECK_RESPONSE: ResourcePackDlcCheckResult.Valid,
  ACTIVATION_RESPONSE: 'success',
  SHOW_PACK_DOWNLOAD_CONFIRMATION: false
};
const resourcePacks_platFormLockedPackIds = ['resource-pack-6'];
const resourcePacks_packsWithSettings = ['resource-pack-5', 'behavior-pack-2'];
const resourcePacks_createMockPack = packId => {
  return {
    id: packId,
    contentId: packId,
    name: `Mock Pack ${packId}`,
    creator: 'Creator',
    description: `This is a pack description for ${packId}.`,
    size: '3.5MB',
    image: pack_image_namespaceObject,
    isMarketplaceItem: true,
    isPlatformLocked: resourcePacks_platFormLockedPackIds.includes(packId),
    hasSettings: resourcePacks_packsWithSettings.includes(packId)
  };
};
function resourcePacksFacetFactory(proxy) {
  // Resource packs
  const resourcePacks = [...new Array(12)].map((_, i) => resourcePacks_createMockPack(i ? `resource-pack-${i}` : 'global-pack')).reverse().reduce((acc, cur) => resourcePacks_objectSpread(resourcePacks_objectSpread({}, acc), {}, {
    [cur.id]: resourcePacks_objectSpread({}, cur)
  }), {});
  const originalAvailableResourcePacks = [resourcePacks['resource-pack-1'], resourcePacks['resource-pack-2'], resourcePacks['resource-pack-4'], resourcePacks['resource-pack-5'], resourcePacks['resource-pack-6']];
  const availableResourcePacks = originalAvailableResourcePacks.slice();
  const originalRealmsPacks = [resourcePacks['resource-pack-3'], resourcePacks['resource-pack-7'], resourcePacks['resource-pack-8'], resourcePacks['resource-pack-9']];
  const realmsPacks = originalRealmsPacks.slice();
  const originalUnownedPacks = [resourcePacks['resource-pack-10'], resourcePacks['resource-pack-11'], resourcePacks['resource-pack-12']];
  const unownedPacks = originalUnownedPacks.slice();
  const activeGlobalPacks = Debug.EMPTY_GLOBAL_RESOURCE_PACKS ? [] : [resourcePacks['global-pack']];
  const activeResourcePacks = [...availableResourcePacks.splice(0, Debug.NUM_ACTIVE_PACKS)]; // Behavior packs

  const behaviorPacks = [...new Array(12)].map((_, i) => resourcePacks_createMockPack(`behavior-pack-${i + 1}`)).reverse().reduce((acc, cur) => resourcePacks_objectSpread(resourcePacks_objectSpread({}, acc), {}, {
    [cur.id]: resourcePacks_objectSpread({}, cur)
  }), {});
  const originalAvailableBehaviorPacks = [behaviorPacks['behavior-pack-1'], behaviorPacks['behavior-pack-2'], behaviorPacks['behavior-pack-4'], behaviorPacks['behavior-pack-5'], behaviorPacks['behavior-pack-6']];
  const availableBehaviorPacks = originalAvailableBehaviorPacks.slice();
  const activeBehaviorPacks = [...availableBehaviorPacks.splice(0, Debug.NUM_ACTIVE_PACKS)];
  let activatingId = null;
  let downloadInterval;
  proxy.prompt = {
    id: 'helloWorld',
    active: false,
    body: '',
    title: '',
    handleAction: id => {
      console.log('Handling prompt option: ', id);
      proxy.prompt.active = false;

      if (id === 0) {
        proxy.confirmDownload();
      }
    },
    actions: []
  };
  proxy.texturePacks = {};
  proxy.behaviorPacks = {};
  proxy.sharedPacks = false;
  proxy.realmsPlusSupported = Debug.REALMS_PLUS_SUPPORTED;
  proxy.realmsSubscriber = Debug.REALMS_PLUS_SUBSCRIBER;
  proxy.status = ResourcePacksFacetStatus.Idle;
  proxy.marketplacePackId = '';
  proxy.texturePacks.active = activeResourcePacks;
  proxy.texturePacks.activeGlobal = activeGlobalPacks;
  proxy.texturePacks.available = availableResourcePacks;
  proxy.texturePacks.realms = realmsPacks;
  proxy.texturePacks.unowned = unownedPacks;
  proxy.behaviorPacks.active = activeBehaviorPacks;
  proxy.behaviorPacks.available = availableBehaviorPacks;
  proxy.resourcePackToDownload = {
    title: '',
    body: ''
  };
  proxy.downloadProgress = 0;
  proxy.importProgress = 0;

  proxy.activate = id => {
    activatingId = id; // In the behavior packs tab the behavior packs should be used

    if (window.location.href.indexOf('behavior-packs') !== -1) {
      let index, targetArray;

      if (proxy.behaviorPacks.available.findIndex(pack => pack.id === activatingId) != -1) {
        targetArray = proxy.behaviorPacks.available;
      } else {
        // trying to activate unknown pack
        return false;
      }

      if (activatingId != null) {
        index = targetArray.findIndex(pack => pack.id === activatingId);
        targetArray.splice(index, 1);
        proxy.behaviorPacks.active.unshift(behaviorPacks[activatingId]);
      }

      return true;
    }

    const targetPack = resourcePacks[id];
    proxy.resourcePackToDownload.title = targetPack.name; // If there is no pack validation error

    switch (Debug.DLC_CHECK_RESPONSE) {
      case ResourcePackDlcCheckResult.Valid:
        // You don't have the pack downloaded already
        if (Debug.SHOW_PACK_DOWNLOAD_CONFIRMATION) {
          proxy.status = ResourcePacksFacetStatus.WaitingForPrompt;
          proxy.marketplacePackId = id;
          setTimeout(() => {
            proxy.status = ResourcePacksFacetStatus.CheckingResourcePacks; // @Vii, is this the correct status at this time?

            proxy.prompt.active = true;
            proxy.prompt.title = 'Ready to download?';
            proxy.prompt.body = `${targetPack.name} needs to be downloaded before it can be activated.`;
            proxy.prompt.actions = [{
              id: 0,
              label: 'Download and activate pack',
              variant: PromptActionVariant.Primary
            }, {
              id: 1,
              label: 'Cancel',
              variant: PromptActionVariant.Secondary
            }];
          }, 50);
        } // If already downloaded, jump straight to the activation
        else {
            proxy.confirmDownload();
          }

        return;
    } // If the above didn't trigger, we can trust it's one of the errors


    proxy.prompt.active = true;
    proxy.prompt.title = 'Lorem';
    proxy.prompt.body = 'Ipsum';
    proxy.prompt.actions = [{
      id: 0,
      label: 'Activate anyway',
      variant: PromptActionVariant.Primary
    }, {
      id: 1,
      label: 'Go back',
      variant: PromptActionVariant.Secondary
    }];
  };

  proxy.deactivate = id => {
    let targetArray; // In the behavior packs tab the pack activation should not emulate a download

    if (window.location.href.indexOf('behavior-packs') !== -1) {
      // Remove the pack from active packs
      const index = proxy.behaviorPacks.active.findIndex(pack => pack.id === id);

      if (index != -1) {
        proxy.behaviorPacks.active.splice(index, 1);
      } // Find which group that pack previously belonged to


      if (originalAvailableBehaviorPacks.findIndex(pack => pack.id === id) != -1) {
        targetArray = proxy.behaviorPacks.available;
      } else {
        // trying to deactivate unknown pack
        return;
      }

      targetArray.unshift(behaviorPacks[id]);
      return;
    } // Remove the pack from active packs


    const index = proxy.texturePacks.active.findIndex(pack => pack.id === id);

    if (index != -1) {
      proxy.texturePacks.active.splice(index, 1);
    } // Find which group that pack previously belonged to


    if (originalAvailableResourcePacks.findIndex(pack => pack.id === id) != -1) {
      targetArray = proxy.texturePacks.available;
    } else if (originalRealmsPacks.findIndex(pack => pack.id === id) != -1) {
      targetArray = proxy.texturePacks.realms;
    } else if (originalUnownedPacks.findIndex(pack => pack.id === id) != -1) {
      targetArray = proxy.texturePacks.unowned;
    } else {
      // trying to deactivate unknown pack
      return;
    }

    targetArray.unshift(resourcePacks[id]);
  };

  proxy.showSettings = id => {
    console.log(`Showing settings for pack ${id}`);
  };

  proxy.confirmDownload = () => {
    let index, targetArray;
    if (activatingId == null) return false;

    if (proxy.texturePacks.available.findIndex(pack => pack.id === activatingId) != -1) {
      targetArray = proxy.texturePacks.available;
    } else if (proxy.texturePacks.realms.findIndex(pack => pack.id === activatingId) != -1) {
      targetArray = proxy.texturePacks.realms;
    } else if (proxy.texturePacks.unowned.findIndex(pack => pack.id === activatingId) != -1) {
      targetArray = proxy.texturePacks.unowned;
    } else {
      // trying to activate unknown pack
      return false;
    }

    proxy.status = ResourcePacksFacetStatus.DownloadingResourcePacks;
    downloadInterval = setInterval(() => {
      // When download is complete
      if (proxy.downloadProgress >= 1.0) {
        proxy.downloadProgress = 1.0;

        if (proxy.importProgress < 1) {
          proxy.importProgress = (proxy.importProgress * 10 + 1) / 10;
        } // When import is complete
        else {
            proxy.importProgress = 1.0;
            proxy.status = ResourcePacksFacetStatus.ActivateDownloadedPack;
            clearInterval(downloadInterval);

            if (Debug.ACTIVATION_RESPONSE === 'success') {
              // Successful download/import
              setTimeout(() => {
                proxy.downloadProgress = 0;
                proxy.importProgress = 0;

                if (activatingId != null) {
                  index = targetArray.findIndex(pack => pack.id === activatingId);
                  targetArray.splice(index, 1);
                  proxy.texturePacks.active.unshift(resourcePacks[activatingId]);
                }

                proxy.status = ResourcePacksFacetStatus.Idle;
              }, MOCK_DOWNLOAD_SPEED);
            } // On activation failure
            else {
                // Set the prompt to show an error and listen for a response
                proxy.prompt.active = true;
                proxy.prompt.title = 'CreateNewWorld.dynamicModal.title';
                proxy.prompt.body = 'CreateNewWorld.dynamicModal.body';
              }
          }
      } else {
        proxy.downloadProgress = (proxy.downloadProgress * 10 + 1) / 10;
      }
    }, MOCK_DOWNLOAD_SPEED);
    return true;
  };

  proxy.cancelDownload = () => {
    clearInterval(downloadInterval);
    proxy.downloadProgress = 0;
    proxy.importProgress = 0;
    proxy.status = ResourcePacksFacetStatus.Idle;
    return true;
  };

  proxy.changePackPriority = (_, prevIndex, newIndex) => {
    const packs = ~window.location.href.indexOf('behavior-packs') ? proxy.behaviorPacks : proxy.texturePacks;
    const element = packs.active[prevIndex];
    packs.active.splice(prevIndex, 1);
    packs.active.splice(newIndex, 0, element);
  };

  return proxy;
}
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/editWorld.ts




const editWorldSharedFacetDefaultState = {
  closeWorld: () => {},
  deleteWorld: () => {},
  loadWorld: {
    run: () => {},
    clear: () => {}
  },
  duplicateWorld: {
    run: () => {},
    clear: () => {},
    result: undefined
  },
  worldData: {
    general: {
      worldName: 'my own world',
      gameMode: types_GameMode.SURVIVAL,
      difficulty: DifficultyEnum.EASY
    },
    advanced: {
      worldSeed: '54MP1E5EED',
      useFlatWorld: false,
      startWithMap: false,
      bonusChest: false,
      showCoordinates: false,
      firesSpreads: true,
      tntExplodes: true,
      respawnBlocksExplode: true,
      mobLoot: true,
      naturalRegeneration: true,
      tileDrops: true,
      immediateRespawn: false,
      respawnRadius: '5',
      simulationDistance: 8
    },
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerSupported: true,
      playerPermissions: createNewWorldFacet_PlayerPermissions.MEMBER,
      multiplayerGame: true,
      playerAccess: PlayerAccess.FRIENDS,
      visibleToLanPlayers: true,
      friendlyFire: true,
      platformPlayerAccess: PlayerAccess.FRIENDS,
      platformPlayerAccessSupported: false,
      platformPlayerAccessEnabled: true,
      platformPlayerInviteAccessSupported: true
    },
    cheats: {
      cheatsEnabled: false,
      commandsEnabled: true,
      daylightCycle: DaylightCycleEnum.NORMAL,
      keepInventory: false,
      mobSpawning: false,
      mobGriefing: false,
      entitiesDropLoot: false,
      weather: false,
      commandBlocks: false,
      educationEdition: false,
      tickSpeed: '1'
    },
    betaFeatures: initialBetaFeaturesData,
    lockedTemplate: false,
    isUsingTemplate: false
  },
  worldSummary: {
    fileSize: '300 MB',
    lastPlayed: '2 Jan 2023',
    worldIconPath: ''
  },
  saveLocalWorld: {
    run: () => {},
    clear: () => {},
    cancel: () => true,
    result: undefined,
    state: AsyncStatefulFunctionState.Idle
  },
  activatePack: {
    run: () => {},
    clear: () => {},
    result: undefined
  },
  deactivatePack: {
    run: () => {},
    clear: () => {},
    result: undefined
  },
  activatePackContinue: {
    run: () => {},
    clear: () => {},
    result: undefined
  },
  deactivatePackContinue: {
    run: () => {},
    clear: () => {},
    result: undefined
  },
  changePackPriority: {
    run: () => {},
    clear: () => {},
    result: undefined
  },
  downloadPack: {
    run: () => {},
    clear: () => {},
    cancel: () => {
      return true;
    },
    result: undefined,
    state: AsyncStatefulFunctionState.Idle
  },
  isAchievementsEditDisabled: false,
  worldPacks: {
    texturePacks: {
      activeGlobal: [],
      active: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i}`)),
      available: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i + 3}`)),
      realms: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i + 6}`)),
      unowned: []
    },
    behaviorPacks: {
      active: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i}`)),
      available: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i + 3}`))
    },
    realmsPlusSupported: true,
    realmsSubscriber: true,
    sharedPacks: false
  },
  downloadPackActionProgress: 0,
  downloadPackActionStatus: PackDownloaderStatus.Idle
};

function editWorldData(overrides) {
  return mergeDeepRight_default()(editWorldSharedFacetDefaultState, overrides);
}

const editWorldFacetNotificationsBanner = editWorldData({
  isAchievementsEditDisabled: true,
  worldData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.CHECK_INTERNET_CONNECTION,
      multiplayerGame: true
    }
  }
});
const editWorldFacetActivePacksEmptyState = editWorldData({
  worldPacks: {
    texturePacks: {
      activeGlobal: [],
      active: [],
      available: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i}`)),
      realms: [],
      unowned: []
    }
  }
});
const editWorldFacetAvailablePacksEmptyState = editWorldData({
  worldPacks: {
    texturePacks: {
      activeGlobal: [],
      active: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i}`)),
      available: [],
      realms: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i + 3}`)),
      unowned: []
    }
  }
});
const editWorldFacetMultiplayerTabMultiplayerEnabled = editWorldData({
  worldData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerGame: true
    }
  }
});
const editWorldFacetMultiplayerTabMultiplayerDisabled = editWorldData({
  worldData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerGame: false
    }
  }
});
const editWorldFacetMultiplayerTabWarning = editWorldData({
  worldData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.CHECK_INTERNET_CONNECTION,
      multiplayerGame: true
    }
  }
});
const editWorldFacetRealmsPacksEmptyState = editWorldData({
  worldPacks: {
    texturePacks: {
      activeGlobal: [],
      active: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i}`)),
      available: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i + 3}`)),
      realms: [],
      unowned: []
    }
  }
});
const editWorldFacetRealmsPacksNotSubscriber = editWorldData({
  worldPacks: {
    texturePacks: {
      activeGlobal: [],
      active: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i}`)),
      available: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i + 3}`)),
      realms: [],
      unowned: []
    },
    realmsPlusSupported: true,
    realmsSubscriber: false
  }
});
const editWorldFacetDownloading = editWorldData({
  downloadPackActionStatus: PackDownloaderStatus.Downloading,
  downloadPackActionProgress: 0.4
});
const editWorldFacetImporting = editWorldData({
  downloadPackActionStatus: PackDownloaderStatus.Importing,
  downloadPackActionProgress: 0.7
});
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/inbox.ts

const inbox_ONE_WEEK = 604800;
const ONE_DAY = 86400;
const getTestData = [{
  id: 'HistoryTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - inbox_ONE_WEEK - ONE_DAY,
  dateString: '11:35 am',
  dateLabel: '',
  title: 'News History Test1',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: true,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.NEWS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE
}, {
  id: 'HistoryTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - inbox_ONE_WEEK - ONE_DAY - ONE_DAY,
  dateString: '11:35 am',
  dateLabel: '',
  title: 'News History Test2',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.NEWS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 3
}, {
  id: 'RecentTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - ONE_DAY,
  dateString: '11:35 am',
  dateLabel: '',
  title: 'News Recent Test1',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: true,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.NEWS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 0
}, {
  id: 'RecentTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - inbox_ONE_WEEK + ONE_DAY,
  dateString: '6:34 pm',
  dateLabel: '',
  title: 'Invite Recent Test1',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: true,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.INVITES,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.ACCEPTED
}, {
  id: 'HistoryTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - inbox_ONE_WEEK - ONE_DAY,
  dateString: '11:35 am',
  dateLabel: '',
  title: 'Invite History Test1',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.INVITES,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.REJECTED
}, {
  id: 'RecentTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - 4 * ONE_DAY,
  dateString: '6:34 pm',
  dateLabel: '',
  title: 'Invite Recent Test2',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: true,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.INVITES,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.ACCEPTED
}, {
  id: 'HistoryTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - inbox_ONE_WEEK - ONE_DAY - ONE_DAY,
  dateString: '11:3 am',
  dateLabel: '',
  title: 'Invite History Test2',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.INVITES,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.NONE
}, {
  id: 'HistoryTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - inbox_ONE_WEEK - ONE_DAY,
  dateString: '11:39 am',
  dateLabel: '',
  title: 'Realms History Test1',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: true,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.REALMS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 0
}, {
  id: 'RecentTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - ONE_DAY - ONE_DAY - ONE_DAY,
  dateString: '11:38 am',
  dateLabel: '',
  title: 'Realms Recent Test1',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.REALMS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 4
}, {
  id: 'RecentTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - ONE_DAY - ONE_DAY - ONE_DAY - ONE_DAY,
  dateString: '11:38 am',
  dateLabel: '',
  title: 'Realms Recent Test2',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: true,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.REALMS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE
}];
const getSortedTestData = {
  recent: [{
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK,
    dateString: '6:34 pm',
    dateLabel: '',
    title: 'Realms Invite',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: true,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.ACCEPTED
  }, {
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK - 3,
    dateString: '11:35 am',
    dateLabel: '',
    title: 'Timed Event',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: false,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.NONE,
    inviteDaysLeft: 5
  }, {
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK - 2,
    dateString: '11:35 am',
    dateLabel: '',
    title: 'Expiring Event',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: true,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.NONE
  }, {
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK - 3,
    dateString: '11:35 am',
    dateLabel: '',
    title: 'Expired Event',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: true,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.REJECTED
  }],
  history: [{
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK + 8,
    dateString: '6:34 pm',
    dateLabel: '',
    title: 'Realms Invite',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: true,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.ACCEPTED
  }, {
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK + 9,
    dateString: '11:02 am',
    dateLabel: '',
    title: 'Timed Event',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: false,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.NONE
  }, {
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK + 11,
    dateString: '1:45 am',
    dateLabel: '',
    title: 'Expiring Event',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: true,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.NONE
  }, {
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK + 10,
    dateString: '11:35 am',
    dateLabel: '',
    title: 'Expired Event',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: true,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.EXPIRED,
    inviteDaysLeft: -2
  }]
};
const inboxSharedFacetDefaultState = {
  inboxMessages: getTestData,
  realmsSubscriber: false,
  deleteNotification: id => {
    return id;
  }
};
const inboxSharedFacetEmptySubbedState = {
  inboxMessages: [],
  realmsSubscriber: true,
  deleteNotification: id => {
    return id;
  }
};
const inboxSharedFacetEmptyNotSubbedState = {
  inboxMessages: [],
  realmsSubscriber: false,
  deleteNotification: id => {
    return id;
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/marketplaceSuggestions.ts
const marketplaceSuggestionsSharedFacetDefaultState = {
  getMorePacks: {
    pageId: 'mock-id',
    title: 'Mock Title'
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/notificationOptions.ts
const notificationOptionsSharedFacetDefaultState = {
  doNotShowEntitlementsWarning: false
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/options.ts
function options_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function options_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { options_ownKeys(Object(source), true).forEach(function (key) { options_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { options_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function options_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const optionsSharedFacetDefaultState = {
  renderDistance: 17,
  defaultRenderDistance: 8,
  maxRenderDistance: 16,
  showRenderDistanceWarningModal: true,
  touchControlScheme: TouchControlSchemeEnum.TOUCH,
  showTouchControlSelectionScreen: false,
  useMobileDataOnce: false,
  playVideoInTouchControlSelectionScreen: true
};
const singularValuesOptionsFacet = options_objectSpread(options_objectSpread({}, optionsSharedFacetDefaultState), {}, {
  renderDistance: 1,
  defaultRenderDistance: 1,
  maxRenderDistance: 1,
  showRenderDistanceWarningModal: true,
  touchControlScheme: TouchControlSchemeEnum.TOUCH,
  showTouchControlSelectionScreen: false,
  playVideoInTouchControlSelectionScreen: true
});
const lessThanMaxOptionsFacet = options_objectSpread(options_objectSpread({}, optionsSharedFacetDefaultState), {}, {
  renderDistance: 7,
  defaultRenderDistance: 5,
  maxRenderDistance: 10,
  showRenderDistanceWarningModal: true,
  touchControlScheme: TouchControlSchemeEnum.TOUCH,
  showTouchControlSelectionScreen: false,
  playVideoInTouchControlSelectionScreen: true
});
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/announcementImages/index.ts
/* global require */


const announcementImages_context = __webpack_require__(42569);

const announcementImages = announcementImages_context.keys().sort(localeCompare).map(fileName => {
  const path = announcementImages_context(fileName);
  return path;
});
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/playerMessagingService.ts


const exampleLongText = 'The Caves & Cliffs: Part II update has arrived, bringing new features and more to explore!\n\n• Increased the world height and depth, adding 50% more vertical space to build and explore\n• New cave generation to explore below your existing worlds\n• New cave and mountain biomes like Lush Caves and Jagged Peaks\n• Fixed over 70 bugs, issues, and parity changes\n\nTo see the full changelog, head to aka.ms/MinecraftUpdate.\nPlease search for any bugs you find on bugs.mojang.com and let us know what you think at feedback.minecraft.net!';
const exampleButtons = [{
  id: 'Dismiss',
  text: '',
  link: '',
  action: 'dismiss',
  reportClick: () => {
    console.log(`Messaging Service - clicked Dismiss Button`);
  },
  additionalProperties: []
}, {
  id: 'CallToAction',
  text: '',
  link: 'ebbead54-7b4f-46ff-9839-e715e482a88d',
  action: 'productId',
  reportClick: () => {
    console.log(`Messaging Service - clicked Unlock Button`);
  },
  additionalProperties: []
}];
const exampleImages = [{
  id: 'Primary',
  url: announcementImages[0],
  isLoaded: true,
  additionalProperties: []
}, {
  id: 'Secondary',
  url: announcementImages[1],
  isLoaded: true,
  additionalProperties: []
}, {
  id: 'Primary',
  url: announcementImages[1],
  isLoaded: true,
  additionalProperties: []
}];
const exampleAnnouncementMessages = [//template 1
{
  id: 'ImageText',
  surface: 'LoginAnnouncement',
  template: 'ImageText',
  images: [exampleImages[0]],
  buttons: [exampleButtons[0]],
  additionalProperties: [{
    key: 'header',
    value: '1.14.0 Update'
  }, {
    key: 'body',
    value: exampleLongText
  }]
}, //template 2
{
  id: 'ImageThumbnailCTA',
  surface: 'LoginAnnouncement',
  template: 'ImageThumbnailCTA',
  images: [exampleImages[0], exampleImages[1]],
  buttons: [exampleButtons[0], exampleButtons[1]],
  additionalProperties: [{
    key: 'header',
    value: 'Minecraft Spring Sale'
  }, {
    key: 'body',
    value: exampleLongText
  }]
}, //template 3
{
  id: 'HeroImageCTA',
  surface: 'LoginAnnouncement',
  template: 'HeroImageCTA',
  images: [exampleImages[2]],
  buttons: [exampleButtons[0], exampleButtons[1]],
  additionalProperties: [{
    key: 'header',
    value: 'Special Gift'
  }, {
    key: 'body',
    value: 'Dress up as a Nether denizen with this free pack!'
  }]
}];

function logClick(messageID, buttonID) {
  console.log(`Messaging Service - reporting click for message "${messageID}" on button "${buttonID}"`);
}

function logDismiss(messageID) {
  console.log(`Messaging Service - reporting dismiss for message "${messageID}"`);
} // The fixture data contains the basic versions of the message templates


const playerMessagingServiceSharedFacetDefaultState = {
  status: PlayerMessagingServiceFacetStatus.LOADED,
  data: {
    messageCount: exampleAnnouncementMessages.length,
    messages: Array.from(Array(exampleAnnouncementMessages.length).keys()).map(key => {
      const message = {
        id: exampleAnnouncementMessages[key].id,
        surface: exampleAnnouncementMessages[key].surface,
        template: exampleAnnouncementMessages[key].template,
        images: exampleAnnouncementMessages[key].images,
        buttons: exampleAnnouncementMessages[key].buttons,
        additionalProperties: exampleAnnouncementMessages[key].additionalProperties
      };
      return message;
    })
  },
  reportClick: (messageID, buttonID) => {
    logClick(messageID, buttonID);
  },
  reportDismiss: messageID => {
    logDismiss(messageID);
  }
};
const playerMessagingServiceFacetLoading = {
  status: PlayerMessagingServiceFacetStatus.LOADING,
  data: {
    messageCount: 0,
    messages: []
  },
  reportClick: (messageID, buttonID) => {
    logClick(messageID, buttonID);
  },
  reportDismiss: messageID => {
    logDismiss(messageID);
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/playerReport.ts
const playerReportFacetDefaultState = {
  isChatAvailable: () => {
    return true;
  },
  reportPlayer: () => {
    console.log('reportPlayer()');
  },
  reportArea: 0,
  reportReason: 0,
  reportMessage: '',
  xuid: '',
  uuid: '',
  selectedChatMessages: [],
  reportableChatMessages: [{
    message: 'Hello there',
    author: 'Steve',
    isAuthorBeingReported: false
  }, {
    message: 'Yo',
    author: 'Alex',
    isAuthorBeingReported: true
  }, {
    message: 'This is a fake message',
    author: 'Steve',
    isAuthorBeingReported: false
  }, {
    message: 'Very nice',
    author: 'Alex',
    isAuthorBeingReported: true
  }, {
    message: 'Test 123',
    author: 'Alex',
    isAuthorBeingReported: true
  }, {
    message: 'Lorem ipsum',
    author: 'Alex',
    isAuthorBeingReported: true
  }, {
    message: 'Hey',
    author: 'Alex',
    isAuthorBeingReported: true
  }, {
    message: 'Howdy',
    author: 'Grubba',
    isAuthorBeingReported: false
  }],
  reportAreaOptions: [{
    label: 'xbox.report.area.chat',
    value: 0
  }, {
    label: 'xbox.report.area.skin',
    value: 1
  }, {
    label: 'xbox.report.area.gameplay',
    value: 2
  }, {
    label: 'xbox.report.area.ingame',
    value: 3
  }, {
    label: 'xbox.report.area.other',
    value: 4
  }]
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/profanityFilter.ts
const profanityFilterDefaultState = {
  isProfanityInString: stringToCheck => {
    return !!stringToCheck && stringToCheck.includes('bummer');
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/gamer-icons/gamer-icon-steve.png
const gamer_icon_steve_namespaceObject = __webpack_require__.p + "assets/gamer-icon-steve-db6c7.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/gamer-icons/gamer-icon-pig.png
const gamer_icon_pig_namespaceObject = __webpack_require__.p + "assets/gamer-icon-pig-04391.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/gamer-icons/gamer-icon-alex.png
const gamer_icon_alex_namespaceObject = __webpack_require__.p + "assets/gamer-icon-alex-d725b.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/gamer-icons/gamer-icon-creeper.png
const gamer_icon_creeper_namespaceObject = __webpack_require__.p + "assets/gamer-icon-creeper-ff16b.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/realms/castle-village.jpg
const castle_village_namespaceObject = __webpack_require__.p + "assets/castle-village-8f6fa.jpg";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/realms/grassland-pond.jpg
const grassland_pond_namespaceObject = __webpack_require__.p + "assets/grassland-pond-74fee.jpg";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/realms/nether-portal.jpg
const nether_portal_namespaceObject = __webpack_require__.p + "assets/nether-portal-9acc8.jpg";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/realms/infinity-dungeon.jpg
const infinity_dungeon_namespaceObject = __webpack_require__.p + "assets/infinity-dungeon-45451.jpg";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/fake-world-preview.jpg
const fake_world_preview_namespaceObject = __webpack_require__.p + "assets/fake-world-preview-1eac4.jpg";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmsStories.ts











const CURRENT_TIME_MILLISECONDS = new Date().getTime();
const recentDummySessions = [{
  id: '1',
  login: CURRENT_TIME_MILLISECONDS - 7.2e6,
  // 2 Hours ago
  logout: CURRENT_TIME_MILLISECONDS // now

}, {
  id: '2',
  login: CURRENT_TIME_MILLISECONDS - 10.8e6,
  // 3 Hours ago
  logout: CURRENT_TIME_MILLISECONDS - 9e5 // 15 minutes ago

}, {
  id: '3',
  login: CURRENT_TIME_MILLISECONDS - 16.2e6,
  // 4 Hours and 30 minutes ago
  logout: CURRENT_TIME_MILLISECONDS - 3.6e6 // 1 Hour ago

}, {
  id: '4',
  login: CURRENT_TIME_MILLISECONDS - 24.12e6,
  // 6 Hours and 42 minutes ago
  logout: CURRENT_TIME_MILLISECONDS - 8.28e6 // 2 Hours and 18 minutes aog

}, {
  id: '5',
  login: CURRENT_TIME_MILLISECONDS - 3e7,
  // 8 hours and 20 minutes ago
  logout: CURRENT_TIME_MILLISECONDS - 12e6 // 3 hours and and 20 minutes ago

}];
const fakeGamerTags = ['Binghost', 'Caribooboo', 'Thortoise', 'Patrio', 'ElegantPlant', 'MusicDove', 'FunkyDonkey', 'RundownJonny', 'SteamLarva', 'Albin447', 'Starfishht', 'Zebrawl', 'Bachelord', 'OnixMoon', 'CrookedMelon', 'VainDuckling', 'ControlSage', 'FirstHaunt', 'ShowBirdie', 'Wimpeee', 'Geishadow', 'KaosDragon', 'DonKiwi', 'Falconartist', 'BlandWarlock', 'IckyOx', 'Quinn2000', 'LaserWarhawk', 'JellyBeaver', 'FarmElf', 'Antiger', 'Pionearly', 'Gamermaid', 'Armydillo', 'NosyVillager', 'MarbleHornet', 'XtremeKeith', 'LuchaBeetle', 'RabidRaccoon', 'BeesDotGov', 'Spaladin', 'BeastLee', 'Cyborne', 'Vipersia', 'AdviceDwarf', 'DeviousLich', 'LaserMantis', 'YungBevy', 'FormalWarden', 'Uthando'];
const fakeCommentBodies = ['Cool! I will be there.', 'Yay :)', 'Cool story bro', 'Nice!', `I can't wait to try this :O`, `Sorry, I can't hangout.`, 'Hello darkness my old friend', `Lets Goooooo!`, `I use to be an adventurer until I took an arrow to the knee`, `Yo thats crazy`, `Yasss Queen!`, `Come to Brasil!`, `Notice me senpai, notice me!`, `Please like, comment and subscribe to my channel.`, `Mr Stark I dont feel soo good.`, `I got some chill lofi beats to relax/study to`, `They don't think it be like it is, but it do.`, `Rock and Stone!`, `You're telling me a shrimp fried this rice?!`, `A jorb well done!`, `It doesn't look like anything to me`, `OMG I cant even right now!!`, `What is this chicanery?!`, `How gauche`, `Well actually...`, `Hehehehe :P`, 'HueHueHue', `Ha, you fell for my machinations!`, `I got 99 problems and creepers are definitely one of them`, `If you really wanted to do that, then why wouldn't you do that? Instead you did this.`, `Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc interdum, nunc nec auctor tempus, augue ex vulputate eros, at iaculis orci nisi sit amet ligula. Cras posuere scelerisque vestibulum. Nulla facilisi. Fusce varius cursus sagittis. Proin malesuada porta convallis. Proin blandit justo vel tortor lacinia, nec accumsan enim pulvinar.`, `According to all known laws of aviation, there is no way a bee should be able to fly. Its wings are too small to get its fat little body off the ground. The bee, of course, flies anyway because bees don't care what humans think is impossible.`, `Nulla malesuada pellentesque elit eget gravida cum sociis. Eu tincidunt tortor aliquam nulla facilisi cras fermentum odio. Eget velit aliquet sagittis id consectetur purus ut. Lectus vestibulum mattis ullamcorper velit sed ullamcorper morbi tincidunt ornare. Nunc faucibus a pellentesque sit amet porttitor.`, `Porttitor rhoncus dolor purus non enim praesent elementum. Et malesuada fames ac turpis egestas integer eget. Magna eget est lorem ipsum dolor sit amet consectetur adipiscing.`, `Commodo elit at imperdiet dui accumsan sit amet nulla facilisi. At elementum eu facilisis sed odio. Neque egestas congue quisque egestas. Ultrices tincidunt arcu non sodales. Ut tortor pretium viverra.`, `Quisque porttitor commodo eros. Integer eget dolor vel sem aliquam faucibus. Aenean elit massa, malesuada ut dapibus vitae, fermentum ut dui. Nullam fermentum est rutrum, finibus nulla eget, malesuada arcu. Quisque interdum enim justo, eu vehicula tellus pellentesque vel. Fusce sed nunc vestibulum, condimentum risus et, dapibus lectus.`];
const fakeTimestamps = ['Recently', '20 Minutes Ago', '1 Hour Ago', '2 Hours Ago', '8 Hours Ago', '12 Hours Ago', '21 Hours Ago', 'Yesterday', '2 Days Ago', '3 Days Ago', '4 Days Ago', '1 Week Ago', '2 Weeks Ago', '3 Weeks Ago', '1 Month Ago', '2 Months Ago', '1 Year Ago'];
const demoGamerIcons = [gamer_icon_steve_namespaceObject, gamer_icon_alex_namespaceObject, gamer_icon_creeper_namespaceObject, gamer_icon_pig_namespaceObject, gamer_icon_villager_namespaceObject];
const async_action_run_functions = new Map();
async_action_run_functions.set('TOGGLE_STORY_LIKE', () => {
  console.log('The like on the story has been toggled');
});
async_action_run_functions.set('TOGGLE_COMMENT_LIKE', () => {
  console.log('The like on the comment has been toggled');
});
async_action_run_functions.set('DELETE_COMMENT', () => {
  console.log('Comment has been deleted');
});
async_action_run_functions.set('FETCH_STORY_COMMENTS', () => {
  console.log('The comments on the story have been fetched');
});
async_action_run_functions.set('FETCH_STORY_IMAGE', () => {
  console.log(`The story's image has been fetched`);
});
async_action_run_functions.set('DELETE_STORY', () => {
  console.log('The story has been deleted');
});
async_action_run_functions.set('FETCH_PLAYER_SESSIONS', () => {// Commenting out as it produces a lot of bloat in the unit tests
  // console.log('Player Sessions have been fetched')
});
async_action_run_functions.set('FETCH_REALM_MEMBERS', () => {
  console.log(`The realm members have been fetched`);
});
async_action_run_functions.set('FETCH_REALM_STORIES', () => {
  console.log(`The realm stories have been fetched`);
});
async_action_run_functions.set('POST_STORY', () => {
  console.log('Story has been posted');
});
async_action_run_functions.set('POST_COMMENT', () => {
  console.log('Comment has been posted');
});

function generatePostAsyncAction(key, isToggle = false) {
  return {
    run: async_action_run_functions.get(key),
    cancel: () => false,
    clear: () => {},
    state: isToggle ? AsyncStatefulFunctionState.Completed : AsyncStatefulFunctionState.Completed,
    result: PostResult.SUCCESS
  };
}

function generateFetchAsyncAction(key) {
  return {
    run: async_action_run_functions.get(key),
    cancel: () => false,
    clear: () => {},
    state: AsyncStatefulFunctionState.Completed,
    result: FetchResult.SUCCESS
  };
}

const playerI = {
  gamerTag: 'PlayerUno',
  gamerIcon: gamer_icon_steve_namespaceObject,
  role: RealmPlayerRoleEnum.OPERATOR,
  isOnline: true,
  profileStatus: RealmsStoriesFacetStatus.LOADED,
  recentSessions: [recentDummySessions[0], recentDummySessions[3]],
  fetchSessions: generateFetchAsyncAction('FETCH_PLAYER_SESSIONS')
};
const playerII = {
  gamerTag: 'ToniLi2',
  gamerIcon: gamer_icon_alex_namespaceObject,
  role: RealmPlayerRoleEnum.OPERATOR,
  isOnline: true,
  profileStatus: RealmsStoriesFacetStatus.LOADED,
  recentSessions: [recentDummySessions[1]],
  fetchSessions: generateFetchAsyncAction('FETCH_PLAYER_SESSIONS')
};
const playerIII = {
  gamerTag: 'Doom3rBoi',
  gamerIcon: gamer_icon_creeper_namespaceObject,
  role: RealmPlayerRoleEnum.OPERATOR,
  isOnline: false,
  profileStatus: RealmsStoriesFacetStatus.LOADED,
  recentSessions: [recentDummySessions[2]],
  fetchSessions: generateFetchAsyncAction('FETCH_PLAYER_SESSIONS')
};
const playerIV = {
  gamerTag: 'ForkKnife',
  gamerIcon: gamer_icon_villager_namespaceObject,
  role: RealmPlayerRoleEnum.OPERATOR,
  isOnline: false,
  profileStatus: RealmsStoriesFacetStatus.LOADED,
  recentSessions: [recentDummySessions[3]],
  fetchSessions: generateFetchAsyncAction('FETCH_PLAYER_SESSIONS')
};
const playerV = {
  gamerTag: 'Ember5',
  gamerIcon: gamer_icon_pig_namespaceObject,
  role: RealmPlayerRoleEnum.OPERATOR,
  isOnline: false,
  profileStatus: RealmsStoriesFacetStatus.LOADED,
  recentSessions: [recentDummySessions[4]],
  fetchSessions: generateFetchAsyncAction('FETCH_PLAYER_SESSIONS')
};
const SYSTEM_REALM_PLAYER = {
  gamerTag: 'Minecraft',
  gamerIcon: gamer_icon_villager_namespaceObject,
  role: RealmPlayerRoleEnum.OWNER,
  isOnline: false,
  profileStatus: RealmsStoriesFacetStatus.LOADED,
  recentSessions: [],
  fetchSessions: generateFetchAsyncAction('FETCH_PLAYER_SESSIONS')
};
const fakeRealmMembers = generateMemberList();
const staticComments = [{
  id: '10035',
  storyID: '',
  author: playerII,
  body: `Wow, I can't believe that happened!`,
  timePosted: 'Recently',
  totalLikes: 1,
  hasViewed: false,
  hasLiked: true,
  toggleLike: generatePostAsyncAction('TOGGLE_COMMENT_LIKE', true),
  delete: generatePostAsyncAction('DELETE_COMMENT')
}, {
  id: '10036',
  storyID: '',
  author: playerIII,
  body: `Cool story bro`,
  timePosted: '5 Days Ago',
  totalLikes: 5,
  hasViewed: true,
  hasLiked: false,
  toggleLike: generatePostAsyncAction('TOGGLE_COMMENT_LIKE', true),
  delete: generatePostAsyncAction('DELETE_COMMENT')
}, {
  id: '10037',
  storyID: '',
  author: playerIV,
  body: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.`,
  timePosted: '2 Weeks Ago',
  totalLikes: 0,
  hasViewed: true,
  hasLiked: false,
  toggleLike: generatePostAsyncAction('TOGGLE_COMMENT_LIKE', true),
  delete: generatePostAsyncAction('DELETE_COMMENT')
}, {
  id: '10038',
  storyID: '',
  author: playerV,
  body: `Neque convallis a cras semper auctor neque vitae tempus. Scelerisque eleifend donec pretium vulputate sapien nec sagittis. Ultricies tristique nulla aliquet enim tortor at auctor.`,
  timePosted: '1 Month Ago',
  totalLikes: 0,
  hasViewed: true,
  hasLiked: false,
  toggleLike: generatePostAsyncAction('TOGGLE_COMMENT_LIKE', true),
  delete: generatePostAsyncAction('DELETE_COMMENT')
}];
const dummyRealmStories = [{
  id: '1004',
  author: playerI,
  body: 'Hey miners, in the next coming weeks I will be creating a new world for the Infinity Dungeon resource pack! The world will be up for a couple of months. To celebrate this world’s launch we will be having a weekend event where we can all explore the infinite dungeon together! ',
  timePosted: '8 Hours Ago',
  image: infinity_dungeon_namespaceObject,
  imageStatus: RealmsStoriesFacetStatus.LOADED,
  comments: getRandomComments(21, '1004'),
  commentsStatus: RealmsStoriesFacetStatus.LOADED,
  totalComments: 15,
  totalLikes: 72,
  hasLiked: true,
  hasViewed: false,
  toggleLike: generatePostAsyncAction('TOGGLE_STORY_LIKE', true),
  fetchImage: generateFetchAsyncAction('FETCH_STORY_IMAGE'),
  fetchComments: generateFetchAsyncAction('FETCH_STORY_COMMENTS'),
  delete: generatePostAsyncAction('DELETE_STORY')
}, {
  id: '1003',
  author: SYSTEM_REALM_PLAYER,
  body: 'Member001 created the first Nether Portal in this realm.',
  timePosted: 'Yesterday',
  image: nether_portal_namespaceObject,
  imageStatus: RealmsStoriesFacetStatus.LOADED,
  comments: getRandomComments(7, '1003'),
  commentsStatus: RealmsStoriesFacetStatus.LOADED,
  totalComments: 7,
  totalLikes: 25,
  hasLiked: false,
  hasViewed: true,
  toggleLike: generatePostAsyncAction('TOGGLE_STORY_LIKE', true),
  fetchImage: generateFetchAsyncAction('FETCH_STORY_IMAGE'),
  fetchComments: generateFetchAsyncAction('FETCH_STORY_COMMENTS'),
  delete: generatePostAsyncAction('DELETE_STORY')
}, {
  id: '1002',
  author: playerV,
  body: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam aliquet pulvinar velit et tincidunt. Donec id nisi justo. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam condimentum ex elit. Quisque rhoncus, lorem at malesuada convallis, erat metus vulputate dolor, quis dapibus ex nulla vel nisl. In dapibus condimentum scelerisque.',
  image: grassland_pond_namespaceObject,
  imageStatus: RealmsStoriesFacetStatus.UNLOADED,
  timePosted: '1 Week Ago',
  comments: staticComments,
  commentsStatus: RealmsStoriesFacetStatus.LOADED,
  totalComments: 3,
  totalLikes: 4,
  hasLiked: false,
  hasViewed: true,
  toggleLike: generatePostAsyncAction('TOGGLE_STORY_LIKE', true),
  fetchImage: generateFetchAsyncAction('FETCH_STORY_IMAGE'),
  fetchComments: generateFetchAsyncAction('FETCH_STORY_COMMENTS'),
  delete: generatePostAsyncAction('DELETE_STORY')
}, {
  id: '1001',
  author: playerIV,
  body: 'Progress update on the village of the castle Granite Keep. All block donations are appreciated!',
  timePosted: '2 Weeks Ago',
  image: castle_village_namespaceObject,
  imageStatus: RealmsStoriesFacetStatus.LOADED,
  comments: getRandomComments(30, '1001'),
  commentsStatus: RealmsStoriesFacetStatus.LOADED,
  totalComments: 30,
  totalLikes: 100,
  hasLiked: false,
  hasViewed: true,
  toggleLike: generatePostAsyncAction('TOGGLE_STORY_LIKE', true),
  fetchImage: generateFetchAsyncAction('FETCH_STORY_IMAGE'),
  fetchComments: generateFetchAsyncAction('FETCH_STORY_COMMENTS'),
  delete: generatePostAsyncAction('DELETE_STORY')
}, {
  id: '1000',
  author: playerV,
  body: 'HELP, SOMEONE STOLE MY DIAMONDS! Who ever did it GIVE IT BACK NOW !!1!1 Morbi nec turpis vehicula, molestie mi in, maximus diam. Fusce lobortis lectus a leo molestie, id pellentesque odio feugiat. Nullam id iaculis mauris.',
  timePosted: '1 Month Ago',
  image: '',
  imageStatus: RealmsStoriesFacetStatus.LOADED,
  comments: [],
  commentsStatus: RealmsStoriesFacetStatus.LOADED,
  totalComments: 0,
  totalLikes: 0,
  hasLiked: false,
  hasViewed: true,
  toggleLike: generatePostAsyncAction('TOGGLE_STORY_LIKE', true),
  fetchImage: generateFetchAsyncAction('FETCH_STORY_IMAGE'),
  fetchComments: generateFetchAsyncAction('FETCH_STORY_COMMENTS'),
  delete: generatePostAsyncAction('DELETE_STORY')
}];

function getRandomComments(amount, id) {
  const comments = [];

  for (let i = 0; i < amount; i++) {
    const bodyIndex = Math.floor(Math.random() * fakeCommentBodies.length);
    const tsIndex = Math.floor(Math.random() * fakeTimestamps.length);
    const playerIndex = Math.floor(Math.random() * fakeRealmMembers.length);
    const comment = {
      id: `1000${i}`,
      storyID: id,
      author: fakeRealmMembers[playerIndex],
      body: fakeCommentBodies[bodyIndex],
      timePosted: fakeTimestamps[tsIndex],
      totalLikes: getRandomNumber(11),
      hasViewed: true,
      hasLiked: false,
      toggleLike: generatePostAsyncAction('TOGGLE_STORY_LIKE', true),
      delete: generatePostAsyncAction('DELETE_COMMENT')
    };
    comment.delete = generatePostAsyncAction('DELETE_COMMENT');
    comments.push(comment);
  }

  return comments;
}

const fakeRealmScreenShots = [{
  image: castle_village_namespaceObject,
  filePath: castle_village_namespaceObject,
  lastModifiedTime: CURRENT_TIME_MILLISECONDS,
  printableModifiedTime: 'Recently',
  valid: true
}, {
  image: nether_portal_namespaceObject,
  filePath: nether_portal_namespaceObject,
  lastModifiedTime: CURRENT_TIME_MILLISECONDS - 10000,
  printableModifiedTime: '3 Hours Ago',
  valid: true
}, {
  image: grassland_pond_namespaceObject,
  filePath: grassland_pond_namespaceObject,
  lastModifiedTime: CURRENT_TIME_MILLISECONDS - 100000,
  printableModifiedTime: '3 Days Ago at 12:15pm',
  valid: true
}, {
  image: infinity_dungeon_namespaceObject,
  filePath: infinity_dungeon_namespaceObject,
  lastModifiedTime: CURRENT_TIME_MILLISECONDS - 1000000,
  printableModifiedTime: 'Last Week',
  valid: true
}, {
  image: fake_world_preview_namespaceObject,
  filePath: fake_world_preview_namespaceObject,
  lastModifiedTime: CURRENT_TIME_MILLISECONDS - 2000000,
  printableModifiedTime: '2 Weeks Ago',
  valid: true
}];
const exampleRealmData = {
  id: '523f19',
  stories: Array.from(Array(dummyRealmStories.length).keys()).map(key => {
    var _dummyRealmStories$in, _dummyRealmStories$in2;

    const index = key % dummyRealmStories.length;
    const story = {
      id: `${dummyRealmStories[index].id}`,
      author: dummyRealmStories[index].author,
      body: dummyRealmStories[index].body,
      timePosted: dummyRealmStories[index].timePosted,
      image: dummyRealmStories[index].image,
      imageStatus: dummyRealmStories[index].imageStatus,
      comments: dummyRealmStories[index].comments,
      commentsStatus: dummyRealmStories[index].commentsStatus,
      totalComments: (_dummyRealmStories$in = (_dummyRealmStories$in2 = dummyRealmStories[index].comments) === null || _dummyRealmStories$in2 === void 0 ? void 0 : _dummyRealmStories$in2.length) !== null && _dummyRealmStories$in !== void 0 ? _dummyRealmStories$in : 0,
      totalLikes: dummyRealmStories[index].totalLikes,
      hasLiked: dummyRealmStories[index].hasLiked,
      hasViewed: dummyRealmStories[index].hasViewed,
      toggleLike: generatePostAsyncAction('TOGGLE_STORY_LIKE', true),
      fetchImage: generateFetchAsyncAction('FETCH_STORY_IMAGE'),
      fetchComments: generateFetchAsyncAction('FETCH_STORY_COMMENTS'),
      delete: generatePostAsyncAction('DELETE_STORY')
    };
    return story;
  }),
  members: fakeRealmMembers,
  fetchMembers: generateFetchAsyncAction('FETCH_REALM_MEMBERS'),
  fetchStories: generateFetchAsyncAction('FETCH_REALM_STORIES'),
  localScreenshots: fakeRealmScreenShots,
  localScreenshotsStatus: RealmsStoriesFacetStatus.LOADED
};

function generateMemberList() {
  const randomPlayers = Array.from(Array(50).keys()).map(key => {
    const index = key % fakeGamerTags.length;
    const logoutTime = getRandomNumberInRange(9e7, 1e9);
    return {
      gamerTag: fakeGamerTags[index],
      gamerIcon: demoGamerIcons[getRandomNumber(demoGamerIcons.length)],
      role: key % 3 === 0 ? RealmPlayerRoleEnum.MEMBER : RealmPlayerRoleEnum.VISITOR,
      isOnline: Math.floor(Math.random() * key) < 3,
      profileStatus: RealmsStoriesFacetStatus.LOADED,
      recentSessions: [{
        id: `${index}`,
        login: getRandomNumberInRange(logoutTime, logoutTime + 2.7e7),
        // +6 hours
        logout: CURRENT_TIME_MILLISECONDS - logoutTime
      }],
      fetchSessions: generateFetchAsyncAction('FETCH_PLAYER_SESSIONS')
    };
  });
  return [...randomPlayers, playerI, playerII, playerIII, playerIV, playerV];
}

function getRandomNumber(max) {
  return Math.floor(Math.random() * max);
}

function getRandomNumberInRange(min, max) {
  return Math.floor(Math.random() * (max - min));
}

const blankRealmPersistentData = {
  currentStoryId: '',
  postInProgressBody: '',
  storyScreenshotSelectionFilePath: '',
  currentMemberFilterOption: RealmMemberFilterOption.All,
  currentMemberSearchText: '',
  currentMemberSortOption: RealmMemberSortOption.MostRecent
};
const testRealmActions = {
  postStory: generatePostAsyncAction('POST_STORY'),
  postComment: generatePostAsyncAction('POST_COMMENT')
};
const realmsStoriesSharedFacetDefaultState = {
  status: RealmsStoriesFacetStatus.LOADED,
  data: exampleRealmData,
  persistentData: blankRealmPersistentData,
  actions: testRealmActions
};
const realmsStoriesFacetLoading = {
  status: RealmsStoriesFacetStatus.LOADING,
  data: {
    id: '0',
    stories: [],
    members: [],
    localScreenshots: [],
    localScreenshotsStatus: RealmsStoriesFacetStatus.LOADING,
    fetchMembers: generateFetchAsyncAction('FETCH_REALM_MEMBERS'),
    fetchStories: generateFetchAsyncAction('FETCH_REALM_STORIES')
  },
  persistentData: blankRealmPersistentData,
  actions: testRealmActions
};
const realmsStoriesDemoFacet = {
  status: RealmsStoriesFacetStatus.LOADED,
  data: {
    id: '1000',
    stories: [dummyRealmStories[2]],
    members: [playerI, playerII, playerIII, playerIV, playerV],
    localScreenshots: fakeRealmScreenShots,
    localScreenshotsStatus: RealmsStoriesFacetStatus.LOADED,
    fetchMembers: generateFetchAsyncAction('FETCH_REALM_MEMBERS'),
    fetchStories: generateFetchAsyncAction('FETCH_REALM_STORIES')
  },
  persistentData: blankRealmPersistentData,
  actions: testRealmActions
};
const blankRealmStory = {
  id: '73874589-534e-41c8-94ec-f5f77b94ccf2',
  author: SYSTEM_REALM_PLAYER,
  body: '',
  timePosted: '',
  image: grassland_pond_namespaceObject,
  comments: [],
  totalComments: 0,
  totalLikes: 20,
  hasLiked: false,
  hasViewed: true,
  toggleLike: generatePostAsyncAction('TOGGLE_STORY_LIKE', true),
  fetchImage: generateFetchAsyncAction('FETCH_STORY_IMAGE'),
  fetchComments: generateFetchAsyncAction('FETCH_STORY_COMMENTS'),
  delete: generatePostAsyncAction('DELETE_STORY')
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/screenTechStack.ts

const screenTechStackFacetDefaultState = {
  getTechStackForScreen: () => UITechStack.OreUI,
  selectTechStackForScreen: () => {}
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/abandoned-village.png
const abandoned_village_namespaceObject = __webpack_require__.p + "assets/abandoned-village-a58af.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/coastal-village.png
const coastal_village_namespaceObject = __webpack_require__.p + "assets/coastal-village-d7104.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/desert-village.png
const desert_village_namespaceObject = __webpack_require__.p + "assets/desert-village-c7d0b.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/outpost-ahead.png
const outpost_ahead_namespaceObject = __webpack_require__.p + "assets/outpost-ahead-d8b8f.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/seedTemplates.ts




const fakeSeedTemplateData = [{
  title: 'Snowy Village',
  image: undefined,
  seedValue: '22061'
}, {
  title: 'Epic Jungle',
  image: undefined,
  seedValue: '-786098485'
}, {
  title: 'Taiga Village',
  image: undefined,
  seedValue: '-1943825025'
}, {
  title: 'Desert Village',
  image: desert_village_namespaceObject,
  seedValue: '1738801'
}, {
  title: 'Survival Island',
  image: undefined,
  seedValue: '-509091417'
}, {
  title: 'Outpost Ahead',
  image: outpost_ahead_namespaceObject,
  seedValue: '300746916'
}, {
  title: 'Coastal Village',
  image: coastal_village_namespaceObject,
  seedValue: '280548954'
}, {
  title: 'Abandoned Village',
  image: abandoned_village_namespaceObject,
  seedValue: '0'
}, {
  title: 'Taiga Bay',
  image: undefined,
  seedValue: '1371621129'
}];
const seedTemplatesSharedFacetDefaultState = {
  templates: fakeSeedTemplateData,
  failedToFetch: false
};
const seedTemplatesSharedFacetEmptyState = {
  templates: [],
  failedToFetch: false
};
const seedTemplatesSharedFacetFailedState = {
  templates: [],
  failedToFetch: true
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/simulationDistance.ts
const simulationDistanceSharedFacetDefaultState = {
  simulationDistanceOptions: [4, 6, 8, 10]
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/telemetry.ts
const telemetrySharedFacetDefaultState = {
  fireEventButtonPressed: (buttonName, details) => {
    console.log(buttonName, details);
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/userAccount.ts
const userAccountSharedFacetDefaultState = {
  hasPremiumNetworkAccess: true,
  isLoggedInWithMicrosoftAccount: false,
  isTrialAccount: false,
  hasValidCrossPlatformSkin: true,

  showPremiumNetworkUpsellModal() {},

  showMicrosoftAccountLogInScreen() {}

};
const userAccountFacetTrialMode = {
  hasPremiumNetworkAccess: true,
  isLoggedInWithMicrosoftAccount: false,
  isTrialAccount: true,
  hasValidCrossPlatformSkin: true,

  showPremiumNetworkUpsellModal() {},

  showMicrosoftAccountLogInScreen() {}

}; // Function to make visual regression testing easier

function getUserAccountFacetData({
  hasPremiumNetworkAccess = false,
  isLoggedInWithMicrosoftAccount = true
}) {
  return {
    hasPremiumNetworkAccess: hasPremiumNetworkAccess,
    isLoggedInWithMicrosoftAccount: isLoggedInWithMicrosoftAccount,
    isTrialAccount: false,
    hasValidCrossPlatformSkin: true,

    showPremiumNetworkUpsellModal() {},

    showMicrosoftAccountLogInScreen() {}

  };
}
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/webBrowser.ts
const webBrowserFacetDefaultState = {
  openLink: link => {
    console.log(`Clicked on link ${link}`);
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/world-preview-default.jpg
const seedTemplateImages_world_preview_default_namespaceObject = __webpack_require__.p + "assets/world-preview-default-a8cf0.jpg";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/world-preview-wrong-dimensions_1.png
const world_preview_wrong_dimensions_1_namespaceObject = __webpack_require__.p + "assets/world-preview-wrong-dimensions_1-29081.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/world-preview-wrong-dimensions_2.png
const world_preview_wrong_dimensions_2_namespaceObject = __webpack_require__.p + "assets/world-preview-wrong-dimensions_2-2a704.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/worldList.ts







const worldList_currentGameVersion = {
  major: 1,
  minor: 19,
  patch: 0,
  revision: 0,
  isBeta: false
};
const oldGameVersion = {
  major: 1,
  minor: 18,
  patch: 0,
  revision: 0,
  isBeta: false
};
const worldList_images = [abandoned_village_namespaceObject, world_preview_wrong_dimensions_1_namespaceObject, coastal_village_namespaceObject, desert_village_namespaceObject, seedTemplateImages_world_preview_default_namespaceObject, outpost_ahead_namespaceObject, world_preview_wrong_dimensions_2_namespaceObject];
const worldIDs = ['L1XqY0sPAQA=', 'L2XqY0sPAQA=', 'L3XqY0sPAQA=', 'L4XqY0sPAQA=', 'L5XqY0sPAQA=', 'L6XqY0sPAQA=', 'L7XqY0sPAQA=', 'L8XqY0sPAQA=', 'bad-world'];
const worldNames = ['My world 1', 'My world 2', 'My world but with a long name 3', 'My world 4', 'Copy My world 5', 'My world 6', 'My world 7', 'Experimental World', 'Bad World'];
const gameVersion = [worldList_currentGameVersion, worldList_currentGameVersion, worldList_currentGameVersion, worldList_currentGameVersion, worldList_currentGameVersion, worldList_currentGameVersion, worldList_currentGameVersion, oldGameVersion, worldList_currentGameVersion];
const isExperimental = [false, false, false, false, false, false, false, true, false];
const lastPlayedDates = [1665460196, 1665461196, 1665462196, 1665463196, 1665464196, 1665465196, 1665466196, 1665467196, 1665468196, 1665469196, 1665470196, 1665471196];
const worlds = [...new Array(9)].map((_, i) => ({
  id: worldIDs[i],
  name: worldNames[i],
  lastPlayed: lastPlayedDates[i],
  gameMode: i % 3,
  fileSize: '30 MB',
  previewImgPath: worldList_images[i % worldList_images.length],
  isExperimental: isExperimental[i],
  gameVersion: gameVersion[i]
}));
const worldsMissingEntitlement = [...new Array(5)].map((_, i) => ({
  id: worldIDs[i],
  name: `World ${i + 1} missing entitlement `,
  lastPlayed: lastPlayedDates[i],
  gameMode: i % 3,
  fileSize: '30 MB',
  previewImgPath: worldList_images[i % worldList_images.length],
  isExperimental: isExperimental[i],
  gameVersion: gameVersion[i]
}));
const worldListSharedFacetDefaultState = {
  localWorlds: worlds
};
const worldListSharedFacetEmptyState = {
  localWorlds: []
};
const worldListSharedFacetMissingEntitlementState = {
  localWorlds: worlds,
  localWorldsWithoutEntitlement: worldsMissingEntitlement
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/worldStartup.ts
const worldStartupSharedFacetDefaultState = {
  startLocalWorld: {
    run: worldId => {
      console.log(`Starting local world with id: ${worldId}`);
    },
    clear: () => {}
  }
};
function worldStartupSharedFacetWithResult(result) {
  return {
    startLocalWorld: {
      run: worldId => {
        console.log(`Starting local world with id: ${worldId}`);
      },
      clear: () => {},
      result: result
    }
  };
}
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/worldTemplateList.ts
const templateNames = ['SkyBlocks', 'Furniture Fury', 'Minecraft Fortress 2'];
const worldTemplateListSharedFacetDefaultState = {
  premiumTemplates: templateNames.map(name => ({
    name
  })),
  customTemplates: []
};
const worldTemplateListSharedFacetEmptyState = {
  premiumTemplates: [],
  customTemplates: []
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/worldTransfer.ts
function worldTransfer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function worldTransfer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { worldTransfer_ownKeys(Object(source), true).forEach(function (key) { worldTransfer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { worldTransfer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function worldTransfer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const worldTransferSharedFacetDefaultState = {
  importWorld: {
    progress: 0,
    result: undefined,
    state: AsyncStatefulFunctionState.Idle,
    run: () => {
      console.log(`Import world from local files`);
    },
    clear: () => {},
    cancel: () => true
  }
};
function worldTransferSharedFacetWithProgress(progress) {
  return worldTransfer_objectSpread(worldTransfer_objectSpread({}, worldTransferSharedFacetDefaultState), {}, {
    importWorld: worldTransfer_objectSpread(worldTransfer_objectSpread({}, worldTransferSharedFacetDefaultState.importWorld), {}, {
      progress
    })
  });
}
function worldTransferSharedFacetWithResult(result) {
  return worldTransfer_objectSpread(worldTransfer_objectSpread({}, worldTransferSharedFacetDefaultState), {}, {
    importWorld: worldTransfer_objectSpread(worldTransfer_objectSpread({}, worldTransferSharedFacetDefaultState.importWorld), {}, {
      result
    })
  });
}
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/index.ts

























;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryCommentItem/RealmStoryCommentItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmStoryCommentItem = ({"container":"FpN0b","detailsSection":"ncVDY","interactiveBorder":"WvU3_","contentOuter":"VxQ9V","contentInnerWrapper":"OzWSm","contentSection":"rTBvd"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryCommentItem/images/heart_outline.png
const RealmStoryCommentItem_images_heart_outline_namespaceObject = __webpack_require__.p + "assets/heart_outline-84139.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryCommentItem/images/heart_sprite.png
const RealmStoryCommentItem_images_heart_sprite_namespaceObject = __webpack_require__.p + "assets/heart_sprite-88957.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryCommentItem/images/options.png
const RealmStoryCommentItem_images_options_namespaceObject = __webpack_require__.p + "assets/options-9456a.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryCommentItem/RealmStoryCommentItem.tsx













function RealmStoryCommentItem_RealmStoryCommentItem({
  comment,
  index,
  role = 'inherit'
}) {
  const {
    t
  } = useLocalization('RealmsStoryCommentsRoute');
  const commentBody = (0,react_facet_src.useFacetMap)(c => c.body, [], [comment]);
  const dateTimePosted = (0,react_facet_src.useFacetMap)(c => c.timePosted, [], [comment]);
  const authorGamerTag = (0,react_facet_src.useFacetMap)(c => c.author.gamerTag, [], [comment]);
  const likeIcon = (0,react_facet_src.useFacetMap)(c => c.hasLiked === true ? RealmStoryCommentItem_images_heart_sprite_namespaceObject : RealmStoryCommentItem_images_heart_outline_namespaceObject, [], [comment]);
  const likeButtonRole = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(c => c.hasLiked ? 'primary' : 'neutral', [], [comment]));
  const commentLikes = (0,react_facet_src.useFacetMap)(c => c.totalLikes, [], [comment]);
  const toggleCommentLike = (0,react_facet_src.useFacetCallback)(comment => () => {
    comment.toggleLike.run();
  }, [], [comment]);
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensCollectionProvider, {
    collection: realmsTokens
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmStoryCommentItem.container
  }, /*#__PURE__*/react.createElement(ListItem_ListItem, {
    gamepadIndex: index
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(RealmStoryCommentItem.interactiveBorder, RealmStoryCommentItem.detailsSection)
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.Main, {
    role: "neutral"
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit"
  }, authorGamerTag), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "grey"
  }, dateTimePosted))), /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 0,
    narrationText: t('.likeComment'),
    inputLegend: t('.likeComment'),
    onClick: toggleCommentLike,
    role: likeButtonRole === react_facet_src.NO_VALUE ? 'neutral' : likeButtonRole
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: likeIcon
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionTiny",
    color: "inherit"
  }, commentLikes)), /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 1,
    narrationText: t('.commentOptions'),
    inputLegend: t('.commentOptions'),
    onClick: () => {}
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: RealmStoryCommentItem_images_options_namespaceObject
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionTiny",
    color: "inherit"
  }, t('.options')))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(RealmStoryCommentItem.contentOuter, semanticClassNames.background.base, semanticClassNames.border)
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmStoryCommentItem.contentInnerWrapper
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmStoryCommentItem.contentSection
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "white"
  }, commentBody))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoryCommentsRoute/RealmsStoryCommentsRoute.tsx
















var CommentScreenStepEnum;

(function (CommentScreenStepEnum) {
  CommentScreenStepEnum[CommentScreenStepEnum["View"] = 0] = "View";
  CommentScreenStepEnum[CommentScreenStepEnum["Create"] = 1] = "Create";
})(CommentScreenStepEnum || (CommentScreenStepEnum = {}));

function RealmsStoryCommentsRoute_RealmsStoryCommentsRoute() {
  const historyAPI = RouteHistory_useRouteHistory();
  const breakpoint = useWindowBreakpoint();
  const {
    t
  } = useLocalization('RealmsStoryCommentsRoute');
  const [commentScreenStep, setCommentScreenStep] = (0,react_facet_src.useFacetState)(CommentScreenStepEnum.View);
  const [displayError, setDisplayError] = (0,react_facet_src.useFacetState)(false);
  const params = useRouteParams();
  const storyID = decodeURIComponent(params.id);
  const facetComments = (0,react_facet_src.useSharedFacet)(realmStoryCommentsSelector(storyID));
  const facetData = (0,react_facet_src.useSharedFacet)(realmStorySelector(storyID));
  const isRealmStoryLoaded = (0,react_facet_src.useFacetMap)(data => data.realmStory != null, [], [facetData]);
  const realmStory = (0,react_facet_src.useFacetMap)(data => {
    var _data$realmStory;

    return (_data$realmStory = data.realmStory) !== null && _data$realmStory !== void 0 ? _data$realmStory : blankRealmStory;
  }, [], [facetData]);
  const totalComments = (0,react_facet_src.useFacetMap)(data => {
    var _data$realmStory2;

    return data.isCommentsLoaded && (_data$realmStory2 = data.realmStory) !== null && _data$realmStory2 !== void 0 && _data$realmStory2.comments ? data.realmStory.comments.length : 0;
  }, [], [facetData]);
  const headerText = (0,react_facet_src.useFacetMap)(totalComments => t('.header', [`${totalComments}`]), [t], [totalComments]);
  const hasComments = (0,react_facet_src.useFacetMap)(total => total > 0, [], [totalComments]);
  const footerGamepadIndex = (0,react_facet_src.useFacetMap)(total => total + 1, [], [totalComments]);
  const isViewCommentsStep = (0,react_facet_src.useFacetMap)(commentScreenStep => commentScreenStep === CommentScreenStepEnum.View, [], [commentScreenStep]);
  const realmActionsFacet = (0,react_facet_src.useFacetMap)(facet => facet.actions, [], [(0,react_facet_src.useSharedFacet)(realmsStoriesFacet)]);
  const realmPersistentDataFacet = (0,react_facet_src.useFacetMap)(facet => {
    facet.persistentData.currentStoryId = storyID;
    return facet.persistentData;
  }, [storyID], [(0,react_facet_src.useSharedFacet)(realmsStoriesFacet)]);
  (0,react_facet_src.useFacetEffect)(data => {
    var _data$realmStory3;

    if (data.isCommentsLoaded && ((_data$realmStory3 = data.realmStory) === null || _data$realmStory3 === void 0 ? void 0 : _data$realmStory3.comments) == null) {
      historyAPI.goBack();
    }
  }, [historyAPI], [facetData]);
  const resetPersistentDataValues = (0,react_facet_src.useFacetCallback)((value, actions) => () => {
    value.postInProgressBody = '';
    value.currentStoryId = '';
    actions.postComment.clear();
  }, [], [realmPersistentDataFacet, realmActionsFacet]);
  const resetCommentBodyValue = (0,react_facet_src.useFacetCallback)(value => () => {
    value.postInProgressBody = '';
  }, [], [realmPersistentDataFacet]);
  const onWritePostClickHandler = (0,react_facet_src.useFacetCallback)((actions, commentScreenStep) => () => {
    if (commentScreenStep === CommentScreenStepEnum.Create) {
      actions.postComment.run();

      if (actions.postComment.result == null) {
        setCommentScreenStep(CommentScreenStepEnum.View);
      } else if (actions.postComment.result !== PostResult.SUCCESS) {
        setDisplayError(true);
      }
    } else {
      setCommentScreenStep(CommentScreenStepEnum.Create);
    }
  }, [setDisplayError, setCommentScreenStep], [realmActionsFacet, commentScreenStep]);
  const onBackButtonClickHandler = (0,react_facet_src.useFacetCallback)(commentScreenStep => () => {
    if (commentScreenStep == CommentScreenStepEnum.View) {
      resetPersistentDataValues();
      historyAPI.goBack();
    } else {
      resetCommentBodyValue();
      setCommentScreenStep(CommentScreenStepEnum.View);
    }
  }, [resetPersistentDataValues, resetCommentBodyValue, setCommentScreenStep, historyAPI], [commentScreenStep]);
  const onAcknowledgeErrorHandler = (0,react_facet_src.useFacetCallback)(actions => () => {
    setDisplayError(false);
    actions.postComment.clear();
    resetCommentBodyValue();
    setCommentScreenStep(CommentScreenStepEnum.View);
  }, [setDisplayError, setCommentScreenStep, resetCommentBodyValue], [realmActionsFacet]);
  return /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensCollectionProvider, {
    collection: realmsTokens
  }, /*#__PURE__*/react.createElement(GlassPane_GlassPane, {
    role: "primary"
  }, /*#__PURE__*/react.createElement(RealmsStoriesErrorModal, {
    isVisible: displayError,
    onClose: onAcknowledgeErrorHandler,
    variant: "comment-post"
  }), /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout, {
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: onBackButtonClickHandler
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography, {
      variant: "header5A",
      color: "black"
    }, headerText),
    footer: /*#__PURE__*/react.createElement(react_facet_src.Mount, {
      when: isViewCommentsStep,
      condition: false
    }, /*#__PURE__*/react.createElement(Panel_Panel, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
      variant: "primary",
      gamepadIndex: footerGamepadIndex,
      onClick: onWritePostClickHandler,
      inputLegend: t('.postComment'),
      autofocus: true,
      disabled: (0,react_facet_src.useFacetMap)(persistentData => persistentData.postInProgressBody === '', [], [realmPersistentDataFacet])
    }, t('.postComment'))))
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isViewCommentsStep
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmsStoryCommentsRoute.realmsBackground
  }, /*#__PURE__*/react.createElement(Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 4,
    narrowSize: 3
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isRealmStoryLoaded
  }, /*#__PURE__*/react.createElement(RealmSideStoryPost_RealmSideStoryPost, {
    onWriteStoryClick: onWritePostClickHandler,
    realmStory: realmStory
  }))), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 2,
    wideSize: 8,
    narrowSize: 5
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasComments
  }, /*#__PURE__*/react.createElement(FlatList, {
    gamepadIndex: 0,
    data: facetComments,
    renderItem: ({
      itemFacet,
      index
    }) => /*#__PURE__*/react.createElement(RealmStoryCommentItem_RealmStoryCommentItem, {
      comment: itemFacet,
      index: index
    })
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasComments,
    condition: false
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    title: t('.noCommentsTitle'),
    text: t('.noCommentsBody'),
    imgSrc: enderman_holding_dirt_namespaceObject,
    borderless: true
  }))))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isViewCommentsStep,
    condition: false
  }, /*#__PURE__*/react.createElement(Panel_Panel, {
    style: {
      width: '100%',
      verticalAlign: 'middle'
    }
  }, /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, null, t('.leaveComment')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(BaseTextField_BaseTextField, {
    value: (0,react_facet_src.useFacetMemo)(value => value.postInProgressBody, [], [realmPersistentDataFacet]),
    narrationText: false,
    maxLength: 350,
    placeholder: t('.commentEllipses'),
    rows: breakpoint === 'narrow' ? 20 : 60,
    onChange: (0,react_facet_src.useFacetCallback)(value => newValue => {
      value.postInProgressBody = newValue;
    }, [], [realmPersistentDataFacet])
  }))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsImagePicker/RealmsImagePicker.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmsImagePicker = ({"image":"PtGyl","imageContainer":"oIK_p","checkboxContainer":"Ay1YH","noScreenshotsImage":"pUFem","darkBorder":"QBoHS","lightBorder":"a4Bzp"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsImagePicker/images/no-screenshots-animal-picture.gif
const no_screenshots_animal_picture_namespaceObject = __webpack_require__.p + "assets/no-screenshots-animal-picture-3a1f7.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsImagePicker/RealmsImagePicker.tsx










function RealmsImagePicker_RealmsImagePicker({
  screenshots,
  selectedImage,
  onSelect,
  startIndex
}) {
  const breakpoint = useWindowBreakpoint();
  const {
    t
  } = useLocalization('RealmsStories.imagePicker');
  return /*#__PURE__*/react.createElement(GridList_GridList, {
    gamepadIndex: 0,
    columns: 2,
    firstRowSeparatorVertical: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 1
    }),
    itemSeparatorHorizontal: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: breakpoint === 'narrow' ? 1 : 3
    }),
    itemSeparatorVertical: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: breakpoint === 'narrow' ? 2 : 4
    }),
    renderItem: ({
      itemFacet,
      index
    }) => /*#__PURE__*/react.createElement(ScreenshotContainer, {
      screenshot: itemFacet,
      selectedImage: selectedImage,
      onSelect: onSelect,
      t: t,
      index: startIndex + index
    }),
    data: screenshots,
    emptyMessage: /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
      gamepadIndex: 1,
      title: t('.noScreenshotsMessageTitle'),
      text: t('.noScreenshotsMessageBody'),
      imgSrc: no_screenshots_animal_picture_namespaceObject,
      imgClass: RealmsImagePicker.noScreenshotsImage,
      borderless: true
    })
  });
}

function ScreenshotContainer({
  screenshot,
  selectedImage,
  onSelect,
  t,
  index
}) {
  const [isSelected, setSelected] = (0,react_facet_src.useFacetState)(false);
  const image = (0,react_facet_src.useFacetMap)(s => s.image, [], [screenshot]);
  const lastModifiedTime = (0,react_facet_src.useFacetMap)(s => s.printableModifiedTime, [], [screenshot]);
  const selectionText = (0,react_facet_src.useFacetMap)(isSelected => isSelected ? t('.isSelected') : t('.notSelected'), [t], [isSelected]);
  const handleScreenshotClick = (0,react_facet_src.useFacetCallback)((screenshot, isSelected) => () => {
    if (isSelected) {
      onSelect('', '');
    } else {
      onSelect(screenshot.filePath, screenshot.image);
    }
  }, [onSelect], [screenshot, isSelected]);
  (0,react_facet_src.useFacetEffect)((screenshot, selectedImage) => {
    setSelected(screenshot.image === selectedImage);
  }, [setSelected], [screenshot, selectedImage]);
  const narrationText = `${image} . ${lastModifiedTime} . ${selectionText}`;
  const selectedStyle = (0,react_facet_src.useFacetMap)(isSelected => classnames_default()(RealmsImagePicker.imageContainer, isSelected ? RealmsImagePicker.lightBorder : RealmsImagePicker.darkBorder), [], [isSelected]);
  return /*#__PURE__*/react.createElement("div", {
    className: RealmsImagePicker.screenshotContainer
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: selectedStyle,
    onClick: handleScreenshotClick
  }, /*#__PURE__*/react.createElement("span", {
    className: RealmsImagePicker.checkboxContainer
  }, /*#__PURE__*/react.createElement(BaseCheckbox_BaseCheckbox, {
    value: isSelected,
    narrationText: narrationText,
    gamepad: {
      index: index
    }
  })), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: image,
    className: RealmsImagePicker.image
  })), /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "paragraphs",
    align: "right"
  }, lastModifiedTime));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryRoute/RealmsNewStoryRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmsNewStoryRoute = ({"screenBackground":"E8Kk1","largeThumbnail":"VIamv","noImageContainer":"Yx2BY","imageContainer":"XhMe3","noImageText":"kDJ9j","imagePickerContainer":"KtCLa","writeStoryContainer":"wmyG_"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryRoute/RealmsNewStoryRoute.tsx













var NewStoryWizardStep;

(function (NewStoryWizardStep) {
  NewStoryWizardStep[NewStoryWizardStep["ImageSelect"] = 0] = "ImageSelect";
  NewStoryWizardStep[NewStoryWizardStep["WriteStory"] = 1] = "WriteStory";
})(NewStoryWizardStep || (NewStoryWizardStep = {}));

function RealmsNewStoryRoute_RealmsNewStoryRoute() {
  const historyAPI = RouteHistory_useRouteHistory();
  const breakpoint = useWindowBreakpoint();
  const {
    t
  } = useLocalization('RealmsNewStoryRoute');
  const [wizardStep, setWizardStep] = (0,react_facet_src.useFacetState)(NewStoryWizardStep.WriteStory);
  const [selectedImage, setSelectedImage] = (0,react_facet_src.useFacetState)('');
  const [previousImage, setPreviousImage] = (0,react_facet_src.useFacetState)('');
  const [storyHasImage, setStoryHasImage] = (0,react_facet_src.useFacetState)(false);
  const [displayError, setDisplayError] = (0,react_facet_src.useFacetState)(false);
  const realmsStories = (0,react_facet_src.useSharedFacet)(realmsStoriesFacet);
  const isSelectImageStep = (0,react_facet_src.useFacetMap)(step => step === NewStoryWizardStep.ImageSelect, [], [wizardStep]);
  const headerText = (0,react_facet_src.useFacetMap)(step => step === NewStoryWizardStep.ImageSelect ? t('.selectScreenshot') : t('.header'), [t], [wizardStep]);
  const localScreenshots = (0,react_facet_src.useFacetMap)(facet => facet.data.localScreenshots, [], [realmsStories]);
  const persistentData = (0,react_facet_src.useFacetMap)(facet => facet.persistentData, [], [realmsStories]);
  const realmActions = (0,react_facet_src.useFacetMap)(facet => facet.actions, [], [realmsStories]);
  const textFieldRows = breakpoint === 'desktop' ? 16 : 4;
  const isPostEmpty = (0,react_facet_src.useFacetMap)(persistentData => persistentData.postInProgressBody === '' && persistentData.storyScreenshotSelectionFilePath === '', [], [persistentData]);
  const onGoBackHandler = (0,react_facet_src.useFacetCallback)((value, step, previousImage) => () => {
    if (step === NewStoryWizardStep.WriteStory) {
      value.storyScreenshotSelectionFilePath = '';
      value.postInProgressBody = '';
      setSelectedImage('');
      setWizardStep(NewStoryWizardStep.WriteStory);
      historyAPI.goBack();
    } else {
      setSelectedImage(previousImage);
      setWizardStep(NewStoryWizardStep.WriteStory);
    }
  }, [setSelectedImage, setWizardStep, historyAPI], [persistentData, wizardStep, previousImage]);
  const onScreenshotSelectHandler = (0,react_facet_src.useFacetCallback)(value => (imagePath, image) => {
    value.storyScreenshotSelectionFilePath = imagePath;
    setSelectedImage(image);
  }, [setSelectedImage], [persistentData]);
  const onNextButtonHandler = (0,react_facet_src.useFacetCallback)(wizardStep => () => {
    if (wizardStep === NewStoryWizardStep.ImageSelect) {
      setWizardStep(NewStoryWizardStep.WriteStory);
    }
  }, [setWizardStep], [wizardStep]);
  const onPostNewStoryHandler = (0,react_facet_src.useFacetCallback)(actions => () => {
    actions.postStory.run();

    if (actions.postStory.result !== PostResult.SUCCESS) {
      setDisplayError(true);
    }
  }, [setDisplayError], [realmActions]);
  const onImagePickerStepHandler = (0,react_facet_src.useFacetCallback)(selectedImage => () => {
    setWizardStep(NewStoryWizardStep.ImageSelect);
    setPreviousImage(selectedImage);
  }, [setWizardStep, setPreviousImage], [selectedImage]);
  const onAcknowledgeErrorHandler = (0,react_facet_src.useFacetCallback)(actions => () => {
    setDisplayError(false);
    actions.postStory.clear();
  }, [setDisplayError], [realmActions]);
  (0,react_facet_src.useFacetEffect)(selectedImage => {
    setStoryHasImage(selectedImage !== '');
  }, [setStoryHasImage], [selectedImage]); // Responsive Styles

  const writeStoryContainerStyles = classnames_default()({
    [RealmsNewStoryRoute.writeStoryContainer]: breakpoint === 'desktop'
  });
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane, {
    role: "primary"
  }, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout, {
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: onGoBackHandler
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography, {
      variant: "header5A",
      color: "black"
    }, headerText),
    footer: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
      when: isSelectImageStep
    }, /*#__PURE__*/react.createElement(Panel_Panel, {
      style: {
        flexDirection: 'row',
        paddingTop: '1rem',
        paddingBottom: '1rem'
      }
    }, /*#__PURE__*/react.createElement(Button_Button_Button, {
      inputLegend: t('.cancel'),
      onClick: onGoBackHandler,
      horizontal: true
    }, t('.cancel')), /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 4
    }), /*#__PURE__*/react.createElement(Button_Button_Button, {
      inputLegend: t('.next'),
      onClick: onNextButtonHandler,
      variant: "primary",
      horizontal: true
    }, t('.next')))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
      when: isSelectImageStep,
      condition: false
    }, /*#__PURE__*/react.createElement(Panel_Panel, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
      inputLegend: t('.post'),
      onClick: onPostNewStoryHandler,
      variant: "primary",
      disabled: isPostEmpty
    }, t('.post')))))
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmsNewStoryRoute.screenBackground
  }, /*#__PURE__*/react.createElement(RealmsStoriesErrorModal, {
    isVisible: displayError,
    onClose: onAcknowledgeErrorHandler,
    variant: "story-post"
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isSelectImageStep
  }, /*#__PURE__*/react.createElement(Grid_Grid, null, /*#__PURE__*/react.createElement("div", {
    className: RealmsNewStoryRoute.imagePickerContainer
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 2,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: -1,
    wideSize: 2,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 3,
    wideSize: 8,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(RealmsImagePicker_RealmsImagePicker, {
    screenshots: localScreenshots,
    selectedImage: selectedImage,
    onSelect: onScreenshotSelectHandler,
    startIndex: 4
  })), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: -1,
    wideSize: 2,
    narrowSize: 0
  }))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isSelectImageStep,
    condition: false
  }, /*#__PURE__*/react.createElement("div", {
    className: writeStoryContainerStyles
  }, /*#__PURE__*/react.createElement(Grid_Grid, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 5,
    narrowSize: 4
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmsNewStoryRoute.imageContainer
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: storyHasImage
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: selectedImage,
    className: RealmsNewStoryRoute.largeThumbnail
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: storyHasImage,
    condition: false
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmsNewStoryRoute.noImageContainer
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmsNewStoryRoute.noImageText
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    align: "center",
    verticalAlign: "center"
  }, t('.noImageSelected')))))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.selectScreenshot'),
    variant: "secondary",
    onClick: onImagePickerStepHandler
  }, t('.selectTheScreenshot'))), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 2,
    wideSize: 7,
    narrowSize: 4
  }, /*#__PURE__*/react.createElement(BaseTextField_BaseTextField, {
    rows: textFieldRows,
    maxLength: 350,
    placeholder: t('.textBoxPlaceholder'),
    value: (0,react_facet_src.useFacetMap)(persistentData => persistentData.postInProgressBody, [], [persistentData]),
    onChange: (0,react_facet_src.useFacetCallback)(persistentData => newValue => {
      persistentData.postInProgressBody = newValue;
    }, [], [persistentData]),
    narrationText: (0,react_facet_src.useFacetMap)(persistentData => persistentData.postInProgressBody, [], [persistentData])
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 6
  })))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/EditWorldRoute.tsx











const EditWorldRoute = () => {
  const editWorldSharedFacet = (0,react_facet_src.useSharedFacet)(editWorldFacet);
  const editWorldMultiplayerSelectorFacet = (0,react_facet_src.useSharedFacet)(editWorldMultiplayerSelector);
  const editWorldAdvancedSelectorFacet = (0,react_facet_src.useSharedFacet)(advancedSettingsSelectorEditWorld);
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const worldStartupSharedFacet = (0,react_facet_src.useSharedFacet)(worldStartupFacet_worldStartupFacet);
  const worldId = useWorldID();
  const historyAPI = RouteHistory_useRouteHistory();
  const willPlay = (0,react.useRef)(false);
  (0,react_facet_src.useFacetEffect)((facet, worldStartupFacet) => {
    const wasSaved = facet.saveLocalWorld.state === AsyncStatefulFunctionState.Completed;

    if (worldId != null && wasSaved) {
      if (willPlay.current === true) {
        worldStartupFacet.startLocalWorld.run(worldId);
      } else {
        historyAPI.goBack();
      }

      return () => {
        facet.closeWorld(worldId);
        facet.saveLocalWorld.clear();
      };
    }
  }, [worldId, historyAPI, willPlay], [editWorldSharedFacet, worldStartupSharedFacet]);
  const loadWorld = (0,react_facet_src.useFacetCallback)(facet => worldId => facet.loadWorld.run(worldId), [], [editWorldSharedFacet]);
  (0,react.useEffect)(() => {
    if (worldId != null) {
      loadWorld(worldId);
    }
  }, [loadWorld, worldId]);
  const worldIsLoaded = (0,react_facet_src.useFacetMap)(facet => {
    const generalTab = facet.worldData.general;
    const advancedTab = facet.worldData.advanced;
    const multiplayerTab = facet.worldData.multiplayer;
    const cheatsTab = facet.worldData.cheats;
    return facet.loadWorld.result == null && Object.keys(generalTab).length !== 0 && Object.keys(advancedTab).length !== 0 && Object.keys(multiplayerTab).length !== 0 && Object.keys(cheatsTab).length !== 0;
  }, [], [editWorldSharedFacet]);
  const isUsingTemplate = (0,react_facet_src.useFacetMap)((facet, worldIsLoaded) => worldIsLoaded ? facet.worldData.isUsingTemplate : false, [], [editWorldSharedFacet, worldIsLoaded]);
  const isLockedTemplate = (0,react_facet_src.useFacetMap)((editWorldSharedFacet, worldIsLoaded) => {
    var _editWorldSharedFacet;

    return worldIsLoaded ? (_editWorldSharedFacet = editWorldSharedFacet.worldData) === null || _editWorldSharedFacet === void 0 ? void 0 : _editWorldSharedFacet.lockedTemplate : false;
  }, [], [editWorldSharedFacet, worldIsLoaded]);
  const worldData = (0,react_facet_src.useFacetMap)(facet => facet.worldData, [], [editWorldSharedFacet]);
  const generalData = (0,react_facet_src.useFacetMap)(facet => facet.general, [], [worldData]);
  const worldPacks = (0,react_facet_src.useFacetMap)(facet => facet.worldPacks, [], [editWorldSharedFacet]);
  const editWorldBetaFeatures = (0,react_facet_src.useFacetMap)(facet => facet.worldData.betaFeatures, [], [editWorldSharedFacet]);
  const formatBytes = useFormatBytes();
  const availableSize = (0,react_facet_src.useFacetMap)(({
    storageUsed,
    storageSize
  }) => formatBytes(Math.max(0, storageSize - storageUsed)), [formatBytes], [deviceInformationSharedFacet]); // Download pack modals.

  const showDownloadPackModal = (0,react_facet_src.useFacetMap)(facet => facet.downloadPackActionStatus !== PackDownloaderStatus.Idle, [], [editWorldSharedFacet]);
  const showDownloadPackErrorModal = (0,react_facet_src.useFacetMap)(facet => facet.downloadPack.result != null, [], [editWorldSharedFacet]);
  const [downloadPackName, setDownloadPackName] = (0,react_facet_src.useFacetState)('');
  const downloadPackError = (0,react_facet_src.useFacetMap)(facet => facet.downloadPack.result, [], [editWorldSharedFacet]);
  const downloadPackPercentage = (0,react_facet_src.useFacetMap)(facet => facet.downloadPackActionProgress, [], [editWorldSharedFacet]);
  const isDownloadingPack = (0,react_facet_src.useFacetMap)(facet => facet.downloadPackActionStatus === PackDownloaderStatus.Downloading, [], [editWorldSharedFacet]);
  const isImportingPack = (0,react_facet_src.useFacetMap)(facet => facet.downloadPackActionStatus === PackDownloaderStatus.Importing, [], [editWorldSharedFacet]); // Pack actions.

  const onDownloadPack = (0,react_facet_src.useFacetCallback)(facet => (packId, packName) => {
    if (worldId != null) {
      setDownloadPackName(packName);
      facet.downloadPack.run(worldId, packId, PackType.Resource);
    }
  }, [worldId, setDownloadPackName], [editWorldSharedFacet]);
  const onDownloadPackCancel = (0,react_facet_src.useFacetCallback)(facet => () => {
    facet.downloadPack.cancel();
  }, [], [editWorldSharedFacet]);
  const showResourcePacksErrorModal = ResourcePacksErrorModal.useShowModal();
  const showResourcePacksDependenciesErrorModal = ResourcePacksDependenciesErrorModal.useShowModal();
  const showResourcePacksDownloadConfirmationModal = ResourcePacksDownloadConfirmationModal.useShowModal();
  const showBehaviorPacksConfirmationModal = BehaviorPacksConfirmationModal.useShowModal();
  const onActivatePackContinue = (0,react_facet_src.useFacetCallback)(facet => () => {
    if (worldId != null) {
      facet.activatePackContinue.run(worldId);

      if (facet.activatePackContinue.result != null) {
        showResourcePacksErrorModal({
          errorCode: facet.activatePackContinue.result
        });
      }

      facet.activatePackContinue.clear();
    }
  }, [worldId, showResourcePacksErrorModal], [editWorldSharedFacet]);
  const onDeactivatePackContinue = (0,react_facet_src.useFacetCallback)(facet => () => {
    if (worldId != null) {
      facet.deactivatePackContinue.run(worldId);

      if (facet.deactivatePackContinue.result != null) {
        showResourcePacksErrorModal({
          errorCode: facet.deactivatePackContinue.result
        });
      }
    }
  }, [worldId, showResourcePacksErrorModal], [editWorldSharedFacet]);
  const onActivatePack = (0,react_facet_src.useFacetCallback)(facet => (packId, packType, packName, packSize) => {
    if (worldId != null) {
      facet.activatePack.run(worldId, packId, packType, false);

      if (facet.activatePack.result === PackActionError.NeedToDownloadPack) {
        showResourcePacksDownloadConfirmationModal({
          packId: packId,
          packName: packName,
          packSize: packSize,
          availableSize: availableSize,
          onAccept: onDownloadPack
        });
      } else if (facet.activatePack.result === PackActionError.AddDependenciesError) {
        showResourcePacksDependenciesErrorModal({
          onAccept: onActivatePackContinue
        });
      } else if (facet.activatePack.result === PackActionError.DataWarning) {
        showBehaviorPacksConfirmationModal({
          packId: packId,
          type: 'activated',
          packType: packType,
          onAccept: onActivatePackContinue
        });
      } else if (facet.activatePack.result != null) {
        showResourcePacksErrorModal({
          errorCode: facet.activatePack.result
        });
      }

      facet.activatePack.clear();
    }
  }, [worldId, availableSize, onActivatePackContinue, onDownloadPack, showResourcePacksDependenciesErrorModal, showResourcePacksDownloadConfirmationModal, showResourcePacksErrorModal, showBehaviorPacksConfirmationModal], [editWorldSharedFacet]);
  const onDeactivatePack = (0,react_facet_src.useFacetCallback)(facet => (packId, packType) => {
    if (worldId != null) {
      facet.deactivatePack.run(worldId, packId, packType, false);

      if (facet.deactivatePack.result === PackActionError.DataWarning) {
        showBehaviorPacksConfirmationModal({
          packId: packId,
          type: 'deactivate',
          packType: packType,
          onAccept: onDeactivatePackContinue
        });
      } else if (facet.deactivatePack.result != null) {
        showResourcePacksErrorModal({
          errorCode: facet.deactivatePack.result
        });
      }
    }
  }, [worldId, showBehaviorPacksConfirmationModal, onDeactivatePackContinue, showResourcePacksErrorModal], [editWorldSharedFacet]);
  const onChangePackPriority = (0,react_facet_src.useFacetCallback)(facet => (packId, packType, fromIndex, toIndex) => {
    if (worldId != null) facet.changePackPriority.run(worldId, packId, packType, fromIndex, toIndex);
  }, [worldId], [editWorldSharedFacet]);
  const worldPreviewImagePath = (0,react_facet_src.useFacetMap)(facet => facet.worldSummary.worldIconPath != null && facet.worldSummary.worldIconPath.length > 0 ? facet.worldSummary.worldIconPath : world_preview_default_namespaceObject, [], [editWorldSharedFacet]);
  const backButtonCallback = (0,react_facet_src.useFacetCallback)(facet => () => {
    if (worldId != null) {
      facet.saveLocalWorld.run(worldId);
      willPlay.current = false;
    }
  }, [worldId, willPlay], [editWorldSharedFacet]);
  const startLocalWordCallback = (0,react_facet_src.useFacetCallback)(editWorldFacet => () => {
    if (worldId != null) {
      editWorldFacet.saveLocalWorld.run(worldId);
      willPlay.current = true;
    }
  }, [worldId, willPlay], [editWorldSharedFacet]);
  const worldStartFailed = (0,react_facet_src.useFacetMap)(worldStartup => {
    const result = worldStartup.startLocalWorld.result;
    return result != null && result != StartLocalWorldResult.Ok;
  }, [], [worldStartupSharedFacet]);
  const showSavingModal = (0,react_facet_src.useFacetMap)(facet => {
    return facet.saveLocalWorld.state === AsyncStatefulFunctionState.InProgress;
  }, [], [editWorldSharedFacet]);
  const showEditWorldErrorModal = (0,react_facet_src.useFacetMap)(facet => {
    return facet.loadWorld.result != null || facet.duplicateWorld.result != null || facet.saveLocalWorld.result != null;
  }, [], [editWorldSharedFacet]);
  const cheatsData = (0,react_facet_src.useFacetMap)(editWorldFacet => {
    var _editWorldFacet$world;

    return (_editWorldFacet$world = editWorldFacet.worldData) === null || _editWorldFacet$world === void 0 ? void 0 : _editWorldFacet$world.cheats;
  }, [], [editWorldSharedFacet]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: worldIsLoaded
  }, /*#__PURE__*/react.createElement(WorldModeContext.Provider, {
    value: "edit"
  }, /*#__PURE__*/react.createElement(WorldSettingsWrapper, {
    generalData: generalData,
    multiplayerData: editWorldMultiplayerSelectorFacet,
    cheatsData: cheatsData,
    isLockedTemplate: isLockedTemplate,
    worldPacks: worldPacks,
    showDownloadPackModal: showDownloadPackModal,
    downloadPackName: downloadPackName,
    downloadPackPercentage: downloadPackPercentage,
    isDownloadingPack: isDownloadingPack,
    isImportingPack: isImportingPack,
    worldPreviewImage: worldPreviewImagePath,
    isUsingTemplate: isUsingTemplate,
    renderPage: (0,react_facet_src.useFacetWrap)(true),
    onActivatePack: onActivatePack,
    onDeactivatePack: onDeactivatePack,
    onDownloadPackCancel: onDownloadPackCancel,
    onChangePackPriority: onChangePackPriority,
    advancedSettings: editWorldAdvancedSelectorFacet,
    experimentsData: editWorldBetaFeatures,
    backButtonCallback: backButtonCallback,
    mainActionCallback: startLocalWordCallback,
    realmsActionCallback: () => null
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: worldStartFailed
  }, /*#__PURE__*/react.createElement(UnexpectedLaunchErrorModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showDownloadPackErrorModal
  }, /*#__PURE__*/react.createElement(ResourcePacksDownloadErrorModal.Component, {
    errorCode: downloadPackError,
    onClose: onDownloadPackCancel
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showSavingModal
  }, /*#__PURE__*/react.createElement(SavingWorldModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showEditWorldErrorModal
  }, /*#__PURE__*/react.createElement(EditWorldErrorModal.Component, null))));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/index.ts

;// CONCATENATED MODULE: ./packages/ui/src/Badge/Badge.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Badge = ({"badge":"Fb8kl","badgeWithCounterWrapper":"RlfkW","badgeWithCounter":"Fp9K8"});
;// CONCATENATED MODULE: ./packages/ui/src/Badge/Badge.tsx






function Badge_Badge({
  role = 'destructiveTint',
  children,
  overflowCount = 99
}) {
  const {
    color: {
      [role]: semanticClassNames
    }
  } = useSemanticTokens(); // If a number is passed in as a child, the badge gets a counter

  const counter = children != null;
  const badgeClasses = classnames_default()(semanticClassNames.border.base, semanticClassNames.background.base, semanticClassNames.text.base, counter ? Badge.badgeWithCounter : Badge.badge);
  const childText = (0,react_facet_src.useFacetMap)(children => children > overflowCount && overflowCount != false ? `+${overflowCount}` : `${children}`, [overflowCount], [(0,react_facet_src.useFacetWrap)(children !== null && children !== void 0 ? children : 0)]);

  if (counter) {
    return /*#__PURE__*/react.createElement("div", {
      className: badgeClasses
    }, /*#__PURE__*/react.createElement("div", {
      className: Badge.badgeWithCounterWrapper
    }, /*#__PURE__*/react.createElement(Typography_Typography, {
      variant: "body",
      color: "inherit",
      align: "center"
    }, childText)));
  }

  return /*#__PURE__*/react.createElement("div", {
    className: badgeClasses
  }, /*#__PURE__*/react.createElement("div", {
    className: Badge.badge
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxListItem/images/trash.png
const trash_namespaceObject = __webpack_require__.p + "assets/trash-4fd68.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForwardWhite/images/arrowForwardWhite.png
const arrowForwardWhite_namespaceObject = __webpack_require__.p + "assets/arrowForwardWhite-9acff.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForwardWhite/IconArrowForwardWhite.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowForwardWhite = ({"iconArrowForwardWhite":"VBVxi"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForwardWhite/IconArrowForwardWhite.tsx




const IconArrowForwardWhite_IconArrowForwardWhite = () => /*#__PURE__*/react.createElement(Image_Image_Image, {
  className: IconArrowForwardWhite.iconArrowForwardWhite,
  src: arrowForwardWhite_namespaceObject,
  imageRendering: "pixelated"
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxListItem/InboxListItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InboxListItem = ({"iconTrashCan":"gRR2U"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxListItem/InboxListItem.tsx












function StatusTag({
  invite,
  daysLeft
}) {
  const {
    t
  } = useLocalization('InboxRoute');
  const role = (0,react_facet_src.useFacetMap)((invite, daysLeft) => {
    switch (invite.invStatus) {
      case InvitationStatus.ACCEPTED:
        return 'primaryTint';

      case InvitationStatus.REJECTED:
        return 'destructiveTint';

      case InvitationStatus.EXPIRED:
        return 'noticeTint';

      case InvitationStatus.NONE:
        if (daysLeft != null && (invite.announcementType == InboxMessageType.NEWS || invite.announcementType == InboxMessageType.REALMS)) {
          if (daysLeft <= 0) {
            return 'noticeTint';
          } else {
            return 'informativeTint';
          }
        }

      default:
        return 'noticeTint';
    }
  }, [], [invite, daysLeft]);
  const label = (0,react_facet_src.useFacetMap)((invite, daysLeft) => {
    switch (invite.invStatus) {
      case InvitationStatus.ACCEPTED:
        return t('.accepted');

      case InvitationStatus.REJECTED:
        return t('.rejected');

      case InvitationStatus.EXPIRED:
        return t('.expired');

      default:
        if (daysLeft != null && (invite.announcementType == InboxMessageType.NEWS || invite.announcementType == InboxMessageType.REALMS)) {
          if (daysLeft <= 0) {
            return t('.expired');
          } else {
            return t('.endsSoon', [`${daysLeft}`]);
          }
        }

        return '';
    }
  }, [t], [invite, daysLeft]);
  const shouldRenderTag = (0,react_facet_src.useFacetMap)((invite, daysLeft) => {
    return invite.invStatus != InvitationStatus.NONE || daysLeft != null;
  }, [], [invite, daysLeft]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldRenderTag
  }, /*#__PURE__*/react.createElement(Tag_Tag, {
    role: role
  }, label));
}
function InboxListItem_InboxListItem({
  item,
  gamepadIndex
}) {
  return /*#__PURE__*/react.createElement(ListItem_ListItem, {
    gamepadIndex: gamepadIndex,
    defaultFocusedChildBehavior: "grid"
  }, /*#__PURE__*/react.createElement(InboxListItemAction, {
    item: item,
    gamepadIndex: 0
  }), /*#__PURE__*/react.createElement(InboxAdditionalActions, {
    item: item,
    gamepadIndex: 1
  }));
}

const InboxListItemAction = ({
  item
}) => {
  const textRole = 'neutral';
  const {
    color: {
      inherit: semanticClassNames
    },
    variant
  } = useSemanticTokens();
  const {
    t
  } = useLocalization('InboxListItem');
  const daysLeft = (0,react_facet_src.useFacetMap)(item => {
    return item.inviteDaysLeft;
  }, [], [item]);
  return /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: textRole
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.Action, {
    inputLegend: t('.view'),
    narrationText: t('.view'),
    onClick: () => {},
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => item.read == false, [], [item])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ListItem_ListItem.Cell, null, /*#__PURE__*/react.createElement(Badge_Badge, null)), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }))), /*#__PURE__*/react.createElement(ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement("div", {
    className: semanticClassNames.text.base
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, (0,react_facet_src.useFacetMap)(item => item.title, [], [item])))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(semanticClassNames.text.base, variant.dimmer)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionShort",
    color: "inherit"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, (0,react_facet_src.useFacetMap)(item => item.sender, [], [item]))))), /*#__PURE__*/react.createElement(ListItem_ListItem.Cell, null, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(semanticClassNames.text.base, variant.dimmer)
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body",
    color: "inherit"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive, null, (0,react_facet_src.useFacetMap)(item => item.dateString, [], [item])))), /*#__PURE__*/react.createElement(StatusTag, {
    invite: item,
    daysLeft: daysLeft
  })), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  })));
};

const InboxAdditionalActions = ({
  item
}) => {
  const {
    t
  } = useLocalization('InboxListItem');
  const textRole = 'neutral';
  const {
    color: {
      inherit: semanticClassNames
    }
  } = useSemanticTokens();
  return /*#__PURE__*/react.createElement(SemanticRoleProvider, {
    role: textRole
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => item.invStatus == InvitationStatus.NONE && item.invType != InvitationType.NONE, [], [item])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 0,
    narrationText: t('.accept'),
    inputLegend: t('.accept') // TODO: State handling for Inbox Accepted Button Click
    ,
    onClick: () => {
      console.log('Inbox Accepted Clicked');
    }
  }, /*#__PURE__*/react.createElement(IconCheckWhite_IconCheckWhite, null), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement("div", {
    className: semanticClassNames.text.base
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionTiny",
    color: "inherit"
  }, t('.accept')))), /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 3,
    narrationText: t('.reject'),
    inputLegend: t('.reject') // TODO: State handling for Inbox Rejected Button Click
    ,
    onClick: () => {
      console.log('Inbox Rejected Clicked');
    }
  }, /*#__PURE__*/react.createElement(IconCrossWhite_IconCrossWhite, null), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement("div", {
    className: semanticClassNames.text.base
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionTiny",
    color: "inherit"
  }, t('.reject')))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => item.invStatus == InvitationStatus.ACCEPTED && item.invType == InvitationType.REALMS, [], [item])
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 1,
    narrationText: t('.go'),
    inputLegend: t('.go') // TODO: State handling for notification Go Button Click
    ,
    onClick: () => {
      console.log('Notification Go Clicked');
    }
  }, /*#__PURE__*/react.createElement(IconArrowForwardWhite_IconArrowForwardWhite, null), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement("div", {
    className: semanticClassNames.text.base
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionTiny",
    color: "inherit"
  }, t('.go'))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => item.invStatus != InvitationStatus.NONE || item.invType == InvitationType.NONE, [], [item])
  }, /*#__PURE__*/react.createElement(ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 3,
    narrationText: t('.delete'),
    inputLegend: t('.delete') // TODO: State handling for notification Deleted Button Click
    ,
    onClick: () => {
      console.log('Notification Deleted Clicked');
    }
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: trash_namespaceObject,
    className: classnames_default()(InboxListItem.iconTrashCan, semanticClassNames.icon)
  }), /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement("div", {
    className: semanticClassNames.text.base
  }, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "captionTiny",
    color: "inherit"
  }, t('.delete'))))));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxListItem/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/images/NoNews.png
const NoNews_namespaceObject = __webpack_require__.p + "assets/NoNews-191af.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/images/NoRealmsInvites.png
const NoRealmsInvites_namespaceObject = __webpack_require__.p + "assets/NoRealmsInvites-3af80.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/images/NoRealmsNews.png
const NoRealmsNews_namespaceObject = __webpack_require__.p + "assets/NoRealmsNews-ed604.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/images/GenericError.png
const GenericError_namespaceObject = __webpack_require__.p + "assets/GenericError-2a9c9.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/InboxSectionList.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InboxSectionList = ({"emptyStateArt":"_7QZv"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/InboxSectionList.tsx















function InboxSectionList_InboxSectionList({
  data,
  value
}) {
  const hasData = (0,react_facet_src.useFacetMap)(data => data != null && (data.history.length > 0 || data.recent.length > 0), [], [data]);
  const {
    t
  } = useLocalization('InboxSectionList');
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasData
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(SectionList, {
    gamepadIndex: 0,
    header: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 4
    }),
    data: (0,react_facet_src.useFacetMap)(data => [{
      role: 'neutral',
      title: t('.recent'),
      data: data.recent
    }, {
      role: 'neutral',
      title: t('.history'),
      data: data.history
    }], [t], [data]),
    renderSectionHeader: (title, role) => /*#__PURE__*/react.createElement(ListHeader_ListHeader, {
      role: role,
      label: title
    }),
    sectionSeparator: /*#__PURE__*/react.createElement(Spacing_Spacing, {
      size: 4
    }),
    renderItem: ({
      itemFacet,
      index
    }) => {
      return /*#__PURE__*/react.createElement(InboxListItem_InboxListItem, {
        item: itemFacet,
        gamepadIndex: index
      });
    },
    footer: /*#__PURE__*/react.createElement(InputLegend_InputLegend.Space, {
      extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing, {
        size: 1
      })
    })
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasData,
    condition: false
  }, /*#__PURE__*/react.createElement(InboxSectionList_EmptyState, {
    value: value,
    realmsSubscriber: (0,react_facet_src.useFacetMap)(inbox => {
      return inbox.realmsSubscriber;
    }, [], [(0,react_facet_src.useSharedFacet)(inboxSharedFacet)])
  })));
}

function getVariantValues(values, t) {
  switch (values) {
    case InboxMessageType.NEWS:
      return {
        title: t('.emptyMessageTitle'),
        text: t('.emptyMessageText'),
        imgSrc: NoNews_namespaceObject
      };

    case InboxMessageType.INVITES:
      return {
        title: t('.emptyInvitesTitle'),
        text: t('.emptyInvitesText'),
        imgSrc: NoRealmsInvites_namespaceObject
      };

    case InboxMessageType.REALMS:
      return {
        title: t('.emptyRealmSubTitle'),
        text: t('.emptyRealmSubText'),
        imgSrc: NoRealmsNews_namespaceObject
      };

    default:
      return {
        title: t('.errorTitle'),
        text: t('.errorText'),
        imgSrc: GenericError_namespaceObject
      };
  }
}

function InboxSectionList_EmptyState({
  value,
  realmsSubscriber
}) {
  const {
    t
  } = useLocalization('InboxRoute');
  const data = getVariantValues(value, t);
  const historyAPI = RouteHistory_useRouteHistory();
  const mountRealmsUpsell = (0,react_facet_src.useFacetMap)(realmsSubscriber => {
    return value == InboxMessageType.REALMS && !realmsSubscriber;
  }, [value], [realmsSubscriber]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: mountRealmsUpsell,
    condition: true
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensCollectionProvider, {
    collection: realmsTokens
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    autofocus: true,
    gamepadIndex: 0,
    title: t('.emptyRealmNoSubTitle'),
    text: t('.emptyRealmNoSubText'),
    imgSrc: NoRealmsNews_namespaceObject,
    imgClass: InboxSectionList.emptyStateArt,
    buttons: [{
      text: t('.learn'),
      inputLegend: t('.select'),
      onClick: () => historyAPI.push('/realms-plus-pdp?tab=default'),
      variant: 'primary'
    }]
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: mountRealmsUpsell,
    condition: false
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    autofocus: true,
    gamepadIndex: 0,
    title: data.title,
    text: data.text,
    imgSrc: data.imgSrc,
    imgClass: InboxSectionList.emptyStateArt
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSideMenu/images/News.png
const News_namespaceObject = __webpack_require__.p + "assets/News-70f04.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSideMenu/images/Invites.png
const Invites_namespaceObject = __webpack_require__.p + "assets/Invites-409fa.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSideMenu/images/Realms.png
const Realms_namespaceObject = __webpack_require__.p + "assets/Realms-2b629.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSideMenu/InboxSideMenu.tsx












function getCategories(t) {
  return [{
    displayName: t('.news'),
    imageUrl: News_namespaceObject,
    imageId: 'newsIcon',
    contentType: InboxMessageType.NEWS,
    value: 'news'
  }, {
    displayName: t('.invites'),
    imageUrl: Invites_namespaceObject,
    imageId: 'invitesIcon',
    contentType: InboxMessageType.INVITES,
    value: 'invites'
  }, {
    displayName: t('.realms'),
    imageUrl: Realms_namespaceObject,
    imageId: 'realmsIcon',
    contentType: InboxMessageType.REALMS,
    value: 'realms'
  }];
}

function InboxSideMenu() {
  /** This is just boilerplate code for when to show a loading state */
  const {
    t
  } = useLocalization('InboxRoute');
  const categories = getCategories(t);
  return /*#__PURE__*/react.createElement(SideMenu_SideMenu, {
    gamepadIndex: 1,
    loading: (0,dist.useIsDeferring)(),
    autofocus: true
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu.ItemList, {
    items: (0,react_facet_src.useFacetWrap)(categories),
    initialGamepadIndex: 0,
    renderItem: InboxSideMenu_SideMenuItem
  }));
}
function InboxSideMenu_SideMenuItem({
  item,
  gamepadIndex
}) {
  const historyAPI = RouteHistory_useRouteHistory();
  const {
    t
  } = useLocalization('InboxRoute');
  const params = useRouteParams();
  const menuItemText = (0,react_facet_src.useFacetMap)(item => item.displayName, [], [item]);
  const prefix = 'inbox';
  const selected = (0,react_facet_src.useFacetMap)(item => {
    return params.tab === item.value;
  }, [params], [item]);
  return /*#__PURE__*/react.createElement(dist.DeferredMount, null, /*#__PURE__*/react.createElement(SideMenu_SideMenu.ListItem, {
    narrationText: menuItemText,
    onSelect: (0,react_facet_src.useFacetCallback)(item => () => {
      if (item.value === params.tab) return;
      historyAPI.replaceKeepingFocus(`/${prefix}/${item.value}`);
    }, [params, historyAPI], [item]),
    value: (0,react_facet_src.useFacetMap)(item => item.value, [], [item]),
    selected: selected,
    gamepadIndex: gamepadIndex,
    inputLegend: t('.select')
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu.ItemCell, null, /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
    iconSrc: (0,react_facet_src.useFacetMap)(item => item.imageUrl, [], [item]),
    selected: selected
  })), /*#__PURE__*/react.createElement(SideMenu_SideMenu.ItemMain, null, /*#__PURE__*/react.createElement(Typography_Typography, {
    variant: "body"
  }, menuItemText))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/InboxRoute/InboxRoute.tsx










function InboxRoute() {
  const historyAPI = RouteHistory_useRouteHistory();
  const {
    t
  } = useLocalization('InboxRoute');
  const breakpoint = useWindowBreakpoint();
  const params = useRouteParams();
  const categorizedMessages = (0,react_facet_src.useSharedFacet)(categorizedMessagesSelector);
  const newsData = (0,react_facet_src.useFacetMap)(categorizedMessages => {
    return categorizedMessages.newsData;
  }, [], [categorizedMessages]);
  const inviteData = (0,react_facet_src.useFacetMap)(categorizedMessages => {
    return categorizedMessages.invitesData;
  }, [], [categorizedMessages]);
  const realmsData = (0,react_facet_src.useFacetMap)(categorizedMessages => {
    return categorizedMessages.realmsData;
  }, [], [categorizedMessages]);
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout, {
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: () => {
        historyAPI.goBack();
      }
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography, {
      variant: "header5A",
      color: "black"
    }, t('.header'))
  }, /*#__PURE__*/react.createElement(Grid_Grid, null, breakpoint === 'desktop' && /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 4,
    narrowSize: 3
  }, /*#__PURE__*/react.createElement(Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(InboxSideMenu, null)), /*#__PURE__*/react.createElement(Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 8,
    narrowSize: 5
  }, params.tab == categoryDataToStringValue(InboxMessageType.NEWS) && /*#__PURE__*/react.createElement(InboxSectionList_InboxSectionList, {
    data: newsData,
    value: InboxMessageType.NEWS
  }), params.tab == categoryDataToStringValue(InboxMessageType.INVITES) && /*#__PURE__*/react.createElement(InboxSectionList_InboxSectionList, {
    data: inviteData,
    value: InboxMessageType.INVITES
  }), params.tab == categoryDataToStringValue(InboxMessageType.REALMS) && /*#__PURE__*/react.createElement(InboxSectionList_InboxSectionList, {
    data: realmsData,
    value: InboxMessageType.REALMS
  }))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/InboxRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/GuidedCreateWorldRoute/GuidedCreateWorldRoute.tsx




function GuidedCreateWorldRoute() {
  const {
    t
  } = useLocalization('GuidedCreateWorldRoute');
  const historyAPI = RouteHistory_useRouteHistory();
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout, {
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: () => historyAPI.goBack()
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography, {
      variant: "header5A",
      color: "black"
    }, t('.title'))
  }, /*#__PURE__*/react.createElement(react.Fragment, null))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/index.screen.tsx


































 // eslint-disable-next-line @typescript-eslint/no-unused-vars

const EmptyRoute = () => {
  const history = useRouteHistory();
  return /*#__PURE__*/React.createElement(Modal, null, /*#__PURE__*/React.createElement(Modal.Header, null, "Missing Route"), /*#__PURE__*/React.createElement(Modal.Content, null, /*#__PURE__*/React.createElement(Modal.Text, {
    gamepadIndex: 0,
    narrationText: "The route you're trying to access isn't included in this build. Did you remember to enable the environment variable?"
  }, "The route you're trying to access isn't included in this build. Did you remember to enable the environment variable?")), /*#__PURE__*/React.createElement(Modal.Buttons, null, /*#__PURE__*/React.createElement(Button, {
    gamepadIndex: 0,
    autofocus: true,
    inputLegend: "Go Back",
    variant: "primary",
    onClick: () => history.goBack()
  }, "Go Back")));
}; // eslint-disable-next-line import/no-default-export


function App() {
  return /*#__PURE__*/react.createElement(Application, {
    scalingMode: 'legacy',
    defaultRoute: "/play",
    scope: ['in-game', 'out-of-game'],
    errorComponent: ErrorModal_ErrorModal,
    developmentTranslations: allTranslationsUsedByVanilla,
    gamepadAdapterVersion: GamepadAdapterVersion.LEGACY,
    semanticTokens: vanillaTokens,
    wrapperComponent: ProfanityWarningModalProvider
  }, /*#__PURE__*/react.createElement(Route_Route, {
    route: "/achievements/:tab?",
    component: AchievementsRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: ['completed', 'locked'].map(status => ({
      status: status
    }))
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/achievement-detail/:id",
    component: AchievementDetailsRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: [{
      id: '0'
    }]
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/create-new-world/seed-templates",
    component: SeedTemplateRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/create-new-world/:tab/:worldTemplateId?",
    component: CreateNewWorldRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: createNewWorldTabValues.map(tab => ({
      tab: tab
    }))
  }), /*#__PURE__*/react.createElement(RedirectWrapper, {
    from: "/create-new-world",
    to: "/create-new-world/general"
  }),  true && /*#__PURE__*/react.createElement(Route_Route, {
    route: "/guided-create-world",
    component: GuidedCreateWorldRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/play/touch-control-selection/:id",
    component: WorldStartupTouchControlSelectionRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }),  true && /*#__PURE__*/react.createElement(Route_Route, {
    route: "/play/:tab?",
    component: PlayScreenRoute_PlayScreenRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: ['all', 'realms', 'servers', 'friends'].map(status => ({
      status: status
    }))
  }),  true && /*#__PURE__*/react.createElement(RedirectWrapper, {
    from: "/play",
    to: "/play/all"
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/mobile-data-blocked-modal/show-modal",
    component: MobileDataBlockedModalRoute_MobileDataBlockedModalRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/render-distance-warning-modal",
    component: RenderDistanceWarningRoute,
    transitionComponent: RouteInstantTransition_RouteInstantTransition
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/touch-control-selection",
    component: TouchControlSelectionRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/realms-stories/:tab/:realmId?",
    component: RealmsStoriesRoute_RealmsStoriesRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: realmsStoriesTabValues.map(tab => ({
      tab: tab
    }))
  }), /*#__PURE__*/react.createElement(RedirectWrapper, {
    from: "/realms-stories",
    to: "/realms-stories/home"
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/realms-new-story",
    component: RealmsNewStoryRoute_RealmsNewStoryRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/realms-story-comments/:id",
    component: RealmsStoryCommentsRoute_RealmsStoryCommentsRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: [{
      id: '0'
    }]
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/announcement-modal/:id",
    component: AnnouncementModalRoute,
    transitionComponent: RouteInstantTransition_RouteInstantTransition,
    knownEntries: [{
      id: '0'
    }]
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/player-banned-modal",
    component: PlayerBannedModalRoute,
    transitionComponent: RouteInstantTransition_RouteInstantTransition
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/player-report",
    component: ReportPlayerRoute,
    transitionComponent: RouteInstantTransition_RouteInstantTransition
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/sign-in-achievements",
    component: SignInAchievementsRoute_SignInAchievementsRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    unmountOnPush: true
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/sign-in-add-friend",
    component: SignInAddFriendRoute_SignInAddFriendRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/sign-in-play-on-server",
    component: SignInPlayOnServerRoute_SignInPlayOnServerRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/sign-in-save-purchases",
    component: SignInSavePurchasesRoute_SignInSavePurchasesRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(Route_Route, {
    route: "/first-time-sign-in",
    component: FirstTimeSignInRoute_FirstTimeSignInRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }),  true && /*#__PURE__*/react.createElement(Route_Route, {
    route: "/inbox/:tab",
    component: InboxRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: ['news', 'invites', 'realms'].map(tab => ({
      tab: tab
    }))
  }),  true && /*#__PURE__*/react.createElement(RedirectWrapper, {
    from: "/inbox/",
    to: "/inbox/:tab"
  }),  true && /*#__PURE__*/react.createElement(Route_Route, {
    route: "/edit-world/:id/:tab/:worldTemplateId?",
    component: EditWorldRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }),  true && /*#__PURE__*/react.createElement(RedirectWrapper, {
    from: "/edit-world/:id",
    to: "/edit-world/:id/general"
  }), /*#__PURE__*/react.createElement(InputLegend_InputLegend, null));
}
render( /*#__PURE__*/react.createElement(App, null), document.getElementById('root'));
})();

/******/ })()
;